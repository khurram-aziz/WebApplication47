(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';

var _react = require('react');

var _react2 = _interopRequireDefault(_react);

var _reactDom = require('react-dom');

var _reactDom2 = _interopRequireDefault(_reactDom);

var _Fabric = require('office-ui-fabric-react/lib/Fabric');

var _Button = require('office-ui-fabric-react/lib/Button');

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var MyPage = function MyPage() {
    return _react2.default.createElement(
        _Fabric.Fabric,
        null,
        _react2.default.createElement(
            _Button.DefaultButton,
            null,
            'I am a button'
        )
    );
};

_reactDom2.default.render(_react2.default.createElement(MyPage, null), document.getElementById('app'));

},{"office-ui-fabric-react/lib/Button":77,"office-ui-fabric-react/lib/Fabric":81,"react":"react","react-dom":"react-dom"}],2:[function(require,module,exports){
(function (global){
"use strict";
/**
 * An IThemingInstruction can specify a rawString to be preserved or a theme slot and a default value
 * to use if that slot is not specified by the theme.
 */
var __assign = (this && this.__assign) || Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t[p] = s[p];
    }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
// IE needs to inject styles using cssText. However, we need to evaluate this lazily, so this
// value will initialize as undefined, and later will be set once on first loadStyles injection.
var _injectStylesWithCssText;
// Store the theming state in __themeState__ global scope for reuse in the case of duplicate
// load-themed-styles hosted on the page.
var _root = (typeof window === 'undefined') ? global : window; // tslint:disable-line:no-any
var _themeState = initializeThemeState();
/**
 * Matches theming tokens. For example, "[theme: themeSlotName, default: #FFF]" (including the quotes).
 */
// tslint:disable-next-line:max-line-length
var _themeTokenRegex = /[\'\"]\[theme:\s*(\w+)\s*(?:\,\s*default:\s*([\\"\']?[\.\,\(\)\#\-\s\w]*[\.\,\(\)\#\-\w][\"\']?))?\s*\][\'\"]/g;
/** Maximum style text length, for supporting IE style restrictions. */
var MAX_STYLE_CONTENT_SIZE = 10000;
var now = function () { return (typeof performance !== 'undefined' && !!performance.now) ? performance.now() : Date.now(); };
function measure(func) {
    var start = now();
    func();
    var end = now();
    _themeState.perf.duration += end - start;
}
/**
 * initialize global state object
 */
function initializeThemeState() {
    var state = _root.__themeState__ || {
        theme: undefined,
        lastStyleElement: undefined,
        registeredStyles: []
    };
    if (!state.runState) {
        state = __assign({}, (state), { perf: {
                count: 0,
                duration: 0
            }, runState: {
                flushTimer: 0,
                mode: 0 /* sync */,
                buffer: []
            } });
    }
    if (!state.registeredThemableStyles) {
        state = __assign({}, (state), { registeredThemableStyles: [] });
    }
    _root.__themeState__ = state;
    return state;
}
/**
 * Loads a set of style text. If it is registered too early, we will register it when the window.load
 * event is fired.
 * @param {string | ThemableArray} styles Themable style text to register.
 * @param {boolean} loadAsync When true, always load styles in async mode, irrespective of current sync mode.
 */
function loadStyles(styles, loadAsync) {
    if (loadAsync === void 0) { loadAsync = false; }
    measure(function () {
        var styleParts = Array.isArray(styles) ? styles : splitStyles(styles);
        if (_injectStylesWithCssText === undefined) {
            _injectStylesWithCssText = shouldUseCssText();
        }
        var _a = _themeState.runState, mode = _a.mode, buffer = _a.buffer, flushTimer = _a.flushTimer;
        if (loadAsync || mode === 1 /* async */) {
            buffer.push(styleParts);
            if (!flushTimer) {
                _themeState.runState.flushTimer = asyncLoadStyles();
            }
        }
        else {
            applyThemableStyles(styleParts);
        }
    });
}
exports.loadStyles = loadStyles;
/**
 * Allows for customizable loadStyles logic. e.g. for server side rendering application
 * @param {(processedStyles: string, rawStyles?: string | ThemableArray) => void}
 * a loadStyles callback that gets called when styles are loaded or reloaded
 */
function configureLoadStyles(loadStylesFn) {
    _themeState.loadStyles = loadStylesFn;
}
exports.configureLoadStyles = configureLoadStyles;
/**
 * Configure run mode of load-themable-styles
 * @param mode load-themable-styles run mode, async or sync
 */
function configureRunMode(mode) {
    _themeState.runState.mode = mode;
}
exports.configureRunMode = configureRunMode;
/**
 * external code can call flush to synchronously force processing of currently buffered styles
 */
function flush() {
    measure(function () {
        var styleArrays = _themeState.runState.buffer.slice();
        _themeState.runState.buffer = [];
        var mergedStyleArray = [].concat.apply([], styleArrays);
        if (mergedStyleArray.length > 0) {
            applyThemableStyles(mergedStyleArray);
        }
    });
}
exports.flush = flush;
/**
 * register async loadStyles
 */
function asyncLoadStyles() {
    return setTimeout(function () {
        _themeState.runState.flushTimer = 0;
        flush();
    }, 0);
}
/**
 * Loads a set of style text. If it is registered too early, we will register it when the window.load event
 * is fired.
 * @param {string} styleText Style to register.
 * @param {IStyleRecord} styleRecord Existing style record to re-apply.
 */
function applyThemableStyles(stylesArray, styleRecord) {
    if (_themeState.loadStyles) {
        _themeState.loadStyles(resolveThemableArray(stylesArray).styleString, stylesArray);
    }
    else {
        _injectStylesWithCssText ?
            registerStylesIE(stylesArray, styleRecord) :
            registerStyles(stylesArray);
    }
}
/**
 * Registers a set theme tokens to find and replace. If styles were already registered, they will be
 * replaced.
 * @param {theme} theme JSON object of theme tokens to values.
 */
function loadTheme(theme) {
    _themeState.theme = theme;
    // reload styles.
    reloadStyles();
}
exports.loadTheme = loadTheme;
/**
 * Clear already registered style elements and style records in theme_State object
 * @option: specify which group of registered styles should be cleared.
 * Default to be both themable and non-themable styles will be cleared
 */
function clearStyles(option) {
    if (option === void 0) { option = 3 /* all */; }
    if (option === 3 /* all */ || option === 2 /* onlyNonThemable */) {
        clearStylesInternal(_themeState.registeredStyles);
        _themeState.registeredStyles = [];
    }
    if (option === 3 /* all */ || option === 1 /* onlyThemable */) {
        clearStylesInternal(_themeState.registeredThemableStyles);
        _themeState.registeredThemableStyles = [];
    }
}
exports.clearStyles = clearStyles;
function clearStylesInternal(records) {
    records.forEach(function (styleRecord) {
        var styleElement = styleRecord && styleRecord.styleElement;
        if (styleElement && styleElement.parentElement) {
            styleElement.parentElement.removeChild(styleElement);
        }
    });
}
/**
 * Reloads styles.
 */
function reloadStyles() {
    if (_themeState.theme) {
        var themableStyles = [];
        for (var _i = 0, _a = _themeState.registeredThemableStyles; _i < _a.length; _i++) {
            var styleRecord = _a[_i];
            themableStyles.push(styleRecord.themableStyle);
        }
        if (themableStyles.length > 0) {
            clearStyles(1 /* onlyThemable */);
            applyThemableStyles([].concat.apply([], themableStyles));
        }
    }
}
/**
 * Find theme tokens and replaces them with provided theme values.
 * @param {string} styles Tokenized styles to fix.
 */
function detokenize(styles) {
    if (styles) {
        styles = resolveThemableArray(splitStyles(styles)).styleString;
    }
    return styles;
}
exports.detokenize = detokenize;
/**
 * Resolves ThemingInstruction objects in an array and joins the result into a string.
 * @param {ThemableArray} splitStyleArray ThemableArray to resolve and join.
 */
function resolveThemableArray(splitStyleArray) {
    var theme = _themeState.theme;
    var themable = false;
    // Resolve the array of theming instructions to an array of strings.
    // Then join the array to produce the final CSS string.
    var resolvedArray = (splitStyleArray || []).map(function (currentValue) {
        var themeSlot = currentValue.theme;
        if (themeSlot) {
            themable = true;
            // A theming annotation. Resolve it.
            var themedValue = theme ? theme[themeSlot] : undefined;
            var defaultValue = currentValue.defaultValue || 'inherit';
            // Warn to console if we hit an unthemed value even when themes are provided, but only if "DEBUG" is true.
            // Allow the themedValue to be undefined to explicitly request the default value.
            if (theme && !themedValue && console && !(themeSlot in theme) && typeof DEBUG !== 'undefined' && DEBUG) {
                console.warn("Theming value not provided for \"" + themeSlot + "\". Falling back to \"" + defaultValue + "\".");
            }
            return themedValue || defaultValue;
        }
        else {
            // A non-themable string. Preserve it.
            return currentValue.rawString;
        }
    });
    return {
        styleString: resolvedArray.join(''),
        themable: themable
    };
}
/**
 * Split tokenized CSS into an array of strings and theme specification objects
 * @param {string} styles Tokenized styles to split.
 */
function splitStyles(styles) {
    var result = [];
    if (styles) {
        var pos = 0; // Current position in styles.
        var tokenMatch = void 0; // tslint:disable-line:no-null-keyword
        while (tokenMatch = _themeTokenRegex.exec(styles)) {
            var matchIndex = tokenMatch.index;
            if (matchIndex > pos) {
                result.push({
                    rawString: styles.substring(pos, matchIndex)
                });
            }
            result.push({
                theme: tokenMatch[1],
                defaultValue: tokenMatch[2] // May be undefined
            });
            // index of the first character after the current match
            pos = _themeTokenRegex.lastIndex;
        }
        // Push the rest of the string after the last match.
        result.push({
            rawString: styles.substring(pos)
        });
    }
    return result;
}
exports.splitStyles = splitStyles;
/**
 * Registers a set of style text. If it is registered too early, we will register it when the
 * window.load event is fired.
 * @param {ThemableArray} styleArray Array of IThemingInstruction objects to register.
 * @param {IStyleRecord} styleRecord May specify a style Element to update.
 */
function registerStyles(styleArray) {
    var head = document.getElementsByTagName('head')[0];
    var styleElement = document.createElement('style');
    var _a = resolveThemableArray(styleArray), styleString = _a.styleString, themable = _a.themable;
    styleElement.type = 'text/css';
    styleElement.appendChild(document.createTextNode(styleString));
    _themeState.perf.count++;
    head.appendChild(styleElement);
    var record = {
        styleElement: styleElement,
        themableStyle: styleArray
    };
    if (themable) {
        _themeState.registeredThemableStyles.push(record);
    }
    else {
        _themeState.registeredStyles.push(record);
    }
}
/**
 * Registers a set of style text, for IE 9 and below, which has a ~30 style element limit so we need
 * to register slightly differently.
 * @param {ThemableArray} styleArray Array of IThemingInstruction objects to register.
 * @param {IStyleRecord} styleRecord May specify a style Element to update.
 */
function registerStylesIE(styleArray, styleRecord) {
    var head = document.getElementsByTagName('head')[0];
    var registeredStyles = _themeState.registeredStyles;
    var lastStyleElement = _themeState.lastStyleElement;
    var stylesheet = lastStyleElement ? lastStyleElement.styleSheet : undefined;
    var lastStyleContent = stylesheet ? stylesheet.cssText : '';
    var lastRegisteredStyle = registeredStyles[registeredStyles.length - 1];
    var resolvedStyleText = resolveThemableArray(styleArray).styleString;
    if (!lastStyleElement || (lastStyleContent.length + resolvedStyleText.length) > MAX_STYLE_CONTENT_SIZE) {
        lastStyleElement = document.createElement('style');
        lastStyleElement.type = 'text/css';
        if (styleRecord) {
            head.replaceChild(lastStyleElement, styleRecord.styleElement);
            styleRecord.styleElement = lastStyleElement;
        }
        else {
            head.appendChild(lastStyleElement);
        }
        if (!styleRecord) {
            lastRegisteredStyle = {
                styleElement: lastStyleElement,
                themableStyle: styleArray
            };
            registeredStyles.push(lastRegisteredStyle);
        }
    }
    lastStyleElement.styleSheet.cssText += detokenize(resolvedStyleText);
    Array.prototype.push.apply(lastRegisteredStyle.themableStyle, styleArray); // concat in-place
    // Preserve the theme state.
    _themeState.lastStyleElement = lastStyleElement;
}
/**
 * Checks to see if styleSheet exists as a property off of a style element.
 * This will determine if style registration should be done via cssText (<= IE9) or not
 */
function shouldUseCssText() {
    var useCSSText = false;
    if (typeof document !== 'undefined') {
        var emptyStyle = document.createElement('style');
        emptyStyle.type = 'text/css';
        useCSSText = !!emptyStyle.styleSheet;
    }
    return useCSSText;
}



}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],3:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
/**
 * Injection mode for the stylesheet.
 *
 * @public
 */
var InjectionMode;
(function (InjectionMode) {
    /**
     * Avoids style injection, use getRules() to read the styles.
     */
    InjectionMode[InjectionMode["none"] = 0] = "none";
    /**
     * Inserts rules using the insertRule api.
     */
    InjectionMode[InjectionMode["insertNode"] = 1] = "insertNode";
    /**
     * Appends rules using appendChild.
     */
    InjectionMode[InjectionMode["appendChild"] = 2] = "appendChild";
})(InjectionMode = exports.InjectionMode || (exports.InjectionMode = {}));
var STYLESHEET_SETTING = '__stylesheet__';
var _stylesheet;
/**
 * Represents the state of styles registered in the page. Abstracts
 * the surface for adding styles to the stylesheet, exposes helpers
 * for reading the styles registered in server rendered scenarios.
 *
 * @public
 */
var Stylesheet = /** @class */ (function () {
    function Stylesheet(config) {
        this._config = tslib_1.__assign({ injectionMode: 1 /* insertNode */ }, config);
        this.reset();
    }
    /**
     * Gets the singleton instance.
     */
    Stylesheet.getInstance = function () {
        // tslint:disable-next-line:no-any
        var win = typeof window !== 'undefined' ? window : {};
        _stylesheet = win[STYLESHEET_SETTING];
        if (!_stylesheet) {
            // tslint:disable-next-line:no-string-literal
            var fabricConfig = (win && win['FabricConfig']) || {};
            _stylesheet = win[STYLESHEET_SETTING] = new Stylesheet(fabricConfig.mergeStyles);
        }
        return _stylesheet;
    };
    /**
     * Configures the stylesheet.
     */
    Stylesheet.prototype.setConfig = function (config) {
        this._config = tslib_1.__assign({}, this._config, config);
    };
    /**
     * Generates a unique classname.
     *
     * @param displayName - Optional value to use as a prefix.
     */
    Stylesheet.prototype.getClassName = function (displayName) {
        var prefix = displayName || 'css';
        return prefix + "-" + this._counter++;
    };
    /**
     * Used internally to cache information about a class which was
     * registered with the stylesheet.
     */
    Stylesheet.prototype.cacheClassName = function (className, key, args, rules) {
        this._keyToClassName[key] = className;
        this._classNameToArgs[className] = {
            args: args,
            rules: rules
        };
    };
    /**
     * Gets the appropriate classname given a key which was previously
     * registered using cacheClassName.
     */
    Stylesheet.prototype.classNameFromKey = function (key) {
        return this._keyToClassName[key];
    };
    /**
     * Gets the arguments associated with a given classname which was
     * previously registered using cacheClassName.
     */
    Stylesheet.prototype.argsFromClassName = function (className) {
        var entry = this._classNameToArgs[className];
        return (entry && entry.args);
    };
    /**
   * Gets the arguments associated with a given classname which was
   * previously registered using cacheClassName.
   */
    Stylesheet.prototype.insertedRulesFromClassName = function (className) {
        var entry = this._classNameToArgs[className];
        return (entry && entry.rules);
    };
    /**
     * Inserts a css rule into the stylesheet.
     */
    Stylesheet.prototype.insertRule = function (rule) {
        var element = this._getElement();
        var injectionMode = element ? this._config.injectionMode : 0 /* none */;
        switch (injectionMode) {
            case 1 /* insertNode */:
                var sheet = element.sheet;
                try {
                    // tslint:disable-next-line:no-any
                    sheet.insertRule(rule, sheet.cssRules.length);
                }
                catch (e) {
                    /* no-op on errors */
                }
                break;
            case 2 /* appendChild */:
                _createStyleElement(rule);
                break;
            default:
                this._rules.push(rule);
                break;
        }
        if (this._config.onInsertRule) {
            this._config.onInsertRule(rule);
        }
    };
    /**
     * Gets all rules registered with the stylesheet; only valid when
     * using InsertionMode.none.
     */
    Stylesheet.prototype.getRules = function () {
        return (this._rules.join('') || '') + (this._rulesToInsert.join('') || '');
    };
    /**
     * Resets the internal state of the stylesheet. Only used in server
     * rendered scenarios where we're using InsertionMode.none.
     */
    Stylesheet.prototype.reset = function () {
        this._rules = [];
        this._rulesToInsert = [];
        this._counter = 0;
        this._classNameToArgs = {};
        this._keyToClassName = {};
        if (this._timerId) {
            clearTimeout(this._timerId);
            this._timerId = 0;
        }
    };
    Stylesheet.prototype._getElement = function () {
        if (!this._styleElement && typeof document !== 'undefined') {
            this._styleElement = _createStyleElement();
        }
        return this._styleElement;
    };
    return Stylesheet;
}());
exports.Stylesheet = Stylesheet;
function _createStyleElement(content) {
    var styleElement = document.createElement('style');
    styleElement.setAttribute('data-merge-styles', 'true');
    styleElement.type = 'text/css';
    if (content) {
        styleElement.appendChild(document.createTextNode(content));
    }
    document.head.appendChild(styleElement);
    return styleElement;
}

},{"tslib":155}],4:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Combine a set of styles together (but does not register css classes.)
 * @public
 */
function concatStyleSets() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    // tslint:disable-next-line:no-any
    var mergedSet = {};
    for (var _a = 0, args_1 = args; _a < args_1.length; _a++) {
        var currentSet = args_1[_a];
        if (currentSet) {
            for (var prop in currentSet) {
                if (currentSet.hasOwnProperty(prop)) {
                    var mergedValue = mergedSet[prop];
                    var currentValue = currentSet[prop];
                    if (mergedValue === undefined) {
                        mergedSet[prop] = currentValue;
                    }
                    else {
                        mergedSet[prop] = (Array.isArray(mergedValue) ? mergedValue : [mergedValue]).concat((Array.isArray(currentValue) ? currentValue : [currentValue]));
                    }
                }
            }
        }
    }
    return mergedSet;
}
exports.concatStyleSets = concatStyleSets;

},{}],5:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Stylesheet_1 = require("./Stylesheet");
/**
 * Separates the classes and style objects. Any classes that are pre-registered
 * args are auto expanded into objects.
 */
function extractStyleParts() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    var classes = [];
    var objects = [];
    var stylesheet = Stylesheet_1.Stylesheet.getInstance();
    function _processArgs(argsList) {
        for (var _i = 0, argsList_1 = argsList; _i < argsList_1.length; _i++) {
            var arg = argsList_1[_i];
            if (arg) {
                if (typeof arg === 'string') {
                    if (arg.indexOf(' ') >= 0) {
                        _processArgs(arg.split(' '));
                    }
                    else {
                        var translatedArgs = stylesheet.argsFromClassName(arg);
                        if (translatedArgs) {
                            _processArgs(translatedArgs);
                        }
                        else {
                            // Avoid adding the same class twice.
                            if (classes.indexOf(arg) === -1) {
                                classes.push(arg);
                            }
                        }
                    }
                }
                else if (Array.isArray(arg)) {
                    _processArgs(arg);
                }
                else if (typeof arg === 'object') {
                    objects.push(arg);
                }
            }
        }
    }
    _processArgs(args);
    return {
        classes: classes,
        objects: objects
    };
}
exports.extractStyleParts = extractStyleParts;

},{"./Stylesheet":3}],6:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Stylesheet_1 = require("./Stylesheet");
var styleToClassName_1 = require("./styleToClassName");
/**
 * Registers a font face.
 * @public
 */
function fontFace(font) {
    Stylesheet_1.Stylesheet.getInstance().insertRule("@font-face{" + styleToClassName_1.serializeRuleEntries(font) + "}");
}
exports.fontFace = fontFace;

},{"./Stylesheet":3,"./styleToClassName":12}],7:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _vendorSettings;
function getVendorSettings() {
    if (!_vendorSettings) {
        var doc = typeof document !== 'undefined' ? document : undefined;
        var nav = typeof navigator !== 'undefined' ? navigator : undefined;
        var userAgent = nav ? nav.userAgent.toLowerCase() : undefined;
        if (!doc) {
            _vendorSettings = {
                isWebkit: true,
                isMoz: true,
                isOpera: true,
                isMs: true
            };
        }
        else {
            _vendorSettings = {
                isWebkit: !!(doc && 'WebkitAppearance' in doc.documentElement.style),
                isMoz: !!(userAgent && userAgent.indexOf('firefox') > -1),
                isOpera: !!(userAgent && userAgent.indexOf('opera') > -1),
                isMs: !!(nav && (/rv:11.0/i.test(nav.userAgent) || /Edge\/\d./i.test(navigator.userAgent)))
            };
        }
    }
    return _vendorSettings;
}
exports.getVendorSettings = getVendorSettings;
/**
 * Sets the vendor settings for prefixing and vendor specific operations.
 */
function setVendorSettings(vendorSettings) {
    _vendorSettings = vendorSettings;
}
exports.setVendorSettings = setVendorSettings;

},{}],8:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var mergeStyles_1 = require("./mergeStyles");
exports.mergeStyles = mergeStyles_1.mergeStyles;
var mergeStyleSets_1 = require("./mergeStyleSets");
exports.mergeStyleSets = mergeStyleSets_1.mergeStyleSets;
var concatStyleSets_1 = require("./concatStyleSets");
exports.concatStyleSets = concatStyleSets_1.concatStyleSets;
var fontFace_1 = require("./fontFace");
exports.fontFace = fontFace_1.fontFace;
var keyframes_1 = require("./keyframes");
exports.keyframes = keyframes_1.keyframes;
var Stylesheet_1 = require("./Stylesheet");
exports.InjectionMode = Stylesheet_1.InjectionMode;
exports.Stylesheet = Stylesheet_1.Stylesheet;

},{"./Stylesheet":3,"./concatStyleSets":4,"./fontFace":6,"./keyframes":9,"./mergeStyleSets":10,"./mergeStyles":11}],9:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Stylesheet_1 = require("./Stylesheet");
var styleToClassName_1 = require("./styleToClassName");
/**
 * Registers keyframe definitions.
 *
 * @public
 */
function keyframes(timeline) {
    var stylesheet = Stylesheet_1.Stylesheet.getInstance();
    var name = stylesheet.getClassName();
    var rulesArray = [];
    for (var prop in timeline) {
        if (timeline.hasOwnProperty(prop)) {
            rulesArray.push(prop, '{', styleToClassName_1.serializeRuleEntries(timeline[prop]), '}');
        }
    }
    var rules = rulesArray.join('');
    stylesheet.insertRule("@keyframes " + name + "{" + rules + "}");
    // If needed later, we would add vendor prefixes here.
    return name;
}
exports.keyframes = keyframes;

},{"./Stylesheet":3,"./styleToClassName":12}],10:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var extractStyleParts_1 = require("./extractStyleParts");
var concatStyleSets_1 = require("./concatStyleSets");
var styleToClassName_1 = require("./styleToClassName");
/**
 * Allows you to pass in 1 or more sets of areas which will return a merged
 * set of classes.
 *
 * @public
 */
function mergeStyleSets() {
    var cssSets = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        cssSets[_i] = arguments[_i];
    }
    // tslint:disable-next-line:no-any
    var classNameSet = {};
    var classMap = {};
    var cssSet = cssSets[0];
    if (cssSet) {
        if (cssSets.length > 1) {
            cssSet = concatStyleSets_1.concatStyleSets.apply(void 0, cssSets);
        }
        var registrations = [];
        for (var prop in cssSet) {
            if (cssSet.hasOwnProperty(prop)) {
                var args = cssSet[prop];
                // tslint:disable-next-line:no-any
                var _a = extractStyleParts_1.extractStyleParts(args), classes = _a.classes, objects = _a.objects;
                var registration = styleToClassName_1.styleToRegistration({ displayName: prop }, objects);
                registrations.push(registration);
                if (registration) {
                    classMap[prop] = registration.className;
                    classNameSet[prop] = classes.concat([registration.className]).join(' ');
                }
            }
        }
        for (var _b = 0, registrations_1 = registrations; _b < registrations_1.length; _b++) {
            var registration = registrations_1[_b];
            if (registration) {
                styleToClassName_1.applyRegistration(registration, classMap);
            }
        }
    }
    return classNameSet;
}
exports.mergeStyleSets = mergeStyleSets;

},{"./concatStyleSets":4,"./extractStyleParts":5,"./styleToClassName":12}],11:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var styleToClassName_1 = require("./styleToClassName");
var extractStyleParts_1 = require("./extractStyleParts");
/**
 * Concatination helper, which can merge class names together. Skips over falsey values.
 *
 * @public
 */
function mergeStyles() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    var _a = extractStyleParts_1.extractStyleParts(args), classes = _a.classes, objects = _a.objects;
    if (objects.length) {
        classes.push(styleToClassName_1.styleToClassName(objects));
    }
    return classes.join(' ');
}
exports.mergeStyles = mergeStyles;

},{"./extractStyleParts":5,"./styleToClassName":12}],12:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Stylesheet_1 = require("./Stylesheet");
var kebabRules_1 = require("./transforms/kebabRules");
var prefixRules_1 = require("./transforms/prefixRules");
var provideUnits_1 = require("./transforms/provideUnits");
var rtlifyRules_1 = require("./transforms/rtlifyRules");
var DISPLAY_NAME = 'displayName';
function getDisplayName(rules) {
    var rootStyle = rules && rules['&'];
    return rootStyle ? rootStyle.displayName : undefined;
}
function extractRules(args, rules, currentSelector) {
    if (rules === void 0) { rules = { __order: [] }; }
    if (currentSelector === void 0) { currentSelector = '&'; }
    var stylesheet = Stylesheet_1.Stylesheet.getInstance();
    var currentRules = rules[currentSelector];
    if (!currentRules) {
        currentRules = {};
        rules[currentSelector] = currentRules;
        rules.__order.push(currentSelector);
    }
    for (var _i = 0, args_1 = args; _i < args_1.length; _i++) {
        var arg = args_1[_i];
        // If the arg is a string, we need to look up the class map and merge.
        if (typeof arg === 'string') {
            var expandedRules = stylesheet.argsFromClassName(arg);
            if (expandedRules) {
                extractRules(expandedRules, rules, currentSelector);
            }
            // Else if the arg is an array, we need to recurse in.
        }
        else if (Array.isArray(arg)) {
            extractRules(arg, rules, currentSelector);
        }
        else {
            // tslint:disable-next-line:no-any
            for (var prop in arg) {
                if (prop === 'selectors') {
                    // tslint:disable-next-line:no-any
                    var selectors = arg.selectors;
                    for (var newSelector in selectors) {
                        if (selectors.hasOwnProperty(newSelector)) {
                            var selectorValue = selectors[newSelector];
                            if (newSelector.indexOf('@media') === 0) {
                                newSelector = newSelector + '{' + currentSelector;
                            }
                            else if (newSelector.indexOf(':') === 0) {
                                newSelector = currentSelector + newSelector;
                            }
                            else if (newSelector.indexOf('&') < 0) {
                                newSelector = currentSelector + ' ' + newSelector;
                            }
                            extractRules([selectorValue], rules, newSelector);
                        }
                    }
                }
                else {
                    // Else, add the rule to the currentSelector.
                    if (prop === 'margin' || prop === 'padding') {
                        // tslint:disable-next-line:no-any
                        expandQuads(currentRules, prop, arg[prop]);
                    }
                    else {
                        // tslint:disable-next-line:no-any
                        currentRules[prop] = arg[prop];
                    }
                }
            }
        }
    }
    return rules;
}
function expandQuads(currentRules, name, value) {
    var parts = (typeof value === 'string') ? value.split(' ') : [value];
    currentRules[name + 'Top'] = parts[0];
    currentRules[name + 'Right'] = parts[1] || parts[0];
    currentRules[name + 'Bottom'] = parts[2] || parts[0];
    currentRules[name + 'Left'] = parts[3] || parts[1] || parts[0];
}
function getKeyForRules(rules) {
    var serialized = [];
    var hasProps = false;
    for (var _i = 0, _a = rules.__order; _i < _a.length; _i++) {
        var selector = _a[_i];
        serialized.push(selector);
        var rulesForSelector = rules[selector];
        for (var propName in rulesForSelector) {
            if (rulesForSelector.hasOwnProperty(propName)) {
                hasProps = true;
                serialized.push(propName, rulesForSelector[propName]);
            }
        }
    }
    return hasProps ? serialized.join('') : undefined;
}
function serializeRuleEntries(ruleEntries) {
    if (!ruleEntries) {
        return '';
    }
    var allEntries = [];
    for (var entry in ruleEntries) {
        if (ruleEntries.hasOwnProperty(entry) && entry !== DISPLAY_NAME) {
            allEntries.push(entry, ruleEntries[entry]);
        }
    }
    // Apply transforms.
    for (var i = 0; i < allEntries.length; i += 2) {
        kebabRules_1.kebabRules(allEntries, i);
        provideUnits_1.provideUnits(allEntries, i);
        rtlifyRules_1.rtlifyRules(allEntries, i);
        prefixRules_1.prefixRules(allEntries, i);
    }
    // Apply punctuation.
    for (var i = 1; i < allEntries.length; i += 4) {
        allEntries.splice(i, 1, ':', allEntries[i], ';');
    }
    return allEntries.join('');
}
exports.serializeRuleEntries = serializeRuleEntries;
function styleToRegistration() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    var rules = extractRules(args);
    var key = getKeyForRules(rules);
    if (key) {
        var stylesheet = Stylesheet_1.Stylesheet.getInstance();
        var registration = {
            className: stylesheet.classNameFromKey(key),
            key: key,
            args: args
        };
        if (!registration.className) {
            registration.className = stylesheet.getClassName(getDisplayName(rules));
            var rulesToInsert = [];
            for (var _a = 0, _b = rules.__order; _a < _b.length; _a++) {
                var selector = _b[_a];
                rulesToInsert.push(selector, serializeRuleEntries(rules[selector]));
            }
            registration.rulesToInsert = rulesToInsert;
        }
        return registration;
    }
}
exports.styleToRegistration = styleToRegistration;
function applyRegistration(registration, classMap) {
    var stylesheet = Stylesheet_1.Stylesheet.getInstance();
    var className = registration.className, key = registration.key, args = registration.args, rulesToInsert = registration.rulesToInsert;
    if (rulesToInsert) {
        // rulesToInsert is an ordered array of selector/rule pairs.
        for (var i = 0; i < rulesToInsert.length; i += 2) {
            var rules = rulesToInsert[i + 1];
            if (rules) {
                var selector = rulesToInsert[i];
                // Fix selector using map.
                selector = selector.replace(/(&)|\$([\w-]+)\b/g, function (match, amp, cn) {
                    if (amp) {
                        return '.' + registration.className;
                    }
                    else if (cn) {
                        return '.' + ((classMap && classMap[cn]) || cn);
                    }
                    return '';
                });
                // Insert. Note if a media query, we must close the query with a final bracket.
                var processedRule = selector + "{" + rules + "}" + ((selector.indexOf('@media') === 0) ? '}' : '');
                stylesheet.insertRule(processedRule);
            }
        }
        stylesheet.cacheClassName(className, key, args, rulesToInsert);
    }
}
exports.applyRegistration = applyRegistration;
function styleToClassName() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    var registration = styleToRegistration.apply(void 0, args);
    if (registration) {
        applyRegistration(registration);
        return registration.className;
    }
    return '';
}
exports.styleToClassName = styleToClassName;

},{"./Stylesheet":3,"./transforms/kebabRules":13,"./transforms/prefixRules":14,"./transforms/provideUnits":15,"./transforms/rtlifyRules":16}],13:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
function kebabRules(rulePairs, index) {
    rulePairs[index] = rulePairs[index].replace(/([A-Z])/g, '-$1').toLowerCase();
}
exports.kebabRules = kebabRules;

},{}],14:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var getVendorSettings_1 = require("../getVendorSettings");
var autoPrefixNames = {
    'user-select': 1
};
function prefixRules(rulePairs, index) {
    var vendorSettings = getVendorSettings_1.getVendorSettings();
    var name = rulePairs[index];
    if (autoPrefixNames[name]) {
        var value = rulePairs[index + 1];
        if (autoPrefixNames[name]) {
            if (vendorSettings.isWebkit) {
                rulePairs.push('-webkit-' + name, value);
            }
            if (vendorSettings.isMoz) {
                rulePairs.push('-moz-' + name, value);
            }
            if (vendorSettings.isMs) {
                rulePairs.push('-ms-' + name, value);
            }
            if (vendorSettings.isOpera) {
                rulePairs.push('-o-' + name, value);
            }
        }
    }
}
exports.prefixRules = prefixRules;

},{"../getVendorSettings":7}],15:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var NON_PIXEL_NUMBER_PROPS = [
    'column-count',
    'font-weight',
    'flex-basis',
    'flex',
    'flex-grow',
    'flex-shrink',
    'opacity',
    'order',
    'z-index',
    'zoom'
];
function provideUnits(rulePairs, index) {
    var name = rulePairs[index];
    var value = rulePairs[index + 1];
    if (typeof value === 'number') {
        var unit = (NON_PIXEL_NUMBER_PROPS.indexOf(name) === -1) ? 'px' : '';
        rulePairs[index + 1] = "" + value + unit;
    }
}
exports.provideUnits = provideUnits;

},{}],16:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _nameReplacements = {
    'left': 'right',
    'right': 'left'
};
var _valueReplacements = {
    'w-resize': 'e-resize',
    'sw-resize': 'se-resize',
    'nw-resize': 'ne-resize'
};
var NO_FLIP = '@noflip';
var _rtl = getRTL();
function setRTL(isRTL) {
    _rtl = isRTL;
}
exports.setRTL = setRTL;
function getRTL() {
    if (_rtl === undefined) {
        _rtl = (typeof document !== 'undefined' &&
            !!document.documentElement &&
            document.documentElement.getAttribute('dir') === 'rtl');
    }
    return _rtl;
}
exports.getRTL = getRTL;
function rtlifyRules(rulePairs, index) {
    if (getRTL()) {
        var name_1 = rulePairs[index];
        var value = rulePairs[index + 1];
        if (value.indexOf(NO_FLIP) >= 0) {
            rulePairs[index + 1] = value.replace(/\s*(?:\/\*\s*)?\@noflip\b(?:\s*\*\/)?\s*?/g, '');
        }
        else if (name_1.indexOf('left') >= 0) {
            rulePairs[index] = name_1.replace('left', 'right');
        }
        else if (name_1.indexOf('right') >= 0) {
            rulePairs[index] = name_1.replace('right', 'left');
        }
        else if (String(value).indexOf('left') >= 0) {
            rulePairs[index + 1] = value.replace('left', 'right');
        }
        else if (String(value).indexOf('right') >= 0) {
            rulePairs[index + 1] = value.replace('right', 'left');
        }
        else if (_nameReplacements[name_1]) {
            rulePairs[index] = _nameReplacements[name_1];
        }
        else if (_valueReplacements[value]) {
            rulePairs[index + 1] = _valueReplacements[value];
        }
        else {
            switch (name_1) {
                case 'margin':
                case 'padding':
                    rulePairs[index + 1] = flipQuad(value);
                    break;
                case 'box-shadow':
                    rulePairs[index + 1] = negateNum(value, 0);
                    break;
            }
        }
    }
}
exports.rtlifyRules = rtlifyRules;
function negateNum(value, partIndex) {
    var parts = value.split(' ');
    var numberVal = parseInt(parts[partIndex], 10);
    parts[0] = parts[0].replace(String(numberVal), String(numberVal * -1));
    return parts.join(' ');
}
function flipQuad(value) {
    if (typeof value === 'string') {
        var parts = value.split(' ');
        if (parts.length === 4) {
            return parts[0] + " " + parts[3] + " " + parts[2] + " " + parts[1];
        }
    }
    return value;
}

},{}],17:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var index_1 = require("@uifabric/merge-styles/lib/index");
exports.InjectionMode = index_1.InjectionMode;
exports.Stylesheet = index_1.Stylesheet;
exports.concatStyleSets = index_1.concatStyleSets;
exports.fontFace = index_1.fontFace;
exports.keyframes = index_1.keyframes;
exports.mergeStyleSets = index_1.mergeStyleSets;
exports.mergeStyles = index_1.mergeStyles;

},{"@uifabric/merge-styles/lib/index":8}],18:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var index_1 = require("../utilities/index");
var index_2 = require("../styles/index");
exports.AnimationClassNames = index_1.buildClassMap(index_2.AnimationStyles);

},{"../styles/index":30,"../utilities/index":35}],19:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var index_1 = require("@uifabric/merge-styles/lib/index");
var DefaultPalette_1 = require("../styles/DefaultPalette");
var index_2 = require("../styles/index");
exports.ColorClassNames = {};
for (var colorName in DefaultPalette_1.DefaultPalette) {
    if (DefaultPalette_1.DefaultPalette.hasOwnProperty(colorName)) {
        // Foreground color
        _defineGetter(exports.ColorClassNames, colorName, '', false, 'color');
        // Hover color
        _defineGetter(exports.ColorClassNames, colorName, 'Hover', true, 'color');
        // Background color
        _defineGetter(exports.ColorClassNames, colorName, 'Background', false, 'background');
        // Background hover
        _defineGetter(exports.ColorClassNames, colorName, 'BackgroundHover', true, 'background');
        // Border color
        _defineGetter(exports.ColorClassNames, colorName, 'Border', false, 'borderColor');
        // Border hover color
        _defineGetter(exports.ColorClassNames, colorName, 'BorderHover', true, 'borderColor');
    }
}
/**
 * Defines a getter for the given class configuration.
 */
function _defineGetter(obj, colorName, suffix, isHover, cssProperty) {
    Object.defineProperty(obj, colorName + suffix, {
        get: function () {
            // tslint:disable-next-line:no-any
            var style = (_a = {}, _a[cssProperty] = index_2.getTheme().palette[colorName], _a);
            return index_1.mergeStyles(isHover ? { selectors: { ':hover': style } } : style).toString();
            var _a;
        },
        enumerable: true,
        configurable: true
    });
}

},{"../styles/DefaultPalette":26,"../styles/index":30,"@uifabric/merge-styles/lib/index":8}],20:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var index_1 = require("../utilities/index");
var index_2 = require("../styles/index");
exports.FontClassNames = index_1.buildClassMap(index_2.DefaultFontStyles);

},{"../styles/index":30,"../utilities/index":35}],21:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var AnimationClassNames_1 = require("./AnimationClassNames");
exports.AnimationClassNames = AnimationClassNames_1.AnimationClassNames;
var FontClassNames_1 = require("./FontClassNames");
exports.FontClassNames = FontClassNames_1.FontClassNames;
var ColorClassNames_1 = require("./ColorClassNames");
exports.ColorClassNames = ColorClassNames_1.ColorClassNames;

},{"./AnimationClassNames":18,"./ColorClassNames":19,"./FontClassNames":20}],22:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
tslib_1.__exportStar(require("./classNames/index"), exports);
tslib_1.__exportStar(require("./styles/index"), exports);
tslib_1.__exportStar(require("./utilities/index"), exports);
tslib_1.__exportStar(require("./MergeStyles"), exports);

},{"./MergeStyles":17,"./classNames/index":21,"./styles/index":30,"./utilities/index":35,"tslib":155}],23:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var index_1 = require("@uifabric/merge-styles/lib/index");
/* Register the keyframes */
var EASING_FUNCTION_1 = 'cubic-bezier(.1,.9,.2,1)';
var EASING_FUNCTION_2 = 'cubic-bezier(.1,.25,.75,.9)';
var DURATION_1 = '0.167s';
var DURATION_2 = '0.267s';
var DURATION_3 = '0.367s';
var DURATION_4 = '0.467s';
var FADE_IN = index_1.keyframes({
    from: { opacity: 0 },
    to: { opacity: 1 }
});
var FADE_OUT = index_1.keyframes({
    from: { opacity: 1 },
    to: { opacity: 0 }
});
var SLIDE_RIGHT_IN10 = _createSlideInX(-10);
var SLIDE_RIGHT_IN20 = _createSlideInX(-20);
var SLIDE_RIGHT_IN40 = _createSlideInX(-40);
var SLIDE_RIGHT_IN400 = _createSlideInX(-400);
var SLIDE_LEFT_IN10 = _createSlideInX(10);
var SLIDE_LEFT_IN20 = _createSlideInX(20);
var SLIDE_LEFT_IN40 = _createSlideInX(40);
var SLIDE_LEFT_IN400 = _createSlideInX(400);
var SLIDE_UP_IN10 = _createSlideInY(10);
var SLIDE_UP_IN20 = _createSlideInY(20);
var SLIDE_DOWN_IN10 = _createSlideInY(-10);
var SLIDE_DOWN_IN20 = _createSlideInY(-20);
var SLIDE_RIGHT_OUT10 = _createSlideOutX(10);
var SLIDE_RIGHT_OUT20 = _createSlideOutX(20);
var SLIDE_RIGHT_OUT40 = _createSlideOutX(40);
var SLIDE_RIGHT_OUT400 = _createSlideOutX(400);
var SLIDE_LEFT_OUT10 = _createSlideOutX(-10);
var SLIDE_LEFT_OUT20 = _createSlideOutX(-20);
var SLIDE_LEFT_OUT40 = _createSlideOutX(-40);
var SLIDE_LEFT_OUT400 = _createSlideOutX(-400);
var SLIDE_UP_OUT10 = _createSlideOutY(-10);
var SLIDE_UP_OUT20 = _createSlideOutY(-20);
var SLIDE_DOWN_OUT10 = _createSlideOutY(10);
var SLIDE_DOWN_OUT20 = _createSlideOutY(20);
var SCALE_UP100 = index_1.keyframes({
    from: { transform: 'scale3d(.98,.98,1)' },
    to: { transform: 'scale3d(1,1,1)' }
});
var SCALE_DOWN98 = index_1.keyframes({
    from: { transform: 'scale3d(1,1,1)' },
    to: { transform: 'scale3d(.98,.98,1)' },
});
var SCALE_DOWN100 = index_1.keyframes({
    from: { transform: 'scale3d(1.03,1.03,1)' },
    to: { transform: 'scale3d(1,1,1)' }
});
var SCALE_UP103 = index_1.keyframes({
    from: { transform: 'scale3d(1,1,1)' },
    to: { transform: 'scale3d(1.03,1.03,1)' }
});
var ROTATE90 = index_1.keyframes({
    from: { transform: 'rotateZ(0deg)' },
    to: { transform: 'rotateZ(90deg)' }
});
var ROTATE_N90 = index_1.keyframes({
    from: { transform: 'rotateZ(0deg)' },
    to: { transform: 'rotateZ(-90deg)' }
});
/**
 * All Fabric standard animations, exposed as json objects referencing predefined
 * keyframes. These objects can be mixed in with other class definitions.
 */
exports.AnimationStyles = {
    slideRightIn10: _createAnimation(FADE_IN + "," + SLIDE_RIGHT_IN10, DURATION_3, EASING_FUNCTION_1),
    slideRightIn20: _createAnimation(FADE_IN + "," + SLIDE_RIGHT_IN20, DURATION_3, EASING_FUNCTION_1),
    slideRightIn40: _createAnimation(FADE_IN + "," + SLIDE_RIGHT_IN40, DURATION_3, EASING_FUNCTION_1),
    slideRightIn400: _createAnimation(FADE_IN + "," + SLIDE_RIGHT_IN400, DURATION_3, EASING_FUNCTION_1),
    slideLeftIn10: _createAnimation(FADE_IN + "," + SLIDE_LEFT_IN10, DURATION_3, EASING_FUNCTION_1),
    slideLeftIn20: _createAnimation(FADE_IN + "," + SLIDE_LEFT_IN20, DURATION_3, EASING_FUNCTION_1),
    slideLeftIn40: _createAnimation(FADE_IN + "," + SLIDE_LEFT_IN40, DURATION_3, EASING_FUNCTION_1),
    slideLeftIn400: _createAnimation(FADE_IN + "," + SLIDE_LEFT_IN400, DURATION_3, EASING_FUNCTION_1),
    slideUpIn10: _createAnimation(FADE_IN + "," + SLIDE_UP_IN10, DURATION_3, EASING_FUNCTION_1),
    slideUpIn20: _createAnimation(FADE_IN + "," + SLIDE_UP_IN20, DURATION_3, EASING_FUNCTION_1),
    slideDownIn10: _createAnimation(FADE_IN + "," + SLIDE_DOWN_IN10, DURATION_3, EASING_FUNCTION_1),
    slideDownIn20: _createAnimation(FADE_IN + "," + SLIDE_DOWN_IN20, DURATION_3, EASING_FUNCTION_1),
    slideRightOut10: _createAnimation(FADE_OUT + "," + SLIDE_RIGHT_OUT10, DURATION_3, EASING_FUNCTION_1),
    slideRightOut20: _createAnimation(FADE_OUT + "," + SLIDE_RIGHT_OUT20, DURATION_3, EASING_FUNCTION_1),
    slideRightOut40: _createAnimation(FADE_OUT + "," + SLIDE_RIGHT_OUT40, DURATION_3, EASING_FUNCTION_1),
    slideRightOut400: _createAnimation(FADE_OUT + "," + SLIDE_RIGHT_OUT400, DURATION_3, EASING_FUNCTION_1),
    slideLeftOut10: _createAnimation(FADE_OUT + "," + SLIDE_LEFT_OUT10, DURATION_3, EASING_FUNCTION_1),
    slideLeftOut20: _createAnimation(FADE_OUT + "," + SLIDE_LEFT_OUT20, DURATION_3, EASING_FUNCTION_1),
    slideLeftOut40: _createAnimation(FADE_OUT + "," + SLIDE_LEFT_OUT40, DURATION_3, EASING_FUNCTION_1),
    slideLeftOut400: _createAnimation(FADE_OUT + "," + SLIDE_LEFT_OUT400, DURATION_3, EASING_FUNCTION_1),
    slideUpOut10: _createAnimation(FADE_OUT + "," + SLIDE_UP_OUT10, DURATION_3, EASING_FUNCTION_1),
    slideUpOut20: _createAnimation(FADE_OUT + "," + SLIDE_UP_OUT20, DURATION_3, EASING_FUNCTION_1),
    slideDownOut10: _createAnimation(FADE_OUT + "," + SLIDE_DOWN_OUT10, DURATION_3, EASING_FUNCTION_1),
    slideDownOut20: _createAnimation(FADE_OUT + "," + SLIDE_DOWN_OUT20, DURATION_3, EASING_FUNCTION_1),
    scaleUpIn100: _createAnimation(FADE_IN + "," + SCALE_UP100, DURATION_3, EASING_FUNCTION_1),
    scaleDownIn100: _createAnimation(FADE_IN + "," + SCALE_DOWN100, DURATION_3, EASING_FUNCTION_1),
    scaleUpOut103: _createAnimation(FADE_OUT + "," + SCALE_UP103, DURATION_1, EASING_FUNCTION_2),
    scaleDownOut98: _createAnimation(FADE_OUT + "," + SCALE_DOWN98, DURATION_1, EASING_FUNCTION_2),
    fadeIn100: _createAnimation(FADE_IN, DURATION_1, EASING_FUNCTION_2),
    fadeIn200: _createAnimation(FADE_IN, DURATION_2, EASING_FUNCTION_2),
    fadeIn400: _createAnimation(FADE_IN, DURATION_3, EASING_FUNCTION_2),
    fadeIn500: _createAnimation(FADE_IN, DURATION_4, EASING_FUNCTION_2),
    fadeOut100: _createAnimation(FADE_OUT, DURATION_1, EASING_FUNCTION_2),
    fadeOut200: _createAnimation(FADE_OUT, DURATION_2, EASING_FUNCTION_2),
    fadeOut400: _createAnimation(FADE_OUT, DURATION_3, EASING_FUNCTION_2),
    fadeOut500: _createAnimation(FADE_OUT, DURATION_4, EASING_FUNCTION_2),
    rotate90deg: _createAnimation(ROTATE90, '0.1s', EASING_FUNCTION_2),
    rotateN90deg: _createAnimation(ROTATE_N90, '0.1s', EASING_FUNCTION_2)
    // expandCollapse 100/200/400, delay 100/200
};
function _createAnimation(animationName, animationDuration, animationTimingFunction) {
    return {
        animationName: animationName,
        animationDuration: animationDuration,
        animationTimingFunction: animationTimingFunction,
        animationFillMode: 'both'
    };
}
function _createSlideInX(fromX) {
    return index_1.keyframes({
        from: { transform: "translate3d(" + fromX + "px,0,0)" },
        to: { transform: "translate3d(0,0,0)" }
    });
}
function _createSlideInY(fromY) {
    return index_1.keyframes({
        from: { transform: "translate3d(0," + fromY + "px,0)" },
        to: { transform: "translate3d(0,0,0)" }
    });
}
function _createSlideOutX(toX) {
    return index_1.keyframes({
        from: { transform: "translate3d(0,0,0)" },
        to: { transform: "translate3d(" + toX + "px,0,0)" }
    });
}
function _createSlideOutY(toY) {
    return index_1.keyframes({
        from: { transform: "translate3d(0,0,0)" },
        to: { transform: "translate3d(0," + toY + "px,0)" }
    });
}

},{"@uifabric/merge-styles/lib/index":8}],24:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.HighContrastSelector = '@media screen and (-ms-high-contrast: active)';
exports.ScreenWidthMinSmall = 320;
exports.ScreenWidthMinMedium = 480;
exports.ScreenWidthMinLarge = 640;
exports.ScreenWidthMinXLarge = 1024;
exports.ScreenWidthMinXXLarge = 1366;
exports.ScreenWidthMinXXXLarge = 1920;
exports.ScreenWidthMaxSmall = exports.ScreenWidthMinMedium - 1;
exports.ScreenWidthMaxMedium = exports.ScreenWidthMinLarge - 1;
exports.ScreenWidthMaxLarge = exports.ScreenWidthMinXLarge - 1;
exports.ScreenWidthMaxXLarge = exports.ScreenWidthMinXXLarge - 1;
exports.ScreenWidthMaxXXLarge = exports.ScreenWidthMinXXXLarge - 1;

},{}],25:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var index_1 = require("@uifabric/merge-styles/lib/index");
var fonts_1 = require("./fonts");
var language_1 = require("@uifabric/utilities/lib/language");
// Default urls.
var DefaultBaseUrl = 'https://static2.sharepointonline.com/files/fabric/assets';
// Standard font styling.
exports.DefaultFontStyles = fonts_1.createFontStyles(language_1.getLanguage());
function _registerFontFace(fontFamily, url, fontWeight) {
    fontFamily = "'" + fontFamily + "'";
    index_1.fontFace({
        fontFamily: fontFamily,
        src: "url('" + url + ".woff2') format('woff2')," +
            ("url('" + url + ".woff') format('woff')"),
        fontWeight: fontWeight,
        fontStyle: 'normal'
    });
}
function _registerFontFaceSet(baseUrl, fontFamily, cdnFolder, cdnFontName) {
    if (cdnFontName === void 0) { cdnFontName = 'segoeui'; }
    var urlBase = baseUrl + "/" + cdnFolder + "/" + cdnFontName;
    _registerFontFace(fontFamily, urlBase + '-light', fonts_1.FontWeights.light);
    _registerFontFace(fontFamily, urlBase + '-semilight', fonts_1.FontWeights.semilight);
    _registerFontFace(fontFamily, urlBase + '-regular', fonts_1.FontWeights.regular);
    _registerFontFace(fontFamily, urlBase + '-semibold', fonts_1.FontWeights.semibold);
}
function registerDefaultFontFaces(baseUrl) {
    if (baseUrl) {
        var fontUrl = baseUrl + "/fonts";
        // Produce @font-face definitions for all supported web fonts.
        _registerFontFaceSet(fontUrl, fonts_1.LocalizedFontNames.Thai, 'leelawadeeui-thai', 'leelawadeeui');
        _registerFontFaceSet(fontUrl, fonts_1.LocalizedFontNames.Arabic, 'segoeui-arabic');
        _registerFontFaceSet(fontUrl, fonts_1.LocalizedFontNames.Cyrillic, 'segoeui-cyrillic');
        _registerFontFaceSet(fontUrl, fonts_1.LocalizedFontNames.EastEuropean, 'segoeui-easteuropean');
        _registerFontFaceSet(fontUrl, fonts_1.LocalizedFontNames.Greek, 'segoeui-greek');
        _registerFontFaceSet(fontUrl, fonts_1.LocalizedFontNames.Hebrew, 'segoeui-hebrew');
        _registerFontFaceSet(fontUrl, fonts_1.LocalizedFontNames.Vietnamese, 'segoeui-vietnamese');
        _registerFontFaceSet(fontUrl, fonts_1.LocalizedFontNames.WestEuropean, 'segoeui-westeuropean');
        _registerFontFaceSet(fontUrl, fonts_1.LocalizedFontFamilies.Selawik, 'selawik', 'selawik');
        // Leelawadee UI (Thai) does not have a 'light' weight, so we override
        // the font-face generated above to use the 'semilight' weight instead.
        _registerFontFace('Leelawadee UI Web', fontUrl + "/leelawadeeui-thai/leelawadeeui-semilight", fonts_1.FontWeights.light);
        // Leelawadee UI (Thai) does not have a 'semibold' weight, so we override
        // the font-face generated above to use the 'bold' weight instead.
        _registerFontFace('Leelawadee UI Web', fontUrl + "/leelawadeeui-thai/leelawadeeui-bold", fonts_1.FontWeights.semibold);
    }
}
exports.registerDefaultFontFaces = registerDefaultFontFaces;
/**
 * Reads the fontBaseUrl from window.FabricConfig.fontBaseUrl or falls back to a default.
 */
function _getFontBaseUrl() {
    var win = typeof window !== 'undefined' ? window : undefined;
    // tslint:disable-next-line:no-string-literal no-any
    var fabricConfig = win ? win['FabricConfig'] : undefined;
    return (fabricConfig && fabricConfig.fontBaseUrl !== undefined) ? fabricConfig.fontBaseUrl : DefaultBaseUrl;
}
/**
 * Register the font faces.
 */
registerDefaultFontFaces(_getFontBaseUrl());

},{"./fonts":27,"@uifabric/merge-styles/lib/index":8,"@uifabric/utilities/lib/language":58}],26:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.DefaultPalette = {
    themeDarker: '#004578',
    themeDark: '#005a9e',
    themeDarkAlt: '#106ebe',
    themePrimary: '#0078d7',
    themeSecondary: '#2b88d8',
    themeTertiary: '#71afe5',
    themeLight: '#c7e0f4',
    themeLighter: '#deecf9',
    themeLighterAlt: '#eff6fc',
    black: '#000000',
    blackTranslucent40: 'rgba(0,0,0,.4)',
    neutralDark: '#212121',
    neutralPrimary: '#333333',
    neutralPrimaryAlt: '#3c3c3c',
    neutralSecondary: '#666666',
    neutralTertiary: '#a6a6a6',
    neutralTertiaryAlt: '#c8c8c8',
    neutralQuaternary: '#d0d0d0',
    neutralQuaternaryAlt: '#dadada',
    neutralLight: '#eaeaea',
    neutralLighter: '#f4f4f4',
    neutralLighterAlt: '#f8f8f8',
    accent: '#0078d7',
    white: '#ffffff',
    yellow: '#ffb900',
    yellowLight: '#fff100',
    orange: '#d83b01',
    orangeLight: '#ea4300',
    orangeLighter: '#ff8c00',
    redDark: '#a80000',
    red: '#e81123',
    magentaDark: '#5c005c',
    magenta: '#b4009e',
    magentaLight: '#e3008c',
    purpleDark: '#32145a',
    purple: '#5c2d91',
    purpleLight: '#b4a0ff',
    blueDark: '#002050',
    blueMid: '#00188f',
    blue: '#0078d7',
    blueLight: '#00bcf2',
    tealDark: '#004b50',
    teal: '#008272',
    tealLight: '#00b294',
    greenDark: '#004b1c',
    green: '#107c10',
    greenLight: '#bad80a',
};

},{}],27:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// Fallback fonts, if specified system or web fonts are unavailable.
var FontFamilyFallbacks = "'Segoe UI', -apple-system, BlinkMacSystemFont, 'Roboto', 'Helvetica Neue', sans-serif";
// Font face names to be registered.
var LocalizedFontNames;
(function (LocalizedFontNames) {
    LocalizedFontNames.Arabic = 'Segoe UI Web (Arabic)';
    LocalizedFontNames.Cyrillic = 'Segoe UI Web (Cyrillic)';
    LocalizedFontNames.EastEuropean = 'Segoe UI Web (East European)';
    LocalizedFontNames.Greek = 'Segoe UI Web (Greek)';
    LocalizedFontNames.Hebrew = 'Segoe UI Web (Hebrew)';
    LocalizedFontNames.Thai = 'Leelawadee UI Web';
    LocalizedFontNames.Vietnamese = 'Segoe UI Web (Vietnamese)';
    LocalizedFontNames.WestEuropean = 'Segoe UI Web (West European)';
    LocalizedFontNames.Selawik = 'Selawik Web';
})(LocalizedFontNames = exports.LocalizedFontNames || (exports.LocalizedFontNames = {}));
// Font families with fallbacks, for the general regions.
var LocalizedFontFamilies;
(function (LocalizedFontFamilies) {
    LocalizedFontFamilies.Arabic = "'" + LocalizedFontNames.Arabic + "'";
    LocalizedFontFamilies.ChineseSimplified = "'Microsoft Yahei UI', Verdana, Simsun";
    LocalizedFontFamilies.ChineseTraditional = "'Microsoft Jhenghei UI', Pmingliu";
    LocalizedFontFamilies.Cyrillic = "'" + LocalizedFontNames.Cyrillic + "'";
    LocalizedFontFamilies.EastEuropean = "'" + LocalizedFontNames.EastEuropean + "'";
    LocalizedFontFamilies.Greek = "'" + LocalizedFontNames.Greek + "'";
    LocalizedFontFamilies.Hebrew = "'" + LocalizedFontNames.Hebrew + "'";
    LocalizedFontFamilies.Hindi = "'Nirmala UI'";
    LocalizedFontFamilies.Japanese = "'Yu Gothic UI', 'Meiryo UI', Meiryo, 'MS Pgothic', Osaka";
    LocalizedFontFamilies.Korean = "'Malgun Gothic', Gulim";
    LocalizedFontFamilies.Selawik = "'" + LocalizedFontNames.Selawik + "'";
    LocalizedFontFamilies.Thai = "'Leelawadee UI Web', 'Kmer UI'";
    LocalizedFontFamilies.Vietnamese = "'" + LocalizedFontNames.Vietnamese + "'";
    LocalizedFontFamilies.WestEuropean = "'" + LocalizedFontNames.WestEuropean + "'";
})(LocalizedFontFamilies = exports.LocalizedFontFamilies || (exports.LocalizedFontFamilies = {}));
// Mapping of language prefix to to font family.
var LanguageToFontMap = {
    'ar': LocalizedFontFamilies.Arabic,
    'bg': LocalizedFontFamilies.Cyrillic,
    'cs': LocalizedFontFamilies.EastEuropean,
    'el': LocalizedFontFamilies.Greek,
    'et': LocalizedFontFamilies.EastEuropean,
    'he': LocalizedFontFamilies.Hebrew,
    'hi': LocalizedFontFamilies.Hindi,
    'hr': LocalizedFontFamilies.EastEuropean,
    'hu': LocalizedFontFamilies.EastEuropean,
    'ja': LocalizedFontFamilies.Japanese,
    'kk': LocalizedFontFamilies.EastEuropean,
    'ko': LocalizedFontFamilies.Korean,
    'lt': LocalizedFontFamilies.EastEuropean,
    'lv': LocalizedFontFamilies.EastEuropean,
    'pl': LocalizedFontFamilies.EastEuropean,
    'ru': LocalizedFontFamilies.Cyrillic,
    'sk': LocalizedFontFamilies.EastEuropean,
    'sr-latn': LocalizedFontFamilies.EastEuropean,
    'th': LocalizedFontFamilies.Thai,
    'tr': LocalizedFontFamilies.EastEuropean,
    'uk': LocalizedFontFamilies.Cyrillic,
    'vi': LocalizedFontFamilies.Vietnamese,
    'zh-hans': LocalizedFontFamilies.ChineseSimplified,
    'zh-hant': LocalizedFontFamilies.ChineseTraditional,
};
// Standard font sizes.
var FontSizes;
(function (FontSizes) {
    FontSizes.mini = '10px';
    FontSizes.xSmall = '11px';
    FontSizes.small = '12px';
    FontSizes.smallPlus = '13px';
    FontSizes.medium = '14px';
    FontSizes.mediumPlus = '15px';
    FontSizes.icon = '16px';
    FontSizes.large = '17px';
    FontSizes.xLarge = '21px';
    FontSizes.xxLarge = '28px';
    FontSizes.superLarge = '42px';
    FontSizes.mega = '72px';
})(FontSizes = exports.FontSizes || (exports.FontSizes = {}));
// Standard font weights.
var FontWeights;
(function (FontWeights) {
    FontWeights.light = 100;
    FontWeights.semilight = 300;
    FontWeights.regular = 400;
    FontWeights.semibold = 600;
    FontWeights.bold = 700;
})(FontWeights = exports.FontWeights || (exports.FontWeights = {}));
// Standard Icon Sizes.
var IconFontSizes;
(function (IconFontSizes) {
    IconFontSizes.xSmall = '10px';
    IconFontSizes.small = '12px';
    IconFontSizes.medium = '16px';
    IconFontSizes.large = '20px';
})(IconFontSizes = exports.IconFontSizes || (exports.IconFontSizes = {}));
function createFontStyles(localeCode) {
    return {
        tiny: _createFont(FontSizes.mini, FontWeights.semibold, localeCode),
        xSmall: _createFont(FontSizes.xSmall, FontWeights.regular, localeCode),
        small: _createFont(FontSizes.small, FontWeights.regular, localeCode),
        smallPlus: _createFont(FontSizes.smallPlus, FontWeights.regular, localeCode),
        medium: _createFont(FontSizes.medium, FontWeights.regular, localeCode),
        mediumPlus: _createFont(FontSizes.mediumPlus, FontWeights.regular, localeCode),
        large: _createFont(FontSizes.large, FontWeights.semilight, localeCode),
        xLarge: _createFont(FontSizes.xLarge, FontWeights.light, localeCode),
        xxLarge: _createFont(FontSizes.xxLarge, FontWeights.light, localeCode),
        superLarge: _createFont(FontSizes.superLarge, FontWeights.light, localeCode),
        mega: _createFont(FontSizes.mega, FontWeights.light, localeCode)
    };
}
exports.createFontStyles = createFontStyles;
function _getFontFamily(language) {
    var fontFamily = LocalizedFontFamilies.WestEuropean;
    for (var lang in LanguageToFontMap) {
        if (LanguageToFontMap.hasOwnProperty(lang) && language && lang.indexOf(language) === 0) {
            // tslint:disable-next-line:no-any
            fontFamily = LanguageToFontMap[lang];
            break;
        }
    }
    return fontFamily + ", " + FontFamilyFallbacks;
}
function _createFont(size, weight, localeCode) {
    return {
        fontFamily: _getFontFamily(localeCode),
        MozOsxFontSmoothing: 'grayscale',
        WebkitFontSmoothing: 'antialiased',
        fontSize: size,
        fontWeight: weight
    };
}

},{}],28:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Generates a focus style which can be used to define an :after focus border.
 *
 * @param theme - The theme object to use.
 * @param inset - The number of pixels to inset the border.
 * @param color - The color for the border.
 * @param position - The positioning applied to the container. Must
 * be 'relative' or 'absolute' so that the focus border can live around it.
 * @returns The style object.
 */
function getFocusStyle(theme, inset, position) {
    if (inset === void 0) { inset = 0; }
    if (position === void 0) { position = 'relative'; }
    return {
        outline: 'transparent',
        position: position,
        selectors: {
            '::-moz-focus-inner': {
                border: '0'
            },
            '.ms-Fabric.is-focusVisible &:focus:after': {
                content: '""',
                position: 'absolute',
                left: inset + 1,
                top: inset + 1,
                bottom: inset + 1,
                right: inset + 1,
                border: '1px solid ' + theme.palette.white,
                outline: '1px solid ' + theme.palette.neutralSecondary,
                zIndex: 1
            }
        }
    };
}
exports.getFocusStyle = getFocusStyle;

},{}],29:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.hiddenContentStyle = {
    position: 'absolute',
    width: 1,
    height: 1,
    margin: -1,
    padding: 0,
    border: 0,
    overflow: 'hidden'
};

},{}],30:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var AnimationStyles_1 = require("./AnimationStyles");
exports.AnimationStyles = AnimationStyles_1.AnimationStyles;
var DefaultPalette_1 = require("./DefaultPalette");
exports.DefaultPalette = DefaultPalette_1.DefaultPalette;
var DefaultFontStyles_1 = require("./DefaultFontStyles");
exports.DefaultFontStyles = DefaultFontStyles_1.DefaultFontStyles;
exports.registerDefaultFontFaces = DefaultFontStyles_1.registerDefaultFontFaces;
var fonts_1 = require("./fonts");
exports.FontSizes = fonts_1.FontSizes;
exports.FontWeights = fonts_1.FontWeights;
exports.IconFontSizes = fonts_1.IconFontSizes;
exports.createFontStyles = fonts_1.createFontStyles;
var getFocusStyle_1 = require("./getFocusStyle");
exports.getFocusStyle = getFocusStyle_1.getFocusStyle;
var hiddenContentStyle_1 = require("./hiddenContentStyle");
exports.hiddenContentStyle = hiddenContentStyle_1.hiddenContentStyle;
var theme_1 = require("./theme");
exports.ThemeSettingName = theme_1.ThemeSettingName;
exports.getTheme = theme_1.getTheme;
exports.loadTheme = theme_1.loadTheme;
exports.createTheme = theme_1.createTheme;
exports.registerOnThemeChangeCallback = theme_1.registerOnThemeChangeCallback;
exports.removeOnThemeChangeCallback = theme_1.removeOnThemeChangeCallback;
tslib_1.__exportStar(require("./CommonStyles"), exports);

},{"./AnimationStyles":23,"./CommonStyles":24,"./DefaultFontStyles":25,"./DefaultPalette":26,"./fonts":27,"./getFocusStyle":28,"./hiddenContentStyle":29,"./theme":31,"tslib":155}],31:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var Customizations_1 = require("@uifabric/utilities/lib/Customizations");
var DefaultFontStyles_1 = require("./DefaultFontStyles");
var DefaultPalette_1 = require("./DefaultPalette");
var load_themed_styles_1 = require("@microsoft/load-themed-styles");
var _theme = {
    palette: DefaultPalette_1.DefaultPalette,
    semanticColors: _makeSemanticColorsFromPalette(DefaultPalette_1.DefaultPalette, false),
    fonts: DefaultFontStyles_1.DefaultFontStyles,
    isInverted: false
};
var _onThemeChangeCallbacks = [];
exports.ThemeSettingName = 'theme';
if (!Customizations_1.Customizations.getSettings([exports.ThemeSettingName]).theme) {
    var win = typeof window !== 'undefined' ? window : undefined;
    // tslint:disable:no-string-literal no-any
    if (win && win['FabricConfig'] && win['FabricConfig'].theme) {
        _theme = createTheme(win['FabricConfig'].theme);
    }
    // tslint:enable:no-string-literal no-any
    // Set the default theme.
    Customizations_1.Customizations.applySettings((_a = {}, _a[exports.ThemeSettingName] = _theme, _a));
}
/**
 * Gets the theme object.
 */
function getTheme() {
    return _theme;
}
exports.getTheme = getTheme;
/**
 * Registers a callback that gets called whenever the theme changes.
 * This should only be used when the component cannot automatically get theme changes through its state.
 * This will not register duplicate callbacks.
 */
function registerOnThemeChangeCallback(callback) {
    if (_onThemeChangeCallbacks.indexOf(callback) === -1) {
        _onThemeChangeCallbacks.push(callback);
    }
}
exports.registerOnThemeChangeCallback = registerOnThemeChangeCallback;
/**
 * See registerOnThemeChangeCallback().
 * Removes previously registered callbacks.
 */
function removeOnThemeChangeCallback(callback) {
    var i = _onThemeChangeCallbacks.indexOf(callback);
    if (i === -1) {
        return;
    }
    _onThemeChangeCallbacks.splice(i, 1);
}
exports.removeOnThemeChangeCallback = removeOnThemeChangeCallback;
/**
 * Applies the theme, while filling in missing slots.
 */
function loadTheme(theme) {
    _theme = createTheme(theme);
    // Invoke the legacy method of theming the page as well.
    load_themed_styles_1.loadTheme(tslib_1.__assign({}, _theme.palette, _theme.semanticColors));
    Customizations_1.Customizations.applySettings((_a = {}, _a[exports.ThemeSettingName] = _theme, _a));
    _onThemeChangeCallbacks.forEach(function (callback) {
        try {
            callback(_theme);
        }
        catch (e) {
            // don't let a bad callback break everything else
        }
    });
    return _theme;
    var _a;
}
exports.loadTheme = loadTheme;
/**
 * Creates a custom theme definition which can be used with the Customizer.
 */
function createTheme(theme) {
    var newPalette = tslib_1.__assign({}, DefaultPalette_1.DefaultPalette, theme.palette);
    if (!theme.palette || !theme.palette.accent) {
        newPalette.accent = newPalette.themePrimary;
    }
    return {
        palette: newPalette,
        fonts: tslib_1.__assign({}, DefaultFontStyles_1.DefaultFontStyles, theme.fonts),
        semanticColors: tslib_1.__assign({}, _makeSemanticColorsFromPalette(newPalette, !!theme.isInverted), theme.semanticColors),
        isInverted: !!theme.isInverted
    };
}
exports.createTheme = createTheme;
// Generates all the semantic slot colors based on the Fabric palette.
// We'll use these as fallbacks for semantic slots that the passed in theme did not define.
function _makeSemanticColorsFromPalette(p, isInverted) {
    return {
        bodyBackground: p.white,
        bodyText: p.neutralPrimary,
        bodyTextChecked: p.black,
        bodySubtext: p.neutralSecondary,
        bodyDivider: p.neutralLight,
        disabledBackground: p.neutralLighter,
        disabledText: p.neutralTertiary,
        disabledBodyText: p.neutralTertiaryAlt,
        disabledSubtext: p.neutralQuaternary,
        focusBorder: p.black,
        errorText: !isInverted ? p.redDark : '#ff5f5f',
        warningText: !isInverted ? '#333333' : '#ffffff',
        errorBackground: !isInverted ? 'rgba(232, 17, 35, .2)' : 'rgba(232, 17, 35, .5)',
        blockingBackground: !isInverted ? 'rgba(234, 67, 0, .2)' : 'rgba(234, 67, 0, .5)',
        warningBackground: !isInverted ? 'rgba(255, 185, 0, .2)' : 'rgba(255, 251, 0, .6)',
        warningHighlight: !isInverted ? '#ffb900' : '#fff100',
        successBackground: !isInverted ? 'rgba(186, 216, 10, .2)' : 'rgba(186, 216, 10, .4)',
        inputBorder: p.neutralTertiary,
        inputBorderHovered: p.neutralDark,
        inputBackgroundChecked: p.themePrimary,
        inputBackgroundCheckedHovered: p.themeDarkAlt,
        inputForegroundChecked: p.white,
        inputFocusBorderAlt: p.themePrimary,
        buttonBackground: p.neutralLighter,
        buttonBackgroundChecked: p.neutralTertiaryAlt,
        buttonBackgroundHovered: p.neutralLight,
        buttonBackgroundCheckedHovered: p.neutralLight,
        buttonBorder: 'transparent',
        buttonText: p.neutralPrimary,
        buttonTextHovered: p.black,
        buttonTextChecked: p.neutralDark,
        buttonTextCheckedHovered: p.black,
        menuItemBackgroundHovered: p.neutralLighter,
        menuItemBackgroundChecked: p.neutralLight,
        menuIcon: p.themePrimary,
        menuHeader: p.themePrimary,
        listBackground: p.white,
        listTextColor: p.neutralPrimary,
        listItemBackgroundHovered: p.neutralLighter,
        listItemBackgroundChecked: p.neutralLight,
        listItemBackgroundCheckedHovered: p.neutralQuaternaryAlt
    };
}
var _a;

},{"./DefaultFontStyles":25,"./DefaultPalette":26,"@microsoft/load-themed-styles":2,"@uifabric/utilities/lib/Customizations":39,"tslib":155}],32:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var MergeStyles_1 = require("../MergeStyles");
/**
 * Builds a class names object from a given map.
 *
 * @param styles - Map of unprocessed styles.
 * @returns Map of property name to class name.
 */
function buildClassMap(styles) {
    var classes = {};
    var _loop_1 = function (styleName) {
        if (styles.hasOwnProperty(styleName)) {
            var className_1;
            Object.defineProperty(classes, styleName, {
                get: function () {
                    if (className_1 === undefined) {
                        // tslint:disable-next-line:no-any
                        className_1 = MergeStyles_1.mergeStyles(styles[styleName]).toString();
                    }
                    return className_1;
                },
                enumerable: true,
                configurable: true
            });
        }
    };
    for (var styleName in styles) {
        _loop_1(styleName);
    }
    return classes;
}
exports.buildClassMap = buildClassMap;

},{"../MergeStyles":17}],33:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var index_1 = require("@uifabric/merge-styles/lib/index");
var icons_1 = require("./icons");
var defaultIconStyles = {
    display: 'inline-block'
};
/**
 * Gets an icon classname. You should be able to add this classname to an I tag with no
 * additional classnames, and render the icon.
 *
 * @public
 */
function getIconClassName(name) {
    var className = '';
    var icon = icons_1.getIcon(name);
    if (icon) {
        className = index_1.mergeStyles(icon.subset.className, defaultIconStyles, {
            selectors: {
                '::before': {
                    content: "\"" + icon.code + "\""
                }
            }
        });
    }
    return className;
}
exports.getIconClassName = getIconClassName;

},{"./icons":34,"@uifabric/merge-styles/lib/index":8}],34:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var warn_1 = require("@uifabric/utilities/lib/warn");
var GlobalSettings_1 = require("@uifabric/utilities/lib/GlobalSettings");
var index_1 = require("@uifabric/merge-styles/lib/index");
var ICON_SETTING_NAME = 'icons';
var _iconSettings = GlobalSettings_1.GlobalSettings.getValue(ICON_SETTING_NAME, {
    __options: {
        disableWarnings: false,
        warnOnMissingIcons: true
    },
    __remapped: {}
});
/**
 * Registers a given subset of icons.
 *
 * @param iconSubset - the icon subset definition.
 */
function registerIcons(iconSubset, options) {
    var subset = tslib_1.__assign({}, iconSubset, { isRegistered: false, className: undefined });
    var icons = iconSubset.icons;
    // Grab options, optionally mix user provided ones on top.
    options = options ? tslib_1.__assign({}, _iconSettings.__options, options) : _iconSettings.__options;
    for (var iconName in icons) {
        if (icons.hasOwnProperty(iconName)) {
            var code = icons[iconName];
            var normalizedIconName = iconName.toLowerCase();
            if (_iconSettings[normalizedIconName]) {
                if (!options.disableWarnings) {
                    warn_1.warn("Icon '" + iconName + " being re-registered. Ignoring duplicate registration.");
                }
            }
            else {
                _iconSettings[normalizedIconName] = {
                    code: code,
                    subset: subset
                };
            }
        }
    }
}
exports.registerIcons = registerIcons;
/**
 * Remaps one icon name to another.
 */
function registerIconAlias(iconName, mappedToName) {
    _iconSettings.__remapped[iconName.toLowerCase()] = mappedToName.toLowerCase();
}
exports.registerIconAlias = registerIconAlias;
/**
 * Gets an icon definition. If an icon is requested but the subset has yet to be registered,
 * it will get registered immediately.
 *
 * @public
 * @param name - Name of icon.
 */
function getIcon(name) {
    var icon = undefined;
    var options = _iconSettings.__options;
    name = name ? name.toLowerCase() : '';
    name = _iconSettings.__remapped[name] || name;
    if (name) {
        icon = _iconSettings[name];
        if (icon) {
            var subset = icon.subset;
            if (subset.fontFace && !subset.isRegistered) {
                // Register font face for given icons.
                index_1.fontFace(subset.fontFace);
                // Generate a base class name for the given font.
                subset.className = index_1.mergeStyles(subset.style, {
                    fontFamily: subset.fontFace.fontFamily,
                    fontWeight: subset.fontFace.fontWeight || 'normal',
                    fontStyle: subset.fontFace.fontStyle || 'normal'
                }).toString();
                subset.isRegistered = true;
            }
        }
        else {
            if (!options.disableWarnings && options.warnOnMissingIcons) {
                warn_1.warn("The icon \"" + name + "\" was used but not registered. See http://aka.ms/fabric-icon-usage for more information.");
            }
        }
    }
    return icon;
}
exports.getIcon = getIcon;
/**
 * Sets the icon options.
 *
 * @public
 */
function setIconOptions(options) {
    _iconSettings.__options = tslib_1.__assign({}, _iconSettings.__options, options);
}
exports.setIconOptions = setIconOptions;

},{"@uifabric/merge-styles/lib/index":8,"@uifabric/utilities/lib/GlobalSettings":44,"@uifabric/utilities/lib/warn":72,"tslib":155}],35:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var buildClassMap_1 = require("./buildClassMap");
exports.buildClassMap = buildClassMap_1.buildClassMap;
var icons_1 = require("./icons");
exports.getIcon = icons_1.getIcon;
exports.registerIcons = icons_1.registerIcons;
exports.registerIconAlias = icons_1.registerIconAlias;
exports.setIconOptions = icons_1.setIconOptions;
var getIconClassName_1 = require("./getIconClassName");
exports.getIconClassName = getIconClassName_1.getIconClassName;

},{"./buildClassMap":32,"./getIconClassName":33,"./icons":34}],36:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Bugs often appear in async code when stuff gets disposed, but async operations don't get canceled.
 * This Async helper class solves these issues by tying async code to the lifetime of a disposable object.
 *
 * Usage: Anything class extending from BaseModel can access this helper via this.async. Otherwise create a
 * new instance of the class and remember to call dispose() during your code's dispose handler.
 *
 * @public
 */
var Async = /** @class */ (function () {
    // tslint:disable-next-line:no-any
    function Async(parent, onError) {
        this._timeoutIds = null;
        this._immediateIds = null;
        this._intervalIds = null;
        this._animationFrameIds = null;
        this._isDisposed = false;
        this._parent = parent || null;
        this._onErrorHandler = onError;
        this._noop = function () { };
    }
    /**
     * Dispose function, clears all async operations.
     */
    Async.prototype.dispose = function () {
        var id;
        this._isDisposed = true;
        this._parent = null;
        // Clear timeouts.
        if (this._timeoutIds) {
            for (id in this._timeoutIds) {
                if (this._timeoutIds.hasOwnProperty(id)) {
                    this.clearTimeout(parseInt(id, 10));
                }
            }
            this._timeoutIds = null;
        }
        // Clear immediates.
        if (this._immediateIds) {
            for (id in this._immediateIds) {
                if (this._immediateIds.hasOwnProperty(id)) {
                    this.clearImmediate(parseInt(id, 10));
                }
            }
            this._immediateIds = null;
        }
        // Clear intervals.
        if (this._intervalIds) {
            for (id in this._intervalIds) {
                if (this._intervalIds.hasOwnProperty(id)) {
                    this.clearInterval(parseInt(id, 10));
                }
            }
            this._intervalIds = null;
        }
        // Clear animation frames.
        if (this._animationFrameIds) {
            for (id in this._animationFrameIds) {
                if (this._animationFrameIds.hasOwnProperty(id)) {
                    this.cancelAnimationFrame(parseInt(id, 10));
                }
            }
            this._animationFrameIds = null;
        }
    };
    /**
     * SetTimeout override, which will auto cancel the timeout during dispose.
     * @param callback - Callback to execute.
     * @param duration - Duration in milliseconds.
     * @returns The setTimeout id.
     */
    Async.prototype.setTimeout = function (callback, duration) {
        var _this = this;
        var timeoutId = 0;
        if (!this._isDisposed) {
            if (!this._timeoutIds) {
                this._timeoutIds = {};
            }
            /* tslint:disable:ban-native-functions */
            timeoutId = setTimeout(function () {
                // Time to execute the timeout, enqueue it as a foreground task to be executed.
                try {
                    // Now delete the record and call the callback.
                    if (_this._timeoutIds) {
                        delete _this._timeoutIds[timeoutId];
                    }
                    callback.apply(_this._parent);
                }
                catch (e) {
                    if (_this._onErrorHandler) {
                        _this._onErrorHandler(e);
                    }
                }
            }, duration);
            /* tslint:enable:ban-native-functions */
            this._timeoutIds[timeoutId] = true;
        }
        return timeoutId;
    };
    /**
     * Clears the timeout.
     * @param id - Id to cancel.
     */
    Async.prototype.clearTimeout = function (id) {
        if (this._timeoutIds && this._timeoutIds[id]) {
            /* tslint:disable:ban-native-functions */
            clearTimeout(id);
            delete this._timeoutIds[id];
            /* tslint:enable:ban-native-functions */
        }
    };
    /**
     * SetImmediate override, which will auto cancel the immediate during dispose.
     * @param callback - Callback to execute.
     * @returns The setTimeout id.
     */
    Async.prototype.setImmediate = function (callback) {
        var _this = this;
        var immediateId = 0;
        if (!this._isDisposed) {
            if (!this._immediateIds) {
                this._immediateIds = {};
            }
            /* tslint:disable:ban-native-functions */
            var setImmediateCallback = function () {
                // Time to execute the timeout, enqueue it as a foreground task to be executed.
                try {
                    // Now delete the record and call the callback.
                    if (_this._immediateIds) {
                        delete _this._immediateIds[immediateId];
                    }
                    callback.apply(_this._parent);
                }
                catch (e) {
                    _this._logError(e);
                }
            };
            immediateId = window.setImmediate ? window.setImmediate(setImmediateCallback) : window.setTimeout(setImmediateCallback, 0);
            /* tslint:enable:ban-native-functions */
            this._immediateIds[immediateId] = true;
        }
        return immediateId;
    };
    /**
     * Clears the immediate.
     * @param id - Id to cancel.
     */
    Async.prototype.clearImmediate = function (id) {
        if (this._immediateIds && this._immediateIds[id]) {
            /* tslint:disable:ban-native-functions */
            window.clearImmediate ? window.clearImmediate(id) : window.clearTimeout(id);
            delete this._immediateIds[id];
            /* tslint:enable:ban-native-functions */
        }
    };
    /**
     * SetInterval override, which will auto cancel the timeout during dispose.
     * @param callback - Callback to execute.
     * @param duration - Duration in milliseconds.
     * @returns The setTimeout id.
     */
    Async.prototype.setInterval = function (callback, duration) {
        var _this = this;
        var intervalId = 0;
        if (!this._isDisposed) {
            if (!this._intervalIds) {
                this._intervalIds = {};
            }
            /* tslint:disable:ban-native-functions */
            intervalId = setInterval(function () {
                // Time to execute the interval callback, enqueue it as a foreground task to be executed.
                try {
                    callback.apply(_this._parent);
                }
                catch (e) {
                    _this._logError(e);
                }
            }, duration);
            /* tslint:enable:ban-native-functions */
            this._intervalIds[intervalId] = true;
        }
        return intervalId;
    };
    /**
     * Clears the interval.
     * @param id - Id to cancel.
     */
    Async.prototype.clearInterval = function (id) {
        if (this._intervalIds && this._intervalIds[id]) {
            /* tslint:disable:ban-native-functions */
            clearInterval(id);
            delete this._intervalIds[id];
            /* tslint:enable:ban-native-functions */
        }
    };
    /**
     * Creates a function that, when executed, will only call the func function at most once per
     * every wait milliseconds. Provide an options object to indicate that func should be invoked
     * on the leading and/or trailing edge of the wait timeout. Subsequent calls to the throttled
     * function will return the result of the last func call.
     *
     * Note: If leading and trailing options are true func will be called on the trailing edge of
     * the timeout only if the the throttled function is invoked more than once during the wait timeout.
     *
     * @param func - The function to throttle.
     * @param wait - The number of milliseconds to throttle executions to. Defaults to 0.
     * @param options - The options object.
     * @returns The new throttled function.
     */
    Async.prototype.throttle = function (func, wait, options) {
        var _this = this;
        if (this._isDisposed) {
            return this._noop;
        }
        var waitMS = wait || 0;
        var leading = true;
        var trailing = true;
        var lastExecuteTime = 0;
        var lastResult;
        // tslint:disable-next-line:no-any
        var lastArgs;
        var timeoutId = null;
        if (options && typeof (options.leading) === 'boolean') {
            leading = options.leading;
        }
        if (options && typeof (options.trailing) === 'boolean') {
            trailing = options.trailing;
        }
        var callback = function (userCall) {
            var now = (new Date).getTime();
            var delta = now - lastExecuteTime;
            var waitLength = leading ? waitMS - delta : waitMS;
            if (delta >= waitMS && (!userCall || leading)) {
                lastExecuteTime = now;
                if (timeoutId) {
                    _this.clearTimeout(timeoutId);
                    timeoutId = null;
                }
                lastResult = func.apply(_this._parent, lastArgs);
            }
            else if (timeoutId === null && trailing) {
                timeoutId = _this.setTimeout(callback, waitLength);
            }
            return lastResult;
        };
        // tslint:disable-next-line:no-any
        var resultFunction = function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            lastArgs = args;
            return callback(true);
        };
        return resultFunction;
    };
    /**
     * Creates a function that will delay the execution of func until after wait milliseconds have
     * elapsed since the last time it was invoked. Provide an options object to indicate that func
     * should be invoked on the leading and/or trailing edge of the wait timeout. Subsequent calls
     * to the debounced function will return the result of the last func call.
     *
     * Note: If leading and trailing options are true func will be called on the trailing edge of
     * the timeout only if the the debounced function is invoked more than once during the wait
     * timeout.
     *
     * @param func - The function to debounce.
     * @param wait - The number of milliseconds to delay.
     * @param options - The options object.
     * @returns The new debounced function.
     */
    Async.prototype.debounce = function (func, wait, options) {
        var _this = this;
        if (this._isDisposed) {
            var noOpFunction = (function () {
                /** Do nothing */
            });
            noOpFunction.cancel = function () { return; };
            /* tslint:disable:no-any */
            noOpFunction.flush = (function () { return null; });
            /* tslint:enable:no-any */
            noOpFunction.pending = function () { return false; };
            return noOpFunction;
        }
        var waitMS = wait || 0;
        var leading = false;
        var trailing = true;
        var maxWait = null;
        var lastCallTime = 0;
        var lastExecuteTime = (new Date).getTime();
        var lastResult;
        // tslint:disable-next-line:no-any
        var lastArgs;
        var timeoutId = null;
        if (options && typeof (options.leading) === 'boolean') {
            leading = options.leading;
        }
        if (options && typeof (options.trailing) === 'boolean') {
            trailing = options.trailing;
        }
        if (options && typeof (options.maxWait) === 'number' && !isNaN(options.maxWait)) {
            maxWait = options.maxWait;
        }
        var invokeFunction = function (time) {
            if (timeoutId) {
                _this.clearTimeout(timeoutId);
                timeoutId = null;
            }
            lastExecuteTime = time;
            lastResult = func.apply(_this._parent, lastArgs);
        };
        var callback = function (userCall) {
            var now = (new Date).getTime();
            var executeImmediately = false;
            if (userCall) {
                if (leading && now - lastCallTime >= waitMS) {
                    executeImmediately = true;
                }
                lastCallTime = now;
            }
            var delta = now - lastCallTime;
            var waitLength = waitMS - delta;
            var maxWaitDelta = now - lastExecuteTime;
            var maxWaitExpired = false;
            if (maxWait !== null) {
                // maxWait only matters when there is a pending callback
                if (maxWaitDelta >= maxWait && timeoutId) {
                    maxWaitExpired = true;
                }
                else {
                    waitLength = Math.min(waitLength, maxWait - maxWaitDelta);
                }
            }
            if (delta >= waitMS || maxWaitExpired || executeImmediately) {
                invokeFunction(now);
            }
            else if ((timeoutId === null || !userCall) && trailing) {
                timeoutId = _this.setTimeout(callback, waitLength);
            }
            return lastResult;
        };
        var cancel = function () {
            if (timeoutId) {
                _this.clearTimeout(timeoutId);
            }
        };
        var flush = function () {
            if (timeoutId) {
                _this.clearTimeout(timeoutId);
                invokeFunction(new Date().getTime());
            }
            return lastResult;
        };
        var pending = function () {
            return !!timeoutId;
        };
        // tslint:disable-next-line:no-any
        var resultFunction = (function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            lastArgs = args;
            return callback(true);
        });
        resultFunction.cancel = cancel;
        resultFunction.flush = flush;
        resultFunction.pending = pending;
        return resultFunction;
    };
    Async.prototype.requestAnimationFrame = function (callback) {
        var _this = this;
        var animationFrameId = 0;
        if (!this._isDisposed) {
            if (!this._animationFrameIds) {
                this._animationFrameIds = {};
            }
            /* tslint:disable:ban-native-functions */
            var animationFrameCallback = function () {
                try {
                    // Now delete the record and call the callback.
                    if (_this._animationFrameIds) {
                        delete _this._animationFrameIds[animationFrameId];
                    }
                    callback.apply(_this._parent);
                }
                catch (e) {
                    _this._logError(e);
                }
            };
            animationFrameId = window.requestAnimationFrame ?
                window.requestAnimationFrame(animationFrameCallback) :
                window.setTimeout(animationFrameCallback, 0);
            /* tslint:enable:ban-native-functions */
            this._animationFrameIds[animationFrameId] = true;
        }
        return animationFrameId;
    };
    Async.prototype.cancelAnimationFrame = function (id) {
        if (this._animationFrameIds && this._animationFrameIds[id]) {
            /* tslint:disable:ban-native-functions */
            window.cancelAnimationFrame ? window.cancelAnimationFrame(id) : window.clearTimeout(id);
            /* tslint:enable:ban-native-functions */
            delete this._animationFrameIds[id];
        }
    };
    // tslint:disable-next-line:no-any
    Async.prototype._logError = function (e) {
        if (this._onErrorHandler) {
            this._onErrorHandler(e);
        }
    };
    return Async;
}());
exports.Async = Async;

},{}],37:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var EventGroup_1 = require("./EventGroup");
var scroll_1 = require("./scroll");
var dom_1 = require("./dom");
var SCROLL_ITERATION_DELAY = 16;
var SCROLL_GUTTER_HEIGHT = 100;
var MAX_SCROLL_VELOCITY = 15;
/**
 * AutoScroll simply hooks up mouse events given a parent element, and scrolls the container
 * up/down depending on how close the mouse is to the top/bottom of the container.
 *
 * Once you don't want autoscroll any more, just dispose the helper and it will unhook events.
 *
 * @public
 */
var AutoScroll = /** @class */ (function () {
    function AutoScroll(element) {
        this._events = new EventGroup_1.EventGroup(this);
        this._scrollableParent = scroll_1.findScrollableParent(element);
        this._incrementScroll = this._incrementScroll.bind(this);
        this._scrollRect = dom_1.getRect(this._scrollableParent);
        // tslint:disable-next-line:no-any
        if (this._scrollableParent === window) {
            this._scrollableParent = document.body;
        }
        if (this._scrollableParent) {
            this._events.on(window, 'mousemove', this._onMouseMove, true);
            this._events.on(window, 'touchmove', this._onTouchMove, true);
        }
    }
    AutoScroll.prototype.dispose = function () {
        this._events.dispose();
        this._stopScroll();
    };
    AutoScroll.prototype._onMouseMove = function (ev) {
        this._computeScrollVelocity(ev.clientY);
    };
    AutoScroll.prototype._onTouchMove = function (ev) {
        if (ev.touches.length > 0) {
            this._computeScrollVelocity(ev.touches[0].clientY);
        }
    };
    AutoScroll.prototype._computeScrollVelocity = function (clientY) {
        if (!this._scrollRect) {
            return;
        }
        var scrollRectTop = this._scrollRect.top;
        var scrollClientBottom = scrollRectTop + this._scrollRect.height - SCROLL_GUTTER_HEIGHT;
        if (clientY < (scrollRectTop + SCROLL_GUTTER_HEIGHT)) {
            this._scrollVelocity = Math.max(-MAX_SCROLL_VELOCITY, -MAX_SCROLL_VELOCITY * ((SCROLL_GUTTER_HEIGHT - (clientY - scrollRectTop)) / SCROLL_GUTTER_HEIGHT));
        }
        else if (clientY > scrollClientBottom) {
            this._scrollVelocity = Math.min(MAX_SCROLL_VELOCITY, MAX_SCROLL_VELOCITY * ((clientY - scrollClientBottom) / SCROLL_GUTTER_HEIGHT));
        }
        else {
            this._scrollVelocity = 0;
        }
        if (this._scrollVelocity) {
            this._startScroll();
        }
        else {
            this._stopScroll();
        }
    };
    AutoScroll.prototype._startScroll = function () {
        if (!this._timeoutId) {
            this._incrementScroll();
        }
    };
    AutoScroll.prototype._incrementScroll = function () {
        if (this._scrollableParent) {
            this._scrollableParent.scrollTop += Math.round(this._scrollVelocity);
        }
        this._timeoutId = setTimeout(this._incrementScroll, SCROLL_ITERATION_DELAY);
    };
    AutoScroll.prototype._stopScroll = function () {
        if (this._timeoutId) {
            clearTimeout(this._timeoutId);
            delete this._timeoutId;
        }
    };
    return AutoScroll;
}());
exports.AutoScroll = AutoScroll;

},{"./EventGroup":42,"./dom":53,"./scroll":67}],38:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var React = require("react");
var Async_1 = require("./Async");
var EventGroup_1 = require("./EventGroup");
var warn_1 = require("./warn");
/**
 * BaseComponent class, which provides basic helpers for all components.
 *
 * @public
 */
var BaseComponent = /** @class */ (function (_super) {
    tslib_1.__extends(BaseComponent, _super);
    // tslint:enable:variable-name
    /**
     * BaseComponent constructor
     * @param props - The props for the component.
     * @param context - The context for the component.
     */
    // tslint:disable-next-line:no-any
    function BaseComponent(props, context) {
        var _this = _super.call(this, props, context) || this;
        _this._shouldUpdateComponentRef = true;
        _makeAllSafe(_this, BaseComponent.prototype, [
            'componentWillMount',
            'componentDidMount',
            'shouldComponentUpdate',
            'componentWillUpdate',
            'componentWillReceiveProps',
            'render',
            'componentDidUpdate',
            'componentWillUnmount'
        ]);
        return _this;
    }
    /**
     * When the component will receive props, make sure the componentRef is updated.
     */
    // tslint:disable-next-line:no-any
    BaseComponent.prototype.componentWillReceiveProps = function (newProps, newContext) {
        this._updateComponentRef(this.props, newProps);
    };
    /**
     * When the component has mounted, update the componentRef.
     */
    BaseComponent.prototype.componentDidMount = function () {
        this._updateComponentRef(undefined, this.props);
    };
    /**
     * If we have disposables, dispose them automatically on unmount.
     */
    BaseComponent.prototype.componentWillUnmount = function () {
        if (this.__disposables) {
            for (var i = 0, len = this._disposables.length; i < len; i++) {
                var disposable = this.__disposables[i];
                if (disposable.dispose) {
                    disposable.dispose();
                }
            }
            this.__disposables = null;
        }
    };
    Object.defineProperty(BaseComponent.prototype, "className", {
        /**
         * Gets the object's class name.
         */
        get: function () {
            if (!this.__className) {
                var funcNameRegex = /function (.{1,})\(/;
                var results = (funcNameRegex).exec((this).constructor.toString());
                this.__className = (results && results.length > 1) ? results[1] : '';
            }
            return this.__className;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BaseComponent.prototype, "_disposables", {
        /**
         * Allows subclasses to push things to this._disposables to be auto disposed.
         */
        get: function () {
            if (!this.__disposables) {
                this.__disposables = [];
            }
            return this.__disposables;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BaseComponent.prototype, "_async", {
        /**
         * Gets the async instance associated with the component, created on demand. The async instance gives
         * subclasses a way to execute setTimeout/setInterval async calls safely, where the callbacks
         * will be cleared/ignored automatically after unmounting. The helpers within the async object also
         * preserve the this pointer so that you don't need to "bind" the callbacks.
         */
        get: function () {
            if (!this.__async) {
                this.__async = new Async_1.Async(this);
                this._disposables.push(this.__async);
            }
            return this.__async;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BaseComponent.prototype, "_events", {
        /**
         * Gets the event group instance assocaited with the component, created on demand. The event instance
         * provides on/off methods for listening to DOM (or regular javascript object) events. The event callbacks
         * will be automatically disconnected after unmounting. The helpers within the events object also
         * preserve the this reference so that you don't need to "bind" the callbacks.
         */
        get: function () {
            if (!this.__events) {
                this.__events = new EventGroup_1.EventGroup(this);
                this._disposables.push(this.__events);
            }
            return this.__events;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Helper to return a memoized ref resolver function.
     * @param refName - Name of the member to assign the ref to.
     * @returns A function instance keyed from the given refname.
     */
    BaseComponent.prototype._resolveRef = function (refName) {
        var _this = this;
        if (!this.__resolves) {
            this.__resolves = {};
        }
        if (!this.__resolves[refName]) {
            // tslint:disable-next-line:no-any
            this.__resolves[refName] = function (ref) {
                // tslint:disable-next-line:no-any
                return _this[refName] = ref;
            };
        }
        return this.__resolves[refName];
    };
    /**
     * Updates the componentRef (by calling it with "this" when necessary.)
     */
    BaseComponent.prototype._updateComponentRef = function (currentProps, newProps) {
        if (newProps === void 0) { newProps = {}; }
        if (this._shouldUpdateComponentRef &&
            ((!currentProps && newProps.componentRef) ||
                (currentProps && currentProps.componentRef !== newProps.componentRef))) {
            if (currentProps && currentProps.componentRef) {
                currentProps.componentRef(null);
            }
            if (newProps.componentRef) {
                newProps.componentRef(this);
            }
        }
    };
    /**
     * Warns when a deprecated props are being used.
     *
     * @param deprecationMap - The map of deprecations, where key is the prop name and the value is
     * either null or a replacement prop name.
     */
    BaseComponent.prototype._warnDeprecations = function (deprecationMap) {
        warn_1.warnDeprecations(this.className, this.props, deprecationMap);
    };
    /**
     * Warns when props which are mutually exclusive with each other are both used.
     *
     * @param mutuallyExclusiveMap - The map of mutually exclusive props.
     */
    BaseComponent.prototype._warnMutuallyExclusive = function (mutuallyExclusiveMap) {
        warn_1.warnMutuallyExclusive(this.className, this.props, mutuallyExclusiveMap);
    };
    /**
     * Warns when props are required if a condition is met.
     *
     * @param requiredProps - The name of the props that are required when the condition is met.
     * @param conditionalPropName - The name of the prop that the condition is based on.
     * @param condition - Whether the condition is met.
     */
    BaseComponent.prototype._warnConditionallyRequiredProps = function (requiredProps, conditionalPropName, condition) {
        warn_1.warnConditionallyRequiredProps(this.className, this.props, requiredProps, conditionalPropName, condition);
    };
    return BaseComponent;
}(React.Component));
exports.BaseComponent = BaseComponent;
/**
 * Helper to override a given method with a wrapper method that can try/catch the original, but also
 * ensures that the BaseComponent's methods are called before the subclass's. This ensures that
 * componentWillUnmount in the base is called and that things in the _disposables array are disposed.
 */
function _makeAllSafe(obj, prototype, methodNames) {
    for (var i = 0, len = methodNames.length; i < len; i++) {
        _makeSafe(obj, prototype, methodNames[i]);
    }
}
function _makeSafe(obj, prototype, methodName) {
    // tslint:disable:no-any
    var classMethod = obj[methodName];
    var prototypeMethod = prototype[methodName];
    // tslint:enable:no-any
    if (classMethod || prototypeMethod) {
        // tslint:disable-next-line:no-any
        obj[methodName] = function () {
            var retVal;
            try {
                if (prototypeMethod) {
                    retVal = prototypeMethod.apply(this, arguments);
                }
                if (classMethod !== prototypeMethod) {
                    retVal = classMethod.apply(this, arguments);
                }
            }
            catch (e) {
                var errorMessage = "Exception in " + obj.className + "." + methodName + "(): " + (typeof e === 'string' ? e : e.stack);
                if (BaseComponent.onError) {
                    BaseComponent.onError(errorMessage, e);
                }
            }
            return retVal;
        };
    }
}
BaseComponent.onError = function (errorMessage) {
    console.error(errorMessage);
    throw errorMessage;
};
/**
 * Simple constant function for returning null, used to render empty templates in JSX.
 *
 * @public
 */
function nullRender() { return null; }
exports.nullRender = nullRender;

},{"./Async":36,"./EventGroup":42,"./warn":72,"react":"react","tslib":155}],39:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var GlobalSettings_1 = require("./GlobalSettings");
var EventGroup_1 = require("./EventGroup");
var CustomizationsGlobalKey = 'customizations';
var NO_CUSTOMIZATIONS = { settings: {}, scopedSettings: {} };
var _allSettings = GlobalSettings_1.GlobalSettings.getValue(CustomizationsGlobalKey, {
    settings: {},
    scopedSettings: {}
});
var _events = new EventGroup_1.EventGroup(_allSettings);
var Customizations = /** @class */ (function () {
    function Customizations() {
    }
    Customizations.reset = function () {
        _allSettings.settings = {};
        _allSettings.scopedSettings = {};
    };
    // tslint:disable-next-line:no-any
    Customizations.applySettings = function (settings) {
        _allSettings.settings = tslib_1.__assign({}, _allSettings.settings, settings);
        Customizations._raiseChange();
    };
    // tslint:disable-next-line:no-any
    Customizations.applyScopedSettings = function (scopeName, settings) {
        _allSettings.scopedSettings[scopeName] = tslib_1.__assign({}, _allSettings.scopedSettings[scopeName], settings);
        Customizations._raiseChange();
    };
    Customizations.getSettings = function (properties, scopeName, localSettings
        // tslint:disable-next-line:no-any
    ) {
        if (localSettings === void 0) { localSettings = NO_CUSTOMIZATIONS; }
        // tslint:disable-next-line:no-any
        var settings = {};
        var localScopedSettings = (scopeName && localSettings.scopedSettings[scopeName]) || {};
        var globalScopedSettings = (scopeName && _allSettings.scopedSettings[scopeName]) || {};
        for (var _i = 0, properties_1 = properties; _i < properties_1.length; _i++) {
            var property = properties_1[_i];
            settings[property] = (localScopedSettings[property] ||
                localSettings.settings[property] ||
                globalScopedSettings[property] ||
                _allSettings.settings[property]);
        }
        return settings;
    };
    Customizations.observe = function (onChange) {
        _events.on(_allSettings, 'change', onChange);
    };
    Customizations.unobserve = function (onChange) {
        _events.off(_allSettings, 'change', onChange);
    };
    Customizations._raiseChange = function () {
        _events.raise('change');
    };
    return Customizations;
}());
exports.Customizations = Customizations;

},{"./EventGroup":42,"./GlobalSettings":44,"tslib":155}],40:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var React = require("react");
var PropTypes = require("prop-types");
var BaseComponent_1 = require("./BaseComponent");
/**
 * The Customizer component allows for default props to be mixed into components which
 * are decorated with the customizable() decorator. This enables injection scenarios like:
 *
 * 1. render svg icons instead of the icon font within all buttons
 * 2. inject a custom theme object into a component
 *
 * Props are provided via the settings prop, which should be a json map which contains 1 or more
 * name/value pairs representing injectable props.
 *
 * @public
 */
var Customizer = /** @class */ (function (_super) {
    tslib_1.__extends(Customizer, _super);
    // tslint:disable-next-line:no-any
    function Customizer(props, context) {
        var _this = _super.call(this, props) || this;
        _this.state = _this._getCustomizations(props, context);
        return _this;
    }
    Customizer.prototype.getChildContext = function () {
        return this.state;
    };
    // tslint:disable-next-line:no-any
    Customizer.prototype.componentWillReceiveProps = function (newProps, newContext) {
        this.setState(this._getCustomizations(newProps, newContext));
    };
    Customizer.prototype.render = function () {
        return React.Children.only(this.props.children);
    };
    Customizer.prototype._getCustomizations = function (props, context) {
        var _a = props.settings, settings = _a === void 0 ? {} : _a, _b = props.scopedSettings, scopedSettings = _b === void 0 ? {} : _b;
        var _c = context.customizations, customizations = _c === void 0 ? { settings: {}, scopedSettings: {} } : _c;
        var newScopedSettings = tslib_1.__assign({}, scopedSettings);
        for (var name_1 in customizations.scopedSettings) {
            if (customizations.scopedSettings.hasOwnProperty(name_1)) {
                newScopedSettings[name_1] = tslib_1.__assign({}, scopedSettings[name_1], customizations.scopedSettings[name_1]);
            }
        }
        return {
            customizations: {
                settings: tslib_1.__assign({}, settings, customizations.settings),
                scopedSettings: newScopedSettings
            }
        };
    };
    Customizer.contextTypes = {
        customizations: PropTypes.object
    };
    Customizer.childContextTypes = Customizer.contextTypes;
    return Customizer;
}(BaseComponent_1.BaseComponent));
exports.Customizer = Customizer;

},{"./BaseComponent":38,"prop-types":153,"react":"react","tslib":155}],41:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var React = require("react");
/**
 * Utility component for delaying the render of a child component after a given delay. This component
 * requires a single child component; don't pass in many components. Wrap multiple components in a DIV
 * if necessary.
 *
 * @public
 */
var DelayedRender = /** @class */ (function (_super) {
    tslib_1.__extends(DelayedRender, _super);
    function DelayedRender(props) {
        var _this = _super.call(this, props) || this;
        _this.state = {
            isRendered: false
        };
        return _this;
    }
    DelayedRender.prototype.componentDidMount = function () {
        var _this = this;
        var delay = this.props.delay;
        this._timeoutId = setTimeout(function () {
            _this.setState({
                isRendered: true
            });
        }, delay);
    };
    DelayedRender.prototype.componentWillUnmount = function () {
        if (this._timeoutId) {
            clearTimeout(this._timeoutId);
        }
    };
    DelayedRender.prototype.render = function () {
        return this.state.isRendered ? React.Children.only(this.props.children) : null;
    };
    // tslint:disable-next-line:typedef
    DelayedRender.defaultProps = {
        delay: 0
    };
    return DelayedRender;
}(React.Component));
exports.DelayedRender = DelayedRender;

},{"react":"react","tslib":155}],42:[function(require,module,exports){
"use strict";
/* tslint:disable:no-string-literal */
Object.defineProperty(exports, "__esModule", { value: true });
/** An instance of EventGroup allows anything with a handle to it to trigger events on it.
 *  If the target is an HTMLElement, the event will be attached to the element and can be
 *  triggered as usual (like clicking for onclick).
 *  The event can be triggered by calling EventGroup.raise() here. If the target is an
 *  HTMLElement, the event gets raised and is handled by the browser. Otherwise, it gets
 *  handled here in EventGroup, and the handler is called in the context of the parent
 *  (which is passed in in the constructor).
 *
 * @public
 */
var EventGroup = /** @class */ (function () {
    /** parent: the context in which events attached to non-HTMLElements are called */
    // tslint:disable-next-line:no-any
    function EventGroup(parent) {
        this._id = EventGroup._uniqueId++;
        this._parent = parent;
        this._eventRecords = [];
    }
    /** For IE8, bubbleEvent is ignored here and must be dealt with by the handler.
     *  Events raised here by default have bubbling set to false and cancelable set to true.
     *  This applies also to built-in events being raised manually here on HTMLElements,
     *  which may lead to unexpected behavior if it differs from the defaults.
     *
     */
    EventGroup.raise = function (
        // tslint:disable-next-line:no-any
        target, eventName, 
        // tslint:disable-next-line:no-any
        eventArgs, bubbleEvent) {
        var retVal;
        if (EventGroup._isElement(target)) {
            if (document.createEvent) {
                var ev = document.createEvent('HTMLEvents');
                ev.initEvent(eventName, bubbleEvent || false, true);
                // tslint:disable-next-line:no-any
                ev['args'] = eventArgs;
                retVal = target.dispatchEvent(ev);
                // tslint:disable-next-line:no-any
            }
            else if (document['createEventObject']) {
                // tslint:disable-next-line:no-any
                var evObj = document['createEventObject'](eventArgs);
                // cannot set cancelBubble on evObj, fireEvent will overwrite it
                target.fireEvent('on' + eventName, evObj);
            }
        }
        else {
            while (target && retVal !== false) {
                var events = target.__events__;
                var eventRecords = events ? events[eventName] : null;
                if (eventRecords) {
                    for (var id in eventRecords) {
                        if (eventRecords.hasOwnProperty(id)) {
                            var eventRecordList = eventRecords[id];
                            for (var listIndex = 0; retVal !== false && listIndex < eventRecordList.length; listIndex++) {
                                var record = eventRecordList[listIndex];
                                if (record.objectCallback) {
                                    retVal = record.objectCallback.call(record.parent, eventArgs);
                                }
                            }
                        }
                    }
                }
                // If the target has a parent, bubble the event up.
                target = bubbleEvent ? target.parent : null;
            }
        }
        return retVal;
    };
    // tslint:disable-next-line:no-any
    EventGroup.isObserved = function (target, eventName) {
        var events = target && target.__events__;
        return !!events && !!events[eventName];
    };
    /** Check to see if the target has declared support of the given event. */
    // tslint:disable-next-line:no-any
    EventGroup.isDeclared = function (target, eventName) {
        var declaredEvents = target && target.__declaredEvents;
        return !!declaredEvents && !!declaredEvents[eventName];
    };
    // tslint:disable-next-line:no-any
    EventGroup.stopPropagation = function (event) {
        if (event.stopPropagation) {
            event.stopPropagation();
        }
        else {
            event.cancelBubble = true;
        }
    };
    EventGroup._isElement = function (target) {
        return (!!target && (!!target.addEventListener ||
            (typeof HTMLElement !== 'undefined' && target instanceof HTMLElement)));
    };
    EventGroup.prototype.dispose = function () {
        if (!this._isDisposed) {
            this._isDisposed = true;
            this.off();
            this._parent = null;
        }
    };
    /** On the target, attach a set of events, where the events object is a name to function mapping. */
    // tslint:disable-next-line:no-any
    EventGroup.prototype.onAll = function (target, events, useCapture) {
        for (var eventName in events) {
            if (events.hasOwnProperty(eventName)) {
                this.on(target, eventName, events[eventName], useCapture);
            }
        }
    };
    /** On the target, attach an event whose handler will be called in the context of the parent
     * of this instance of EventGroup.
     */
    // tslint:disable-next-line:no-any
    EventGroup.prototype.on = function (target, eventName, callback, useCapture) {
        var _this = this;
        if (eventName.indexOf(',') > -1) {
            var events = eventName.split(/[ ,]+/);
            for (var i = 0; i < events.length; i++) {
                this.on(target, events[i], callback, useCapture);
            }
        }
        else {
            var parent_1 = this._parent;
            var eventRecord = {
                target: target,
                eventName: eventName,
                parent: parent_1,
                callback: callback,
                useCapture: useCapture || false
            };
            // Initialize and wire up the record on the target, so that it can call the callback if the event fires.
            var events = (target.__events__ = target.__events__ || {});
            events[eventName] = events[eventName] || {
                count: 0
            };
            events[eventName][this._id] = events[eventName][this._id] || [];
            events[eventName][this._id].push(eventRecord);
            events[eventName].count++;
            if (EventGroup._isElement(target)) {
                // tslint:disable-next-line:no-any
                var processElementEvent = function () {
                    var args = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        args[_i] = arguments[_i];
                    }
                    if (_this._isDisposed) {
                        return;
                    }
                    var result;
                    try {
                        result = callback.apply(parent_1, args);
                        if (result === false && args[0]) {
                            var e = args[0];
                            if (e.preventDefault) {
                                e.preventDefault();
                            }
                            if (e.stopPropagation) {
                                e.stopPropagation();
                            }
                            e.cancelBubble = true;
                        }
                    }
                    catch (e) {
                        /* ErrorHelper.log(e); */
                    }
                    return result;
                };
                eventRecord.elementCallback = processElementEvent;
                if (target.addEventListener) {
                    /* tslint:disable:ban-native-functions */
                    target.addEventListener(eventName, processElementEvent, useCapture);
                    /* tslint:enable:ban-native-functions */
                }
                else if (target.attachEvent) {
                    target.attachEvent('on' + eventName, processElementEvent);
                }
            }
            else {
                // tslint:disable-next-line:no-any
                var processObjectEvent = function () {
                    var args = [];
                    for (var _i = 0; _i < arguments.length; _i++) {
                        args[_i] = arguments[_i];
                    }
                    if (_this._isDisposed) {
                        return;
                    }
                    return callback.apply(parent_1, args);
                };
                eventRecord.objectCallback = processObjectEvent;
            }
            // Remember the record locally, so that it can be removed.
            this._eventRecords.push(eventRecord);
        }
    };
    // tslint:disable-next-line:no-any
    EventGroup.prototype.off = function (target, eventName, callback, useCapture) {
        for (var i = 0; i < this._eventRecords.length; i++) {
            var eventRecord = this._eventRecords[i];
            if ((!target || target === eventRecord.target) &&
                (!eventName || eventName === eventRecord.eventName) &&
                (!callback || callback === eventRecord.callback) &&
                ((typeof useCapture !== 'boolean') || useCapture === eventRecord.useCapture)) {
                var events = eventRecord.target.__events__;
                var targetArrayLookup = events[eventRecord.eventName];
                var targetArray = targetArrayLookup ? targetArrayLookup[this._id] : null;
                // We may have already target's entries, so check for null.
                if (targetArray) {
                    if (targetArray.length === 1 || !callback) {
                        targetArrayLookup.count -= targetArray.length;
                        delete events[eventRecord.eventName][this._id];
                    }
                    else {
                        targetArrayLookup.count--;
                        targetArray.splice(targetArray.indexOf(eventRecord), 1);
                    }
                    if (!targetArrayLookup.count) {
                        delete events[eventRecord.eventName];
                    }
                }
                if (eventRecord.elementCallback) {
                    if (eventRecord.target.removeEventListener) {
                        eventRecord.target.removeEventListener(eventRecord.eventName, eventRecord.elementCallback, eventRecord.useCapture);
                    }
                    else if (eventRecord.target.detachEvent) {
                        eventRecord.target.detachEvent('on' + eventRecord.eventName, eventRecord.elementCallback);
                    }
                }
                this._eventRecords.splice(i--, 1);
            }
        }
    };
    /** Trigger the given event in the context of this instance of EventGroup. */
    // tslint:disable-next-line:no-any
    EventGroup.prototype.raise = function (eventName, eventArgs, bubbleEvent) {
        return EventGroup.raise(this._parent, eventName, eventArgs, bubbleEvent);
    };
    /** Declare an event as being supported by this instance of EventGroup. */
    EventGroup.prototype.declare = function (event) {
        var declaredEvents = this._parent.__declaredEvents = this._parent.__declaredEvents || {};
        if (typeof event === 'string') {
            declaredEvents[event] = true;
        }
        else {
            for (var i = 0; i < event.length; i++) {
                declaredEvents[event[i]] = true;
            }
        }
    };
    // tslint:disable-next-line:no-inferrable-types
    EventGroup._uniqueId = 0;
    return EventGroup;
}());
exports.EventGroup = EventGroup;

},{}],43:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var now = function () { return (typeof performance !== 'undefined' && !!performance.now) ? performance.now() : Date.now(); };
var RESET_INTERVAL = 3 * 60 * 1000; // auto reset every 3 minutes
/**
 * Performance helper class for measuring things.
 *
 * @public
 */
var FabricPerformance = /** @class */ (function () {
    function FabricPerformance() {
    }
    /**
     * Measures execution time of the given syncronous function. If the same logic is executed multiple times,
     * each individual measurement will be collected as well the overall numbers.
     * @param name - The name of this measurement
     * @param func - The logic to be measured for execution time
     */
    FabricPerformance.measure = function (name, func) {
        if (Number.isInteger(FabricPerformance._timeoutId)) {
            FabricPerformance.setPeriodicReset();
        }
        var start = now();
        func();
        var end = now();
        var measurement = FabricPerformance.summary[name] || {
            totalDuration: 0,
            count: 0,
            all: []
        };
        var duration = end - start;
        measurement.totalDuration += duration;
        measurement.count++;
        measurement.all.push({
            duration: duration,
            timeStamp: end
        });
        FabricPerformance.summary[name] = measurement;
    };
    FabricPerformance.reset = function () {
        FabricPerformance.summary = {};
        clearTimeout(FabricPerformance._timeoutId);
        FabricPerformance._timeoutId = NaN;
    };
    FabricPerformance.setPeriodicReset = function () {
        FabricPerformance._timeoutId = setTimeout(function () { return FabricPerformance.reset(); }, RESET_INTERVAL);
    };
    FabricPerformance.summary = {};
    return FabricPerformance;
}());
exports.FabricPerformance = FabricPerformance;

},{}],44:[function(require,module,exports){
"use strict";
/**
 * Storing global state in local module variables has issues when more than one copy
 * if the module gets loaded on the page (due to a bundling error or simply by consuming
 * a prebundled script.)
 *
 * This file contains helpers to deal with the getting and setting local state, and allows
 * callers to get called back when it mutates.
 */
Object.defineProperty(exports, "__esModule", { value: true });
var GLOBAL_SETTINGS_PROP_NAME = '__globalSettings__';
var CALLBACK_STATE_PROP_NAME = '__callbacks__';
// tslint:disable-next-line:no-any
var _globalSettings = {};
var _counter = 0;
if (typeof window !== 'undefined') {
    // tslint:disable-next-line:no-any
    var win = window;
    _globalSettings = win[GLOBAL_SETTINGS_PROP_NAME] = win[GLOBAL_SETTINGS_PROP_NAME] || (_a = {},
        _a[CALLBACK_STATE_PROP_NAME] = {},
        _a);
}
var _callbacks = _globalSettings[CALLBACK_STATE_PROP_NAME];
/**
 * Global settings helper, which stores settings in the global (window) namespace.
 * If window is not provided, it will store settings in module scope. Provides a
 * way to observe changes as well when their values change.
 *
 * @public
 */
var GlobalSettings = /** @class */ (function () {
    function GlobalSettings() {
    }
    GlobalSettings.getValue = function (key, defaultValue) {
        if (_globalSettings[key] === undefined) {
            _globalSettings[key] = typeof defaultValue === 'function' ? defaultValue() : defaultValue;
        }
        return _globalSettings[key];
    };
    GlobalSettings.setValue = function (key, value) {
        var oldValue = _globalSettings[key];
        if (value !== oldValue) {
            _globalSettings[key] = value;
            var changeDescription = {
                oldValue: oldValue,
                value: value,
                key: key
            };
            for (var id in _callbacks) {
                if (_callbacks.hasOwnProperty(id)) {
                    _callbacks[id](changeDescription);
                }
            }
        }
        return value;
    };
    GlobalSettings.addChangeListener = function (cb) {
        // Note: we use generated ids on the callbacks to create a map of the callbacks, which optimizes removal.
        // (It's faster to delete a key than it is to look up the index of an object and splice an array.)
        var id = cb.__id__;
        if (!id) {
            id = cb.__id__ = String(_counter++);
        }
        _callbacks[id] = cb;
    };
    GlobalSettings.removeChangeListener = function (cb) {
        delete _callbacks[cb.__id__];
    };
    return GlobalSettings;
}());
exports.GlobalSettings = GlobalSettings;
var _a;

},{}],45:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Const enum for keycodes.
 *
 * @public
 */
var KeyCodes;
(function (KeyCodes) {
    KeyCodes[KeyCodes["a"] = 65] = "a";
    KeyCodes[KeyCodes["c"] = 67] = "c";
    KeyCodes[KeyCodes["backspace"] = 8] = "backspace";
    KeyCodes[KeyCodes["comma"] = 188] = "comma";
    KeyCodes[KeyCodes["del"] = 46] = "del";
    KeyCodes[KeyCodes["down"] = 40] = "down";
    KeyCodes[KeyCodes["end"] = 35] = "end";
    KeyCodes[KeyCodes["enter"] = 13] = "enter";
    KeyCodes[KeyCodes["escape"] = 27] = "escape";
    KeyCodes[KeyCodes["home"] = 36] = "home";
    KeyCodes[KeyCodes["left"] = 37] = "left";
    KeyCodes[KeyCodes["pageDown"] = 34] = "pageDown";
    KeyCodes[KeyCodes["pageUp"] = 33] = "pageUp";
    KeyCodes[KeyCodes["right"] = 39] = "right";
    KeyCodes[KeyCodes["semicolon"] = 186] = "semicolon";
    KeyCodes[KeyCodes["space"] = 32] = "space";
    KeyCodes[KeyCodes["tab"] = 9] = "tab";
    KeyCodes[KeyCodes["up"] = 38] = "up";
})(KeyCodes = exports.KeyCodes || (exports.KeyCodes = {}));

},{}],46:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Rectangle helper class.
 *
 * @public
 */
var Rectangle = /** @class */ (function () {
    function Rectangle(left, right, top, bottom) {
        if (left === void 0) { left = 0; }
        if (right === void 0) { right = 0; }
        if (top === void 0) { top = 0; }
        if (bottom === void 0) { bottom = 0; }
        this.top = top;
        this.bottom = bottom;
        this.left = left;
        this.right = right;
    }
    Object.defineProperty(Rectangle.prototype, "width", {
        /**
         * Calculated automatically by subtracting the right from left
         */
        get: function () {
            return this.right - this.left;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Rectangle.prototype, "height", {
        /**
         * Calculated automatically by subtracting the bottom from top.
         */
        get: function () {
            return this.bottom - this.top;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Tests if another rect is approximately equal to this rect (within 4 decimal places.)
     */
    Rectangle.prototype.equals = function (rect) {
        // I'm fixing it to 4 decimal places because it allows enough precision and will handle cases when something should be rounded,
        // like .999999 should round to 1.
        return (parseFloat(this.top.toFixed(4)) === parseFloat(rect.top.toFixed(4)) &&
            parseFloat(this.bottom.toFixed(4)) === parseFloat(rect.bottom.toFixed(4)) &&
            parseFloat(this.left.toFixed(4)) === parseFloat(rect.left.toFixed(4)) &&
            parseFloat(this.right.toFixed(4)) === parseFloat(rect.right.toFixed(4)));
    };
    return Rectangle;
}());
exports.Rectangle = Rectangle;

},{}],47:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Helper to find the index of an item within an array, using a callback to
 * determine the match.
 *
 * @public
 * @param array - Array to search.
 * @param cb - Callback which returns true on matches.
 */
function findIndex(array, cb) {
    var index = -1;
    for (var i = 0; array && i < array.length; i++) {
        if (cb(array[i], i)) {
            index = i;
            break;
        }
    }
    return index;
}
exports.findIndex = findIndex;
/**
 * Helper to find the first item within an array that satisfies the callback.
 * @param array - Array to search
 * @param cb - Callback which returns true on matches
 */
function find(array, cb) {
    var index = findIndex(array, cb);
    if (index < 0) {
        return undefined;
    }
    return array[index];
}
exports.find = find;
/**
 * Creates an array of a given size and helper method to populate.
 *
 * @public
 * @param size - Size of array.
 * @param getItem - Callback to populate given cell index.
 */
function createArray(size, getItem) {
    var array = [];
    for (var i = 0; i < size; i++) {
        array.push(getItem(i));
    }
    return array;
}
exports.createArray = createArray;
/**
 * Convert the given array to a matrix with columnCount number
 * of columns.
 *
 * @public
 * @param items - The array to convert
 * @param columnCount - The number of columns for the resulting matrix
 * @returns {any[][]} - A matrix of items
 */
function toMatrix(items, columnCount) {
    return items.reduce(function (rows, currentValue, index) {
        if (index % columnCount === 0) {
            rows.push([currentValue]);
        }
        else {
            rows[rows.length - 1].push(currentValue);
        }
        return rows;
    }, []);
}
exports.toMatrix = toMatrix;
/**
 * Given an array, it returns a new array that does not contain the item at the given index.
 * @param array - The array to operate on
 * @param index - The index of the element to remove
 */
function removeIndex(array, index) {
    return array.filter(function (_, i) { return index !== i; });
}
exports.removeIndex = removeIndex;
/**
 * Given an array, this function returns a new array where the element at a given index has been replaced.
 * @param array - The array to operate on
 * @param newElement - The element that will be placed in the new array
 * @param index - The index of the element that should be replaced
 */
function replaceElement(array, newElement, index) {
    var copy = array.slice();
    copy[index] = newElement;
    return copy;
}
exports.replaceElement = replaceElement;
/**
 * Given an array, this function returns a new array where an element has been inserted at the given index.
 * @param array - The array to operate on
 * @param index - The index where an element should be inserted
 * @param itemToAdd - The element to insert
 */
function addElementAtIndex(array, index, itemToAdd) {
    var copy = array.slice();
    copy.splice(index, 0, itemToAdd);
    return copy;
}
exports.addElementAtIndex = addElementAtIndex;
/**
 * Given an array where each element is of type T or T[], flatten it into an array of T
 * @param array - The array where each element can optionally also be an array
 */
function flatten(array) {
    var result = [];
    array.forEach(function (item) { return (result = result.concat(item)); });
    return result;
}
exports.flatten = flatten;

},{}],48:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * AssertNever is a utility function that can be used for exhaustiveness checks in switch statements.
 *
 * @public
 */
function assertNever(x) {
    throw new Error('Unexpected object: ' + x);
}
exports.assertNever = assertNever;

},{}],49:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Autobind is a utility for binding methods in a class. This simplifies tagging methods as being "bound" to the this pointer
 * so that they can be used in scenarios that simply require a function callback.
 */
// tslint:disable-next-line:no-any
function autobind(target, key, descriptor) {
    var fn = descriptor.value;
    var defining = false;
    return {
        configurable: true,
        get: function () {
            if (defining || (fn && this === fn.prototype) || this.hasOwnProperty(key)) {
                return fn;
            }
            // Bind method only once, and update the property to return the bound value from now on
            var fnBound = fn && fn.bind(this);
            defining = true;
            Object.defineProperty(this, key, {
                configurable: true,
                writable: true,
                enumerable: true,
                value: fnBound
            });
            defining = false;
            return fnBound;
        },
        // tslint:disable-next-line:no-any
        set: function (newValue) {
            Object.defineProperty(this, key, {
                configurable: true,
                writable: true,
                enumerable: true,
                value: newValue
            });
        }
    };
}
exports.autobind = autobind;

},{}],50:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var index_1 = require("@uifabric/merge-styles/lib/index");
/**
 * Creates a getClassNames function which calls getStyles given the props, and injects them
 * into mergeStyleSets.
 */
function classNamesFunction() {
    // TODO: memoize.
    return function (getStyles, styleProps) { return index_1.mergeStyleSets(getStyles && getStyles(styleProps)); };
}
exports.classNamesFunction = classNamesFunction;

},{"@uifabric/merge-styles/lib/index":8}],51:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Concatination helper, which can merge class names together. Skips over falsey values.
 *
 * @public
 */
function css() {
    var args = [];
    for (var _i = 0; _i < arguments.length; _i++) {
        args[_i] = arguments[_i];
    }
    var classes = [];
    for (var _a = 0, args_1 = args; _a < args_1.length; _a++) {
        var arg = args_1[_a];
        if (arg) {
            if (typeof arg === 'string') {
                classes.push(arg);
            }
            else if ((arg.hasOwnProperty('toString') && typeof (arg.toString) === 'function')) {
                classes.push(arg.toString());
            }
            else {
                // tslint:disable-next-line:no-any
                for (var key in arg) {
                    // tslint:disable-next-line:no-any
                    if (arg[key]) {
                        classes.push(key);
                    }
                }
            }
        }
    }
    return classes.join(' ');
}
exports.css = css;

},{}],52:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var React = require("react");
var PropTypes = require("prop-types");
var Customizations_1 = require("./Customizations");
function customizable(scope, fields
    // tslint:disable-next-line:no-any
) {
    // tslint:disable-next-line:no-shadowed-variable
    return function customizableFactory(
        // tslint:disable-next-line:no-any
        ComposedComponent
        // tslint:disable-next-line:no-any
    ) {
        return _a = /** @class */ (function (_super) {
                tslib_1.__extends(ComponentWithInjectedProps, _super);
                // tslint:disable-next-line:no-any
                function ComponentWithInjectedProps(props, context) {
                    var _this = _super.call(this, props, context) || this;
                    _this._onSettingChanged = _this._onSettingChanged.bind(_this);
                    return _this;
                }
                ComponentWithInjectedProps.prototype.componentDidMount = function () {
                    Customizations_1.Customizations.observe(this._onSettingChanged);
                };
                ComponentWithInjectedProps.prototype.componentWillUnmount = function () {
                    Customizations_1.Customizations.unobserve(this._onSettingChanged);
                };
                ComponentWithInjectedProps.prototype.render = function () {
                    var defaultProps = Customizations_1.Customizations.getSettings(fields, scope, this.context.customizations);
                    return (
                    // tslint:disable-next-line:no-any
                    React.createElement(ComposedComponent, tslib_1.__assign({}, defaultProps, this.props)));
                };
                ComponentWithInjectedProps.prototype._onSettingChanged = function () {
                    this.forceUpdate();
                };
                return ComponentWithInjectedProps;
            }(React.Component)),
            _a.displayName = 'Customized' + scope,
            _a.contextTypes = {
                customizations: PropTypes.object
            },
            _a;
        var _a;
    };
}
exports.customizable = customizable;

},{"./Customizations":39,"prop-types":153,"react":"react","tslib":155}],53:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Sets the virtual parent of an element.
 * Pass `undefined` as the `parent` to clear the virtual parent.
 *
 * @public
 */
function setVirtualParent(child, parent) {
    var virtualChild = child;
    var virtualParent = parent;
    if (!virtualChild._virtual) {
        virtualChild._virtual = {
            children: []
        };
    }
    var oldParent = virtualChild._virtual.parent;
    if (oldParent && oldParent !== parent) {
        // Remove the child from its old parent.
        var index = oldParent._virtual.children.indexOf(virtualChild);
        if (index > -1) {
            oldParent._virtual.children.splice(index, 1);
        }
    }
    virtualChild._virtual.parent = virtualParent || undefined;
    if (virtualParent) {
        if (!virtualParent._virtual) {
            virtualParent._virtual = {
                children: []
            };
        }
        virtualParent._virtual.children.push(virtualChild);
    }
}
exports.setVirtualParent = setVirtualParent;
/**
 * Gets the virtual parent given the child element, if it exists.
 *
 * @public
 */
function getVirtualParent(child) {
    var parent;
    if (child && isVirtualElement(child)) {
        parent = child._virtual.parent;
    }
    return parent;
}
exports.getVirtualParent = getVirtualParent;
/**
 * Gets the element which is the parent of a given element.
 * If `allowVirtuaParents` is `true`, this method prefers the virtual parent over
 * real DOM parent when present.
 *
 * @public
 */
function getParent(child, allowVirtualParents) {
    if (allowVirtualParents === void 0) { allowVirtualParents = true; }
    return child && (allowVirtualParents && getVirtualParent(child) ||
        child.parentNode && child.parentNode);
}
exports.getParent = getParent;
/**
 * Gets the elements which are child elements of the given element.
 * If `allowVirtualChildren` is `true`, this method enumerates virtual child elements
 * after the original children.
 * @param parent
 * @param allowVirtualChildren
 */
function getChildren(parent, allowVirtualChildren) {
    if (allowVirtualChildren === void 0) { allowVirtualChildren = true; }
    var children = [];
    if (parent) {
        for (var i = 0; i < parent.children.length; i++) {
            children.push(parent.children.item(i));
        }
        if (allowVirtualChildren && isVirtualElement(parent)) {
            children.push.apply(children, parent._virtual.children);
        }
    }
    return children;
}
exports.getChildren = getChildren;
/**
 * Determines whether or not a parent element contains a given child element.
 * If `allowVirtualParents` is true, this method may return `true` if the child
 * has the parent in its virtual element hierarchy.
 *
 * @public
 */
function elementContains(parent, child, allowVirtualParents) {
    if (allowVirtualParents === void 0) { allowVirtualParents = true; }
    var isContained = false;
    if (parent && child) {
        if (allowVirtualParents) {
            isContained = false;
            while (child) {
                var nextParent = getParent(child);
                if (nextParent === parent) {
                    isContained = true;
                    break;
                }
                child = nextParent;
            }
        }
        else if (parent.contains) {
            isContained = parent.contains(child);
        }
    }
    return isContained;
}
exports.elementContains = elementContains;
var _isSSR = false;
/**
 * Helper to set ssr mode to simulate no window object returned from getWindow helper.
 *
 * @public
 */
function setSSR(isEnabled) {
    _isSSR = isEnabled;
}
exports.setSSR = setSSR;
/**
 * Helper to get the window object.
 *
 * @public
 */
function getWindow(rootElement) {
    if (_isSSR || typeof window === 'undefined') {
        return undefined;
    }
    else {
        return (rootElement &&
            rootElement.ownerDocument &&
            rootElement.ownerDocument.defaultView ?
            rootElement.ownerDocument.defaultView :
            window);
    }
}
exports.getWindow = getWindow;
/**
 * Helper to get the document object.
 *
 * @public
 */
function getDocument(rootElement) {
    if (_isSSR || typeof document === 'undefined') {
        return undefined;
    }
    else {
        return rootElement && rootElement.ownerDocument ? rootElement.ownerDocument : document;
    }
}
exports.getDocument = getDocument;
/**
 * Helper to get bounding client rect, works with window.
 *
 * @public
 */
function getRect(element) {
    var rect;
    if (element) {
        if (element === window) {
            rect = {
                left: 0,
                top: 0,
                width: window.innerWidth,
                height: window.innerHeight,
                right: window.innerWidth,
                bottom: window.innerHeight
            };
        }
        else if (element.getBoundingClientRect) {
            rect = element.getBoundingClientRect();
        }
    }
    return rect;
}
exports.getRect = getRect;
/**
 * Determines whether or not an element has the virtual hierarchy extension.
 *
 * @public
 */
function isVirtualElement(element) {
    return element && !!element._virtual;
}

},{}],54:[function(require,module,exports){
"use strict";
/* tslint:disable:no-string-literal */
Object.defineProperty(exports, "__esModule", { value: true });
var dom_1 = require("./dom");
var IS_FOCUSABLE_ATTRIBUTE = 'data-is-focusable';
var IS_VISIBLE_ATTRIBUTE = 'data-is-visible';
var FOCUSZONE_ID_ATTRIBUTE = 'data-focuszone-id';
var FOCUSZONE_SUB_ATTRIBUTE = 'data-is-sub-focuszone';
/**
 * Gets the first focusable element.
 *
 * @public
 */
function getFirstFocusable(rootElement, currentElement, includeElementsInFocusZones) {
    return getNextElement(rootElement, currentElement, true, false, false, includeElementsInFocusZones);
}
exports.getFirstFocusable = getFirstFocusable;
/**
 * Gets the last focusable element.
 *
 * @public
 */
function getLastFocusable(rootElement, currentElement, includeElementsInFocusZones) {
    return getPreviousElement(rootElement, currentElement, true, false, true, includeElementsInFocusZones);
}
exports.getLastFocusable = getLastFocusable;
/**
 * Gets the last tabbable element.
 *
 * @public
 */
function getLastTabbable(rootElement, currentElement, includeElementsInFocusZones) {
    return getPreviousElement(rootElement, currentElement, true, false, true, includeElementsInFocusZones, false, true);
}
exports.getLastTabbable = getLastTabbable;
/**
 * Attempts to focus the first focusable element that is a child or child's child of the rootElement.
 *
 * @public
 * @param rootElement - Element to start the search for a focusable child.
 * @returns True if focus was set, false if it was not.
 */
function focusFirstChild(rootElement) {
    var element = getNextElement(rootElement, rootElement, true, false, false, true);
    if (element) {
        element.focus();
        return true;
    }
    return false;
}
exports.focusFirstChild = focusFirstChild;
/**
 * Traverse to find the previous element.
 *
 * @public
 */
function getPreviousElement(rootElement, currentElement, checkNode, suppressParentTraversal, traverseChildren, includeElementsInFocusZones, allowFocusRoot, tabbable) {
    if (!currentElement ||
        (!allowFocusRoot && currentElement === rootElement)) {
        return null;
    }
    var isCurrentElementVisible = isElementVisible(currentElement);
    // Check its children.
    if (traverseChildren && isCurrentElementVisible &&
        (includeElementsInFocusZones || !(isElementFocusZone(currentElement) || isElementFocusSubZone(currentElement)))) {
        var childMatch = getPreviousElement(rootElement, currentElement.lastElementChild, true, true, true, includeElementsInFocusZones, allowFocusRoot, tabbable);
        if (childMatch && ((tabbable && (isElementTabbable(childMatch, true))) || !tabbable)) {
            return childMatch;
        }
    }
    // Check the current node, if it's not the first traversal.
    if (checkNode && isCurrentElementVisible && isElementTabbable(currentElement)) {
        return currentElement;
    }
    // Check its previous sibling.
    var siblingMatch = getPreviousElement(rootElement, currentElement.previousElementSibling, true, true, true, includeElementsInFocusZones, allowFocusRoot, tabbable);
    if (siblingMatch) {
        return siblingMatch;
    }
    // Check its parent.
    if (!suppressParentTraversal) {
        return getPreviousElement(rootElement, currentElement.parentElement, true, false, false, includeElementsInFocusZones, allowFocusRoot, tabbable);
    }
    return null;
}
exports.getPreviousElement = getPreviousElement;
/**
 * Traverse to find the next focusable element.
 *
 * @public
 */
function getNextElement(rootElement, currentElement, checkNode, suppressParentTraversal, suppressChildTraversal, includeElementsInFocusZones, allowFocusRoot) {
    if (!currentElement ||
        (currentElement === rootElement && suppressChildTraversal && !allowFocusRoot)) {
        return null;
    }
    var isCurrentElementVisible = isElementVisible(currentElement);
    // Check the current node, if it's not the first traversal.
    if (checkNode && isCurrentElementVisible && isElementTabbable(currentElement)) {
        return currentElement;
    }
    // Check its children.
    if (!suppressChildTraversal && isCurrentElementVisible &&
        (includeElementsInFocusZones || !(isElementFocusZone(currentElement) || isElementFocusSubZone(currentElement)))) {
        var childMatch = getNextElement(rootElement, currentElement.firstElementChild, true, true, false, includeElementsInFocusZones, allowFocusRoot);
        if (childMatch) {
            return childMatch;
        }
    }
    if (currentElement === rootElement) {
        return null;
    }
    // Check its sibling.
    var siblingMatch = getNextElement(rootElement, currentElement.nextElementSibling, true, true, false, includeElementsInFocusZones, allowFocusRoot);
    if (siblingMatch) {
        return siblingMatch;
    }
    if (!suppressParentTraversal) {
        return getNextElement(rootElement, currentElement.parentElement, false, false, true, includeElementsInFocusZones, allowFocusRoot);
    }
    return null;
}
exports.getNextElement = getNextElement;
/**
 * Determines if an element is visible.
 *
 * @public
 */
function isElementVisible(element) {
    // If the element is not valid, return false.
    if (!element || !element.getAttribute) {
        return false;
    }
    var visibilityAttribute = element.getAttribute(IS_VISIBLE_ATTRIBUTE);
    // If the element is explicitly marked with the visibility attribute, return that value as boolean.
    if (visibilityAttribute !== null && visibilityAttribute !== undefined) {
        return visibilityAttribute === 'true';
    }
    // Fallback to other methods of determining actual visibility.
    return (element.offsetHeight !== 0 ||
        element.offsetParent !== null ||
        // tslint:disable-next-line:no-any
        element.isVisible === true); // used as a workaround for testing.
}
exports.isElementVisible = isElementVisible;
/**
 * Determines if an element can receive focus.
 *
 * @public
 */
function isElementTabbable(element, checkTabIndex) {
    // If this element is null or is disabled, it is not considered tabbable.
    if (!element || element.disabled) {
        return false;
    }
    var tabIndex = 0;
    var tabIndexAttributeValue = null;
    if (element && element.getAttribute) {
        tabIndexAttributeValue = element.getAttribute('tabIndex');
        if (tabIndexAttributeValue) {
            tabIndex = parseInt(tabIndexAttributeValue, 10);
        }
    }
    var isFocusableAttribute = element.getAttribute ? element.getAttribute(IS_FOCUSABLE_ATTRIBUTE) : null;
    var isTabIndexSet = tabIndexAttributeValue !== null && tabIndex >= 0;
    var result = !!element &&
        isFocusableAttribute !== 'false' &&
        (element.tagName === 'A' ||
            (element.tagName === 'BUTTON') ||
            (element.tagName === 'INPUT') ||
            (element.tagName === 'TEXTAREA') ||
            isFocusableAttribute === 'true' ||
            isTabIndexSet ||
            element.getAttribute && element.getAttribute('role') === 'button');
    return checkTabIndex ? (tabIndex !== -1) && result : result;
}
exports.isElementTabbable = isElementTabbable;
/**
 * Determines if a given element is a focus zone.
 *
 * @public
 */
function isElementFocusZone(element) {
    return !!(element && element.getAttribute && !!element.getAttribute(FOCUSZONE_ID_ATTRIBUTE));
}
exports.isElementFocusZone = isElementFocusZone;
/**
 * Determines if a given element is a focus sub zone.
 *
 * @public
 */
function isElementFocusSubZone(element) {
    return !!(element && element.getAttribute && element.getAttribute(FOCUSZONE_SUB_ATTRIBUTE) === 'true');
}
exports.isElementFocusSubZone = isElementFocusSubZone;
/**
 * Determines if an element, or any of its children, contain focus.
 *
 * @public
 */
function doesElementContainFocus(element) {
    var document = dom_1.getDocument(element);
    var currentActiveElement = document && document.activeElement;
    if (currentActiveElement && dom_1.elementContains(element, currentActiveElement)) {
        return true;
    }
    return false;
}
exports.doesElementContainFocus = doesElementContainFocus;

},{"./dom":53}],55:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var REACT_LIFECYCLE_EXCLUSIONS = [
    'setState',
    'render',
    'componentWillMount',
    'componentDidMount',
    'componentWillReceiveProps',
    'shouldComponentUpdate',
    'componentWillUpdate',
    'componentDidUpdate',
    'componentWillUnmount'
];
/**
 * Allows you to hoist methods, except those in an exclusion set from a source object into a destination object.
 *
 * @public
 * @param destination - The instance of the object to hoist the methods onto.
 * @param source - The instance of the object where the methods are hoisted from.
 * @param exclusions - (Optional) What methods to exclude from being hoisted.
 * @returns An array of names of methods that were hoisted.
 */
// tslint:disable-next-line:no-any
function hoistMethods(destination, source, exclusions) {
    if (exclusions === void 0) { exclusions = REACT_LIFECYCLE_EXCLUSIONS; }
    var hoisted = [];
    var _loop_1 = function (methodName) {
        if (typeof source[methodName] === 'function' &&
            destination[methodName] === undefined &&
            (!exclusions || exclusions.indexOf(methodName) === -1)) {
            hoisted.push(methodName);
            /* tslint:disable:no-function-expression */
            destination[methodName] = function () { source[methodName].apply(source, arguments); };
            /* tslint:enable */
        }
    };
    for (var methodName in source) {
        _loop_1(methodName);
    }
    return hoisted;
}
exports.hoistMethods = hoistMethods;
/**
 * Provides a method for convenience to unhoist hoisted methods.
 *
 * @public
 * @param source - The source object upon which methods were hoisted.
 * @param methodNames - An array of method names to unhoist.
 */
// tslint:disable-next-line:no-any
function unhoistMethods(source, methodNames) {
    methodNames
        .forEach(function (methodName) { return delete source[methodName]; });
}
exports.unhoistMethods = unhoistMethods;

},{}],56:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
tslib_1.__exportStar(require("./Async"), exports);
tslib_1.__exportStar(require("./AutoScroll"), exports);
tslib_1.__exportStar(require("./BaseComponent"), exports);
tslib_1.__exportStar(require("./Customizations"), exports);
tslib_1.__exportStar(require("./Customizer"), exports);
tslib_1.__exportStar(require("./DelayedRender"), exports);
tslib_1.__exportStar(require("./EventGroup"), exports);
tslib_1.__exportStar(require("./FabricPerformance"), exports);
tslib_1.__exportStar(require("./GlobalSettings"), exports);
tslib_1.__exportStar(require("./KeyCodes"), exports);
tslib_1.__exportStar(require("./Rectangle"), exports);
tslib_1.__exportStar(require("./array"), exports);
tslib_1.__exportStar(require("./assertNever"), exports);
tslib_1.__exportStar(require("./autobind"), exports);
tslib_1.__exportStar(require("./classNamesFunction"), exports);
tslib_1.__exportStar(require("./css"), exports);
tslib_1.__exportStar(require("./customizable"), exports);
tslib_1.__exportStar(require("./dom"), exports);
tslib_1.__exportStar(require("./focus"), exports);
tslib_1.__exportStar(require("./hoist"), exports);
tslib_1.__exportStar(require("./initials"), exports);
tslib_1.__exportStar(require("./language"), exports);
tslib_1.__exportStar(require("./math"), exports);
tslib_1.__exportStar(require("./memoize"), exports);
tslib_1.__exportStar(require("./object"), exports);
tslib_1.__exportStar(require("./overflow"), exports);
tslib_1.__exportStar(require("./properties"), exports);
tslib_1.__exportStar(require("./resources"), exports);
tslib_1.__exportStar(require("./rtl"), exports);
tslib_1.__exportStar(require("./scroll"), exports);
tslib_1.__exportStar(require("./string"), exports);
tslib_1.__exportStar(require("./styled"), exports);
tslib_1.__exportStar(require("./warn"), exports);

},{"./Async":36,"./AutoScroll":37,"./BaseComponent":38,"./Customizations":39,"./Customizer":40,"./DelayedRender":41,"./EventGroup":42,"./FabricPerformance":43,"./GlobalSettings":44,"./KeyCodes":45,"./Rectangle":46,"./array":47,"./assertNever":48,"./autobind":49,"./classNamesFunction":50,"./css":51,"./customizable":52,"./dom":53,"./focus":54,"./hoist":55,"./initials":57,"./language":58,"./math":60,"./memoize":61,"./object":62,"./overflow":63,"./properties":64,"./resources":65,"./rtl":66,"./scroll":67,"./string":70,"./styled":71,"./warn":72,"tslib":155}],57:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Regular expression matching characters to ignore when calculating the initials.
 * The first part matches characters within parenthesis, including the parenthesis.
 * The second part matches special ASCII characters except space, plus some unicode special characters.
 */
var UNWANTED_CHARS_REGEX = /\([^)]*\)|[\0-\u001F\!-/:-@\[-`\{-\u00BF\u0250-\u036F\uD800-\uFFFF]/g;
/** Regular expression matching one or more spaces. */
var MULTIPLE_WHITESPACES_REGEX = /\s+/g;
/**
 * Regular expression matching languages for which we currently don't support initials.
 * Arabic:   Arabic, Arabic Supplement, Arabic Extended-A.
 * Korean:   Hangul Jamo, Hangul Compatibility Jamo, Hangul Jamo Extended-A, Hangul Syllables, Hangul Jamo Extended-B.
 * Japanese: Hiragana, Katakana.
 * CJK:      CJK Unified Ideographs Extension A, CJK Unified Ideographs, CJK Compatibility Ideographs, CJK Unified Ideographs Extension B
 */
/* tslint:disable:max-line-length */
var UNSUPPORTED_TEXT_REGEX = /[\u0600-\u06FF\u0750-\u077F\u08A0-\u08FF\u1100-\u11FF\u3130-\u318F\uA960-\uA97F\uAC00-\uD7AF\uD7B0-\uD7FF\u3040-\u309F\u30A0-\u30FF\u3400-\u4DBF\u4E00-\u9FFF\uF900-\uFAFF]|[\uD840-\uD869][\uDC00-\uDED6]/;
/* tslint:enable:max-line-length */
function getInitialsLatin(displayName, isRtl) {
    var initials = '';
    var splits = displayName.split(' ');
    if (splits.length === 2) {
        initials += splits[0].charAt(0).toUpperCase();
        initials += splits[1].charAt(0).toUpperCase();
    }
    else if (splits.length === 3) {
        initials += splits[0].charAt(0).toUpperCase();
        initials += splits[2].charAt(0).toUpperCase();
    }
    else if (splits.length !== 0) {
        initials += splits[0].charAt(0).toUpperCase();
    }
    if (isRtl && initials.length > 1) {
        return initials.charAt(1) + initials.charAt(0);
    }
    return initials;
}
function cleanupDisplayName(displayName) {
    displayName = displayName.replace(UNWANTED_CHARS_REGEX, '');
    displayName = displayName.replace(MULTIPLE_WHITESPACES_REGEX, ' ');
    displayName = displayName.trim();
    return displayName;
}
/**
 * Get (up to 2 characters) initials based on display name of the persona.
 *
 * @public
 */
function getInitials(displayName, isRtl) {
    if (!displayName) {
        return '';
    }
    displayName = cleanupDisplayName(displayName);
    if (UNSUPPORTED_TEXT_REGEX.test(displayName)) {
        return '';
    }
    return getInitialsLatin(displayName, isRtl);
}
exports.getInitials = getInitials;

},{}],58:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var dom_1 = require("./dom");
var localStorage_1 = require("./localStorage");
// Default to undefined so that we initialize on first read.
var _language;
/**
 * Gets the rtl state of the page (returns true if in rtl.)
 *
 * @public
 */
function getLanguage() {
    if (_language === undefined) {
        var doc = dom_1.getDocument();
        var savedLanguage = localStorage_1.getItem('language');
        if (savedLanguage !== null) {
            _language = savedLanguage;
        }
        if (_language === undefined && doc) {
            _language = doc.documentElement.getAttribute('lang');
        }
        if (_language === undefined) {
            _language = 'en';
        }
    }
    return _language;
}
exports.getLanguage = getLanguage;
/**
 * Sets the rtl state of the page (by adjusting the dir attribute of the html element.)
 *
 * @public
 */
function setLanguage(language, avoidPersisting) {
    if (avoidPersisting === void 0) { avoidPersisting = false; }
    var doc = dom_1.getDocument();
    if (doc) {
        doc.documentElement.setAttribute('lang', language);
    }
    if (!avoidPersisting) {
        localStorage_1.setItem('language', language);
    }
    _language = language;
}
exports.setLanguage = setLanguage;

},{"./dom":53,"./localStorage":59}],59:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Fetches an item from local storage without throwing an exception
 * @param key The key of the item to fetch from local storage
 */
function getItem(key) {
    var result = null;
    try {
        result = window.localStorage.getItem(key);
    }
    catch (e) {
        /* Eat the exception */
    }
    return result;
}
exports.getItem = getItem;
/**
 * Inserts an item into local storage without throwing an exception
 * @param key The key of the item to add to local storage
 * @param data The data to put into local storage
 */
function setItem(key, data) {
    try {
        window.localStorage.setItem(key, data);
    }
    catch (e) {
        /* Eat the exception */
    }
}
exports.setItem = setItem;

},{}],60:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Determines the distance between two points.
 *
 * @public
 */
function getDistanceBetweenPoints(point1, point2) {
    var distance = Math.sqrt(Math.pow(point1.x - point2.x, 2) + Math.pow(point1.y - point2.y, 2));
    return distance;
}
exports.getDistanceBetweenPoints = getDistanceBetweenPoints;
/**
 * Produces a proportionally-scaled version of an input content size when fit to a bounding size.
 * Given a `contentSize` and a `boundsSize`, this function scales `contentSize` proportionally
 * using either `contain` or `cover` fit behaviors.
 * Use this function to pre-calculate the layout for the CSS `object-fit` and `background-fit` behaviors.
 * With `contain`, the output size must be the largest it can be while completely within the `boundsSize`.
 * With `cover`, the output size must be the smallest it can be while completely around the `boundsSize`.
 * By default, there is a `maxScale` value of 1, which prevents the `contentSize` from being scaled larger.
 *
 * @param options the options for the bounds fit operation
 */
function fitContentToBounds(options) {
    var contentSize = options.contentSize, boundsSize = options.boundsSize, _a = options.mode, mode = _a === void 0 ? 'contain' : _a, _b = options.maxScale, maxScale = _b === void 0 ? 1 : _b;
    var contentAspectRatio = contentSize.width / contentSize.height;
    var boundsAspectRatio = boundsSize.width / boundsSize.height;
    var scale;
    if (mode === 'contain' ? contentAspectRatio > boundsAspectRatio : contentAspectRatio < boundsAspectRatio) {
        scale = boundsSize.width / contentSize.width;
    }
    else {
        scale = boundsSize.height / contentSize.height;
    }
    var finalScale = Math.min(maxScale, scale);
    return {
        width: contentSize.width * finalScale,
        height: contentSize.height * finalScale
    };
}
exports.fitContentToBounds = fitContentToBounds;

},{}],61:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _emptyObject = { empty: true };
var _dictionary = {};
var _weakMap = (typeof WeakMap === 'undefined') ? null : WeakMap;
/**
 *  Test utility for providing a custom weakmap.
 *
 * @internal
 * */
function setMemoizeWeakMap(weakMap) {
    _weakMap = weakMap;
}
exports.setMemoizeWeakMap = setMemoizeWeakMap;
/**
 * Memoize decorator to be used on class methods. Note that the "this" reference
 * will be inaccessible within a memoized method, given that a cached method's this
 * would not be instance specific.
 *
 * @public
 */
function memoize(target, key, descriptor) {
    // We bind to "null" to prevent people from inadvertently pulling values from "this",
    // rather than passing them in as input values which can be memoized.
    var fn = memoizeFunction(descriptor.value && descriptor.value.bind(null));
    return {
        configurable: true,
        get: function () {
            return fn;
        }
    };
}
exports.memoize = memoize;
/**
 * Memoizes a function; when you pass in the same parameters multiple times, it returns a cached result.
 * Be careful when passing in objects, you need to pass in the same INSTANCE for caching to work. Otherwise
 * it will grow the cache unnecessarily. Also avoid using default values that evaluate functions; passing in
 * undefined for a value and relying on a default function will execute it the first time, but will not
 * re-evaluate subsequent times which may have been unexpected.
 *
 * By default, the cache will reset after 100 permutations, to avoid abuse cases where the function is
 * unintendedly called with unique objects. Without a reset, the cache could grow infinitely, so we safeguard
 * by resetting. To override this behavior, pass a value of 0 to the maxCacheSize parameter.
 *
 * @public
 * @param cb - The function to memoize.
 * @param maxCacheSize - Max results to cache. If the cache exceeds this value, it will reset on the next call.
 * @returns A memoized version of the function.
 */
function memoizeFunction(cb, maxCacheSize) {
    if (maxCacheSize === void 0) { maxCacheSize = 100; }
    var rootNode;
    var cacheSize = 0;
    // Avoid breaking scenarios which don't have weak map.
    if (!_weakMap) {
        return cb;
    }
    // tslint:disable-next-line:no-function-expression
    return function memoizedFunction() {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        var currentNode = rootNode;
        if (rootNode === undefined || (maxCacheSize > 0 && cacheSize > maxCacheSize)) {
            rootNode = _createNode();
            cacheSize = 0;
        }
        currentNode = rootNode;
        // Traverse the tree until we find the match.
        for (var i = 0; i < args.length; i++) {
            var arg = _normalizeArg(args[i]);
            if (!currentNode.map.has(arg)) {
                currentNode.map.set(arg, _createNode());
            }
            currentNode = currentNode.map.get(arg);
        }
        if (!currentNode.hasOwnProperty('value')) {
            currentNode.value = cb.apply(void 0, args);
            cacheSize++;
        }
        return currentNode.value;
    };
}
exports.memoizeFunction = memoizeFunction;
function _normalizeArg(val) {
    if (!val) {
        return _emptyObject;
    }
    else if (typeof val === 'object') {
        return val;
    }
    else if (!_dictionary[val]) {
        _dictionary[val] = { val: val };
    }
    return _dictionary[val];
}
function _createNode() {
    return {
        map: _weakMap ? new _weakMap() : null
    };
}

},{}],62:[function(require,module,exports){
(function (process){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// Initialize global window id.
var CURRENT_ID_PROPERTY = '__currentId__';
var DEFAULT_ID_STRING = 'id__';
// tslint:disable-next-line:no-any
var _global = (typeof window !== 'undefined' && window) || process;
if (_global[CURRENT_ID_PROPERTY] === undefined) {
    _global[CURRENT_ID_PROPERTY] = 0;
}
// tslint:disable-next-line:no-any
function checkProperties(a, b) {
    for (var propName in a) {
        if (a.hasOwnProperty(propName)) {
            if (!b.hasOwnProperty(propName) || (b[propName] !== a[propName])) {
                return false;
            }
        }
    }
    return true;
}
/**
 * Compares a to b and b to a.
 *
 * @public
 */
function shallowCompare(a, b) {
    return checkProperties(a, b) && checkProperties(b, a);
}
exports.shallowCompare = shallowCompare;
/**
 * Makes a resulting merge of a bunch of objects. Pass in the target object followed by 1 or more
 * objects as arguments and they will be merged sequentially into the target. Note that this will
 * shallow merge; it will not create new cloned values for target members.
 *
 * @public
 * @param target - Target object to merge following object arguments into.
 * @param args - One or more objects that will be mixed into the target in the order they are provided.
 * @returns Resulting merged target.
 */
// tslint:disable-next-line:no-any
function assign(target) {
    var args = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        args[_i - 1] = arguments[_i];
    }
    return filteredAssign.apply(this, [null, target].concat(args));
}
exports.assign = assign;
/**
 * Makes a resulting merge of a bunch of objects, but allows a filter function to be passed in to filter
 * the resulting merges. This allows for scenarios where you want to merge "everything except that one thing"
 * or "properties that start with data-". Note that this will shallow merge; it will not create new cloned
 * values for target members.
 *
 * @public
 * @param isAllowed - Callback to determine if the given propName is allowed in the result.
 * @param target - Target object to merge following object arguments into.
 * @param args - One or more objects that will be mixed into the target in the order they are provided.
 * @returns Resulting merged target.
 */
// tslint:disable-next-line:no-any
function filteredAssign(isAllowed, target) {
    var args = [];
    for (var _i = 2; _i < arguments.length; _i++) {
        args[_i - 2] = arguments[_i];
    }
    target = target || {};
    for (var _a = 0, args_1 = args; _a < args_1.length; _a++) {
        var sourceObject = args_1[_a];
        if (sourceObject) {
            for (var propName in sourceObject) {
                if (sourceObject.hasOwnProperty(propName) &&
                    (!isAllowed || isAllowed(propName))) {
                    target[propName] = sourceObject[propName];
                }
            }
        }
    }
    return target;
}
exports.filteredAssign = filteredAssign;
/**
 * Generates a unique id in the global scope (this spans across duplicate copies of the same library.)
 *
 * @public
 */
function getId(prefix) {
    var index = _global[CURRENT_ID_PROPERTY]++;
    return (prefix || DEFAULT_ID_STRING) + index;
}
exports.getId = getId;
/* Takes an enum and iterates over each value of the enum (as a string), running the callback on each, returning a mapped array.
 * The callback takes as a first parameter the string that represents the name of the entry, and the second parameter is the
 * value of that entry, which is the value you'd normally use when using the enum (usually a number).
 * */
function mapEnumByName(
    // tslint:disable-next-line:no-any
    theEnum, callback) {
    // map<any> to satisfy compiler since it doesn't realize we strip out undefineds in the .filter() call
    return Object.keys(theEnum).map(function (p) {
        if (String(Number(p)) !== p) {
            return callback(p, theEnum[p]);
        }
    }).filter(function (v) { return !!v; }); // only return elements with values
}
exports.mapEnumByName = mapEnumByName;

}).call(this,require('_process'))

},{"_process":149}],63:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Detects whether an element's content has horizontal overflow
 *
 * @public
 * @param element - Element to check for overflow
 * @returns True if element's content overflows
 */
function hasHorizontalOverflow(element) {
    return element.clientWidth < element.scrollWidth;
}
exports.hasHorizontalOverflow = hasHorizontalOverflow;
/**
 * Detects whether an element's content has vertical overflow
 *
 * @public
 * @param element - Element to check for overflow
 * @returns True if element's content overflows
 */
function hasVerticalOverflow(element) {
    return element.clientHeight < element.scrollHeight;
}
exports.hasVerticalOverflow = hasVerticalOverflow;
/**
 * Detects whether an element's content has overflow in any direction
 *
 * @public
 * @param element - Element to check for overflow
 * @returns True if element's content overflows
 */
function hasOverflow(element) {
    return hasHorizontalOverflow(element) || hasVerticalOverflow(element);
}
exports.hasOverflow = hasOverflow;

},{}],64:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var object_1 = require("./object");
/**
 * An array of events that are allowed on every html element type.
 *
 * @public
 */
exports.baseElementEvents = [
    'onCopy',
    'onCut',
    'onPaste',
    'onCompositionEnd',
    'onCompositionStart',
    'onCompositionUpdate',
    'onFocus',
    'onFocusCapture',
    'onBlur',
    'onBlurCapture',
    'onChange',
    'onInput',
    'onSubmit',
    'onLoad',
    'onError',
    'onKeyDown',
    'onKeyDownCapture',
    'onKeyPress',
    'onKeyUp',
    'onAbort',
    'onCanPlay',
    'onCanPlayThrough',
    'onDurationChange',
    'onEmptied',
    'onEncrypted',
    'onEnded',
    'onLoadedData',
    'onLoadedMetadata',
    'onLoadStart',
    'onPause',
    'onPlay',
    'onPlaying',
    'onProgress',
    'onRateChange',
    'onSeeked',
    'onSeeking',
    'onStalled',
    'onSuspend',
    'onTimeUpdate',
    'onVolumeChange',
    'onWaiting',
    'onClick',
    'onClickCapture',
    'onContextMenu',
    'onDoubleClick',
    'onDrag',
    'onDragEnd',
    'onDragEnter',
    'onDragExit',
    'onDragLeave',
    'onDragOver',
    'onDragStart',
    'onDrop',
    'onMouseDown',
    'onMouseDownCapture',
    'onMouseEnter',
    'onMouseLeave',
    'onMouseMove',
    'onMouseOut',
    'onMouseOver',
    'onMouseUp',
    'onMouseUpCapture',
    'onSelect',
    'onTouchCancel',
    'onTouchEnd',
    'onTouchMove',
    'onTouchStart',
    'onScroll',
    'onWheel'
];
/**
 * An array of element attributes which are allowed on every html element type.
 *
 * @public
 */
exports.baseElementProperties = [
    'defaultChecked',
    'defaultValue',
    'accept',
    'acceptCharset',
    'accessKey',
    'action',
    'allowFullScreen',
    'allowTransparency',
    'alt',
    'async',
    'autoComplete',
    'autoFocus',
    'autoPlay',
    'capture',
    'cellPadding',
    'cellSpacing',
    'charSet',
    'challenge',
    'checked',
    'children',
    'classID',
    'className',
    'cols',
    'colSpan',
    'content',
    'contentEditable',
    'contextMenu',
    'controls',
    'coords',
    'crossOrigin',
    'data',
    'dateTime',
    'default',
    'defer',
    'dir',
    'download',
    'draggable',
    'encType',
    'form',
    'formAction',
    'formEncType',
    'formMethod',
    'formNoValidate',
    'formTarget',
    'frameBorder',
    'headers',
    'height',
    'hidden',
    'high',
    'hrefLang',
    'htmlFor',
    'httpEquiv',
    'icon',
    'id',
    'inputMode',
    'integrity',
    'is',
    'keyParams',
    'keyType',
    'kind',
    'lang',
    'list',
    'loop',
    'low',
    'manifest',
    'marginHeight',
    'marginWidth',
    'max',
    'maxLength',
    'media',
    'mediaGroup',
    'method',
    'min',
    'minLength',
    'multiple',
    'muted',
    'name',
    'noValidate',
    'open',
    'optimum',
    'pattern',
    'placeholder',
    'poster',
    'preload',
    'radioGroup',
    'readOnly',
    'rel',
    'required',
    'role',
    'rows',
    'rowSpan',
    'sandbox',
    'scope',
    'scoped',
    'scrolling',
    'seamless',
    'selected',
    'shape',
    'size',
    'sizes',
    'span',
    'spellCheck',
    'src',
    'srcDoc',
    'srcLang',
    'srcSet',
    'start',
    'step',
    'style',
    'summary',
    'tabIndex',
    'title',
    'type',
    'useMap',
    'value',
    'width',
    'wmode',
    'wrap'
];
/**
 * An array of HTML element properties and events.
 *
 * @public
 */
exports.htmlElementProperties = exports.baseElementProperties.concat(exports.baseElementEvents);
/**
 * An array of A tag properties and events.
 *
 * @public
 */
exports.anchorProperties = exports.htmlElementProperties.concat([
    'href',
    'target'
]);
/**
 * An array of BUTTON tag properties and events.
 *
 * @public
 */
exports.buttonProperties = exports.htmlElementProperties.concat([
    'disabled'
]);
/**
 * An array of DIV tag properties and events.
 *
 * @public
 */
exports.divProperties = exports.htmlElementProperties.concat(['align', 'noWrap']);
/**
 * An array of INPUT tag properties and events.
 *
 * @public
 */
exports.inputProperties = exports.buttonProperties;
/**
 * An array of TEXTAREA tag properties and events.
 *
 * @public
 */
exports.textAreaProperties = exports.buttonProperties;
/**
 * An array of IMAGE tag properties and events.
 *
 * @public
 */
exports.imageProperties = exports.divProperties;
/**
 * Gets native supported props for an html element provided the allowance set. Use one of the property
 * sets defined (divProperties, buttonPropertes, etc) to filter out supported properties from a given
 * props set. Note that all data- and aria- prefixed attributes will be allowed.
 * NOTE: getNativeProps should always be applied first when adding props to a react component. The
 * non-native props should be applied second. This will prevent getNativeProps from overriding your custom props.
 * For example, if props passed to getNativeProps has an onClick function and getNativeProps is added to
 * the component after an onClick function is added, then the getNativeProps onClick will override it.
 *
 * @public
 * @param props - The unfiltered input props
 * @param allowedPropsNames-  The array of allowed propnames.
 * @returns The filtered props
 */
function getNativeProps(props, allowedPropNames, excludedPropNames) {
    return object_1.filteredAssign(function (propName) {
        return ((!excludedPropNames || excludedPropNames.indexOf(propName) < 0) && ((propName.indexOf('data-') === 0) ||
            (propName.indexOf('aria-') === 0) ||
            (allowedPropNames.indexOf(propName) >= 0)));
    }, {}, props);
}
exports.getNativeProps = getNativeProps;

},{"./object":62}],65:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _baseUrl = '';
/** Sets the current base url used for fetching images. */
function getResourceUrl(url) {
    return _baseUrl + url;
}
exports.getResourceUrl = getResourceUrl;
/** Gets the current base url used for fetching images. */
function setBaseUrl(baseUrl) {
    _baseUrl = baseUrl;
}
exports.setBaseUrl = setBaseUrl;

},{}],66:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var dom_1 = require("./dom");
var sessionStorage_1 = require("./sessionStorage");
var RTL_LOCAL_STORAGE_KEY = 'isRTL';
// Default to undefined so that we initialize on first read.
var _isRTL;
/**
 * Gets the rtl state of the page (returns true if in rtl.)
 */
function getRTL() {
    if (_isRTL === undefined) {
        // Fabric supports persisting the RTL setting between page refreshes via session storage
        var savedRTL = sessionStorage_1.getItem(RTL_LOCAL_STORAGE_KEY);
        if (savedRTL !== null) {
            _isRTL = savedRTL === '1';
            setRTL(_isRTL);
        }
        var doc = dom_1.getDocument();
        if (_isRTL === undefined && doc) {
            _isRTL = doc.documentElement.getAttribute('dir') === 'rtl';
        }
    }
    return !!_isRTL;
}
exports.getRTL = getRTL;
/**
 * Sets the rtl state of the page (by adjusting the dir attribute of the html element.)
 */
function setRTL(isRTL, persistSetting) {
    if (persistSetting === void 0) { persistSetting = false; }
    var doc = dom_1.getDocument();
    if (doc) {
        doc.documentElement.setAttribute('dir', isRTL ? 'rtl' : 'ltr');
    }
    if (persistSetting) {
        sessionStorage_1.setItem(RTL_LOCAL_STORAGE_KEY, isRTL ? '1' : '0');
    }
    _isRTL = isRTL;
}
exports.setRTL = setRTL;
/**
 * Returns the given key, but flips right/left arrows if necessary.
 */
function getRTLSafeKeyCode(key) {
    if (getRTL()) {
        if (key === 37 /* left */) {
            key = 39 /* right */;
        }
        else if (key === 39 /* right */) {
            key = 37 /* left */;
        }
    }
    return key;
}
exports.getRTLSafeKeyCode = getRTLSafeKeyCode;

},{"./dom":53,"./sessionStorage":69}],67:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var dom_1 = require("./dom");
var styles = require("./scroll.scss");
var _scrollbarWidth;
var _bodyScrollDisabledCount = 0;
/**
 * Placing this attribute on scrollable divs optimizes detection to know
 * if the div is scrollable or not (given we can avoid expensive operations
 * like getComputedStyle.)
 *
 * @public
 */
exports.DATA_IS_SCROLLABLE_ATTRIBUTE = 'data-is-scrollable';
/**
 * Disables the body scrolling.
 *
 * @public
 */
function disableBodyScroll() {
    var doc = dom_1.getDocument();
    if (doc && doc.body && !_bodyScrollDisabledCount) {
        doc.body.classList.add(styles.scrollDisabled);
    }
    _bodyScrollDisabledCount++;
}
exports.disableBodyScroll = disableBodyScroll;
/**
 * Enables the body scrolling.
 *
 * @public
 */
function enableBodyScroll() {
    if (_bodyScrollDisabledCount > 0) {
        var doc = dom_1.getDocument();
        if (doc && doc.body && _bodyScrollDisabledCount === 1) {
            doc.body.classList.remove(styles.scrollDisabled);
        }
        _bodyScrollDisabledCount--;
    }
}
exports.enableBodyScroll = enableBodyScroll;
/**
 * Calculates the width of a scrollbar for the browser/os.
 *
 * @public
 */
function getScrollbarWidth() {
    if (_scrollbarWidth === undefined) {
        var scrollDiv = document.createElement('div');
        scrollDiv.style.setProperty('width', '100px');
        scrollDiv.style.setProperty('height', '100px');
        scrollDiv.style.setProperty('overflow', 'scroll');
        scrollDiv.style.setProperty('position', 'absolute');
        scrollDiv.style.setProperty('top', '-9999px');
        document.body.appendChild(scrollDiv);
        // Get the scrollbar width
        _scrollbarWidth = scrollDiv.offsetWidth - scrollDiv.clientWidth;
        // Delete the DIV
        document.body.removeChild(scrollDiv);
    }
    return _scrollbarWidth;
}
exports.getScrollbarWidth = getScrollbarWidth;
/**
 * Traverses up the DOM for the element with the data-is-scrollable=true attribute, or returns
 * document.body.
 *
 * @public
 */
function findScrollableParent(startingElement) {
    var el = startingElement;
    // First do a quick scan for the scrollable attribute.
    while (el && el !== document.body) {
        if (el.getAttribute(exports.DATA_IS_SCROLLABLE_ATTRIBUTE) === 'true') {
            return el;
        }
        el = el.parentElement;
    }
    // If we haven't found it, the use the slower method: compute styles to evaluate if overflow is set.
    el = startingElement;
    while (el && el !== document.body) {
        if (el.getAttribute(exports.DATA_IS_SCROLLABLE_ATTRIBUTE) !== 'false') {
            var computedStyles = getComputedStyle(el);
            var overflowY = computedStyles ? computedStyles.getPropertyValue('overflow-y') : '';
            if (overflowY && (overflowY === 'scroll' || overflowY === 'auto')) {
                return el;
            }
        }
        el = el.parentElement;
    }
    // Fall back to window scroll.
    if (!el || el === document.body) {
        // tslint:disable-next-line:no-any
        el = window;
    }
    return el;
}
exports.findScrollableParent = findScrollableParent;

},{"./dom":53,"./scroll.scss":68}],68:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/* tslint:disable */
var load_themed_styles_1 = require("@microsoft/load-themed-styles");
load_themed_styles_1.loadStyles([{ "rawString": ".scrollDisabled_2d80166b{overflow:hidden !important}\n" }]);
exports.scrollDisabled = "scrollDisabled_2d80166b";

},{"@microsoft/load-themed-styles":2}],69:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Fetches an item from session storage without throwing an exception
 * @param key The key of the item to fetch from session storage
 */
function getItem(key) {
    var result = null;
    try {
        result = window.sessionStorage.getItem(key);
    }
    catch (e) {
        /* Eat the exception */
    }
    return result;
}
exports.getItem = getItem;
/**
 * Inserts an item into session storage without throwing an exception
 * @param key The key of the item to add to session storage
 * @param data The data to put into session storage
 */
function setItem(key, data) {
    try {
        window.sessionStorage.setItem(key, data);
    }
    catch (e) {
        /* Eat the exception */
    }
}
exports.setItem = setItem;

},{}],70:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// Regex that finds { and } so they can be removed on a lookup for string format
var FORMAT_ARGS_REGEX = /[\{\}]/g;
// Regex that finds {#} so it can be replaced by the arguments in string format
var FORMAT_REGEX = /\{\d+\}/g;
/**
 * String format method, used for scenarios where at runtime you
 * need to evaluate a formatted string given a tokenized string. This
 * usually only is needed in localization scenarios.

 * Example "I love {0} every {1}".format("CXP") will result in a Debug Exception.
 *
 * @public
 */
// tslint:disable-next-line:no-any
function format(s) {
    'use strict';
    var values = [];
    for (var _i = 1; _i < arguments.length; _i++) {
        values[_i - 1] = arguments[_i];
    }
    var args = values;
    // Callback match function
    function replace_func(match) {
        // looks up in the args
        // tslint:disable-next-line:no-any
        var replacement = args[match.replace(FORMAT_ARGS_REGEX, '')];
        // catches undefined in nondebug and null in debug and nondebug
        if (replacement === null || replacement === undefined) {
            replacement = '';
        }
        return replacement;
    }
    return (s.replace(FORMAT_REGEX, replace_func));
}
exports.format = format;

},{}],71:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var React = require("react");
var index_1 = require("@uifabric/merge-styles/lib/index");
/**
 * The styled HOC wrapper allows you to create a functional wrapper around a given component which will resolve
 * getStyles functional props, and mix customized props passed in using concatStyleSets. Example:
 *
 * ```tsx
 * export const Toggle = styled(
 *   ToggleBase,
 *   {
 *     getStyles: props => ({ root: { background: 'red' }})
 *   }
 * );
 * ```
 *
 */
function styled(Component, getBaseStyles, getProps) {
    return function (componentProps) {
        var getStyles = function (styleProps) { return index_1.concatStyleSets(getBaseStyles && getBaseStyles(styleProps), componentProps && componentProps.getStyles && componentProps.getStyles(styleProps)); };
        var additionalProps = getProps ? getProps(componentProps) : {};
        return (React.createElement(Component, tslib_1.__assign({}, additionalProps, componentProps, { getStyles: getStyles })));
    };
}
exports.styled = styled;

},{"@uifabric/merge-styles/lib/index":8,"react":"react","tslib":155}],72:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var _warningCallback = undefined;
/**
 * Warns when a deprecated props are being used.
 *
 * @public
 * @param componentName - The name of the component being used.
 * @param props - The props passed into the component.
 * @param deprecationMap - The map of deprecations, where key is the prop name and the value is
 * either null or a replacement prop name.
 */
function warnDeprecations(componentName, props, deprecationMap) {
    for (var propName in deprecationMap) {
        if (props && propName in props) {
            var deprecationMessage = componentName + " property '" + propName + "' was used but has been deprecated.";
            var replacementPropName = deprecationMap[propName];
            if (replacementPropName) {
                deprecationMessage += " Use '" + replacementPropName + "' instead.";
            }
            warn(deprecationMessage);
        }
    }
}
exports.warnDeprecations = warnDeprecations;
/**
 * Warns when two props which are mutually exclusive are both being used.
 *
 * @public
 * @param componentName - The name of the component being used.
 * @param props - The props passed into the component.
 * @param exclusiveMap - A map where the key is a parameter, and the value is the other parameter.
 */
function warnMutuallyExclusive(componentName, props, exclusiveMap) {
    for (var propName in exclusiveMap) {
        if (props && propName in props) {
            var propInExclusiveMapValue = exclusiveMap[propName];
            if (propInExclusiveMapValue && propInExclusiveMapValue in props) {
                warn(componentName + " property '" + propName + "' is mutually exclusive with '" + exclusiveMap[propName] + "'. Use one or the other.");
            }
        }
    }
}
exports.warnMutuallyExclusive = warnMutuallyExclusive;
/**
 * Warns when props are required if a condition is met.
 *
 * @public
 * @param componentName - The name of the component being used.
 * @param props - The props passed into the component.
 * @param requiredProps - The name of the props that are required when the condition is met.
 * @param conditionalPropName - The name of the prop that the condition is based on.
 * @param condition - Whether the condition is met.
*/
function warnConditionallyRequiredProps(componentName, props, requiredProps, conditionalPropName, condition) {
    if (condition === true) {
        for (var _i = 0, requiredProps_1 = requiredProps; _i < requiredProps_1.length; _i++) {
            var requiredPropName = requiredProps_1[_i];
            if (!(requiredPropName in props)) {
                warn(componentName + " property '" + requiredPropName + "' is required when '" + conditionalPropName + "' is used.'");
            }
        }
    }
}
exports.warnConditionallyRequiredProps = warnConditionallyRequiredProps;
/**
 * Sends a warning to console, if the api is present.
 *
 * @public
 * @param message - Warning message.
 */
function warn(message) {
    if (_warningCallback) {
        _warningCallback(message);
    }
    else if (console && console.warn) {
        console.warn(message);
    }
}
exports.warn = warn;
/**
 * Configures the warning callback. Passing in undefined will reset it to use the default
 * console.warn function.
 *
 * @public
 * @param warningCallback - Callback to override the generated warnings.
 */
function setWarningCallback(warningCallback) {
    _warningCallback = warningCallback;
}
exports.setWarningCallback = setWarningCallback;

},{}],73:[function(require,module,exports){
"use strict";

/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 * 
 */

function makeEmptyFunction(arg) {
  return function () {
    return arg;
  };
}

/**
 * This function accepts and discards inputs; it has no side effects. This is
 * primarily useful idiomatically for overridable function endpoints which
 * always need to be callable, since JS lacks a null-call idiom ala Cocoa.
 */
var emptyFunction = function emptyFunction() {};

emptyFunction.thatReturns = makeEmptyFunction;
emptyFunction.thatReturnsFalse = makeEmptyFunction(false);
emptyFunction.thatReturnsTrue = makeEmptyFunction(true);
emptyFunction.thatReturnsNull = makeEmptyFunction(null);
emptyFunction.thatReturnsThis = function () {
  return this;
};
emptyFunction.thatReturnsArgument = function (arg) {
  return arg;
};

module.exports = emptyFunction;
},{}],74:[function(require,module,exports){
(function (process){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

/**
 * Use invariant() to assert state which your program assumes to be true.
 *
 * Provide sprintf-style format (only %s is supported) and arguments
 * to provide information about what broke and what you were
 * expecting.
 *
 * The invariant message will be stripped in production, but the invariant
 * will remain to ensure logic does not differ in production.
 */

var validateFormat = function validateFormat(format) {};

if (process.env.NODE_ENV !== 'production') {
  validateFormat = function validateFormat(format) {
    if (format === undefined) {
      throw new Error('invariant requires an error message argument');
    }
  };
}

function invariant(condition, format, a, b, c, d, e, f) {
  validateFormat(format);

  if (!condition) {
    var error;
    if (format === undefined) {
      error = new Error('Minified exception occurred; use the non-minified dev environment ' + 'for the full error message and additional helpful warnings.');
    } else {
      var args = [a, b, c, d, e, f];
      var argIndex = 0;
      error = new Error(format.replace(/%s/g, function () {
        return args[argIndex++];
      }));
      error.name = 'Invariant Violation';
    }

    error.framesToPop = 1; // we don't care about invariant's own frame
    throw error;
  }
}

module.exports = invariant;
}).call(this,require('_process'))

},{"_process":149}],75:[function(require,module,exports){
(function (process){
/**
 * Copyright (c) 2014-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 *
 */

'use strict';

var emptyFunction = require('./emptyFunction');

/**
 * Similar to invariant but only logs a warning if the condition is not met.
 * This can be used to log issues in development environments in critical
 * paths. Removing the logging code for production environments will keep the
 * same logic and follow the same code paths.
 */

var warning = emptyFunction;

if (process.env.NODE_ENV !== 'production') {
  var printWarning = function printWarning(format) {
    for (var _len = arguments.length, args = Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }

    var argIndex = 0;
    var message = 'Warning: ' + format.replace(/%s/g, function () {
      return args[argIndex++];
    });
    if (typeof console !== 'undefined') {
      console.error(message);
    }
    try {
      // --- Welcome to debugging React ---
      // This error was thrown as a convenience so that you can use this stack
      // to find the callsite that caused this warning to fire.
      throw new Error(message);
    } catch (x) {}
  };

  warning = function warning(condition, format) {
    if (format === undefined) {
      throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');
    }

    if (format.indexOf('Failed Composite propType: ') === 0) {
      return; // Ignore CompositeComponent proptype check.
    }

    if (!condition) {
      for (var _len2 = arguments.length, args = Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {
        args[_key2 - 2] = arguments[_key2];
      }

      printWarning.apply(undefined, [format].concat(args));
    }
  };
}

module.exports = warning;
}).call(this,require('_process'))

},{"./emptyFunction":73,"_process":149}],76:[function(require,module,exports){
/*
object-assign
(c) Sindre Sorhus
@license MIT
*/

'use strict';
/* eslint-disable no-unused-vars */
var getOwnPropertySymbols = Object.getOwnPropertySymbols;
var hasOwnProperty = Object.prototype.hasOwnProperty;
var propIsEnumerable = Object.prototype.propertyIsEnumerable;

function toObject(val) {
	if (val === null || val === undefined) {
		throw new TypeError('Object.assign cannot be called with null or undefined');
	}

	return Object(val);
}

function shouldUseNative() {
	try {
		if (!Object.assign) {
			return false;
		}

		// Detect buggy property enumeration order in older V8 versions.

		// https://bugs.chromium.org/p/v8/issues/detail?id=4118
		var test1 = new String('abc');  // eslint-disable-line no-new-wrappers
		test1[5] = 'de';
		if (Object.getOwnPropertyNames(test1)[0] === '5') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test2 = {};
		for (var i = 0; i < 10; i++) {
			test2['_' + String.fromCharCode(i)] = i;
		}
		var order2 = Object.getOwnPropertyNames(test2).map(function (n) {
			return test2[n];
		});
		if (order2.join('') !== '0123456789') {
			return false;
		}

		// https://bugs.chromium.org/p/v8/issues/detail?id=3056
		var test3 = {};
		'abcdefghijklmnopqrst'.split('').forEach(function (letter) {
			test3[letter] = letter;
		});
		if (Object.keys(Object.assign({}, test3)).join('') !==
				'abcdefghijklmnopqrst') {
			return false;
		}

		return true;
	} catch (err) {
		// We don't expect any of the above to throw, but better to be safe.
		return false;
	}
}

module.exports = shouldUseNative() ? Object.assign : function (target, source) {
	var from;
	var to = toObject(target);
	var symbols;

	for (var s = 1; s < arguments.length; s++) {
		from = Object(arguments[s]);

		for (var key in from) {
			if (hasOwnProperty.call(from, key)) {
				to[key] = from[key];
			}
		}

		if (getOwnPropertySymbols) {
			symbols = getOwnPropertySymbols(from);
			for (var i = 0; i < symbols.length; i++) {
				if (propIsEnumerable.call(from, symbols[i])) {
					to[symbols[i]] = from[symbols[i]];
				}
			}
		}
	}

	return to;
};

},{}],77:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
tslib_1.__exportStar(require("./components/Button/index"), exports);

},{"./components/Button/index":111,"tslib":155}],78:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
tslib_1.__exportStar(require("./components/Callout/index"), exports);

},{"./components/Callout/index":115,"tslib":155}],79:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
tslib_1.__exportStar(require("./components/ContextualMenu/index"), exports);

},{"./components/ContextualMenu/index":120,"tslib":155}],80:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
tslib_1.__exportStar(require("./components/Divider/index"), exports);

},{"./components/Divider/index":123,"tslib":155}],81:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
tslib_1.__exportStar(require("./components/Fabric/index"), exports);

},{"./components/Fabric/index":126,"tslib":155}],82:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
tslib_1.__exportStar(require("./components/FocusZone/index"), exports);

},{"./components/FocusZone/index":129,"tslib":155}],83:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
tslib_1.__exportStar(require("./components/Icon/index"), exports);

},{"./components/Icon/index":133,"tslib":155}],84:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
tslib_1.__exportStar(require("./components/Layer/index"), exports);

},{"./components/Layer/index":140,"tslib":155}],85:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
tslib_1.__exportStar(require("./components/Popup/index"), exports);

},{"./components/Popup/index":142,"tslib":155}],86:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
tslib_1.__exportStar(require("@uifabric/styling/lib/index"), exports);

},{"@uifabric/styling/lib/index":22,"tslib":155}],87:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
tslib_1.__exportStar(require("@uifabric/utilities/lib/index"), exports);

},{"@uifabric/utilities/lib/index":56,"tslib":155}],88:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var DirectionalHint;
(function (DirectionalHint) {
    /**
     * Appear above the target element, with the left edges of the callout and target aligning.
     */
    DirectionalHint[DirectionalHint["topLeftEdge"] = 0] = "topLeftEdge";
    /**
     * Appear above the target element, with the centers of the callout and target aligning.
     */
    DirectionalHint[DirectionalHint["topCenter"] = 1] = "topCenter";
    /**
     * Appear above the target element, with the right edges of the callout and target aligning.
     */
    DirectionalHint[DirectionalHint["topRightEdge"] = 2] = "topRightEdge";
    /**
     * Appear above the target element, aligning with the target element such that the callout tends toward the center of the screen.
     */
    DirectionalHint[DirectionalHint["topAutoEdge"] = 3] = "topAutoEdge";
    /**
     * Appear below the target element, with the left edges of the callout and target aligning.
     */
    DirectionalHint[DirectionalHint["bottomLeftEdge"] = 4] = "bottomLeftEdge";
    /**
     * Appear below the target element, with the centers of the callout and target aligning.
     */
    DirectionalHint[DirectionalHint["bottomCenter"] = 5] = "bottomCenter";
    /**
     * Appear below the target element, with the right edges of the callout and target aligning.
     */
    DirectionalHint[DirectionalHint["bottomRightEdge"] = 6] = "bottomRightEdge";
    /**
     * Appear below the target element, aligning with the target element such that the callout tends toward the center of the screen.
     */
    DirectionalHint[DirectionalHint["bottomAutoEdge"] = 7] = "bottomAutoEdge";
    /**
     * Appear to the left of the target element, with the top edges of the callout and target aligning.
     */
    DirectionalHint[DirectionalHint["leftTopEdge"] = 8] = "leftTopEdge";
    /**
     * Appear to the left of the target element, with the centers of the callout and target aligning.
     */
    DirectionalHint[DirectionalHint["leftCenter"] = 9] = "leftCenter";
    /**
     * Appear to the left of the target element, with the bottom edges of the callout and target aligning.
     */
    DirectionalHint[DirectionalHint["leftBottomEdge"] = 10] = "leftBottomEdge";
    /**
     * Appear to the right of the target element, with the top edges of the callout and target aligning.
     */
    DirectionalHint[DirectionalHint["rightTopEdge"] = 11] = "rightTopEdge";
    /**
     * Appear to the right of the target element, with the centers of the callout and target aligning.
     */
    DirectionalHint[DirectionalHint["rightCenter"] = 12] = "rightCenter";
    /**
     * Appear to the right of the target element, with the bottom edges of the callout and target aligning.
     */
    DirectionalHint[DirectionalHint["rightBottomEdge"] = 13] = "rightBottomEdge";
})(DirectionalHint = exports.DirectionalHint || (exports.DirectionalHint = {}));

},{}],89:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var React = require("react");
var BaseButton_1 = require("../BaseButton");
var Utilities_1 = require("../../../Utilities");
var ActionButton_styles_1 = require("./ActionButton.styles");
var ActionButton = /** @class */ (function (_super) {
    tslib_1.__extends(ActionButton, _super);
    function ActionButton() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * Tell BaseComponent to bypass resolution of componentRef.
         */
        _this._shouldUpdateComponentRef = false;
        return _this;
    }
    ActionButton.prototype.render = function () {
        var _a = this.props, styles = _a.styles, theme = _a.theme;
        return (React.createElement(BaseButton_1.BaseButton, tslib_1.__assign({}, this.props, { variantClassName: 'ms-Button--action ms-Button--command', styles: ActionButton_styles_1.getStyles(theme, styles), onRenderDescription: Utilities_1.nullRender })));
    };
    ActionButton = tslib_1.__decorate([
        Utilities_1.customizable('ActionButton', ['theme'])
    ], ActionButton);
    return ActionButton;
}(Utilities_1.BaseComponent));
exports.ActionButton = ActionButton;

},{"../../../Utilities":87,"../BaseButton":92,"./ActionButton.styles":90,"react":"react","tslib":155}],90:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Styling_1 = require("../../../Styling");
var Utilities_1 = require("../../../Utilities");
var BaseButton_styles_1 = require("../BaseButton.styles");
var DEFAULT_BUTTON_HEIGHT = '40px';
var DEFAULT_PADDING = '0 4px';
exports.getStyles = Utilities_1.memoizeFunction(function (theme, customStyles) {
    var baseButtonStyles = BaseButton_styles_1.getStyles(theme);
    var actionButtonStyles = {
        root: {
            padding: DEFAULT_PADDING,
            height: DEFAULT_BUTTON_HEIGHT,
            color: theme.palette.neutralPrimary,
            backgroundColor: 'transparent'
        },
        rootHovered: {
            color: theme.palette.themePrimary,
        },
        iconHovered: {
            color: theme.palette.themePrimary
        },
        rootPressed: {
            color: theme.palette.black,
        },
        rootExpanded: {
            color: theme.palette.themePrimary
        },
        iconPressed: {
            color: theme.palette.themeDarker
        },
        rootDisabled: {
            color: theme.palette.neutralTertiary,
            backgroundColor: 'transparent'
        },
        rootChecked: {
            color: theme.palette.black,
        },
        iconChecked: {
            color: theme.palette.themeDarker
        },
        flexContainer: {
            justifyContent: 'flex-start'
        },
        icon: {
            color: theme.palette.themeDarkAlt
        },
        iconDisabled: {
            color: 'inherit'
        },
        menuIcon: {
            color: theme.palette.neutralSecondary
        },
        textContainer: {
            flexGrow: 0
        }
    };
    return Styling_1.concatStyleSets(baseButtonStyles, actionButtonStyles, customStyles);
});

},{"../../../Styling":86,"../../../Utilities":87,"../BaseButton.styles":93}],91:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Utilities_1 = require("../../Utilities");
var Styling_1 = require("../../Styling");
exports.getBaseButtonClassNames = Utilities_1.memoizeFunction(function (styles, className, variantClassName, iconClassName, menuIconClassName, disabled, checked, expanded, isSplit) {
    var isExpanded = expanded && !isSplit;
    return Styling_1.mergeStyleSets({
        root: [
            'ms-Button',
            styles.root,
            variantClassName,
            className,
            checked && [
                'is-checked',
                styles.rootChecked
            ],
            isExpanded && [
                'is-expanded',
                styles.rootExpanded,
                {
                    selectors: {
                        ':hover .ms-Button-icon': styles.iconExpandedHovered,
                        ':hover .ms-Button-menuIcon': styles.rootExpandedHovered,
                        ':hover': styles.rootExpandedHovered
                    }
                }
            ],
            disabled && [
                'is-disabled',
                styles.rootDisabled
            ],
            !disabled && !isExpanded && !checked && {
                selectors: {
                    ':hover': styles.rootHovered,
                    ':hover .ms-Button-icon': styles.iconHovered,
                    ':hover .ms-Button-description': styles.descriptionHovered,
                    ':hover .ms-Button-menuIcon': styles.menuIconHovered,
                    ':focus': styles.rootFocused,
                    ':active': styles.rootPressed,
                    ':active .ms-Button-icon': styles.iconPressed,
                    ':active .ms-Button-description': styles.descriptionPressed,
                    ':active .ms-Button-menuIcon': styles.menuIconPressed
                }
            },
            disabled && checked && [
                styles.rootCheckedDisabled
            ],
            !disabled && checked && {
                selectors: {
                    ':hover': styles.rootCheckedHovered,
                    ':active': styles.rootCheckedPressed
                }
            }
        ],
        flexContainer: [
            'ms-Button-flexContainer',
            styles.flexContainer
        ],
        textContainer: [
            'ms-Button-textContainer',
            styles.textContainer
        ],
        icon: [
            'ms-Button-icon',
            iconClassName,
            styles.icon,
            isExpanded && styles.iconExpanded,
            checked && styles.iconChecked,
            disabled && styles.iconDisabled,
        ],
        label: [
            'ms-Button-label',
            styles.label,
            checked && styles.labelChecked,
            disabled && styles.labelDisabled,
        ],
        menuIcon: [
            'ms-Button-menuIcon',
            menuIconClassName,
            styles.menuIcon,
            checked && styles.menuIconChecked,
            disabled && styles.menuIconDisabled,
            !disabled &&
                !isExpanded &&
                !checked && {
                selectors: {
                    ':hover': styles.menuIconHovered,
                    ':active': styles.menuIconPressed,
                },
            },
            isExpanded && [
                'is-expanded',
                styles.menuIconExpanded,
                {
                    selectors: {
                        ':hover': styles.menuIconExpandedHovered,
                    },
                },
            ]
        ],
        description: [
            'ms-Button-description',
            styles.description,
            checked && styles.descriptionChecked,
            disabled && styles.descriptionDisabled
        ],
        screenReaderText: [
            'ms-Button-screenReaderText',
            styles.screenReaderText
        ]
    });
});

},{"../../Styling":86,"../../Utilities":87}],92:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var React = require("react");
var Utilities_1 = require("../../Utilities");
var Icon_1 = require("../../Icon");
var ContextualMenu_1 = require("../../ContextualMenu");
var BaseButton_classNames_1 = require("./BaseButton.classNames");
var SplitButton_classNames_1 = require("./SplitButton/SplitButton.classNames");
var BaseButton = /** @class */ (function (_super) {
    tslib_1.__extends(BaseButton, _super);
    function BaseButton(props, rootClassName) {
        var _this = _super.call(this, props) || this;
        _this._warnConditionallyRequiredProps(['menuProps', 'onClick'], 'split', _this.props.split);
        _this._warnDeprecations({
            rootProps: undefined
        });
        _this._labelId = Utilities_1.getId();
        _this._descriptionId = Utilities_1.getId();
        _this._ariaDescriptionId = Utilities_1.getId();
        _this.state = {
            menuProps: null
        };
        return _this;
    }
    Object.defineProperty(BaseButton.prototype, "_isSplitButton", {
        get: function () {
            return (!!this.props.menuProps && !!this.props.onClick) && this.props.split === true;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(BaseButton.prototype, "_isExpanded", {
        get: function () {
            return !!this.state.menuProps;
        },
        enumerable: true,
        configurable: true
    });
    BaseButton.prototype.render = function () {
        var _a = this.props, ariaDescription = _a.ariaDescription, ariaLabel = _a.ariaLabel, ariaHidden = _a.ariaHidden, className = _a.className, description = _a.description, disabled = _a.disabled, primaryDisabled = _a.primaryDisabled, href = _a.href, iconProps = _a.iconProps, menuIconProps = _a.menuIconProps, styles = _a.styles, text = _a.text, checked = _a.checked, variantClassName = _a.variantClassName, theme = _a.theme, getClassNames = _a.getClassNames;
        var menuProps = this.state.menuProps;
        // Button is disabled if the whole button (in case of splitbutton is disabled) or if the primary action is disabled
        var isPrimaryButtonDisabled = (disabled || primaryDisabled);
        this._classNames = getClassNames ? getClassNames(theme, className, variantClassName, iconProps && iconProps.className, menuIconProps && menuIconProps.className, isPrimaryButtonDisabled, checked, !!this.state.menuProps, this.props.split) : BaseButton_classNames_1.getBaseButtonClassNames(styles, className, variantClassName, iconProps && iconProps.className, menuIconProps && menuIconProps.className, isPrimaryButtonDisabled, checked, !!this.state.menuProps, this.props.split);
        var _b = this, _ariaDescriptionId = _b._ariaDescriptionId, _labelId = _b._labelId, _descriptionId = _b._descriptionId;
        // Anchor tag cannot be disabled hence in disabled state rendering
        // anchor button as normal button
        var renderAsAnchor = !isPrimaryButtonDisabled && !!href;
        var tag = renderAsAnchor ? 'a' : 'button';
        var nativeProps = Utilities_1.getNativeProps(Utilities_1.assign(renderAsAnchor ? {} : { type: 'button' }, this.props.rootProps, this.props), renderAsAnchor ? Utilities_1.anchorProperties : Utilities_1.buttonProperties, [
            'disabled' // Let disabled buttons be focused and styled as disabled.
        ]);
        // Check for ariaDescription, description or aria-describedby in the native props to determine source of aria-describedby
        // otherwise default to null.
        var ariaDescribedBy;
        if (ariaDescription) {
            ariaDescribedBy = _ariaDescriptionId;
        }
        else if (description) {
            ariaDescribedBy = _descriptionId;
        }
        else if (nativeProps['aria-describedby']) {
            ariaDescribedBy = nativeProps['aria-describedby'];
        }
        else {
            ariaDescribedBy = null;
        }
        // If an explicit ariaLabel is given, use that as the label and we're done.
        // If an explicit aria-labelledby is given, use that and we're done.
        // If any kind of description is given (which will end up as an aria-describedby attribute),
        // set the labelledby element. Otherwise, the button is labeled implicitly by the descendent
        // text on the button (if it exists). Never set both aria-label and aria-labelledby.
        var ariaLabelledBy = null;
        if (!ariaLabel) {
            if (nativeProps['aria-labelledby']) {
                ariaLabelledBy = nativeProps['aria-labelledby'];
            }
            else if (ariaDescribedBy) {
                ariaLabelledBy = text ? _labelId : null;
            }
        }
        var buttonProps = Utilities_1.assign(nativeProps, {
            className: this._classNames.root,
            ref: this._resolveRef('_buttonElement'),
            'disabled': isPrimaryButtonDisabled,
            'aria-label': ariaLabel,
            'aria-labelledby': ariaLabelledBy,
            'aria-describedby': ariaDescribedBy,
            'data-is-focusable': (this.props['data-is-focusable'] === false || disabled) ? false : true,
            'aria-pressed': checked
        });
        if (ariaHidden) {
            buttonProps['aria-hidden'] = true;
        }
        if (this._isSplitButton) {
            return (this._onRenderSplitButtonContent(tag, buttonProps));
        }
        else if (this.props.menuProps) {
            Utilities_1.assign(buttonProps, {
                'onKeyDown': this._onMenuKeyDown,
                'onClick': this._onMenuClick,
                'aria-expanded': this._isExpanded,
                'aria-owns': this.state.menuProps ? this._labelId + '-menu' : null,
                'aria-haspopup': true
            });
        }
        return this._onRenderContent(tag, buttonProps);
    };
    BaseButton.prototype.componentDidUpdate = function (prevProps, prevState) {
        // If Button's menu was closed, run onAfterMenuDismiss
        if (this.props.onAfterMenuDismiss && prevState.menuProps && !this.state.menuProps) {
            this.props.onAfterMenuDismiss();
        }
    };
    BaseButton.prototype.focus = function () {
        if (this._buttonElement) {
            this._buttonElement.focus();
        }
    };
    BaseButton.prototype.dismissMenu = function () {
        this.setState({ menuProps: null });
    };
    BaseButton.prototype._onRenderContent = function (tag, buttonProps) {
        var props = this.props;
        var Tag = tag;
        var menuIconProps = props.menuIconProps, menuProps = props.menuProps, _a = props.onRenderIcon, onRenderIcon = _a === void 0 ? this._onRenderIcon : _a, _b = props.onRenderAriaDescription, onRenderAriaDescription = _b === void 0 ? this._onRenderAriaDescription : _b, _c = props.onRenderChildren, onRenderChildren = _c === void 0 ? this._onRenderChildren : _c, _d = props.onRenderMenu, onRenderMenu = _d === void 0 ? this._onRenderMenu : _d, _e = props.onRenderMenuIcon, onRenderMenuIcon = _e === void 0 ? this._onRenderMenuIcon : _e;
        var Content = (React.createElement(Tag, tslib_1.__assign({}, buttonProps),
            React.createElement("div", { className: this._classNames.flexContainer },
                onRenderIcon(props, this._onRenderIcon),
                this._onRenderTextContents(),
                onRenderAriaDescription(props, this._onRenderAriaDescription),
                onRenderChildren(props, this._onRenderChildren),
                !this._isSplitButton && (menuProps || menuIconProps || this.props.onRenderMenuIcon) && onRenderMenuIcon(this.props, this._onRenderMenuIcon),
                this.state.menuProps && !this.state.menuProps.doNotLayer && onRenderMenu(menuProps, this._onRenderMenu))));
        if (menuProps && menuProps.doNotLayer) {
            return (React.createElement("div", { style: { display: 'inline-block' } },
                Content,
                this.state.menuProps && onRenderMenu(menuProps, this._onRenderMenu)));
        }
        return Content;
    };
    BaseButton.prototype._onRenderIcon = function (buttonProps, defaultRender) {
        var iconProps = this.props.iconProps;
        if (iconProps) {
            return Icon_1.Icon(tslib_1.__assign({}, iconProps, { className: this._classNames.icon }));
        }
        return null;
    };
    BaseButton.prototype._onRenderTextContents = function () {
        var _a = this.props, text = _a.text, children = _a.children, description = _a.description, _b = _a.onRenderText, onRenderText = _b === void 0 ? this._onRenderText : _b, _c = _a.onRenderDescription, onRenderDescription = _c === void 0 ? this._onRenderDescription : _c;
        if (text || typeof (children) === 'string' || description) {
            return (React.createElement("div", { className: this._classNames.textContainer },
                onRenderText(this.props, this._onRenderText),
                onRenderDescription(this.props, this._onRenderDescription)));
        }
        return ([
            onRenderText(this.props, this._onRenderText),
            onRenderDescription(this.props, this._onRenderDescription)
        ]);
    };
    BaseButton.prototype._onRenderText = function () {
        var _a = this.props, children = _a.children, text = _a.text;
        // For backwards compat, we should continue to take in the text content from children.
        if (text === undefined && typeof (children) === 'string') {
            text = children;
        }
        if (text) {
            return (React.createElement("div", { key: this._labelId, className: this._classNames.label, id: this._labelId }, text));
        }
        return null;
    };
    BaseButton.prototype._onRenderChildren = function () {
        var children = this.props.children;
        // If children is just a string, either it or the text will be rendered via onRenderLabel
        // If children is another component, it will be rendered after text
        if (typeof (children) === 'string') {
            return null;
        }
        return children;
    };
    BaseButton.prototype._onRenderDescription = function (props) {
        var description = this.props.description;
        // ms-Button-description is only shown when the button type is compound.
        // In other cases it will not be displayed.
        return description ? (React.createElement("div", { key: this._descriptionId, className: this._classNames.description, id: this._descriptionId }, description)) : (null);
    };
    BaseButton.prototype._onRenderAriaDescription = function () {
        var ariaDescription = this.props.ariaDescription;
        // If ariaDescription is given, descriptionId will be assigned to ariaDescriptionSpan,
        // otherwise it will be assigned to descriptionSpan.
        return ariaDescription ? (React.createElement("span", { className: this._classNames.screenReaderText, id: this._ariaDescriptionId }, ariaDescription)) : (null);
    };
    BaseButton.prototype._onRenderMenuIcon = function (props) {
        var menuIconProps = this.props.menuIconProps;
        return (React.createElement(Icon_1.Icon, tslib_1.__assign({ iconName: 'ChevronDown' }, menuIconProps, { className: this._classNames.menuIcon })));
    };
    BaseButton.prototype._onRenderMenu = function (menuProps) {
        var _a = menuProps.onDismiss, onDismiss = _a === void 0 ? this._dismissMenu : _a;
        return (React.createElement(ContextualMenu_1.ContextualMenu, tslib_1.__assign({ id: this._labelId + '-menu', directionalHint: 4 /* bottomLeftEdge */ }, menuProps, { className: 'ms-BaseButton-menuhost ' + menuProps.className, target: this._isSplitButton ? this._splitButtonContainer : this._buttonElement, labelElementId: this._labelId, onDismiss: onDismiss })));
    };
    BaseButton.prototype._dismissMenu = function () {
        this.setState({ menuProps: null });
    };
    BaseButton.prototype._onToggleMenu = function () {
        var menuProps = this.props.menuProps;
        var currentMenuProps = this.state.menuProps;
        this.setState({ menuProps: currentMenuProps ? null : menuProps });
    };
    BaseButton.prototype._onRenderSplitButtonContent = function (tag, buttonProps) {
        var _a = this.props, _b = _a.styles, styles = _b === void 0 ? {} : _b, disabled = _a.disabled, checked = _a.checked, getSplitButtonClassNames = _a.getSplitButtonClassNames;
        var classNames = getSplitButtonClassNames ? getSplitButtonClassNames(!!disabled, !!this.state.menuProps, !!checked) : styles && SplitButton_classNames_1.getClassNames(styles, !!disabled, !!this.state.menuProps, !!checked);
        return (React.createElement("div", { "aria-labelledby": buttonProps.ariaLabel, "aria-disabled": disabled, "aria-haspopup": true, "aria-expanded": this._isExpanded, "aria-pressed": this.props.checked, "aria-describedby": buttonProps.ariaDescription, className: classNames && classNames.splitButtonContainer, onKeyDown: this._onMenuKeyDown, ref: this._resolveRef('_splitButtonContainer') },
            React.createElement("span", { "aria-hidden": true, 
                // TODO: THIS SHOULD BE REMOVED!
                style: { 'display': 'flex' } },
                this._onRenderContent(tag, buttonProps),
                this._onRenderSplitButtonMenuButton(classNames),
                this._onRenderSplitButtonDivider(classNames))));
    };
    BaseButton.prototype._onRenderSplitButtonDivider = function (classNames) {
        if (classNames && classNames.divider) {
            return React.createElement("span", { className: classNames.divider });
        }
        return null;
    };
    BaseButton.prototype._onRenderSplitButtonMenuButton = function (classNames) {
        var _a = this.props, menuIconProps = _a.menuIconProps, splitButtonAriaLabel = _a.splitButtonAriaLabel;
        if (menuIconProps === undefined) {
            menuIconProps = {
                iconName: 'ChevronDown'
            };
        }
        var splitButtonProps = {
            'styles': classNames,
            'checked': this.props.checked,
            'disabled': this.props.disabled,
            'onClick': this._onMenuClick,
            'menuProps': undefined,
            'iconProps': menuIconProps,
            'ariaLabel': splitButtonAriaLabel
        };
        return React.createElement(BaseButton, tslib_1.__assign({}, splitButtonProps));
    };
    BaseButton.prototype._onMenuKeyDown = function (ev) {
        if (ev.which === 40 /* down */) {
            var onMenuClick = this.props.onMenuClick;
            onMenuClick && onMenuClick(ev, this);
            !ev.defaultPrevented && this._onToggleMenu();
            ev.preventDefault();
            ev.stopPropagation();
        }
    };
    BaseButton.prototype._onMenuClick = function (ev) {
        var onMenuClick = this.props.onMenuClick;
        onMenuClick && onMenuClick(ev, this);
        !ev.defaultPrevented && this._onToggleMenu();
        ev.preventDefault();
        ev.stopPropagation();
    };
    BaseButton.defaultProps = {
        baseClassName: 'ms-Button',
        classNames: {},
        styles: {},
        split: false,
    };
    tslib_1.__decorate([
        Utilities_1.autobind
    ], BaseButton.prototype, "_onRenderIcon", null);
    tslib_1.__decorate([
        Utilities_1.autobind
    ], BaseButton.prototype, "_onRenderTextContents", null);
    tslib_1.__decorate([
        Utilities_1.autobind
    ], BaseButton.prototype, "_onRenderText", null);
    tslib_1.__decorate([
        Utilities_1.autobind
    ], BaseButton.prototype, "_onRenderChildren", null);
    tslib_1.__decorate([
        Utilities_1.autobind
    ], BaseButton.prototype, "_onRenderDescription", null);
    tslib_1.__decorate([
        Utilities_1.autobind
    ], BaseButton.prototype, "_onRenderAriaDescription", null);
    tslib_1.__decorate([
        Utilities_1.autobind
    ], BaseButton.prototype, "_onRenderMenuIcon", null);
    tslib_1.__decorate([
        Utilities_1.autobind
    ], BaseButton.prototype, "_onRenderMenu", null);
    tslib_1.__decorate([
        Utilities_1.autobind
    ], BaseButton.prototype, "_dismissMenu", null);
    tslib_1.__decorate([
        Utilities_1.autobind
    ], BaseButton.prototype, "_onToggleMenu", null);
    tslib_1.__decorate([
        Utilities_1.autobind
    ], BaseButton.prototype, "_onMenuKeyDown", null);
    tslib_1.__decorate([
        Utilities_1.autobind
    ], BaseButton.prototype, "_onMenuClick", null);
    return BaseButton;
}(Utilities_1.BaseComponent));
exports.BaseButton = BaseButton;

},{"../../ContextualMenu":79,"../../Icon":83,"../../Utilities":87,"./BaseButton.classNames":91,"./SplitButton/SplitButton.classNames":109,"react":"react","tslib":155}],93:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Utilities_1 = require("../../Utilities");
var Styling_1 = require("../../Styling");
var noOutline = {
    outline: 0
};
var iconStyle = {
    fontSize: Styling_1.FontSizes.icon,
    margin: '0 4px',
    height: '16px',
    lineHeight: '16px',
    textAlign: 'center',
    verticalAlign: 'middle',
    flexShrink: 0
};
/**
 * Gets the base button styles. Note: because it is a base class to be used with the `mergeRules`
 * helper, it should have values for all class names in the interface. This let `mergeRules` optimize
 * mixing class names together.
 */
exports.getStyles = Utilities_1.memoizeFunction(function (theme) {
    var semanticColors = theme.semanticColors;
    var border = semanticColors.buttonBorder;
    var disabledBackground = semanticColors.disabledBackground;
    var disabledText = semanticColors.disabledText;
    return {
        root: [
            Styling_1.getFocusStyle(theme, -1),
            theme.fonts.medium,
            {
                boxSizing: 'border-box',
                border: '1px solid ' + border,
                userSelect: 'none',
                display: 'inline-block',
                textDecoration: 'none',
                textAlign: 'center',
                cursor: 'pointer',
                verticalAlign: 'top',
                padding: '0 16px',
                borderRadius: 0
            }
        ],
        rootDisabled: {
            backgroundColor: disabledBackground,
            color: disabledText,
            cursor: 'default',
            pointerEvents: 'none',
            selectors: {
                ':hover': noOutline,
                ':focus': noOutline
            }
        },
        iconDisabled: {
            color: disabledText
        },
        menuIconDisabled: {
            color: disabledText
        },
        flexContainer: {
            display: 'flex',
            height: '100%',
            flexWrap: 'nowrap',
            justifyContent: 'center',
            alignItems: 'center'
        },
        textContainer: {
            flexGrow: 1
        },
        icon: iconStyle,
        menuIcon: [
            iconStyle,
            {
                fontSize: Styling_1.FontSizes.small
            }
        ],
        label: {
            margin: '0 4px',
            lineHeight: '100%'
        },
        screenReaderText: Styling_1.hiddenContentStyle
    };
});

},{"../../Styling":86,"../../Utilities":87}],94:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
/* tslint:disable:no-unused-variable */
var React = require("react");
/* tslint:enable:no-unused-variable */
var Utilities_1 = require("../../Utilities");
var Button_types_1 = require("./Button.types");
var DefaultButton_1 = require("./DefaultButton/DefaultButton");
var ActionButton_1 = require("./ActionButton/ActionButton");
var CompoundButton_1 = require("./CompoundButton/CompoundButton");
var IconButton_1 = require("./IconButton/IconButton");
var PrimaryButton_1 = require("./PrimaryButton/PrimaryButton");
/**
 * This class is deprecated. Use the individual *Button components instead.
 * @deprecated
 */
var Button = /** @class */ (function (_super) {
    tslib_1.__extends(Button, _super);
    function Button(props) {
        var _this = _super.call(this, props) || this;
        /**
         * Set this BaseComponent._resolveComponentRef to false, bypassing resolution of componentRef.
         */
        _this._shouldUpdateComponentRef = false;
        Utilities_1.warn("The Button component has been deprecated. Use specific variants instead. " +
            "(PrimaryButton, DefaultButton, IconButton, ActionButton, etc.)");
        return _this;
    }
    Button.prototype.render = function () {
        var props = this.props;
        switch (props.buttonType) {
            case Button_types_1.ButtonType.command:
                return React.createElement(ActionButton_1.ActionButton, tslib_1.__assign({}, props));
            case Button_types_1.ButtonType.compound:
                return React.createElement(CompoundButton_1.CompoundButton, tslib_1.__assign({}, props));
            case Button_types_1.ButtonType.icon:
                return React.createElement(IconButton_1.IconButton, tslib_1.__assign({}, props));
            case Button_types_1.ButtonType.primary:
                return React.createElement(PrimaryButton_1.PrimaryButton, tslib_1.__assign({}, props));
            default:
                return React.createElement(DefaultButton_1.DefaultButton, tslib_1.__assign({}, props));
        }
    };
    return Button;
}(Utilities_1.BaseComponent));
exports.Button = Button;

},{"../../Utilities":87,"./ActionButton/ActionButton":89,"./Button.types":95,"./CompoundButton/CompoundButton":100,"./DefaultButton/DefaultButton":102,"./IconButton/IconButton":104,"./PrimaryButton/PrimaryButton":108,"react":"react","tslib":155}],95:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ElementType;
(function (ElementType) {
    /** <button> element. */
    ElementType[ElementType["button"] = 0] = "button";
    /** <a> element. */
    ElementType[ElementType["anchor"] = 1] = "anchor";
})(ElementType = exports.ElementType || (exports.ElementType = {}));
var ButtonType;
(function (ButtonType) {
    ButtonType[ButtonType["normal"] = 0] = "normal";
    ButtonType[ButtonType["primary"] = 1] = "primary";
    ButtonType[ButtonType["hero"] = 2] = "hero";
    ButtonType[ButtonType["compound"] = 3] = "compound";
    ButtonType[ButtonType["command"] = 4] = "command";
    ButtonType[ButtonType["icon"] = 5] = "icon";
    ButtonType[ButtonType["default"] = 6] = "default";
})(ButtonType = exports.ButtonType || (exports.ButtonType = {}));

},{}],96:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Styling_1 = require("../../Styling");
function standardStyles(theme) {
    var s = theme.semanticColors;
    var buttonBackground = s.buttonBackground;
    var buttonBackgroundChecked = s.buttonBackgroundChecked;
    var buttonBackgroundHovered = s.buttonBackgroundHovered;
    var buttonBackgroundCheckedHovered = s.buttonBackgroundCheckedHovered;
    var buttonText = s.buttonText;
    var buttonTextHovered = s.buttonTextHovered;
    var buttonTextChecked = s.buttonTextChecked;
    var buttonTextCheckedHovered = s.buttonTextCheckedHovered;
    return {
        root: {
            backgroundColor: buttonBackground,
            color: buttonText
        },
        rootHovered: {
            backgroundColor: buttonBackgroundHovered,
            color: buttonTextHovered
        },
        rootPressed: {
            backgroundColor: buttonBackgroundChecked,
            color: buttonTextChecked
        },
        rootExpanded: {
            backgroundColor: buttonBackgroundChecked,
            color: buttonTextChecked
        },
        rootChecked: {
            backgroundColor: buttonBackgroundChecked,
            color: buttonTextChecked
        },
        rootCheckedHovered: {
            backgroundColor: theme.palette.neutralLight,
            color: buttonTextCheckedHovered
        },
        // Split button styles
        splitButtonContainer: {},
        splitButtonMenuButton: {
            color: theme.palette.white,
            backgroundColor: theme.palette.neutralLighter,
            selectors: {
                ':hover': {
                    backgroundColor: theme.palette.neutralLight
                }
            },
        },
        splitButtonMenuButtonDisabled: {
            backgroundColor: theme.palette.neutralLighter,
            selectors: {
                ':hover': {
                    backgroundColor: theme.palette.neutralLighter,
                }
            }
        },
        splitButtonDivider: {
            backgroundColor: theme.palette.neutralTertiaryAlt
        },
        splitButtonMenuButtonChecked: {
            backgroundColor: theme.palette.themePrimary,
        },
        splitButtonMenuButtonExpanded: {
            backgroundColor: theme.palette.neutralLight,
        },
        splitButtonMenuIcon: {
            color: theme.palette.neutralPrimary
        },
        splitButtonMenuIconDisabled: {
            color: theme.palette.neutralTertiary
        },
    };
}
exports.standardStyles = standardStyles;
function primaryStyles(theme) {
    return {
        root: {
            backgroundColor: theme.palette.themePrimary,
            color: theme.palette.white,
            selectors: (_a = {},
                _a[Styling_1.HighContrastSelector] = {
                    color: 'Window',
                    backgroundColor: 'WindowText',
                    MsHighContrastAdjust: 'none'
                },
                _a)
        },
        rootHovered: {
            backgroundColor: theme.palette.themeDarkAlt,
            color: theme.palette.white,
            selectors: (_b = {},
                _b[Styling_1.HighContrastSelector] = {
                    color: 'Window',
                    backgroundColor: 'WindowText',
                    MsHighContrastAdjust: 'none'
                },
                _b)
        },
        rootPressed: {
            backgroundColor: theme.palette.themeDark,
            color: theme.palette.white,
            selectors: (_c = {},
                _c[Styling_1.HighContrastSelector] = {
                    color: 'Window',
                    backgroundColor: 'WindowText',
                    MsHighContrastAdjust: 'none'
                },
                _c)
        },
        rootExpanded: {
            backgroundColor: theme.palette.themeDark,
            color: theme.palette.white
        },
        rootChecked: {
            backgroundColor: theme.palette.themeDark,
            color: theme.palette.white,
        },
        rootCheckedHovered: {
            backgroundColor: theme.palette.themePrimary,
            color: theme.palette.white
        },
        rootDisabled: {
            selectors: (_d = {},
                _d[Styling_1.HighContrastSelector] = {
                    color: 'GrayText',
                    borderColor: 'GrayText',
                    backgroundColor: 'Window'
                },
                _d),
        },
        // Split button styles
        splitButtonContainer: {},
        splitButtonDivider: {
            backgroundColor: theme.palette.themeLighter
        },
        splitButtonMenuButton: {
            backgroundColor: theme.palette.themePrimary,
            color: theme.palette.white,
            selectors: {
                ':hover': {
                    backgroundColor: theme.palette.themeDark
                }
            },
        },
        splitButtonMenuButtonDisabled: {
            backgroundColor: theme.palette.neutralLighter,
            selectors: {
                ':hover': {
                    backgroundColor: theme.palette.neutralLighter,
                }
            }
        },
        splitButtonMenuButtonChecked: {
            backgroundColor: theme.palette.themeDark,
        },
        splitButtonMenuButtonExpanded: {
            backgroundColor: theme.palette.themeDark,
        },
        splitButtonMenuIcon: {
            color: theme.palette.white
        },
        splitButtonMenuIconDisabled: {
            color: theme.palette.neutralTertiary
        }
    };
    var _a, _b, _c, _d;
}
exports.primaryStyles = primaryStyles;

},{"../../Styling":86}],97:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var React = require("react");
var BaseButton_1 = require("../BaseButton");
var Utilities_1 = require("../../../Utilities");
var CommandBarButton_styles_1 = require("./CommandBarButton.styles");
var CommandBarButton = /** @class */ (function (_super) {
    tslib_1.__extends(CommandBarButton, _super);
    function CommandBarButton() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * Tell BaseComponent to bypass resolution of componentRef.
         */
        _this._shouldUpdateComponentRef = false;
        return _this;
    }
    CommandBarButton.prototype.render = function () {
        var _a = this.props, styles = _a.styles, theme = _a.theme;
        return (React.createElement(BaseButton_1.BaseButton, tslib_1.__assign({}, this.props, { variantClassName: 'ms-Button--commandBar', styles: CommandBarButton_styles_1.getStyles(theme, styles), onRenderDescription: Utilities_1.nullRender })));
    };
    CommandBarButton = tslib_1.__decorate([
        Utilities_1.customizable('CommandBarButton', ['theme'])
    ], CommandBarButton);
    return CommandBarButton;
}(Utilities_1.BaseComponent));
exports.CommandBarButton = CommandBarButton;

},{"../../../Utilities":87,"../BaseButton":92,"./CommandBarButton.styles":98,"react":"react","tslib":155}],98:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Styling_1 = require("../../../Styling");
var Utilities_1 = require("../../../Utilities");
var BaseButton_styles_1 = require("../BaseButton.styles");
var SplitButton_styles_1 = require("../SplitButton/SplitButton.styles");
exports.getStyles = Utilities_1.memoizeFunction(function (theme, customStyles, focusInset, focusColor) {
    var baseButtonStyles = BaseButton_styles_1.getStyles(theme);
    var baseSplitButtonStyles = SplitButton_styles_1.getStyles(theme);
    var commandButtonStyles = {
        root: {
            minWidth: '40px',
            backgroundColor: theme.palette.neutralLighter,
            color: theme.palette.neutralPrimary,
            padding: '0 4px'
        },
        rootHovered: {
            backgroundColor: theme.palette.neutralLight,
            color: theme.palette.neutralDark
        },
        rootPressed: {
            backgroundColor: theme.palette.neutralQuaternaryAlt,
            color: theme.palette.black
        },
        rootChecked: {
            backgroundColor: theme.palette.neutralQuaternaryAlt,
            color: theme.palette.black
        },
        rootExpanded: {
            backgroundColor: theme.palette.neutralQuaternaryAlt,
            color: theme.palette.black
        },
        rootCheckedHovered: {
            backgroundColor: theme.palette.neutralQuaternary,
            color: theme.palette.black,
        },
        label: {
            fontWeight: 'normal' // theme.fontWeights.semibold,
        },
        icon: {
            color: theme.palette.themeDarkAlt
        },
        menuIcon: {
            color: theme.palette.neutralSecondary
        }
    };
    return Styling_1.concatStyleSets(baseButtonStyles, commandButtonStyles, baseSplitButtonStyles, customStyles);
});

},{"../../../Styling":86,"../../../Utilities":87,"../BaseButton.styles":93,"../SplitButton/SplitButton.styles":110}],99:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var ActionButton_1 = require("../ActionButton/ActionButton");
exports.CommandButton = ActionButton_1.ActionButton;

},{"../ActionButton/ActionButton":89}],100:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var React = require("react");
var BaseButton_1 = require("../BaseButton");
var Utilities_1 = require("../../../Utilities");
var CompoundButton_styles_1 = require("./CompoundButton.styles");
var CompoundButton = /** @class */ (function (_super) {
    tslib_1.__extends(CompoundButton, _super);
    function CompoundButton() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * Tell BaseComponent to bypass resolution of componentRef.
         */
        _this._shouldUpdateComponentRef = false;
        return _this;
    }
    CompoundButton.prototype.render = function () {
        var _a = this.props, _b = _a.primary, primary = _b === void 0 ? false : _b, styles = _a.styles, theme = _a.theme;
        return (React.createElement(BaseButton_1.BaseButton, tslib_1.__assign({}, this.props, { variantClassName: primary ? 'ms-Button--compoundPrimary' : 'ms-Button--compound', styles: CompoundButton_styles_1.getStyles(theme, styles, primary) })));
    };
    CompoundButton = tslib_1.__decorate([
        Utilities_1.customizable('CompoundButton', ['theme'])
    ], CompoundButton);
    return CompoundButton;
}(Utilities_1.BaseComponent));
exports.CompoundButton = CompoundButton;

},{"../../../Utilities":87,"../BaseButton":92,"./CompoundButton.styles":101,"react":"react","tslib":155}],101:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Styling_1 = require("../../../Styling");
var Utilities_1 = require("../../../Utilities");
var BaseButton_styles_1 = require("../BaseButton.styles");
var SplitButton_styles_1 = require("../SplitButton/SplitButton.styles");
var ButtonThemes_1 = require("../ButtonThemes");
exports.getStyles = Utilities_1.memoizeFunction(function (theme, customStyles, primary) {
    var baseButtonStyles = BaseButton_styles_1.getStyles(theme);
    var splitButtonStyles = SplitButton_styles_1.getStyles(theme);
    var compoundButtonStyles = {
        root: {
            maxWidth: '280px',
            minHeight: '72px',
            height: 'auto',
            padding: '20px'
        },
        flexContainer: {
            flexDirection: 'row',
            alignItems: 'flex-start',
            minWidth: '100%',
            margin: ''
        },
        textContainer: {
            textAlign: 'left'
        },
        icon: {
            fontSize: '2em',
            lineHeight: '1em',
            height: '1em',
            margin: '0px 8px 0px 0px',
            flexBasis: '1em',
            flexShrink: '0'
        },
        label: {
            margin: '0 0 5px',
            lineHeight: '100%',
            fontWeight: Styling_1.FontWeights.semibold
        },
        description: [
            theme.fonts.small,
            {
                lineHeight: '100%'
            }
        ],
    };
    var standardCompoundTheme = {
        description: {
            color: theme.palette.neutralSecondary,
        },
        descriptionHovered: {
            color: theme.palette.neutralDark
        },
        descriptionPressed: {
            color: 'inherit'
        },
        descriptionChecked: {
            color: 'inherit'
        },
        descriptionDisabled: {
            color: 'inherit'
        }
    };
    var primaryCompoundTheme = {
        description: {
            color: theme.palette.white,
            selectors: (_a = {},
                _a[Styling_1.HighContrastSelector] = {
                    color: 'Window',
                    backgroundColor: 'WindowText',
                    MsHighContrastAdjust: 'none'
                },
                _a)
        },
        descriptionHovered: {
            color: theme.palette.white,
            selectors: (_b = {},
                _b[Styling_1.HighContrastSelector] = {
                    color: 'Window',
                    backgroundColor: 'WindowText',
                    MsHighContrastAdjust: 'none'
                },
                _b)
        },
        descriptionPressed: {
            color: 'inherit'
        },
        descriptionChecked: {
            color: 'inherit'
        },
        descriptionDisabled: {
            color: 'inherit'
        }
    };
    return Styling_1.concatStyleSets(baseButtonStyles, compoundButtonStyles, primary ? ButtonThemes_1.primaryStyles(theme) : ButtonThemes_1.standardStyles(theme), primary ? primaryCompoundTheme : standardCompoundTheme, splitButtonStyles, customStyles);
    var _a, _b;
});

},{"../../../Styling":86,"../../../Utilities":87,"../BaseButton.styles":93,"../ButtonThemes":96,"../SplitButton/SplitButton.styles":110}],102:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var React = require("react");
var BaseButton_1 = require("../BaseButton");
var Utilities_1 = require("../../../Utilities");
var DefaultButton_styles_1 = require("./DefaultButton.styles");
var DefaultButton = /** @class */ (function (_super) {
    tslib_1.__extends(DefaultButton, _super);
    function DefaultButton() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * Tell BaseComponent to bypass resolution of componentRef.
         */
        _this._shouldUpdateComponentRef = false;
        return _this;
    }
    DefaultButton.prototype.render = function () {
        var _a = this.props, _b = _a.primary, primary = _b === void 0 ? false : _b, styles = _a.styles, theme = _a.theme;
        return (React.createElement(BaseButton_1.BaseButton, tslib_1.__assign({}, this.props, { variantClassName: primary ? 'ms-Button--primary' : 'ms-Button--default', styles: DefaultButton_styles_1.getStyles(theme, styles, primary), onRenderDescription: Utilities_1.nullRender })));
    };
    DefaultButton = tslib_1.__decorate([
        Utilities_1.customizable('DefaultButton', ['theme'])
    ], DefaultButton);
    return DefaultButton;
}(Utilities_1.BaseComponent));
exports.DefaultButton = DefaultButton;

},{"../../../Utilities":87,"../BaseButton":92,"./DefaultButton.styles":103,"react":"react","tslib":155}],103:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Styling_1 = require("../../../Styling");
var Utilities_1 = require("../../../Utilities");
var BaseButton_styles_1 = require("../BaseButton.styles");
var SplitButton_styles_1 = require("../SplitButton/SplitButton.styles");
var ButtonThemes_1 = require("../ButtonThemes");
var DEFAULT_BUTTON_HEIGHT = '32px';
var DEFAULT_BUTTON_MINWIDTH = '80px';
exports.getStyles = Utilities_1.memoizeFunction(function (theme, customStyles, primary) {
    var baseButtonStyles = BaseButton_styles_1.getStyles(theme);
    var splitButtonStyles = SplitButton_styles_1.getStyles(theme);
    var defaultButtonStyles = {
        root: {
            minWidth: DEFAULT_BUTTON_MINWIDTH,
            height: DEFAULT_BUTTON_HEIGHT,
        },
        label: {
            fontWeight: Styling_1.FontWeights.semibold
        }
    };
    return Styling_1.concatStyleSets(baseButtonStyles, defaultButtonStyles, primary ? ButtonThemes_1.primaryStyles(theme) : ButtonThemes_1.standardStyles(theme), splitButtonStyles, customStyles);
});

},{"../../../Styling":86,"../../../Utilities":87,"../BaseButton.styles":93,"../ButtonThemes":96,"../SplitButton/SplitButton.styles":110}],104:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var React = require("react");
var BaseButton_1 = require("../BaseButton");
var Utilities_1 = require("../../../Utilities");
var IconButton_styles_1 = require("./IconButton.styles");
var IconButton = /** @class */ (function (_super) {
    tslib_1.__extends(IconButton, _super);
    function IconButton() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * Tell BaseComponent to bypass resolution of componentRef.
         */
        _this._shouldUpdateComponentRef = false;
        return _this;
    }
    IconButton.prototype.render = function () {
        var _a = this.props, styles = _a.styles, theme = _a.theme;
        return (React.createElement(BaseButton_1.BaseButton, tslib_1.__assign({}, this.props, { variantClassName: 'ms-Button--icon', styles: IconButton_styles_1.getStyles(theme, styles), onRenderText: Utilities_1.nullRender, onRenderDescription: Utilities_1.nullRender })));
    };
    IconButton = tslib_1.__decorate([
        Utilities_1.customizable('IconButton', ['theme'])
    ], IconButton);
    return IconButton;
}(Utilities_1.BaseComponent));
exports.IconButton = IconButton;

},{"../../../Utilities":87,"../BaseButton":92,"./IconButton.styles":105,"react":"react","tslib":155}],105:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Styling_1 = require("../../../Styling");
var Utilities_1 = require("../../../Utilities");
var BaseButton_styles_1 = require("../BaseButton.styles");
var SplitButton_styles_1 = require("../SplitButton/SplitButton.styles");
exports.getStyles = Utilities_1.memoizeFunction(function (theme, customStyles) {
    var baseButtonStyles = BaseButton_styles_1.getStyles(theme);
    var splitButtonStyles = SplitButton_styles_1.getStyles(theme);
    var iconButtonStyles = {
        root: {
            padding: '0 4px',
            width: '32px',
            height: '32px',
            backgroundColor: 'transparent'
        },
        rootHovered: {
            color: theme.palette.themeDarker
        },
        rootPressed: {
            color: theme.palette.themePrimary
        },
        rootExpanded: {
            color: theme.palette.themePrimary
        },
        rootChecked: {
            backgroundColor: theme.palette.neutralTertiaryAlt,
        },
        rootCheckedHovered: {
            backgroundColor: theme.palette.neutralLight
        },
        rootDisabled: {
            color: theme.palette.neutralTertiary
        }
    };
    return Styling_1.concatStyleSets(baseButtonStyles, iconButtonStyles, splitButtonStyles, customStyles);
});

},{"../../../Styling":86,"../../../Utilities":87,"../BaseButton.styles":93,"../SplitButton/SplitButton.styles":110}],106:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var React = require("react");
var DefaultButton_1 = require("../DefaultButton/DefaultButton");
var Utilities_1 = require("../../../Utilities");
var MessageBarButton_styles_1 = require("./MessageBarButton.styles");
var MessageBarButton = /** @class */ (function (_super) {
    tslib_1.__extends(MessageBarButton, _super);
    function MessageBarButton() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    MessageBarButton.prototype.render = function () {
        var _a = this.props, styles = _a.styles, theme = _a.theme;
        return (React.createElement(DefaultButton_1.DefaultButton, tslib_1.__assign({}, this.props, { styles: MessageBarButton_styles_1.getStyles(theme, styles), onRenderDescription: Utilities_1.nullRender })));
    };
    MessageBarButton = tslib_1.__decorate([
        Utilities_1.customizable('MessageBarButton', ['theme'])
    ], MessageBarButton);
    return MessageBarButton;
}(Utilities_1.BaseComponent));
exports.MessageBarButton = MessageBarButton;

},{"../../../Utilities":87,"../DefaultButton/DefaultButton":102,"./MessageBarButton.styles":107,"react":"react","tslib":155}],107:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Styling_1 = require("../../../Styling");
var Utilities_1 = require("../../../Utilities");
var BaseButton_styles_1 = require("../BaseButton.styles");
exports.getStyles = Utilities_1.memoizeFunction(function (theme, customStyles, focusInset, focusColor) {
    var baseButtonStyles = BaseButton_styles_1.getStyles(theme);
    var messageBarButtonStyles = {
        root: {
            backgroundColor: theme.palette.neutralQuaternaryAlt,
            color: theme.palette.neutralPrimary
        },
        rootHovered: {
            backgroundColor: theme.palette.neutralTertiaryAlt,
            color: theme.palette.neutralDark
        },
        rootPressed: {
            backgroundColor: theme.palette.neutralTertiary,
            color: theme.palette.neutralDark
        }
    };
    return Styling_1.concatStyleSets(baseButtonStyles, messageBarButtonStyles, customStyles);
});

},{"../../../Styling":86,"../../../Utilities":87,"../BaseButton.styles":93}],108:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var React = require("react");
var Utilities_1 = require("../../../Utilities");
var DefaultButton_1 = require("../DefaultButton/DefaultButton");
var PrimaryButton = /** @class */ (function (_super) {
    tslib_1.__extends(PrimaryButton, _super);
    function PrimaryButton() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * Set this BaseComponent._resolveComponentRef to false, bypassing resolution of componentRef.
         */
        _this._shouldUpdateComponentRef = false;
        return _this;
    }
    PrimaryButton.prototype.render = function () {
        return (React.createElement(DefaultButton_1.DefaultButton, tslib_1.__assign({}, this.props, { primary: true, onRenderDescription: Utilities_1.nullRender })));
    };
    PrimaryButton = tslib_1.__decorate([
        Utilities_1.customizable('PrimaryButton', ['theme'])
    ], PrimaryButton);
    return PrimaryButton;
}(Utilities_1.BaseComponent));
exports.PrimaryButton = PrimaryButton;

},{"../../../Utilities":87,"../DefaultButton/DefaultButton":102,"react":"react","tslib":155}],109:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Utilities_1 = require("../../../Utilities");
var Styling_1 = require("../../../Styling");
exports.getClassNames = Utilities_1.memoizeFunction(function (styles, disabled, expanded, checked) {
    return {
        root: Styling_1.mergeStyles(styles.splitButtonMenuButton, expanded && [
            styles.splitButtonMenuButtonExpanded
        ], disabled && [
            styles.splitButtonMenuButtonDisabled
        ], checked && !disabled && [
            styles.splitButtonMenuButtonChecked
        ]),
        splitButtonContainer: Styling_1.mergeStyles(styles.splitButtonContainer, checked && !disabled && [
            styles.splitButtonContainerChecked,
            {
                selectors: {
                    ':hover': styles.splitButtonContainerCheckedHovered
                }
            }
        ], !disabled && !checked && [{
                selectors: {
                    ':hover': styles.splitButtonContainerHovered,
                    ':focus': styles.splitButtonContainerFocused
                }
            }], disabled && styles.splitButtonContainerDisabled),
        icon: Styling_1.mergeStyles(styles.splitButtonMenuIcon, disabled && styles.splitButtonMenuIconDisabled),
        flexContainer: Styling_1.mergeStyles(styles.splitButtonFlexContainer),
        divider: Styling_1.mergeStyles(styles.splitButtonDivider)
    };
});

},{"../../../Styling":86,"../../../Utilities":87}],110:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Styling_1 = require("../../../Styling");
var Utilities_1 = require("../../../Utilities");
exports.getStyles = Utilities_1.memoizeFunction(function (theme, customStyles) {
    var splitButtonStyles = {
        splitButtonContainer: {
            position: 'relative',
            display: 'inline-block',
            border: '1px solid transparent'
        },
        splitButtonContainerFocused: {
            outline: 'none!important',
            border: '1px solid'
        },
        splitButtonMenuButton: [
            Styling_1.getFocusStyle(theme, -1),
            {
                padding: 6,
                height: 'auto',
                boxSizing: 'border-box',
                border: '1px solid transparent',
                borderRadius: 0,
                outline: 'transparent',
                userSelect: 'none',
                display: 'inline-block',
                textDecoration: 'none',
                textAlign: 'center',
                cursor: 'pointer',
                verticalAlign: 'top',
                width: 32,
                marginLeft: -1
            }
        ],
        splitButtonDivider: {
            position: 'absolute',
            width: 1,
            right: 31,
            top: 8,
            bottom: 8
        },
        splitButtonMenuButtonDisabled: {
            pointerEvents: 'none',
            selectors: {
                ':hover': {
                    cursor: 'default'
                }
            }
        },
        splitButtonFlexContainer: {
            display: 'flex',
            height: '100%',
            flexWrap: 'nowrap',
            justifyContent: 'center',
            alignItems: 'center'
        },
    };
    return Styling_1.concatStyleSets(splitButtonStyles, customStyles);
});

},{"../../../Styling":86,"../../../Utilities":87}],111:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
tslib_1.__exportStar(require("./BaseButton"), exports);
tslib_1.__exportStar(require("./Button.types"), exports);
tslib_1.__exportStar(require("./Button"), exports);
tslib_1.__exportStar(require("./ActionButton/ActionButton"), exports);
tslib_1.__exportStar(require("./CommandBarButton/CommandBarButton"), exports);
tslib_1.__exportStar(require("./CommandButton/CommandButton"), exports);
tslib_1.__exportStar(require("./CompoundButton/CompoundButton"), exports);
tslib_1.__exportStar(require("./DefaultButton/DefaultButton"), exports);
tslib_1.__exportStar(require("./CommandButton/CommandButton"), exports);
tslib_1.__exportStar(require("./MessageBarButton/MessageBarButton"), exports);
tslib_1.__exportStar(require("./PrimaryButton/PrimaryButton"), exports);
tslib_1.__exportStar(require("./IconButton/IconButton"), exports);

},{"./ActionButton/ActionButton":89,"./BaseButton":92,"./Button":94,"./Button.types":95,"./CommandBarButton/CommandBarButton":97,"./CommandButton/CommandButton":99,"./CompoundButton/CompoundButton":100,"./DefaultButton/DefaultButton":102,"./IconButton/IconButton":104,"./MessageBarButton/MessageBarButton":106,"./PrimaryButton/PrimaryButton":108,"tslib":155}],112:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
/* tslint:disable:no-unused-variable */
var React = require("react");
/* tslint:enable:no-unused-variable */
var Utilities_1 = require("../../Utilities");
var CalloutContent_1 = require("./CalloutContent");
var Layer_1 = require("../../Layer");
var Callout = /** @class */ (function (_super) {
    tslib_1.__extends(Callout, _super);
    function Callout(props) {
        var _this = _super.call(this, props) || this;
        _this._warnDeprecations({
            'targetPoint': 'target',
            'useTargetPoint': 'target',
        });
        return _this;
    }
    Callout.prototype.render = function () {
        var content = (React.createElement(CalloutContent_1.CalloutContent, tslib_1.__assign({}, this.props)));
        return this.props.doNotLayer ? content : (React.createElement(Layer_1.Layer, null, content));
    };
    return Callout;
}(Utilities_1.BaseComponent));
exports.Callout = Callout;

},{"../../Layer":84,"../../Utilities":87,"./CalloutContent":114,"react":"react","tslib":155}],113:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/* tslint:disable */
var load_themed_styles_1 = require("@microsoft/load-themed-styles");
load_themed_styles_1.loadStyles([{ "rawString": ".root_36e39b41{position:absolute;-webkit-box-sizing:border-box;box-sizing:border-box;border:1px solid " }, { "theme": "neutralLight", "defaultValue": "#eaeaea" }, { "rawString": "}[dir='ltr'] .root_36e39b41{-webkit-box-shadow:0 0 5px 0px rgba(0,0,0,0.4);box-shadow:0 0 5px 0px rgba(0,0,0,0.4)}[dir='rtl'] .root_36e39b41{-webkit-box-shadow:0 0 5px 0px rgba(0,0,0,0.4);box-shadow:0 0 5px 0px rgba(0,0,0,0.4)}.root_36e39b41::-moz-focus-inner{border:0}.root_36e39b41{outline:transparent}@media screen and (-ms-high-contrast: active){.root_36e39b41{border:1px solid WindowText}}.container_36e39b41{position:relative}.main_36e39b41{background-color:" }, { "theme": "white", "defaultValue": "#ffffff" }, { "rawString": ";overflow-x:hidden;overflow-y:auto;position:relative}.overFlowYHidden_36e39b41{overflow-y:hidden}.beak_36e39b41{position:absolute;background-color:" }, { "theme": "white", "defaultValue": "#ffffff" }, { "rawString": ";-webkit-box-shadow:inherit;box-shadow:inherit;border:inherit;-webkit-box-sizing:border-box;box-sizing:border-box;-webkit-transform:rotate(45deg);transform:rotate(45deg)}.beakCurtain_36e39b41{position:absolute;top:0;right:0;bottom:0;left:0;background-color:" }, { "theme": "white", "defaultValue": "#ffffff" }, { "rawString": "}\n" }]);
exports.root = "root_36e39b41";
exports.container = "container_36e39b41";
exports.main = "main_36e39b41";
exports.overFlowYHidden = "overFlowYHidden_36e39b41";
exports.beak = "beak_36e39b41";
exports.beakCurtain = "beakCurtain_36e39b41";

},{"@microsoft/load-themed-styles":2}],114:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
/* tslint:disable:no-unused-variable */
var React = require("react");
var Utilities_1 = require("../../Utilities");
var positioning_1 = require("../../utilities/positioning");
var Popup_1 = require("../../Popup");
var stylesImport = require("./Callout.scss");
var Styling_1 = require("../../Styling");
var styles = stylesImport;
var BEAK_ORIGIN_POSITION = { top: 0, left: 0 };
// Microsoft Edge will overwrite inline styles if there is an animation pertaining to that style.
// To help ensure that edge will respect the offscreen style opacity
// filter needs to be added as an additional way to set opacity.
var OFF_SCREEN_STYLE = { opacity: 0, filter: 'opacity(0)' };
var BORDER_WIDTH = 1;
var SLIDE_ANIMATIONS = (_a = {},
    _a[positioning_1.RectangleEdge.top] = 'slideUpIn20',
    _a[positioning_1.RectangleEdge.bottom] = 'slideDownIn20',
    _a[positioning_1.RectangleEdge.left] = 'slideLeftIn20',
    _a[positioning_1.RectangleEdge.right] = 'slideRightIn20',
    _a);
var CalloutContent = /** @class */ (function (_super) {
    tslib_1.__extends(CalloutContent, _super);
    function CalloutContent(props) {
        var _this = _super.call(this, props) || this;
        _this._warnDeprecations({ 'beakStyle': 'beakWidth' });
        _this._didSetInitialFocus = false;
        _this.state = {
            positions: undefined,
            slideDirectionalClassName: undefined,
            // @TODO it looks like this is not even being used anymore.
            calloutElementRect: undefined,
            heightOffset: 0
        };
        _this._positionAttempts = 0;
        return _this;
    }
    CalloutContent.prototype.componentDidUpdate = function () {
        this._setInitialFocus();
        this._updateAsyncPosition();
    };
    CalloutContent.prototype.componentWillMount = function () {
        this._setTargetWindowAndElement(this._getTarget());
    };
    CalloutContent.prototype.componentWillUpdate = function (newProps) {
        // If the target element changed, find the new one. If we are tracking target with class name, always find element because we do not know if fabric has rendered a new element and disposed the old element.
        var newTarget = this._getTarget(newProps);
        var oldTarget = this._getTarget();
        if (newTarget !== oldTarget || typeof (newTarget) === 'string' || newTarget instanceof String) {
            this._maxHeight = undefined;
            this._setTargetWindowAndElement(newTarget);
        }
        if (newProps.gapSpace !== this.props.gapSpace || this.props.beakWidth !== newProps.beakWidth) {
            this._maxHeight = undefined;
        }
        if (newProps.finalHeight !== this.props.finalHeight) {
            this._setHeightOffsetEveryFrame();
        }
    };
    CalloutContent.prototype.componentDidMount = function () {
        this._onComponentDidMount();
    };
    CalloutContent.prototype.render = function () {
        // If there is no target window then we are likely in server side rendering and we should not render anything.
        if (!this._targetWindow) {
            return null;
        }
        var _a = this.props, role = _a.role, ariaLabel = _a.ariaLabel, ariaDescribedBy = _a.ariaDescribedBy, ariaLabelledBy = _a.ariaLabelledBy, className = _a.className, target = _a.target, isBeakVisible = _a.isBeakVisible, beakStyle = _a.beakStyle, children = _a.children, beakWidth = _a.beakWidth, calloutWidth = _a.calloutWidth, finalHeight = _a.finalHeight, backgroundColor = _a.backgroundColor, calloutMaxHeight = _a.calloutMaxHeight, onScroll = _a.onScroll;
        target = this._getTarget();
        var positions = this.state.positions;
        var directionalClassName = (positions && positions.targetEdge)
            ? Styling_1.AnimationClassNames[SLIDE_ANIMATIONS[positions.targetEdge]]
            : '';
        var getContentMaxHeight = this._getMaxHeight() + this.state.heightOffset;
        var contentMaxHeight = calloutMaxHeight && (calloutMaxHeight < getContentMaxHeight) ? calloutMaxHeight : getContentMaxHeight;
        var beakReactStyle = this._getBeakPosition(positions, beakWidth, backgroundColor, beakStyle);
        var beakVisible = isBeakVisible && (!!target);
        var content = (React.createElement("div", { ref: this._resolveRef('_hostElement'), className: Utilities_1.css('ms-Callout-container', styles.container) },
            React.createElement("div", { className: Styling_1.mergeStyles('ms-Callout', styles.root, className, directionalClassName, !!calloutWidth && { width: calloutWidth }), style: positions ? positions.elementPosition : OFF_SCREEN_STYLE, tabIndex: -1, 
                // See https://developer.mozilla.org/en-US/docs/Web/HTML/Element/button#Clicking_and_focus
                ref: this._resolveRef('_calloutElement') },
                beakVisible && (React.createElement("div", { className: Utilities_1.css('ms-Callout-beak', styles.beak), style: beakReactStyle })),
                beakVisible &&
                    (React.createElement("div", { className: Utilities_1.css('ms-Callout-beakCurtain', styles.beakCurtain) })),
                React.createElement(Popup_1.Popup, { role: role, ariaLabel: ariaLabel, ariaDescribedBy: ariaDescribedBy, ariaLabelledBy: ariaLabelledBy, className: Utilities_1.css('ms-Callout-main', styles.main, (_b = {},
                        _b[styles.overFlowYHidden] = !!finalHeight,
                        _b)), onDismiss: this.dismiss, onScroll: onScroll, shouldRestoreFocus: true, style: { maxHeight: contentMaxHeight, backgroundColor: backgroundColor } }, children))));
        return content;
        var _b;
    };
    CalloutContent.prototype.dismiss = function (ev) {
        var onDismiss = this.props.onDismiss;
        if (onDismiss) {
            onDismiss(ev);
        }
    };
    CalloutContent.prototype._dismissOnScroll = function (ev) {
        var preventDismissOnScroll = this.props.preventDismissOnScroll;
        if (this.state.positions && !preventDismissOnScroll) {
            this._dismissOnLostFocus(ev);
        }
    };
    CalloutContent.prototype._dismissOnLostFocus = function (ev) {
        var target = ev.target;
        var clickedOutsideCallout = this._hostElement && !Utilities_1.elementContains(this._hostElement, target);
        if ((!this._target && clickedOutsideCallout) ||
            ev.target !== this._targetWindow &&
                clickedOutsideCallout &&
                (this._target.stopPropagation ||
                    (!this._target || (target !== this._target && !Utilities_1.elementContains(this._target, target))))) {
            this.dismiss(ev);
        }
    };
    CalloutContent.prototype._setInitialFocus = function () {
        if (this.props.setInitialFocus && !this._didSetInitialFocus && this.state.positions) {
            this._didSetInitialFocus = true;
            Utilities_1.focusFirstChild(this._calloutElement);
        }
    };
    CalloutContent.prototype._onComponentDidMount = function () {
        var _this = this;
        // This is added so the callout will dismiss when the window is scrolled
        // but not when something inside the callout is scrolled. The delay seems
        // to be required to avoid React firing an async focus event in IE from
        // the target changing focus quickly prior to rendering the callout.
        this._async.setTimeout(function () {
            _this._events.on(_this._targetWindow, 'scroll', _this._dismissOnScroll, true);
            _this._events.on(_this._targetWindow, 'resize', _this.dismiss, true);
            _this._events.on(_this._targetWindow.document.body, 'focus', _this._dismissOnLostFocus, true);
            _this._events.on(_this._targetWindow.document.body, 'click', _this._dismissOnLostFocus, true);
        }, 0);
        if (this.props.onLayerMounted) {
            this.props.onLayerMounted();
        }
        this._updateAsyncPosition();
        this._setHeightOffsetEveryFrame();
    };
    CalloutContent.prototype._updateAsyncPosition = function () {
        var _this = this;
        this._async.requestAnimationFrame(function () { return _this._updatePosition(); });
    };
    CalloutContent.prototype._updatePosition = function () {
        var positions = this.state.positions;
        var hostElement = this._hostElement;
        var calloutElement = this._calloutElement;
        if (hostElement && calloutElement) {
            var currentProps = void 0;
            currentProps = Utilities_1.assign(currentProps, this.props);
            currentProps.bounds = this._getBounds();
            currentProps.target = this._target;
            var newPositions = positioning_1.positionCallout(currentProps, hostElement, calloutElement);
            // Set the new position only when the positions are not exists or one of the new callout positions are different.
            // The position should not change if the position is within 2 decimal places.
            if ((!positions && newPositions) ||
                (positions && newPositions && !this._arePositionsEqual(positions, newPositions)
                    && this._positionAttempts < 5)) {
                // We should not reposition the callout more than a few times, if it is then the content is likely resizing
                // and we should stop trying to reposition to prevent a stack overflow.
                this._positionAttempts++;
                this.setState({
                    positions: newPositions
                });
            }
            else {
                this._positionAttempts = 0;
                if (this.props.onPositioned) {
                    this.props.onPositioned(this.state.positions);
                }
            }
        }
    };
    CalloutContent.prototype._getBeakPosition = function (positions, beakWidth, backgroundColor, beakStyle) {
        var beakStyleWidth = beakWidth;
        // This is here to support the old way of setting the beak size until version 1.0.0.
        // beakStyle is now deprecated and will be be removed at version 1.0.0
        if (beakStyle === 'ms-Callout-smallbeak') {
            beakStyleWidth = 16;
        }
        var beakReactStyle = tslib_1.__assign({}, (positions && positions.beakPosition ? positions.beakPosition.elementPosition : null));
        beakReactStyle.height = beakStyleWidth;
        beakReactStyle.width = beakStyleWidth;
        beakReactStyle.backgroundColor = backgroundColor;
        if (!beakReactStyle.top && !beakReactStyle.bottom && !beakReactStyle.left && !beakReactStyle.right) {
            beakReactStyle.left = BEAK_ORIGIN_POSITION.left;
            beakReactStyle.top = BEAK_ORIGIN_POSITION.top;
        }
        return beakReactStyle;
    };
    CalloutContent.prototype._getBounds = function () {
        if (!this._bounds) {
            var currentBounds = this.props.bounds;
            if (!currentBounds) {
                currentBounds = {
                    top: 0 + this.props.minPagePadding,
                    left: 0 + this.props.minPagePadding,
                    right: this._targetWindow.innerWidth - this.props.minPagePadding,
                    bottom: this._targetWindow.innerHeight - this.props.minPagePadding,
                    width: this._targetWindow.innerWidth - this.props.minPagePadding * 2,
                    height: this._targetWindow.innerHeight - this.props.minPagePadding * 2
                };
            }
            this._bounds = currentBounds;
        }
        return this._bounds;
    };
    CalloutContent.prototype._getMaxHeight = function () {
        if (!this._maxHeight) {
            if (this.props.directionalHintFixed && this._target) {
                var beakWidth = this.props.isBeakVisible ? this.props.beakWidth : 0;
                var gapSpace = this.props.gapSpace ? this.props.gapSpace : 0;
                // Since the callout cannot measure it's border size it must be taken into account here. Otherwise it will
                // overlap with the target.
                var totalGap = gapSpace + beakWidth + BORDER_WIDTH * 2;
                this._maxHeight = positioning_1.getMaxHeight(this._target, this.props.directionalHint, totalGap, this._getBounds());
            }
            else {
                this._maxHeight = this._getBounds().height - BORDER_WIDTH * 2;
            }
        }
        return this._maxHeight;
    };
    CalloutContent.prototype._arePositionsEqual = function (positions, newPosition) {
        return this._comparePositions(positions.elementPosition, newPosition.elementPosition) &&
            this._comparePositions(positions.beakPosition.elementPosition, newPosition.beakPosition.elementPosition);
    };
    CalloutContent.prototype._comparePositions = function (oldPositions, newPositions) {
        for (var key in newPositions) {
            // This needs to be checked here and below because there is a linting error if for in does not immediately have an if statement
            if (newPositions.hasOwnProperty(key)) {
                var oldPositionEdge = oldPositions[key];
                var newPositionEdge = newPositions[key];
                if (oldPositionEdge !== undefined && newPositionEdge !== undefined) {
                    if (oldPositionEdge.toFixed(2) !== newPositionEdge.toFixed(2)) {
                        return false;
                    }
                }
                else {
                    return false;
                }
            }
        }
        return true;
    };
    CalloutContent.prototype._setTargetWindowAndElement = function (target) {
        if (target) {
            if (typeof target === 'string') {
                var currentDoc = Utilities_1.getDocument();
                this._target = currentDoc ? currentDoc.querySelector(target) : null;
                this._targetWindow = Utilities_1.getWindow();
            }
            else if (target.stopPropagation) {
                this._targetWindow = Utilities_1.getWindow(target.toElement);
                this._target = target;
            }
            else if (target.x !== undefined && target.y !== undefined) {
                this._targetWindow = Utilities_1.getWindow();
                this._target = target;
            }
            else {
                var targetElement = target;
                this._targetWindow = Utilities_1.getWindow(targetElement);
                this._target = target;
            }
        }
        else {
            this._targetWindow = Utilities_1.getWindow();
        }
    };
    CalloutContent.prototype._setHeightOffsetEveryFrame = function () {
        var _this = this;
        if (this._calloutElement && this.props.finalHeight) {
            this._setHeightOffsetTimer = this._async.requestAnimationFrame(function () {
                var calloutMainElem = _this._calloutElement.lastChild;
                var cardScrollHeight = calloutMainElem.scrollHeight;
                var cardCurrHeight = calloutMainElem.offsetHeight;
                var scrollDiff = cardScrollHeight - cardCurrHeight;
                _this.setState({
                    heightOffset: _this.state.heightOffset + scrollDiff
                });
                if (calloutMainElem.offsetHeight < _this.props.finalHeight) {
                    _this._setHeightOffsetEveryFrame();
                }
                else {
                    _this._async.cancelAnimationFrame(_this._setHeightOffsetTimer);
                }
            });
        }
    };
    CalloutContent.prototype._getTarget = function (props) {
        if (props === void 0) { props = this.props; }
        var useTargetPoint = props.useTargetPoint, targetPoint = props.targetPoint, target = props.target;
        return useTargetPoint ? targetPoint : target;
    };
    CalloutContent.defaultProps = {
        preventDismissOnScroll: false,
        isBeakVisible: true,
        beakWidth: 16,
        gapSpace: 0,
        minPagePadding: 8,
        directionalHint: 7 /* bottomAutoEdge */
    };
    tslib_1.__decorate([
        Utilities_1.autobind
    ], CalloutContent.prototype, "dismiss", null);
    tslib_1.__decorate([
        Utilities_1.autobind
    ], CalloutContent.prototype, "_setInitialFocus", null);
    tslib_1.__decorate([
        Utilities_1.autobind
    ], CalloutContent.prototype, "_onComponentDidMount", null);
    return CalloutContent;
}(Utilities_1.BaseComponent));
exports.CalloutContent = CalloutContent;
var _a;

},{"../../Popup":85,"../../Styling":86,"../../Utilities":87,"../../utilities/positioning":145,"./Callout.scss":113,"react":"react","tslib":155}],115:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
tslib_1.__exportStar(require("./Callout"), exports);
tslib_1.__exportStar(require("../../common/DirectionalHint"), exports);

},{"../../common/DirectionalHint":88,"./Callout":112,"tslib":155}],116:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Utilities_1 = require("../../Utilities");
var Styling_1 = require("../../Styling");
var ContextualMenu_styles_1 = require("./ContextualMenu.styles");
var VerticalDivider_classNames_1 = require("../Divider/VerticalDivider.classNames");
exports.getSplitButtonVerticalDividerClassNames = Utilities_1.memoizeFunction(function (theme) {
    var semanticColors = theme.semanticColors;
    var ContextualMenuDividerColor = semanticColors.bodyDivider;
    return Styling_1.mergeStyleSets(VerticalDivider_classNames_1.getDividerClassNames(theme), {
        divider: {
            height: 16,
            width: 1,
        }
    });
});
exports.getContextualMenuClassNames = Utilities_1.memoizeFunction(function (theme, className) {
    var styles = ContextualMenu_styles_1.getStyles(theme);
    return Styling_1.mergeStyleSets({
        container: [
            'ms-ContextualMenu-container',
            styles.container,
            className,
            [{
                    selectors: {
                        ':focus': { outline: 0 }
                    }
                }]
        ],
        root: [
            'ms-ContextualMenu is-open',
            styles.root
        ],
        list: [
            'ms-ContextualMenu-list is-open',
            styles.list
        ],
        header: [
            'ms-ContextualMenu-header',
            styles.header
        ],
        title: styles.title
    });
});
exports.getItemClassNames = Utilities_1.memoizeFunction(function (theme, disabled, expanded, checked, isAnchorLink, knownIcon, itemClassName, dividerClassName, iconClassName, subMenuClassName) {
    var semanticColors = theme.semanticColors;
    var ContextualMenuIconColor = semanticColors.menuIcon;
    var styles = ContextualMenu_styles_1.getMenuItemStyles(theme);
    return Styling_1.mergeStyleSets({
        item: [
            'ms-ContextualMenu-item',
            styles.item,
            itemClassName,
        ],
        divider: [
            'ms-ContextualMenu-divider',
            styles.divider,
            dividerClassName,
        ],
        root: [
            'ms-ContextualMenu-link',
            styles.root,
            checked && [
                'is-checked',
                styles.rootChecked
            ],
            isAnchorLink && styles.anchorLink,
            expanded && [
                'is-expanded',
                styles.rootExpanded
            ],
            disabled && [
                'is-disabled',
                styles.rootDisabled
            ],
            !disabled && !expanded && [{
                    selectors: {
                        ':hover': styles.rootHovered,
                        ':active': styles.rootPressed,
                        '.ms-Fabric.is-focusVisible &:focus, .ms-Fabric.is-focusVisible &:focus:hover': styles.rootFocused,
                        '.ms-Fabric.is-focusVisible &:hover': { background: 'inherit;' }
                    }
                }],
        ],
        splitPrimary: [
            styles.root,
            checked && [
                'is-checked',
                styles.rootChecked
            ],
            disabled && [
                'is-disabled',
                styles.rootDisabled
            ],
            !disabled && !checked && [{
                    selectors: {
                        ':hover': styles.rootHovered,
                        ':active': styles.rootPressed,
                        '.ms-Fabric.is-focusVisible &:focus, .ms-Fabric.is-focusVisible &:focus:hover': styles.rootFocused,
                        '.ms-Fabric.is-focusVisible &:hover': { background: 'inherit;' }
                    }
                }]
        ],
        splitMenu: [
            styles.root,
            {
                width: 32
            },
            expanded && [
                'is-expanded',
                styles.rootExpanded
            ],
            disabled && [
                'is-disabled',
                styles.rootDisabled
            ],
            !disabled && !expanded && [{
                    selectors: {
                        ':hover': styles.rootHovered,
                        ':active': styles.rootPressed,
                        '.ms-Fabric.is-focusVisible &:focus, .ms-Fabric.is-focusVisible &:focus:hover': styles.rootFocused,
                        '.ms-Fabric.is-focusVisible &:hover': { background: 'inherit;' }
                    }
                }]
        ],
        linkContent: [
            'ms-ContextualMenu-linkContent',
            styles.linkContent
        ],
        linkContentMenu: [
            'ms-ContextualMenu-linkContent',
            styles.linkContent,
            {
                justifyContent: 'center',
            }
        ],
        icon: [
            'ms-ContextualMenu-icon',
            knownIcon && 'ms-ContextualMenu-iconColor ' && styles.iconColor,
            styles.icon,
            iconClassName,
        ],
        checkmarkIcon: [
            'ms-ContextualMenu-checkmarkIcon',
            knownIcon && 'ms-ContextualMenu-checkmarkIcon ' && styles.checkmarkIcon,
            styles.icon,
            iconClassName,
        ],
        subMenuIcon: [
            'ms-ContextualMenu-submenuIcon',
            styles.subMenuIcon,
            subMenuClassName,
        ],
        label: [
            'ms-ContextualMenu-itemText',
            styles.label
        ],
        splitContainer: styles.splitButtonFlexContainer,
    });
});

},{"../../Styling":86,"../../Utilities":87,"../Divider/VerticalDivider.classNames":121,"./ContextualMenu.styles":118}],117:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var React = require("react");
var ContextualMenu_types_1 = require("./ContextualMenu.types");
var FocusZone_1 = require("../../FocusZone");
var ContextualMenu_classNames_1 = require("./ContextualMenu.classNames");
var Utilities_1 = require("../../Utilities");
var withResponsiveMode_1 = require("../../utilities/decorators/withResponsiveMode");
var Callout_1 = require("../../Callout");
var Icon_1 = require("../../Icon");
var Divider_1 = require("../../Divider");
function hasSubmenuItems(item) {
    var submenuItems = getSubmenuItems(item);
    return !!(submenuItems && submenuItems.length);
}
exports.hasSubmenuItems = hasSubmenuItems;
function getSubmenuItems(item) {
    return item.subMenuProps ? item.subMenuProps.items : item.items;
}
exports.getSubmenuItems = getSubmenuItems;
/**
 * Determines the effective checked state of a menu item.
 *
 * @param item {IContextualMenuItem} to get the check state of.
 * @returns {true} if the item is checked.
 * @returns {false} if the item is unchecked.
 * @returns {null} if the item is not checkable.
 */
function getIsChecked(item) {
    if (item.canCheck) {
        return !!(item.isChecked || item.checked);
    }
    if (typeof item.isChecked === 'boolean') {
        return item.isChecked;
    }
    if (typeof item.checked === 'boolean') {
        return item.checked;
    }
    // Item is not checkable.
    return null;
}
/**
 * Returns true if a list of menu items can contain a checkbox
 */
function canAnyMenuItemsCheck(items) {
    return items.some(function (item) {
        if (item.canCheck) {
            return true;
        }
        // If the item is a section, check if any of the items in the section can check.
        if (item.sectionProps && item.sectionProps.items.some(function (submenuItem) { return submenuItem.canCheck === true; })) {
            return true;
        }
        return false;
    });
}
exports.canAnyMenuItemsCheck = canAnyMenuItemsCheck;
var ContextualMenu = /** @class */ (function (_super) {
    tslib_1.__extends(ContextualMenu, _super);
    function ContextualMenu(props) {
        var _this = _super.call(this, props) || this;
        _this._scrollIdleDelay = 250 /* ms */;
        _this.state = {
            contextualMenuItems: undefined,
            subMenuId: Utilities_1.getId('ContextualMenu')
        };
        _this._warnDeprecations({
            'targetPoint': 'target',
            'useTargetPoint': 'target',
        });
        _this._isFocusingPreviousElement = false;
        _this._isScrollIdle = true;
        return _this;
    }
    ContextualMenu_1 = ContextualMenu;
    ContextualMenu.prototype.dismiss = function (ev, dismissAll) {
        var onDismiss = this.props.onDismiss;
        if (onDismiss) {
            onDismiss(ev, dismissAll);
        }
    };
    ContextualMenu.prototype.componentWillUpdate = function (newProps) {
        if (newProps.target !== this.props.target) {
            var newTarget = newProps.target;
            this._setTargetWindowAndElement(newTarget);
        }
    };
    // Invoked once, both on the client and server, immediately before the initial rendering occurs.
    ContextualMenu.prototype.componentWillMount = function () {
        var target = this.props.target;
        this._setTargetWindowAndElement(target);
        this._previousActiveElement = this._targetWindow ? this._targetWindow.document.activeElement : null;
    };
    // Invoked once, only on the client (not on the server), immediately after the initial rendering occurs.
    ContextualMenu.prototype.componentDidMount = function () {
        this._events.on(this._targetWindow, 'resize', this.dismiss);
        if (this.props.onMenuOpened) {
            this.props.onMenuOpened(this.props);
        }
    };
    // Invoked immediately before a component is unmounted from the DOM.
    ContextualMenu.prototype.componentWillUnmount = function () {
        var _this = this;
        if (this._isFocusingPreviousElement && this._previousActiveElement) {
            // This slight delay is required so that we can unwind the stack, let react try to mess with focus, and then
            // apply the correct focus. Without the setTimeout, we end up focusing the correct thing, and then React wants
            // to reset the focus back to the thing it thinks should have been focused.
            setTimeout(function () { return _this._previousActiveElement.focus(); }, 0);
        }
        if (this.props.onMenuDismissed) {
            this.props.onMenuDismissed(this.props);
        }
        this._events.dispose();
        this._async.dispose();
    };
    ContextualMenu.prototype.render = function () {
        var _this = this;
        var _a = this.props, className = _a.className, items = _a.items, isBeakVisible = _a.isBeakVisible, labelElementId = _a.labelElementId, id = _a.id, targetPoint = _a.targetPoint, useTargetPoint = _a.useTargetPoint, beakWidth = _a.beakWidth, directionalHint = _a.directionalHint, directionalHintForRTL = _a.directionalHintForRTL, gapSpace = _a.gapSpace, coverTarget = _a.coverTarget, ariaLabel = _a.ariaLabel, doNotLayer = _a.doNotLayer, arrowDirection = _a.arrowDirection, target = _a.target, bounds = _a.bounds, useTargetWidth = _a.useTargetWidth, useTargetAsMinWidth = _a.useTargetAsMinWidth, directionalHintFixed = _a.directionalHintFixed, shouldFocusOnMount = _a.shouldFocusOnMount, title = _a.title, customStyles = _a.styles, theme = _a.theme, calloutProps = _a.calloutProps, _b = _a.onRenderSubMenu, onRenderSubMenu = _b === void 0 ? this._onRenderSubMenu : _b;
        var menuClassNames = this.props.getMenuClassNames || ContextualMenu_classNames_1.getContextualMenuClassNames;
        this._classNames = menuClassNames(theme, className);
        var hasIcons = itemsHaveIcons(items);
        function itemsHaveIcons(contextualMenuItems) {
            for (var _i = 0, contextualMenuItems_1 = contextualMenuItems; _i < contextualMenuItems_1.length; _i++) {
                var item = contextualMenuItems_1[_i];
                if (!!item.icon || !!item.iconProps) {
                    return true;
                }
                if (item.itemType === ContextualMenu_types_1.ContextualMenuItemType.Section && item.sectionProps && itemsHaveIcons(item.sectionProps.items)) {
                    return true;
                }
            }
            return false;
        }
        var hasCheckmarks = canAnyMenuItemsCheck(items);
        var submenuProps = this.state.expandedMenuItemKey ? this._getSubmenuProps() : null;
        isBeakVisible = isBeakVisible === undefined ? this.props.responsiveMode <= withResponsiveMode_1.ResponsiveMode.medium : isBeakVisible;
        /**
         * When useTargetWidth is true, get the width of the target element and apply it for the context menu container
         */
        var contextMenuStyle;
        var targetAsHtmlElement = this._target;
        if ((useTargetWidth || useTargetAsMinWidth) && targetAsHtmlElement && targetAsHtmlElement.offsetWidth) {
            var targetWidth = targetAsHtmlElement.offsetWidth;
            if (useTargetWidth) {
                contextMenuStyle = {
                    width: targetWidth
                };
            }
            else if (useTargetAsMinWidth) {
                contextMenuStyle = {
                    minWidth: targetWidth
                };
            }
        }
        // The menu should only return if items were provided, if no items were provided then it should not appear.
        if (items && items.length > 0) {
            var indexCorrection_1 = 0;
            var totalItemCount_1 = 0;
            for (var _i = 0, items_1 = items; _i < items_1.length; _i++) {
                var item = items_1[_i];
                if (item.itemType !== ContextualMenu_types_1.ContextualMenuItemType.Divider &&
                    item.itemType !== ContextualMenu_types_1.ContextualMenuItemType.Header) {
                    totalItemCount_1++;
                }
            }
            return (React.createElement(Callout_1.Callout, tslib_1.__assign({}, calloutProps, { target: useTargetPoint ? targetPoint : target, isBeakVisible: isBeakVisible, beakWidth: beakWidth, directionalHint: directionalHint, directionalHintForRTL: directionalHintForRTL, gapSpace: gapSpace, coverTarget: coverTarget, doNotLayer: doNotLayer, className: 'ms-ContextualMenu-Callout', setInitialFocus: shouldFocusOnMount, onDismiss: this.props.onDismiss, onScroll: this._onScroll, bounds: bounds, directionalHintFixed: directionalHintFixed }),
                React.createElement("div", { role: 'menu', style: contextMenuStyle, ref: function (host) { return _this._host = host; }, id: id, className: this._classNames.container, tabIndex: 0, onKeyDown: this._onMenuKeyDown },
                    title && React.createElement("div", { className: this._classNames.title, role: 'heading', "aria-level": 1 },
                        " ",
                        title,
                        " "),
                    (items && items.length) ? (React.createElement(FocusZone_1.FocusZone, { className: this._classNames.root, direction: arrowDirection, isCircularNavigation: true, allowTabKey: true },
                        React.createElement("ul", { "aria-label": ariaLabel, "aria-labelledby": labelElementId, className: this._classNames.list, onKeyDown: this._onKeyDown }, items.map(function (item, index) {
                            if (item.itemType === ContextualMenu_types_1.ContextualMenuItemType.Divider ||
                                item.itemType === ContextualMenu_types_1.ContextualMenuItemType.Header) {
                                indexCorrection_1++;
                            }
                            return _this._renderMenuItem(item, index, index - indexCorrection_1, totalItemCount_1, hasCheckmarks, hasIcons);
                        })))) : (null),
                    submenuProps && onRenderSubMenu(submenuProps, this._onRenderSubMenu))));
        }
        else {
            return null;
        }
    };
    ContextualMenu.prototype._onRenderSubMenu = function (subMenuProps) {
        return React.createElement(ContextualMenu_1, tslib_1.__assign({}, subMenuProps));
    };
    ContextualMenu.prototype._renderMenuItem = function (item, index, focusableElementIndex, totalItemCount, hasCheckmarks, hasIcons) {
        var renderedItems = [];
        var iconProps = this._getIconProps(item);
        // We only send a dividerClassName when the item to be rendered is a divider. For all other cases, the default divider style is used.
        var dividerClassName = item.itemType === ContextualMenu_types_1.ContextualMenuItemType.Divider ? item.className : undefined;
        var subMenuIconClassName = item.submenuIconProps ? item.submenuIconProps.className : '';
        var getClassNames = item.getItemClassNames || ContextualMenu_classNames_1.getItemClassNames;
        var itemClassNames = getClassNames(this.props.theme, this._isItemDisabled(item), (this.state.expandedMenuItemKey === item.key), !!getIsChecked(item), !!item.href, (iconProps.iconName !== 'None'), item.className, dividerClassName, iconProps.className, subMenuIconClassName);
        if (item.name === '-') {
            item.itemType = ContextualMenu_types_1.ContextualMenuItemType.Divider;
        }
        switch (item.itemType) {
            case ContextualMenu_types_1.ContextualMenuItemType.Divider:
                renderedItems.push(this._renderSeparator(index, itemClassNames));
                break;
            case ContextualMenu_types_1.ContextualMenuItemType.Header:
                renderedItems.push(this._renderSeparator(index, itemClassNames));
                var headerItem = this._renderHeaderMenuItem(item, itemClassNames, index, hasCheckmarks, hasIcons);
                renderedItems.push(this._renderListItem(headerItem, item.key || index, itemClassNames, item.title));
                break;
            case ContextualMenu_types_1.ContextualMenuItemType.Section:
                renderedItems.push(this._renderSectionItem(item, itemClassNames, index, hasCheckmarks, hasIcons));
                break;
            default:
                var menuItem = this._renderNormalItem(item, itemClassNames, index, focusableElementIndex, totalItemCount, hasCheckmarks, hasIcons);
                renderedItems.push(this._renderListItem(menuItem, item.key || index, itemClassNames, item.title));
                break;
        }
        return renderedItems;
    };
    ContextualMenu.prototype._renderSectionItem = function (item, menuClassNames, index, hasCheckmarks, hasIcons) {
        var _this = this;
        var section = item.sectionProps;
        if (!section) {
            return;
        }
        var headerItem;
        if (section.title) {
            var headerContextualMenuItem = {
                key: "section-" + section.title + "-title",
                itemType: ContextualMenu_types_1.ContextualMenuItemType.Header,
                name: section.title,
            };
            headerItem = this._renderHeaderMenuItem(headerContextualMenuItem, menuClassNames, index, hasCheckmarks, hasIcons);
        }
        if (section.items && section.items.length > 0) {
            return (React.createElement("li", { role: 'presentation', key: section.key },
                React.createElement("div", { role: 'group' },
                    React.createElement("ul", { className: this._classNames.list },
                        section.topDivider && this._renderSeparator(index, menuClassNames, true, true),
                        headerItem && this._renderListItem(headerItem, item.key || index, menuClassNames, item.title),
                        section.items.map(function (contextualMenuItem, itemsIndex) { return (_this._renderMenuItem(contextualMenuItem, itemsIndex, itemsIndex, section.items.length, hasCheckmarks, hasIcons)); }),
                        section.bottomDivider && this._renderSeparator(index, menuClassNames, false, true)))));
        }
    };
    ContextualMenu.prototype._renderListItem = function (content, key, classNames, title) {
        return (React.createElement("li", { role: 'presentation', title: title, key: key, className: classNames.item }, content));
    };
    ContextualMenu.prototype._renderSeparator = function (index, classNames, top, fromSection) {
        if (fromSection || index > 0) {
            return (React.createElement("li", { role: 'separator', key: 'separator-' + index + (top === undefined ? '' : (top ? '-top' : '-bottom')), className: classNames.divider }));
        }
        return null;
    };
    ContextualMenu.prototype._renderNormalItem = function (item, classNames, index, focusableElementIndex, totalItemCount, hasCheckmarks, hasIcons) {
        if (item.onRender) {
            return [item.onRender(item, this.dismiss)];
        }
        if (item.href) {
            return this._renderAnchorMenuItem(item, classNames, index, focusableElementIndex, totalItemCount, hasCheckmarks, hasIcons);
        }
        if (item.split && hasSubmenuItems(item)) {
            return this._renderSplitButton(item, classNames, index, focusableElementIndex, totalItemCount, hasCheckmarks, hasIcons);
        }
        return this._renderButtonItem(item, classNames, index, focusableElementIndex, totalItemCount, hasCheckmarks, hasIcons);
    };
    ContextualMenu.prototype._renderHeaderMenuItem = function (item, classNames, index, hasCheckmarks, hasIcons) {
        return (React.createElement("div", { className: this._classNames.header, style: item.style, role: 'heading', "aria-level": this.props.title ? 2 : 1 }, this._renderMenuItemChildren(item, classNames, index, hasCheckmarks, hasIcons)));
    };
    ContextualMenu.prototype._renderAnchorMenuItem = function (item, classNames, index, focusableElementIndex, totalItemCount, hasCheckmarks, hasIcons) {
        return (React.createElement("div", null,
            React.createElement("a", tslib_1.__assign({}, Utilities_1.getNativeProps(item, Utilities_1.anchorProperties), { href: item.href, target: item.target, className: classNames.root, role: 'menuitem', "aria-posinset": focusableElementIndex + 1, "aria-setsize": totalItemCount, "aria-disabled": this._isItemDisabled(item), style: item.style, onClick: this._onAnchorClick.bind(this, item) }), this._renderMenuItemChildren(item, classNames, index, hasCheckmarks, hasIcons))));
    };
    ContextualMenu.prototype._renderButtonItem = function (item, classNames, index, focusableElementIndex, totalItemCount, hasCheckmarks, hasIcons) {
        var _this = this;
        var _a = this.state, expandedMenuItemKey = _a.expandedMenuItemKey, subMenuId = _a.subMenuId;
        var ariaLabel = '';
        if (item.ariaLabel) {
            ariaLabel = item.ariaLabel;
        }
        else if (item.name) {
            ariaLabel = item.name;
        }
        var isChecked = getIsChecked(item);
        var canCheck = isChecked !== null;
        var defaultRole = canCheck ? 'menuitemcheckbox' : 'menuitem';
        var itemButtonProperties = {
            className: classNames.root,
            onClick: this._onItemClick.bind(this, item),
            onKeyDown: hasSubmenuItems(item) ? this._onItemKeyDown.bind(this, item) : null,
            onMouseEnter: this._onItemMouseEnter.bind(this, item),
            onMouseLeave: this._onMouseItemLeave.bind(this, item),
            onMouseDown: function (ev) { return _this._onItemMouseDown(item, ev); },
            onMouseMove: this._onItemMouseMove.bind(this, item),
            disabled: this._isItemDisabled(item),
            href: item.href,
            title: item.title,
            'aria-label': ariaLabel,
            'aria-haspopup': hasSubmenuItems(item) || null,
            'aria-owns': item.key === expandedMenuItemKey ? subMenuId : null,
            'aria-expanded': hasSubmenuItems(item) ? item.key === expandedMenuItemKey : null,
            'aria-checked': isChecked,
            'aria-posinset': focusableElementIndex + 1,
            'aria-setsize': totalItemCount,
            'aria-disabled': this._isItemDisabled(item),
            role: item.role || defaultRole,
            style: item.style
        };
        return (React.createElement("button", tslib_1.__assign({}, Utilities_1.getNativeProps(item, Utilities_1.buttonProperties), itemButtonProperties, { children: this._renderMenuItemChildren(item, classNames, index, hasCheckmarks, hasIcons) })));
    };
    ContextualMenu.prototype._renderSplitButton = function (item, classNames, index, focusableElementIndex, totalItemCount, hasCheckmarks, hasIcons) {
        return (React.createElement("div", { "aria-labelledby": item.ariaLabel, "aria-disabled": this._isItemDisabled(item), "aria-haspopup": true, "aria-describedby": item.ariaDescription, "aria-checked": item.isChecked || item.checked },
            React.createElement("span", { "aria-hidden": true, className: classNames.splitContainer },
                this._renderSplitPrimaryButton(item, classNames, index, hasCheckmarks, hasIcons),
                this._renderSplitDivider(item),
                this._renderSplitIconButton(item, classNames, index))));
    };
    ContextualMenu.prototype._renderSplitPrimaryButton = function (item, classNames, index, hasCheckmarks, hasIcons) {
        var isChecked = getIsChecked(item);
        var canCheck = isChecked !== null;
        var defaultRole = canCheck ? 'menuitemcheckbox' : 'menuitem';
        var itemProps = {
            key: item.key,
            onClick: this._executeItemClick.bind(this, item),
            disabled: this._isItemDisabled(item) || item.primaryDisabled,
            name: item.name,
            className: classNames.splitPrimary,
            role: item.role || defaultRole,
            canCheck: item.canCheck,
            isChecked: item.isChecked,
            checked: item.checked,
            icon: item.icon,
            iconProps: item.iconProps
        };
        return React.createElement('button', Utilities_1.getNativeProps(itemProps, Utilities_1.buttonProperties), this._renderMenuItemChildren(itemProps, classNames, index, hasCheckmarks, hasIcons));
    };
    ContextualMenu.prototype._renderSplitIconButton = function (item, classNames, index) {
        var _this = this;
        var itemProps = {
            onClick: this._onItemClick.bind(this, item),
            disabled: this._isItemDisabled(item),
            className: classNames.splitMenu,
            subMenuProps: item.subMenuProps,
            submenuIconProps: item.submenuIconProps,
            split: true,
        };
        return React.createElement('button', Utilities_1.assign({}, Utilities_1.getNativeProps(itemProps, Utilities_1.buttonProperties), {
            onKeyDown: this._onItemKeyDown.bind(this, item),
            onMouseEnter: this._onItemMouseEnter.bind(this, item),
            onMouseLeave: this._onMouseItemLeave.bind(this, item),
            onMouseDown: function (ev) { return _this._onItemMouseDown(item, ev); },
            onMouseMove: this._onItemMouseMove.bind(this, item)
        }), this._renderMenuItemChildren(itemProps, classNames, index, false, false));
    };
    ContextualMenu.prototype._renderSplitDivider = function (item) {
        var getDividerClassnames = item.getSplitButtonVerticalDividerClassNames || ContextualMenu_classNames_1.getSplitButtonVerticalDividerClassNames;
        return React.createElement(Divider_1.VerticalDivider, { getClassNames: getDividerClassnames });
    };
    ContextualMenu.prototype._renderMenuItemChildren = function (item, classNames, index, hasCheckmarks, hasIcons) {
        var isItemChecked = getIsChecked(item);
        return (React.createElement("div", { className: item.split ? classNames.linkContentMenu : classNames.linkContent },
            (hasCheckmarks) ? (React.createElement(Icon_1.Icon, { iconName: isItemChecked === true ? 'CheckMark' : '', className: classNames.checkmarkIcon, onClick: this._onItemClick.bind(this, item) })) : (null),
            (hasIcons) ? (this._renderIcon(item, classNames)) : (null),
            item.name ? (React.createElement("span", { className: classNames.label }, item.name)) : null,
            hasSubmenuItems(item) ? (React.createElement(Icon_1.Icon, tslib_1.__assign({ iconName: Utilities_1.getRTL() ? 'ChevronLeft' : 'ChevronRight' }, item.submenuIconProps, { className: classNames.subMenuIcon }))) : (null)));
    };
    ContextualMenu.prototype._getIconProps = function (item) {
        var iconProps = item.iconProps ? item.iconProps : {
            iconName: item.icon
        };
        return iconProps;
    };
    ContextualMenu.prototype._renderIcon = function (item, classNames) {
        // Only present to allow continued use of item.icon which is deprecated.
        var iconProps = this._getIconProps(item);
        return React.createElement(Icon_1.Icon, tslib_1.__assign({}, iconProps, { className: classNames.icon }));
    };
    ContextualMenu.prototype._onKeyDown = function (ev) {
        var submenuCloseKey = Utilities_1.getRTL() ? 39 /* right */ : 37 /* left */;
        if (ev.which === 27 /* escape */
            || (ev.which === submenuCloseKey && this.props.isSubMenu && this.props.arrowDirection === FocusZone_1.FocusZoneDirection.vertical)) {
            // When a user presses escape, we will try to refocus the previous focused element.
            this._isFocusingPreviousElement = true;
            ev.preventDefault();
            ev.stopPropagation();
            this.dismiss(ev);
        }
    };
    ContextualMenu.prototype._onMenuKeyDown = function (ev) {
        if (ev.which === 27 /* escape */) {
            this._isFocusingPreviousElement = true;
            ev.preventDefault();
            ev.stopPropagation();
            this.dismiss(ev);
            return;
        }
        if (!this._host) {
            return;
        }
        var elementToFocus = ev.which === 38 /* up */ ?
            Utilities_1.getLastFocusable(this._host, this._host.lastChild, true) :
            ev.which === 40 /* down */ ?
                Utilities_1.getFirstFocusable(this._host, this._host.firstChild, true) :
                null;
        if (elementToFocus) {
            elementToFocus.focus();
            ev.preventDefault();
            ev.stopPropagation();
        }
    };
    /**
     * Scroll handler for the callout to make sure the mouse events
     * for updating focus are not interacting during scroll
     */
    ContextualMenu.prototype._onScroll = function () {
        var _this = this;
        if (!this._isScrollIdle && this._scrollIdleTimeoutId !== undefined) {
            this._async.clearTimeout(this._scrollIdleTimeoutId);
            this._scrollIdleTimeoutId = undefined;
        }
        else {
            this._isScrollIdle = false;
        }
        this._scrollIdleTimeoutId = this._async.setTimeout(function () { _this._isScrollIdle = true; }, this._scrollIdleDelay);
    };
    ContextualMenu.prototype._onItemMouseEnter = function (item, ev) {
        var _this = this;
        if (!this._isScrollIdle) {
            return;
        }
        var targetElement = ev.currentTarget;
        if (item.key !== this.state.expandedMenuItemKey) {
            if (hasSubmenuItems(item)) {
                this._enterTimerId = this._async.setTimeout(function () { return _this._onItemSubMenuExpand(item, targetElement); }, 500);
            }
            else {
                this._enterTimerId = this._async.setTimeout(function () { return _this._onSubMenuDismiss(ev); }, 500);
            }
        }
        targetElement.focus();
    };
    ContextualMenu.prototype._onItemMouseMove = function (item, ev) {
        var _this = this;
        var targetElement = ev.currentTarget;
        if (!this._isScrollIdle || targetElement === this._targetWindow.document.activeElement) {
            return;
        }
        if (item.key !== this.state.expandedMenuItemKey) {
            if (hasSubmenuItems(item)) {
                this._enterTimerId = this._async.setTimeout(function () { return _this._onItemSubMenuExpand(item, targetElement); }, 500);
            }
            else {
                this._enterTimerId = this._async.setTimeout(function () { return _this._onSubMenuDismiss(ev); }, 500);
            }
        }
        targetElement.focus();
    };
    ContextualMenu.prototype._onMouseItemLeave = function (item, ev) {
        if (!this._isScrollIdle) {
            return;
        }
        if (this._enterTimerId !== undefined) {
            this._async.clearTimeout(this._enterTimerId);
            this._enterTimerId = undefined;
        }
        if (item.key === this.state.expandedMenuItemKey && hasSubmenuItems(item)) {
            return;
        }
        /**
         * IE11 focus() method forces parents to scroll to top of element.
         * Edge and IE expose a setActive() function for focusable divs that
         * sets the page focus but does not scroll the parent element.
         */
        if (this._host.setActive) {
            this._host.setActive();
        }
        else {
            this._host.focus();
        }
    };
    ContextualMenu.prototype._onItemMouseDown = function (item, ev) {
        if (item.onMouseDown) {
            item.onMouseDown(item, ev);
        }
    };
    ContextualMenu.prototype._onItemClick = function (item, ev) {
        var items = getSubmenuItems(item);
        if (!items || !items.length) {
            this._executeItemClick(item, ev);
        }
        else {
            if (item.key === this.state.expandedMenuItemKey) {
                this._onSubMenuDismiss(ev);
            }
            else {
                this._onItemSubMenuExpand(item, ev.currentTarget);
            }
        }
        ev.stopPropagation();
        ev.preventDefault();
    };
    ContextualMenu.prototype._onAnchorClick = function (item, ev) {
        this._executeItemClick(item, ev);
        ev.stopPropagation();
    };
    ContextualMenu.prototype._executeItemClick = function (item, ev) {
        if (item.onClick) {
            item.onClick(ev, item);
        }
        else if (this.props.onItemClick) {
            this.props.onItemClick(ev, item);
        }
        !ev.defaultPrevented && this.dismiss(ev, true);
    };
    ContextualMenu.prototype._onItemKeyDown = function (item, ev) {
        var openKey = Utilities_1.getRTL() ? 37 /* left */ : 39 /* right */;
        if (ev.which === openKey) {
            this._onItemSubMenuExpand(item, ev.currentTarget);
            ev.preventDefault();
        }
    };
    ContextualMenu.prototype._onItemSubMenuExpand = function (item, target) {
        if (this.state.expandedMenuItemKey !== item.key) {
            if (this.state.expandedMenuItemKey) {
                this._onSubMenuDismiss();
            }
            this.setState({
                expandedMenuItemKey: item.key,
                submenuTarget: target
            });
        }
    };
    ContextualMenu.prototype._getSubmenuProps = function () {
        var _a = this.state, submenuTarget = _a.submenuTarget, expandedMenuItemKey = _a.expandedMenuItemKey;
        var item = this._findItemByKey(expandedMenuItemKey);
        var submenuProps = null;
        if (item) {
            submenuProps = {
                items: getSubmenuItems(item),
                target: submenuTarget,
                onDismiss: this._onSubMenuDismiss,
                isSubMenu: true,
                id: this.state.subMenuId,
                shouldFocusOnMount: true,
                directionalHint: Utilities_1.getRTL() ? 8 /* leftTopEdge */ : 11 /* rightTopEdge */,
                className: this.props.className,
                gapSpace: 0,
                isBeakVisible: false
            };
            if (item.subMenuProps) {
                Utilities_1.assign(submenuProps, item.subMenuProps);
            }
        }
        return submenuProps;
    };
    ContextualMenu.prototype._findItemByKey = function (key) {
        var items = this.props.items;
        return this._findItemByKeyFromItems(key, items);
    };
    /**
     * Returns the item that mathes a given key if any.
     * @param key The key of the item to match
     * @param items The items to look for the key
     */
    ContextualMenu.prototype._findItemByKeyFromItems = function (key, items) {
        for (var _i = 0, items_2 = items; _i < items_2.length; _i++) {
            var item = items_2[_i];
            if (item.itemType === ContextualMenu_types_1.ContextualMenuItemType.Section && item.sectionProps) {
                var match = this._findItemByKeyFromItems(key, item.sectionProps.items);
                if (match) {
                    return match;
                }
            }
            else if (item.key && item.key === key) {
                return item;
            }
        }
    };
    ContextualMenu.prototype._onSubMenuDismiss = function (ev, dismissAll) {
        if (dismissAll) {
            this.dismiss(ev, dismissAll);
        }
        else {
            this.setState({
                dismissedMenuItemKey: this.state.expandedMenuItemKey,
                expandedMenuItemKey: undefined,
                submenuTarget: undefined
            });
        }
    };
    ContextualMenu.prototype._setTargetWindowAndElement = function (target) {
        if (target) {
            if (typeof target === 'string') {
                var currentDoc = Utilities_1.getDocument();
                this._target = currentDoc ? currentDoc.querySelector(target) : null;
                this._targetWindow = Utilities_1.getWindow();
            }
            else if (target.stopPropagation) {
                this._targetWindow = Utilities_1.getWindow(target.toElement);
                this._target = target;
            }
            else if (target.x !== undefined && target.y !== undefined) {
                this._targetWindow = Utilities_1.getWindow();
                this._target = target;
            }
            else {
                var targetElement = target;
                this._targetWindow = Utilities_1.getWindow(targetElement);
                this._target = target;
            }
        }
        else {
            this._targetWindow = Utilities_1.getWindow();
        }
    };
    ContextualMenu.prototype._isItemDisabled = function (item) {
        return !!(item.isDisabled || item.disabled);
    };
    // The default ContextualMenu properties have no items and beak, the default submenu direction is right and top.
    ContextualMenu.defaultProps = {
        items: [],
        shouldFocusOnMount: true,
        gapSpace: 0,
        directionalHint: 7 /* bottomAutoEdge */,
        beakWidth: 16,
        arrowDirection: FocusZone_1.FocusZoneDirection.vertical,
        getMenuClassNames: ContextualMenu_classNames_1.getContextualMenuClassNames,
    };
    tslib_1.__decorate([
        Utilities_1.autobind
    ], ContextualMenu.prototype, "dismiss", null);
    tslib_1.__decorate([
        Utilities_1.autobind
    ], ContextualMenu.prototype, "_onKeyDown", null);
    tslib_1.__decorate([
        Utilities_1.autobind
    ], ContextualMenu.prototype, "_onMenuKeyDown", null);
    tslib_1.__decorate([
        Utilities_1.autobind
    ], ContextualMenu.prototype, "_onScroll", null);
    tslib_1.__decorate([
        Utilities_1.autobind
    ], ContextualMenu.prototype, "_onMouseItemLeave", null);
    tslib_1.__decorate([
        Utilities_1.autobind
    ], ContextualMenu.prototype, "_onSubMenuDismiss", null);
    ContextualMenu = ContextualMenu_1 = tslib_1.__decorate([
        Utilities_1.customizable('ContextualMenu', ['theme']),
        withResponsiveMode_1.withResponsiveMode
    ], ContextualMenu);
    return ContextualMenu;
    var ContextualMenu_1;
}(Utilities_1.BaseComponent));
exports.ContextualMenu = ContextualMenu;

},{"../../Callout":78,"../../Divider":80,"../../FocusZone":82,"../../Icon":83,"../../Utilities":87,"../../utilities/decorators/withResponsiveMode":144,"./ContextualMenu.classNames":116,"./ContextualMenu.types":119,"react":"react","tslib":155}],118:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var Styling_1 = require("../../Styling");
var Utilities_1 = require("../../Utilities");
var ContextualMenuItemHeight = '32px';
var getItemHighContrastStyles = Utilities_1.memoizeFunction(function () {
    return {
        selectors: (_a = {},
            _a[Styling_1.HighContrastSelector] = {
                backgroundColor: 'Highlight',
                borderColor: 'Highlight',
                color: 'HighlightText',
                MsHighContrastAdjust: 'none'
            },
            _a),
    };
    var _a;
});
exports.getMenuItemStyles = Utilities_1.memoizeFunction(function (theme) {
    var semanticColors = theme.semanticColors, fonts = theme.fonts;
    var ContextualMenuItemBackgroundHoverColor = semanticColors.menuItemBackgroundHovered;
    var ContextualMenuItemBackgroundSelectedColor = semanticColors.menuItemBackgroundChecked;
    var menuItemStyles = {
        item: [
            fonts.medium,
            {
                color: semanticColors.bodyText,
                position: 'relative',
                boxSizing: 'border-box',
            }
        ],
        divider: {
            display: 'block',
            height: '1px',
            backgroundColor: semanticColors.bodyDivider,
            position: 'relative'
        },
        root: [
            Styling_1.getFocusStyle(theme),
            {
                font: 'inherit',
                color: 'inherit',
                backgroundColor: 'transparent',
                border: 'none',
                width: '100%',
                height: ContextualMenuItemHeight,
                lineHeight: ContextualMenuItemHeight,
                display: 'block',
                cursor: 'pointer',
                padding: '0px 6px',
                textAlign: 'left',
            },
        ],
        rootDisabled: {
            color: semanticColors.disabledBodyText,
            cursor: 'default',
            pointerEvents: 'none',
        },
        rootHovered: tslib_1.__assign({ backgroundColor: ContextualMenuItemBackgroundHoverColor }, getItemHighContrastStyles()),
        rootFocused: tslib_1.__assign({ backgroundColor: ContextualMenuItemBackgroundHoverColor }, getItemHighContrastStyles()),
        rootChecked: tslib_1.__assign({}, getItemHighContrastStyles()),
        rootPressed: tslib_1.__assign({ backgroundColor: ContextualMenuItemBackgroundSelectedColor }, getItemHighContrastStyles()),
        rootExpanded: tslib_1.__assign({ backgroundColor: ContextualMenuItemBackgroundSelectedColor, color: semanticColors.bodyTextChecked }, getItemHighContrastStyles()),
        linkContent: {
            whiteSpace: 'nowrap',
            height: 'inherit',
            display: 'flex',
            alignItems: 'center',
            maxWidth: '100%'
        },
        anchorLink: {
            padding: '0px 6px',
            textRendering: 'auto',
            color: 'inherit',
            letterSpacing: 'normal',
            wordSpacing: 'normal',
            textTransform: 'none',
            textIndent: '0px',
            textShadow: 'none',
            textDecoration: 'none',
            boxSizing: 'border-box'
        },
        label: {
            margin: '0 4px',
            verticalAlign: 'middle',
            display: 'inline-block',
            flexGrow: '1',
            textOverflow: 'ellipsis',
            overflow: 'hidden',
            whiteSpace: 'nowrap'
        },
        icon: {
            display: 'inline-block',
            minHeight: '1px',
            maxHeight: ContextualMenuItemHeight,
            width: '14px',
            margin: '0 4px',
            verticalAlign: 'middle',
            flexShrink: '0',
        },
        iconColor: {
            color: semanticColors.menuIcon,
            selectors: (_a = {},
                _a[Styling_1.HighContrastSelector] = {
                    color: 'HighlightText',
                },
                _a)
        },
        checkmarkIcon: {
            color: semanticColors.bodySubtext,
            selectors: (_b = {},
                _b[Styling_1.HighContrastSelector] = {
                    color: 'HighlightText',
                },
                _b)
        },
        subMenuIcon: {
            height: ContextualMenuItemHeight,
            lineHeight: ContextualMenuItemHeight,
            textAlign: 'center',
            display: 'inline-block',
            verticalAlign: 'middle',
            flexShrink: '0',
            fontSize: Styling_1.FontSizes.mini
        },
        splitButtonFlexContainer: {
            display: 'flex',
            height: ContextualMenuItemHeight,
            flexWrap: 'nowrap',
            justifyContent: 'center',
            alignItems: 'center'
        },
        splitButtonSeparator: {}
    };
    return Styling_1.concatStyleSets(menuItemStyles);
    var _a, _b;
});
exports.getStyles = Utilities_1.memoizeFunction(function (theme) {
    var semanticColors = theme.semanticColors, fonts = theme.fonts;
    var ContextualMenuBackground = semanticColors.bodyBackground;
    var ContextualMenuHeaderColor = semanticColors.menuHeader;
    var styles = {
        root: {
            backgroundColor: ContextualMenuBackground,
            minWidth: '180px',
        },
        container: {},
        list: {
            listStyleType: 'none',
            margin: '0',
            padding: '0',
            lineHeight: '0',
        },
        title: {
            fontSize: '16px',
            paddingRight: '14px',
            paddingLeft: '14px',
            paddingBottom: '5px',
            paddingTop: '5px',
            backgroundColor: theme.palette.neutralLight
        },
        header: [
            fonts.small,
            {
                fontWeight: Styling_1.FontWeights.semibold,
                color: ContextualMenuHeaderColor,
                background: 'none',
                border: 'none',
                height: ContextualMenuItemHeight,
                lineHeight: ContextualMenuItemHeight,
                cursor: 'default',
                padding: '0px 6px',
                userSelect: 'none',
                textAlign: 'left',
            }
        ],
    };
    return Styling_1.concatStyleSets(styles);
});

},{"../../Styling":86,"../../Utilities":87,"tslib":155}],119:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var DirectionalHint_1 = require("../../common/DirectionalHint");
exports.DirectionalHint = DirectionalHint_1.DirectionalHint;
var ContextualMenuItemType;
(function (ContextualMenuItemType) {
    ContextualMenuItemType[ContextualMenuItemType["Normal"] = 0] = "Normal";
    ContextualMenuItemType[ContextualMenuItemType["Divider"] = 1] = "Divider";
    ContextualMenuItemType[ContextualMenuItemType["Header"] = 2] = "Header";
    ContextualMenuItemType[ContextualMenuItemType["Section"] = 3] = "Section";
})(ContextualMenuItemType = exports.ContextualMenuItemType || (exports.ContextualMenuItemType = {}));

},{"../../common/DirectionalHint":88}],120:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
tslib_1.__exportStar(require("./ContextualMenu"), exports);
tslib_1.__exportStar(require("./ContextualMenu.types"), exports);

},{"./ContextualMenu":117,"./ContextualMenu.types":119,"tslib":155}],121:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Utilities_1 = require("../../Utilities");
var Styling_1 = require("../../Styling");
exports.getDividerClassNames = Utilities_1.memoizeFunction(function (theme) {
    return Styling_1.mergeStyleSets({
        wrapper: {
            display: 'inline-flex',
            height: '100%',
            alignItems: 'center'
        },
        divider: {
            width: 1,
            height: '100%',
            backgroundColor: theme.palette.neutralTertiaryAlt
        }
    });
});

},{"../../Styling":86,"../../Utilities":87}],122:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var React = require("react");
var VerticalDivider_classNames_1 = require("./VerticalDivider.classNames");
var Styling_1 = require("../../Styling");
exports.VerticalDivider = function (props) {
    var theme = Styling_1.getTheme();
    var classNames = props.getClassNames ? props.getClassNames(theme) : VerticalDivider_classNames_1.getDividerClassNames(theme);
    return (React.createElement("span", { className: classNames.wrapper },
        React.createElement("span", { className: classNames.divider })));
};

},{"../../Styling":86,"./VerticalDivider.classNames":121,"react":"react"}],123:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
tslib_1.__exportStar(require("./VerticalDivider"), exports);

},{"./VerticalDivider":122,"tslib":155}],124:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Utilities_1 = require("../../Utilities");
var Styling_1 = require("../../Styling");
var inheritFont = { fontFamily: 'inherit' };
exports.getClassNames = Utilities_1.memoizeFunction(function (theme, className, isFocusVisible) {
    return {
        root: Styling_1.mergeStyles([
            'ms-Fabric',
            isFocusVisible && 'is-focusVisible',
            className,
            theme.fonts.medium,
            {
                color: theme.palette.neutralPrimary,
                selectors: {
                    '& button': inheritFont,
                    '& input': inheritFont,
                    '& textarea': inheritFont
                }
            }
        ])
    };
});

},{"../../Styling":86,"../../Utilities":87}],125:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var React = require("react");
var Utilities_1 = require("../../Utilities");
var Fabric_classNames_1 = require("./Fabric.classNames");
var DIRECTIONAL_KEY_CODES = [
    38 /* up */,
    40 /* down */,
    37 /* left */,
    39 /* right */,
    36 /* home */,
    35 /* end */,
    9 /* tab */,
    33 /* pageUp */,
    34 /* pageDown */
];
// We will track the last focus visibility state so that if we tear down and recreate
// the Fabric component, we will use the last known value as the default.
var _lastIsFocusVisible = false;
// Ensure that the HTML element has a dir specified. This helps to ensure RTL/LTR macros in css for all components will work.
if (typeof (document) === 'object' && document.documentElement && !document.documentElement.getAttribute('dir')) {
    document.documentElement.setAttribute('dir', 'ltr');
}
var Fabric = /** @class */ (function (_super) {
    tslib_1.__extends(Fabric, _super);
    function Fabric(props) {
        var _this = _super.call(this, props) || this;
        _this.state = {
            isFocusVisible: _lastIsFocusVisible
        };
        return _this;
    }
    Fabric.prototype.componentDidMount = function () {
        this._events.on(document.body, 'mousedown', this._onMouseDown, true);
        this._events.on(document.body, 'keydown', this._onKeyDown, true);
    };
    Fabric.prototype.render = function () {
        var isFocusVisible = this.state.isFocusVisible;
        var className = this.props.className;
        var classNames = Fabric_classNames_1.getClassNames(this.props.theme, className, isFocusVisible);
        var divProps = Utilities_1.getNativeProps(this.props, Utilities_1.divProperties);
        return (React.createElement("div", tslib_1.__assign({}, divProps, { className: classNames.root, ref: this._resolveRef('_root') })));
    };
    Fabric.prototype._onMouseDown = function () {
        if (this.state.isFocusVisible) {
            this.setState({
                isFocusVisible: false
            });
            _lastIsFocusVisible = false;
        }
    };
    Fabric.prototype._onKeyDown = function (ev) {
        if (!this.state.isFocusVisible && DIRECTIONAL_KEY_CODES.indexOf(ev.which) > -1) {
            this.setState({
                isFocusVisible: true
            });
            _lastIsFocusVisible = true;
        }
    };
    Fabric = tslib_1.__decorate([
        Utilities_1.customizable('Fabric', ['theme'])
    ], Fabric);
    return Fabric;
}(Utilities_1.BaseComponent));
exports.Fabric = Fabric;

},{"../../Utilities":87,"./Fabric.classNames":124,"react":"react","tslib":155}],126:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
tslib_1.__exportStar(require("./Fabric"), exports);

},{"./Fabric":125,"tslib":155}],127:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var React = require("react");
var FocusZone_types_1 = require("./FocusZone.types");
var Utilities_1 = require("../../Utilities");
var IS_FOCUSABLE_ATTRIBUTE = 'data-is-focusable';
var IS_ENTER_DISABLED_ATTRIBUTE = 'data-disable-click-on-enter';
var FOCUSZONE_ID_ATTRIBUTE = 'data-focuszone-id';
var TABINDEX = 'tabindex';
var _allInstances = {};
var ALLOWED_INPUT_TYPES = ['text', 'number', 'password', 'email', 'tel', 'url', 'search'];
var ALLOW_VIRTUAL_ELEMENTS = false;
var FocusZone = /** @class */ (function (_super) {
    tslib_1.__extends(FocusZone, _super);
    function FocusZone(props) {
        var _this = _super.call(this, props) || this;
        _this._warnDeprecations({ rootProps: undefined });
        _this._id = Utilities_1.getId('FocusZone');
        _this._focusAlignment = {
            left: 0,
            top: 0
        };
        return _this;
    }
    FocusZone.prototype.componentDidMount = function () {
        _allInstances[this._id] = this;
        if (this._root) {
            var windowElement = this._root.ownerDocument.defaultView;
            var parentElement = Utilities_1.getParent(this._root, ALLOW_VIRTUAL_ELEMENTS);
            while (parentElement &&
                parentElement !== document.body &&
                parentElement.nodeType === 1) {
                if (Utilities_1.isElementFocusZone(parentElement)) {
                    this._isInnerZone = true;
                    break;
                }
                parentElement = Utilities_1.getParent(parentElement, ALLOW_VIRTUAL_ELEMENTS);
            }
            if (!this._isInnerZone) {
                this._events.on(windowElement, 'keydown', this._onKeyDownCapture, true);
            }
            // Assign initial tab indexes so that we can set initial focus as appropriate.
            this._updateTabIndexes();
            if (this.props.defaultActiveElement) {
                this._activeElement = Utilities_1.getDocument().querySelector(this.props.defaultActiveElement);
                this.focus();
            }
        }
    };
    FocusZone.prototype.componentWillUnmount = function () {
        delete _allInstances[this._id];
    };
    FocusZone.prototype.render = function () {
        var _a = this.props, rootProps = _a.rootProps, ariaDescribedBy = _a.ariaDescribedBy, ariaLabelledBy = _a.ariaLabelledBy, className = _a.className;
        var divProps = Utilities_1.getNativeProps(this.props, Utilities_1.divProperties);
        var Tag = this.props.elementType || 'div';
        return (React.createElement(Tag, tslib_1.__assign({ role: 'presentation' }, divProps, rootProps, { className: Utilities_1.css('ms-FocusZone', className), ref: this._resolveRef('_root'), "data-focuszone-id": this._id, "aria-labelledby": ariaLabelledBy, "aria-describedby": ariaDescribedBy, onKeyDown: this._onKeyDown, onFocus: this._onFocus, onMouseDownCapture: this._onMouseDown }), this.props.children));
    };
    /**
     * Sets focus to the first tabbable item in the zone.
     * @returns True if focus could be set to an active element, false if no operation was taken.
     */
    FocusZone.prototype.focus = function (forceIntoFirstElement) {
        if (forceIntoFirstElement === void 0) { forceIntoFirstElement = false; }
        if (this._root) {
            if (!forceIntoFirstElement && this._root.getAttribute(IS_FOCUSABLE_ATTRIBUTE) === 'true' && this._isInnerZone) {
                var ownerZoneElement = this._getOwnerZone(this._root);
                if (ownerZoneElement !== this._root) {
                    var ownerZone = _allInstances[ownerZoneElement.getAttribute(FOCUSZONE_ID_ATTRIBUTE)];
                    return !!ownerZone && ownerZone.focusElement(this._root);
                }
                return false;
            }
            else if (this._activeElement && Utilities_1.elementContains(this._root, this._activeElement)
                && Utilities_1.isElementTabbable(this._activeElement)) {
                this._activeElement.focus();
                return true;
            }
            else {
                var firstChild = this._root.firstChild;
                return this.focusElement(Utilities_1.getNextElement(this._root, firstChild, true));
            }
        }
        return false;
    };
    /**
     * Sets focus to a specific child element within the zone. This can be used in conjunction with
     * onBeforeFocus to created delayed focus scenarios (like animate the scroll position to the correct
     * location and then focus.)
     * @param {HTMLElement} element The child element within the zone to focus.
     * @returns True if focus could be set to an active element, false if no operation was taken.
     */
    FocusZone.prototype.focusElement = function (element) {
        var onBeforeFocus = this.props.onBeforeFocus;
        if (onBeforeFocus && !onBeforeFocus(element)) {
            return false;
        }
        if (element) {
            this._setActiveElement(element);
            if (this._activeElement) {
                this._activeElement.focus();
            }
            return true;
        }
        return false;
    };
    FocusZone.prototype._onFocus = function (ev) {
        var onActiveElementChanged = this.props.onActiveElementChanged;
        if (this._isImmediateDescendantOfZone(ev.target)) {
            this._activeElement = ev.target;
            this._setFocusAlignment(this._activeElement);
        }
        else {
            var parentElement = ev.target;
            while (parentElement && parentElement !== this._root) {
                if (Utilities_1.isElementTabbable(parentElement) && this._isImmediateDescendantOfZone(parentElement)) {
                    this._activeElement = parentElement;
                    break;
                }
                parentElement = Utilities_1.getParent(parentElement, ALLOW_VIRTUAL_ELEMENTS);
            }
        }
        if (onActiveElementChanged) {
            onActiveElementChanged(this._activeElement, ev);
        }
    };
    /**
     * Handle global tab presses so that we can patch tabindexes on the fly.
     */
    FocusZone.prototype._onKeyDownCapture = function (ev) {
        if (ev.which === 9 /* tab */) {
            this._updateTabIndexes();
        }
    };
    FocusZone.prototype._onMouseDown = function (ev) {
        var disabled = this.props.disabled;
        if (disabled) {
            return;
        }
        var target = ev.target;
        var path = [];
        while (target && target !== this._root) {
            path.push(target);
            target = Utilities_1.getParent(target, ALLOW_VIRTUAL_ELEMENTS);
        }
        while (path.length) {
            target = path.pop();
            if (target && Utilities_1.isElementTabbable(target)) {
                this._setActiveElement(target);
            }
            if (Utilities_1.isElementFocusZone(target)) {
                // Stop here since the focus zone will take care of its own children.
                break;
            }
        }
    };
    FocusZone.prototype._setActiveElement = function (element) {
        var previousActiveElement = this._activeElement;
        this._activeElement = element;
        if (previousActiveElement) {
            if (Utilities_1.isElementFocusZone(previousActiveElement)) {
                this._updateTabIndexes(previousActiveElement);
            }
            previousActiveElement.tabIndex = -1;
        }
        if (this._activeElement) {
            if (!this._focusAlignment) {
                this._setFocusAlignment(element, true, true);
            }
            this._activeElement.tabIndex = 0;
        }
    };
    /**
     * Handle the keystrokes.
     */
    FocusZone.prototype._onKeyDown = function (ev) {
        var _a = this.props, direction = _a.direction, disabled = _a.disabled, isInnerZoneKeystroke = _a.isInnerZoneKeystroke;
        if (disabled) {
            return;
        }
        if (document.activeElement === this._root && this._isInnerZone) {
            // If this element has focus, it is being controlled by a parent.
            // Ignore the keystroke.
            return;
        }
        if (this.props.onKeyDown) {
            this.props.onKeyDown(ev);
            if (ev.isDefaultPrevented()) {
                return;
            }
        }
        if (isInnerZoneKeystroke &&
            isInnerZoneKeystroke(ev) &&
            this._isImmediateDescendantOfZone(ev.target)) {
            // Try to focus
            var innerZone = this._getFirstInnerZone();
            if (innerZone) {
                if (!innerZone.focus(true)) {
                    return;
                }
            }
            else if (Utilities_1.isElementFocusSubZone(ev.target)) {
                if (!this.focusElement(Utilities_1.getNextElement(ev.target, ev.target.firstChild, true))) {
                    return;
                }
            }
            else {
                return;
            }
        }
        else if (ev.altKey) {
            return;
        }
        else {
            switch (ev.which) {
                case 32 /* space */:
                    if (this._tryInvokeClickForFocusable(ev.target)) {
                        break;
                    }
                    return;
                case 37 /* left */:
                    if (direction !== FocusZone_types_1.FocusZoneDirection.vertical && this._moveFocusLeft()) {
                        break;
                    }
                    return;
                case 39 /* right */:
                    if (direction !== FocusZone_types_1.FocusZoneDirection.vertical && this._moveFocusRight()) {
                        break;
                    }
                    return;
                case 38 /* up */:
                    if (direction !== FocusZone_types_1.FocusZoneDirection.horizontal && this._moveFocusUp()) {
                        break;
                    }
                    return;
                case 40 /* down */:
                    if (direction !== FocusZone_types_1.FocusZoneDirection.horizontal && this._moveFocusDown()) {
                        break;
                    }
                    return;
                case 9 /* tab */:
                    if (this.props.allowTabKey) {
                        if (direction === FocusZone_types_1.FocusZoneDirection.vertical) {
                            if (ev.shiftKey) {
                                this._moveFocusUp();
                            }
                            else {
                                this._moveFocusDown();
                            }
                            break;
                        }
                        else if (direction === FocusZone_types_1.FocusZoneDirection.horizontal || direction === FocusZone_types_1.FocusZoneDirection.bidirectional) {
                            if (ev.shiftKey) {
                                this._moveFocusLeft();
                            }
                            else {
                                this._moveFocusRight();
                            }
                            break;
                        }
                    }
                    return;
                case 36 /* home */:
                    if (this._isElementInput(ev.target) &&
                        !this._shouldInputLoseFocus(ev.target, false)) {
                        return false;
                    }
                    var firstChild = this._root.firstChild;
                    if (this.focusElement(Utilities_1.getNextElement(this._root, firstChild, true))) {
                        break;
                    }
                    return;
                case 35 /* end */:
                    if (this._isElementInput(ev.target) &&
                        !this._shouldInputLoseFocus(ev.target, true)) {
                        return false;
                    }
                    var lastChild = this._root.lastChild;
                    if (this.focusElement(Utilities_1.getPreviousElement(this._root, lastChild, true, true, true))) {
                        break;
                    }
                    return;
                case 13 /* enter */:
                    if (this._tryInvokeClickForFocusable(ev.target)) {
                        break;
                    }
                    return;
                default:
                    return;
            }
        }
        ev.preventDefault();
        ev.stopPropagation();
    };
    /**
     * Walk up the dom try to find a focusable element.
     */
    FocusZone.prototype._tryInvokeClickForFocusable = function (target) {
        if (target === this._root) {
            return false;
        }
        do {
            if (target.tagName === 'BUTTON' || target.tagName === 'A' || target.tagName === 'INPUT' || target.tagName === 'TEXTAREA') {
                return false;
            }
            if (this._isImmediateDescendantOfZone(target) &&
                target.getAttribute(IS_FOCUSABLE_ATTRIBUTE) === 'true' &&
                target.getAttribute(IS_ENTER_DISABLED_ATTRIBUTE) !== 'true') {
                Utilities_1.EventGroup.raise(target, 'click', null, true);
                return true;
            }
            target = Utilities_1.getParent(target, ALLOW_VIRTUAL_ELEMENTS);
        } while (target !== this._root);
        return false;
    };
    /**
     * Traverse to find first child zone.
     */
    FocusZone.prototype._getFirstInnerZone = function (rootElement) {
        rootElement = rootElement || this._activeElement || this._root;
        if (Utilities_1.isElementFocusZone(rootElement)) {
            return _allInstances[rootElement.getAttribute(FOCUSZONE_ID_ATTRIBUTE)];
        }
        var child = rootElement.firstElementChild;
        while (child) {
            if (Utilities_1.isElementFocusZone(child)) {
                return _allInstances[child.getAttribute(FOCUSZONE_ID_ATTRIBUTE)];
            }
            var match = this._getFirstInnerZone(child);
            if (match) {
                return match;
            }
            child = child.nextElementSibling;
        }
        return null;
    };
    FocusZone.prototype._moveFocus = function (isForward, getDistanceFromCenter, ev) {
        var element = this._activeElement;
        var candidateDistance = -1;
        var candidateElement = undefined;
        var changedFocus = false;
        var isBidirectional = this.props.direction === FocusZone_types_1.FocusZoneDirection.bidirectional;
        if (!element) {
            return false;
        }
        if (this._isElementInput(element)) {
            if (!this._shouldInputLoseFocus(element, isForward)) {
                return false;
            }
        }
        var activeRect = isBidirectional ? element.getBoundingClientRect() : null;
        do {
            element = (isForward ?
                Utilities_1.getNextElement(this._root, element) :
                Utilities_1.getPreviousElement(this._root, element));
            if (isBidirectional) {
                if (element) {
                    var targetRect = element.getBoundingClientRect();
                    var elementDistance = getDistanceFromCenter(activeRect, targetRect);
                    if (elementDistance === -1 && candidateDistance === -1) {
                        candidateElement = element;
                        break;
                    }
                    if (elementDistance > -1 && (candidateDistance === -1 || elementDistance < candidateDistance)) {
                        candidateDistance = elementDistance;
                        candidateElement = element;
                    }
                    if (candidateDistance >= 0 && elementDistance < 0) {
                        break;
                    }
                }
            }
            else {
                candidateElement = element;
                break;
            }
        } while (element);
        // Focus the closest candidate
        if (candidateElement && candidateElement !== this._activeElement) {
            changedFocus = true;
            this.focusElement(candidateElement);
        }
        else if (this.props.isCircularNavigation) {
            if (isForward) {
                return this.focusElement(Utilities_1.getNextElement(this._root, this._root.firstElementChild, true));
            }
            else {
                return this.focusElement(Utilities_1.getPreviousElement(this._root, this._root.lastElementChild, true, true, true));
            }
        }
        return changedFocus;
    };
    FocusZone.prototype._moveFocusDown = function () {
        var targetTop = -1;
        var leftAlignment = this._focusAlignment.left;
        if (this._moveFocus(true, function (activeRect, targetRect) {
            var distance = -1;
            // ClientRect values can be floats that differ by very small fractions of a decimal.
            // If the difference between top and bottom are within a pixel then we should treat
            // them as equivalent by using Math.floor. For instance 5.2222 and 5.222221 should be equivalent,
            // but without Math.Floor they will be handled incorrectly.
            var targetRectTop = Math.floor(targetRect.top);
            var activeRectBottom = Math.floor(activeRect.bottom);
            if (targetRectTop < activeRectBottom) {
                return 999999999;
            }
            if ((targetTop === -1 && targetRectTop >= activeRectBottom) ||
                (targetRectTop === targetTop)) {
                targetTop = targetRectTop;
                if (leftAlignment >= targetRect.left && leftAlignment <= (targetRect.left + targetRect.width)) {
                    distance = 0;
                }
                else {
                    distance = Math.abs((targetRect.left + (targetRect.width / 2)) - leftAlignment);
                }
            }
            return distance;
        })) {
            this._setFocusAlignment(this._activeElement, false, true);
            return true;
        }
        return false;
    };
    FocusZone.prototype._moveFocusUp = function () {
        var targetTop = -1;
        var leftAlignment = this._focusAlignment.left;
        if (this._moveFocus(false, function (activeRect, targetRect) {
            var distance = -1;
            // ClientRect values can be floats that differ by very small fractions of a decimal.
            // If the difference between top and bottom are within a pixel then we should treat
            // them as equivalent by using Math.floor. For instance 5.2222 and 5.222221 should be equivalent,
            // but without Math.Floor they will be handled incorrectly.
            var targetRectBottom = Math.floor(targetRect.bottom);
            var targetRectTop = Math.floor(targetRect.top);
            var activeRectTop = Math.floor(activeRect.top);
            if (targetRectBottom > activeRectTop) {
                return 999999999;
            }
            if ((targetTop === -1 && targetRectBottom <= activeRectTop) ||
                (targetRectTop === targetTop)) {
                targetTop = targetRectTop;
                if (leftAlignment >= targetRect.left && leftAlignment <= (targetRect.left + targetRect.width)) {
                    distance = 0;
                }
                else {
                    distance = Math.abs((targetRect.left + (targetRect.width / 2)) - leftAlignment);
                }
            }
            return distance;
        })) {
            this._setFocusAlignment(this._activeElement, false, true);
            return true;
        }
        return false;
    };
    FocusZone.prototype._moveFocusLeft = function () {
        var _this = this;
        if (this._moveFocus(Utilities_1.getRTL(), function (activeRect, targetRect) {
            var distance = -1;
            if (targetRect.bottom > activeRect.top &&
                targetRect.right <= activeRect.right &&
                _this.props.direction !== FocusZone_types_1.FocusZoneDirection.vertical) {
                distance = activeRect.right - targetRect.right;
            }
            return distance;
        })) {
            this._setFocusAlignment(this._activeElement, true, false);
            return true;
        }
        return false;
    };
    FocusZone.prototype._moveFocusRight = function () {
        var _this = this;
        if (this._moveFocus(!Utilities_1.getRTL(), function (activeRect, targetRect) {
            var distance = -1;
            if (targetRect.top < activeRect.bottom &&
                targetRect.left >= activeRect.left &&
                _this.props.direction !== FocusZone_types_1.FocusZoneDirection.vertical) {
                distance = targetRect.left - activeRect.left;
            }
            return distance;
        })) {
            this._setFocusAlignment(this._activeElement, true, false);
            return true;
        }
        return false;
    };
    FocusZone.prototype._setFocusAlignment = function (element, isHorizontal, isVertical) {
        if (this.props.direction === FocusZone_types_1.FocusZoneDirection.bidirectional &&
            (!this._focusAlignment || isHorizontal || isVertical)) {
            var rect = element.getBoundingClientRect();
            var left = rect.left + (rect.width / 2);
            var top_1 = rect.top + (rect.height / 2);
            if (!this._focusAlignment) {
                this._focusAlignment = { left: left, top: top_1 };
            }
            if (isHorizontal) {
                this._focusAlignment.left = left;
            }
            if (isVertical) {
                this._focusAlignment.top = top_1;
            }
        }
    };
    FocusZone.prototype._isImmediateDescendantOfZone = function (element) {
        return this._getOwnerZone(element) === this._root;
    };
    FocusZone.prototype._getOwnerZone = function (element) {
        var parentElement = Utilities_1.getParent(element, ALLOW_VIRTUAL_ELEMENTS);
        while (parentElement && parentElement !== this._root && parentElement !== document.body) {
            if (Utilities_1.isElementFocusZone(parentElement)) {
                return parentElement;
            }
            parentElement = Utilities_1.getParent(parentElement, ALLOW_VIRTUAL_ELEMENTS);
        }
        return this._root;
    };
    FocusZone.prototype._updateTabIndexes = function (element) {
        if (!element) {
            this._defaultFocusElement = null;
            element = this._root;
            if (this._activeElement && !Utilities_1.elementContains(element, this._activeElement)) {
                this._activeElement = null;
            }
        }
        // If active element changes state to disabled, set it to null.
        // Otherwise, we lose keyboard accessibility to other elements in focus zone.
        if (this._activeElement && !Utilities_1.isElementTabbable(this._activeElement)) {
            this._activeElement = null;
        }
        var childNodes = element.children;
        for (var childIndex = 0; childNodes && childIndex < childNodes.length; childIndex++) {
            var child = childNodes[childIndex];
            if (!Utilities_1.isElementFocusZone(child)) {
                // If the item is explicitly set to not be focusable then TABINDEX needs to be set to -1.
                if (child.getAttribute && child.getAttribute(IS_FOCUSABLE_ATTRIBUTE) === 'false') {
                    child.setAttribute(TABINDEX, '-1');
                }
                if (Utilities_1.isElementTabbable(child)) {
                    if (this.props.disabled) {
                        child.setAttribute(TABINDEX, '-1');
                    }
                    else if (!this._isInnerZone && ((!this._activeElement && !this._defaultFocusElement) || this._activeElement === child)) {
                        this._defaultFocusElement = child;
                        if (child.getAttribute(TABINDEX) !== '0') {
                            child.setAttribute(TABINDEX, '0');
                        }
                    }
                    else if (child.getAttribute(TABINDEX) !== '-1') {
                        child.setAttribute(TABINDEX, '-1');
                    }
                }
                else if (child.tagName === 'svg' && child.getAttribute('focusable') !== 'false') {
                    // Disgusting IE hack. Sad face.
                    child.setAttribute('focusable', 'false');
                }
            }
            else if (child.getAttribute(IS_FOCUSABLE_ATTRIBUTE) === 'true') {
                if (!this._isInnerZone && ((!this._activeElement && !this._defaultFocusElement) || this._activeElement === child)) {
                    this._defaultFocusElement = child;
                    if (child.getAttribute(TABINDEX) !== '0') {
                        child.setAttribute(TABINDEX, '0');
                    }
                }
                else if (child.getAttribute(TABINDEX) !== '-1') {
                    child.setAttribute(TABINDEX, '-1');
                }
            }
            this._updateTabIndexes(child);
        }
    };
    FocusZone.prototype._isElementInput = function (element) {
        if (element && element.tagName && (element.tagName.toLowerCase() === 'input' || element.tagName.toLowerCase() === 'textarea')) {
            return true;
        }
        return false;
    };
    FocusZone.prototype._shouldInputLoseFocus = function (element, isForward) {
        if (element &&
            element.type &&
            ALLOWED_INPUT_TYPES.indexOf(element.type.toLowerCase()) > -1) {
            var selectionStart = element.selectionStart;
            var selectionEnd = element.selectionEnd;
            var isRangeSelected = selectionStart !== selectionEnd;
            var inputValue = element.value;
            // We shouldn't lose focus in the following cases:
            // 1. There is range selected.
            // 2. When selection start is larger than 0 and it is backward.
            // 3. when selection start is not the end of lenght and it is forward.
            if (isRangeSelected ||
                (selectionStart > 0 && !isForward) ||
                (selectionStart !== inputValue.length && isForward)) {
                return false;
            }
        }
        return true;
    };
    FocusZone.defaultProps = {
        isCircularNavigation: false,
        direction: FocusZone_types_1.FocusZoneDirection.bidirectional
    };
    tslib_1.__decorate([
        Utilities_1.autobind
    ], FocusZone.prototype, "_onFocus", null);
    tslib_1.__decorate([
        Utilities_1.autobind
    ], FocusZone.prototype, "_onMouseDown", null);
    tslib_1.__decorate([
        Utilities_1.autobind
    ], FocusZone.prototype, "_onKeyDown", null);
    return FocusZone;
}(Utilities_1.BaseComponent));
exports.FocusZone = FocusZone;

},{"../../Utilities":87,"./FocusZone.types":128,"react":"react","tslib":155}],128:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var FocusZoneDirection;
(function (FocusZoneDirection) {
    /** Only react to up/down arrows. */
    FocusZoneDirection[FocusZoneDirection["vertical"] = 0] = "vertical";
    /** Only react to left/right arrows. */
    FocusZoneDirection[FocusZoneDirection["horizontal"] = 1] = "horizontal";
    /** React to all arrows. */
    FocusZoneDirection[FocusZoneDirection["bidirectional"] = 2] = "bidirectional";
})(FocusZoneDirection = exports.FocusZoneDirection || (exports.FocusZoneDirection = {}));

},{}],129:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
tslib_1.__exportStar(require("./FocusZone"), exports);
tslib_1.__exportStar(require("./FocusZone.types"), exports);

},{"./FocusZone":127,"./FocusZone.types":128,"tslib":155}],130:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var Styling_1 = require("../../Styling");
var Utilities_1 = require("../../Utilities");
exports.getClassNames = Utilities_1.memoizeFunction(function (customStyles) {
    return Styling_1.mergeStyleSets({
        root: {
            display: 'inline-block'
        },
        rootHasPlaceHolder: {
            width: '1em'
        },
        imageContainer: {
            overflow: 'hidden'
        }
    }, customStyles);
});

},{"../../Styling":86,"../../Utilities":87}],131:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
/* tslint:disable */
var React = require("react");
/* tslint:enable */
var Icon_types_1 = require("./Icon.types");
var Image_1 = require("../Image/Image");
var Utilities_1 = require("../../Utilities");
var Styling_1 = require("../../Styling");
var Icon_classNames_1 = require("./Icon.classNames");
exports.Icon = function (props) {
    var ariaLabel = props.ariaLabel, className = props.className, styles = props.styles, iconName = props.iconName;
    var classNames = Icon_classNames_1.getClassNames(styles);
    if (props.iconType === Icon_types_1.IconType.image || props.iconType === Icon_types_1.IconType.Image) {
        var containerClassName = Utilities_1.css('ms-Icon', 'ms-Icon-imageContainer', classNames.root, classNames.imageContainer, className);
        return (React.createElement("div", { className: Utilities_1.css(containerClassName, classNames.root) },
            React.createElement(Image_1.Image, tslib_1.__assign({}, props.imageProps))));
    }
    else if (typeof iconName === 'string' && iconName.length === 0) {
        return (React.createElement("i", tslib_1.__assign({ "aria-label": ariaLabel }, (ariaLabel ? {} : {
            role: 'presentation',
            'aria-hidden': true
        }), Utilities_1.getNativeProps(props, Utilities_1.htmlElementProperties), { className: Utilities_1.css('ms-Icon ms-Icon-placeHolder', classNames.rootHasPlaceHolder, props.className) })));
    }
    else {
        var iconDefinition = Styling_1.getIcon(iconName) || {
            subset: {
                className: undefined
            },
            code: undefined
        };
        return (React.createElement("i", tslib_1.__assign({ "aria-label": ariaLabel }, (ariaLabel ? {} : {
            role: 'presentation',
            'aria-hidden': true,
            'data-icon-name': iconName,
        }), Utilities_1.getNativeProps(props, Utilities_1.htmlElementProperties), { className: Utilities_1.css('ms-Icon', // dangerous?
            iconDefinition.subset.className, classNames.root, props.className) }), iconDefinition.code));
    }
};

},{"../../Styling":86,"../../Utilities":87,"../Image/Image":134,"./Icon.classNames":130,"./Icon.types":132,"react":"react","tslib":155}],132:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
// Please keep alphabetized
var IconType;
(function (IconType) {
    /**
     * Render using the fabric icon font.
     */
    IconType[IconType["default"] = 0] = "default";
    /**
     * Render using an image, where imageProps would be used.
     */
    IconType[IconType["image"] = 1] = "image";
    /**
     * Deprecated, use default.
     * @deprecated
     */
    IconType[IconType["Default"] = 100000] = "Default";
    /**
     * Deprecated, use image.
     * @deprecated
     */
    IconType[IconType["Image"] = 100001] = "Image";
})(IconType = exports.IconType || (exports.IconType = {}));

},{}],133:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
tslib_1.__exportStar(require("./Icon"), exports);
tslib_1.__exportStar(require("./Icon.types"), exports);

},{"./Icon":131,"./Icon.types":132,"tslib":155}],134:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
/* tslint:disable:no-unused-variable */
var React = require("react");
/* tslint:enable:no-unused-variable */
var Utilities_1 = require("../../Utilities");
var Image_types_1 = require("./Image.types");
var Styling_1 = require("../../Styling");
var stylesImport = require("./Image.scss");
var styles = stylesImport;
exports.CoverStyleMap = (_a = {},
    _a[Image_types_1.ImageCoverStyle.landscape] = 'ms-Image-image--landscape ' + styles.imageIsLandscape,
    _a[Image_types_1.ImageCoverStyle.portrait] = 'ms-Image-image--portrait ' + styles.imageIsPortrait,
    _a);
exports.ImageFitMap = (_b = {},
    _b[Image_types_1.ImageFit.center] = 'ms-Image-image--center ' + styles.imageIsCenter,
    _b[Image_types_1.ImageFit.contain] = 'ms-Image-image--contain ' + styles.imageIsContain,
    _b[Image_types_1.ImageFit.cover] = 'ms-Image-image--cover ' + styles.imageIsCover,
    _b[Image_types_1.ImageFit.none] = 'ms-Image-image--none ' + styles.imageIsNone,
    _b);
var KEY_PREFIX = 'fabricImage';
var Image = /** @class */ (function (_super) {
    tslib_1.__extends(Image, _super);
    function Image(props) {
        var _this = _super.call(this, props) || this;
        // Make an initial assumption about the image layout until we can
        // check the rendered element. The value here only takes effect when
        // shouldStartVisible is true.
        _this._coverStyle = Image_types_1.ImageCoverStyle.portrait;
        _this.state = {
            loadState: Image_types_1.ImageLoadState.notLoaded
        };
        return _this;
    }
    Image.prototype.componentWillReceiveProps = function (nextProps) {
        if (nextProps.src !== this.props.src) {
            this.setState({
                loadState: Image_types_1.ImageLoadState.notLoaded
            });
        }
        else if (this.state.loadState === Image_types_1.ImageLoadState.loaded) {
            this._computeCoverStyle(nextProps);
        }
    };
    Image.prototype.componentDidUpdate = function (prevProps, prevState) {
        this._checkImageLoaded();
        if (this.props.onLoadingStateChange
            && prevState.loadState !== this.state.loadState) {
            this.props.onLoadingStateChange(this.state.loadState);
        }
    };
    Image.prototype.render = function () {
        var imageProps = Utilities_1.getNativeProps(this.props, Utilities_1.imageProperties, ['width', 'height']);
        var _a = this.props, src = _a.src, alt = _a.alt, width = _a.width, height = _a.height, shouldFadeIn = _a.shouldFadeIn, shouldStartVisible = _a.shouldStartVisible, className = _a.className, imageFit = _a.imageFit, role = _a.role, maximizeFrame = _a.maximizeFrame;
        var loadState = this.state.loadState;
        var coverStyle = this.props.coverStyle !== undefined ? this.props.coverStyle : this._coverStyle;
        var loaded = loadState === Image_types_1.ImageLoadState.loaded || (loadState === Image_types_1.ImageLoadState.notLoaded && this.props.shouldStartVisible);
        // If image dimensions aren't specified, the natural size of the image is used.
        return (React.createElement("div", { className: Utilities_1.css('ms-Image', styles.root, className, (_b = {},
                _b['ms-Image--maximizeFrame ' + styles.rootIsMaximizeFrame] = maximizeFrame,
                _b)), style: { width: width, height: height }, ref: this._resolveRef('_frameElement') },
            React.createElement("img", tslib_1.__assign({}, imageProps, { onLoad: this._onImageLoaded, onError: this._onImageError, key: KEY_PREFIX + this.props.src || '', className: Utilities_1.css('ms-Image-image', styles.image, exports.CoverStyleMap[coverStyle], (imageFit !== undefined) && exports.ImageFitMap[imageFit], !loaded && 'is-notLoaded', loaded && 'is-loaded ' + styles.imageIsLoaded, shouldFadeIn && 'is-fadeIn', loadState === Image_types_1.ImageLoadState.error && 'is-error', loaded && shouldFadeIn && !shouldStartVisible && Styling_1.AnimationClassNames.fadeIn400, (_c = {},
                    _c['ms-Image-image--scaleWidth ' + styles.imageIsScaleWidth] = (imageFit === undefined && !!width && !height),
                    _c['ms-Image-image--scaleHeight ' + styles.imageIsScaleHeight] = (imageFit === undefined && !width && !!height),
                    _c['ms-Image-image--scaleWidthHeight ' + styles.imageIsScaleWidthHeight] = (imageFit === undefined && !!width && !!height),
                    _c)), ref: this._resolveRef('_imageElement'), src: src, alt: alt, role: role }))));
        var _b, _c;
    };
    Image.prototype._onImageLoaded = function (ev) {
        var _a = this.props, src = _a.src, onLoad = _a.onLoad;
        if (onLoad) {
            onLoad(ev);
        }
        this._computeCoverStyle(this.props);
        if (src) {
            this.setState({
                loadState: Image_types_1.ImageLoadState.loaded
            });
        }
    };
    Image.prototype._checkImageLoaded = function () {
        var src = this.props.src;
        var loadState = this.state.loadState;
        if (loadState === Image_types_1.ImageLoadState.notLoaded) {
            // testing if naturalWidth and naturalHeight are greater than zero is better than checking
            // .complete, because .complete will also be set to true if the image breaks. However,
            // for some browsers, SVG images do not have a naturalWidth or naturalHeight, so fall back
            // to checking .complete for these images.
            var isLoaded = src && this._imageElement && (this._imageElement.naturalWidth > 0 && this._imageElement.naturalHeight > 0) ||
                (this._imageElement.complete && Image._svgRegex.test(src));
            if (isLoaded) {
                this._computeCoverStyle(this.props);
                this.setState({
                    loadState: Image_types_1.ImageLoadState.loaded
                });
            }
        }
    };
    Image.prototype._computeCoverStyle = function (props) {
        var imageFit = props.imageFit, width = props.width, height = props.height;
        // Do not compute cover style if it was already specified in props
        if ((imageFit === Image_types_1.ImageFit.cover || imageFit === Image_types_1.ImageFit.contain) &&
            this.props.coverStyle === undefined &&
            this._imageElement) {
            // Determine the desired ratio using the width and height props.
            // If those props aren't available, measure measure the frame.
            var desiredRatio = void 0;
            if (!!width && !!height) {
                desiredRatio = width / height;
            }
            else {
                desiredRatio = this._frameElement.clientWidth / this._frameElement.clientHeight;
            }
            // Examine the source image to determine its original ratio.
            var naturalRatio = this._imageElement.naturalWidth / this._imageElement.naturalHeight;
            // Should we crop from the top or the sides?
            if (naturalRatio > desiredRatio) {
                this._coverStyle = Image_types_1.ImageCoverStyle.landscape;
            }
            else {
                this._coverStyle = Image_types_1.ImageCoverStyle.portrait;
            }
        }
    };
    Image.prototype._onImageError = function (ev) {
        if (this.props.onError) {
            this.props.onError(ev);
        }
        this.setState({
            loadState: Image_types_1.ImageLoadState.error
        });
    };
    Image.defaultProps = {
        shouldFadeIn: true
    };
    Image._svgRegex = /\.svg$/i;
    tslib_1.__decorate([
        Utilities_1.autobind
    ], Image.prototype, "_onImageLoaded", null);
    tslib_1.__decorate([
        Utilities_1.autobind
    ], Image.prototype, "_onImageError", null);
    return Image;
}(Utilities_1.BaseComponent));
exports.Image = Image;
var _a, _b;

},{"../../Styling":86,"../../Utilities":87,"./Image.scss":135,"./Image.types":136,"react":"react","tslib":155}],135:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/* tslint:disable */
var load_themed_styles_1 = require("@microsoft/load-themed-styles");
load_themed_styles_1.loadStyles([{ "rawString": ".root_766ede21{overflow:hidden}.rootIsMaximizeFrame_766ede21{height:100%;width:100%}.image_766ede21{display:block;opacity:0}.image_766ede21.imageIsLoaded_766ede21{opacity:1}.imageIsCenter_766ede21,.imageIsContain_766ede21,.imageIsCover_766ede21{position:relative;top:50%}[dir='ltr'] .imageIsCenter_766ede21,[dir='ltr'] .imageIsContain_766ede21,[dir='ltr'] .imageIsCover_766ede21{left:50%}[dir='rtl'] .imageIsCenter_766ede21,[dir='rtl'] .imageIsContain_766ede21,[dir='rtl'] .imageIsCover_766ede21{right:50%}html[dir='ltr'] .imageIsCenter_766ede21,html[dir='ltr'] .imageIsContain_766ede21,html[dir='ltr'] .imageIsCover_766ede21{-webkit-transform:translate(-50%, -50%);transform:translate(-50%, -50%)}html[dir='rtl'] .imageIsCenter_766ede21,html[dir='rtl'] .imageIsContain_766ede21,html[dir='rtl'] .imageIsCover_766ede21{-webkit-transform:translate(50%, -50%);transform:translate(50%, -50%)}.imageIsContain_766ede21.imageIsLandscape_766ede21{width:100%;height:auto}.imageIsContain_766ede21.imageIsPortrait_766ede21{height:100%;width:auto}.imageIsCover_766ede21.imageIsLandscape_766ede21{height:100%;width:auto}.imageIsCover_766ede21.imageIsPortrait_766ede21{width:100%;height:auto}.imageIsNone_766ede21{height:auto;width:auto}.imageIsScaleWidthHeight_766ede21{height:100%;width:100%}.imageIsScaleWidth_766ede21{height:auto;width:100%}.imageIsScaleHeight_766ede21{height:100%;width:auto}\n" }]);
exports.root = "root_766ede21";
exports.rootIsMaximizeFrame = "rootIsMaximizeFrame_766ede21";
exports.image = "image_766ede21";
exports.imageIsLoaded = "imageIsLoaded_766ede21";
exports.imageIsCenter = "imageIsCenter_766ede21";
exports.imageIsContain = "imageIsContain_766ede21";
exports.imageIsCover = "imageIsCover_766ede21";
exports.imageIsLandscape = "imageIsLandscape_766ede21";
exports.imageIsPortrait = "imageIsPortrait_766ede21";
exports.imageIsNone = "imageIsNone_766ede21";
exports.imageIsScaleWidthHeight = "imageIsScaleWidthHeight_766ede21";
exports.imageIsScaleWidth = "imageIsScaleWidth_766ede21";
exports.imageIsScaleHeight = "imageIsScaleHeight_766ede21";

},{"@microsoft/load-themed-styles":2}],136:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * The possible methods that can be used to fit the image.
 */
var ImageFit;
(function (ImageFit) {
    /**
     * The image is not scaled. The image is centered and cropped within the content box.
     */
    ImageFit[ImageFit["center"] = 0] = "center";
    /**
     * The image is scaled to maintain its aspect ratio while being fully contained within the frame. The image will
     * be centered horizontally and vertically within the frame. The space in the top and bottom or in the sides of
     * the frame will be empty depending on the difference in aspect ratio between the image and the frame.
     */
    ImageFit[ImageFit["contain"] = 1] = "contain";
    /**
     * The image is scaled to maintain its aspect ratio while filling the frame. Portions of the image will be cropped from
     * the top and bottom, or from the sides, depending on the difference in aspect ratio between the image and the frame.
     */
    ImageFit[ImageFit["cover"] = 2] = "cover";
    /**
     * Neither the image nor the frame are scaled. If their sizes do not match, the image will either be cropped or the
     * frame will have empty space.
     */
    ImageFit[ImageFit["none"] = 3] = "none";
})(ImageFit = exports.ImageFit || (exports.ImageFit = {}));
/**
 * The cover style to be used on the image
 */
var ImageCoverStyle;
(function (ImageCoverStyle) {
    /**
     * The image will be shown at 100% height of container and the width will be scaled accordingly
     */
    ImageCoverStyle[ImageCoverStyle["landscape"] = 0] = "landscape";
    /**
     * The image will be shown at 100% width of container and the height will be scaled accordingly
     */
    ImageCoverStyle[ImageCoverStyle["portrait"] = 1] = "portrait";
})(ImageCoverStyle = exports.ImageCoverStyle || (exports.ImageCoverStyle = {}));
var ImageLoadState;
(function (ImageLoadState) {
    /**
     * The image has not yet been loaded, and there is no error yet.
     */
    ImageLoadState[ImageLoadState["notLoaded"] = 0] = "notLoaded";
    /**
     * The image has been loaded successfully.
     */
    ImageLoadState[ImageLoadState["loaded"] = 1] = "loaded";
    /**
     * An error has been encountered while loading the image.
     */
    ImageLoadState[ImageLoadState["error"] = 2] = "error";
    /**
     * Deprecated at v1.3.6, to replace the src in case of errors, use onLoadingStateChange instead
     * and rerender the Image with a difference src.
     * @deprecated
     */
    ImageLoadState[ImageLoadState["errorLoaded"] = 3] = "errorLoaded";
})(ImageLoadState = exports.ImageLoadState || (exports.ImageLoadState = {}));

},{}],137:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
/* tslint:disable:no-unused-variable */
var React = require("react");
var ReactDOM = require("react-dom");
/* tslint:enable:no-unused-variable */
var Fabric_1 = require("../../Fabric");
var Utilities_1 = require("../../Utilities");
var stylesImport = require("./Layer.scss");
var styles = stylesImport;
var _layersByHostId = {};
var _defaultHostSelector;
var Layer = /** @class */ (function (_super) {
    tslib_1.__extends(Layer, _super);
    function Layer(props) {
        var _this = _super.call(this, props) || this;
        _this._warnDeprecations({
            onLayerMounted: 'onLayerDidMount'
        });
        if (_this.props.hostId) {
            if (!_layersByHostId[_this.props.hostId]) {
                _layersByHostId[_this.props.hostId] = [];
            }
            _layersByHostId[_this.props.hostId].push(_this);
        }
        return _this;
    }
    /**
     * Used for notifying applicable Layers that a host is available/unavailable and to re-evaluate Layers that
     * care about the specific host.
     */
    Layer.notifyHostChanged = function (id) {
        if (_layersByHostId[id]) {
            _layersByHostId[id].forEach(function (layer) { return layer.forceUpdate(); });
        }
    };
    /**
     * Sets the default target selector to use when determining the host in which
     * Layered content will be injected into. If not provided, an element will be
     * created at the end of the document body.
     *
     * Passing in a falsey value will clear the default target and reset back to
     * using a created element at the end of document body.
     */
    Layer.setDefaultTarget = function (selector) {
        _defaultHostSelector = selector;
    };
    Layer.prototype.componentDidMount = function () {
        this.componentDidUpdate();
    };
    Layer.prototype.componentWillUnmount = function () {
        var _this = this;
        this._removeLayerElement();
        if (this.props.hostId) {
            _layersByHostId[this.props.hostId] = _layersByHostId[this.props.hostId].filter(function (layer) { return layer !== _this; });
            if (!_layersByHostId[this.props.hostId].length) {
                delete _layersByHostId[this.props.hostId];
            }
        }
    };
    Layer.prototype.componentDidUpdate = function () {
        var _this = this;
        var host = this._getHost();
        if (host !== this._host) {
            this._removeLayerElement();
        }
        if (host) {
            this._host = host;
            if (!this._layerElement) {
                var doc = Utilities_1.getDocument(this._rootElement);
                this._layerElement = doc.createElement('div');
                this._layerElement.className = Utilities_1.css('ms-Layer', (_a = {},
                    _a['ms-Layer--fixed ' + styles.rootIsFixed] = !this.props.hostId,
                    _a));
                host.appendChild(this._layerElement);
                Utilities_1.setVirtualParent(this._layerElement, this._rootElement);
            }
            // Using this 'unstable' method allows us to retain the React context across the layer projection.
            ReactDOM.unstable_renderSubtreeIntoContainer(this, (React.createElement(Fabric_1.Fabric, { className: Utilities_1.css('ms-Layer-content', styles.content) }, this.props.children)), this._layerElement, function () {
                if (!_this._hasMounted) {
                    _this._hasMounted = true;
                    // TODO: @deprecated cleanup required.
                    if (_this.props.onLayerMounted) {
                        _this.props.onLayerMounted();
                    }
                    _this.props.onLayerDidMount();
                }
            });
        }
        var _a;
    };
    Layer.prototype.render = function () {
        return (React.createElement("span", { className: 'ms-Layer', ref: this._resolveRef('_rootElement') }));
    };
    Layer.prototype._removeLayerElement = function () {
        if (this._layerElement) {
            this.props.onLayerWillUnmount();
            ReactDOM.unmountComponentAtNode(this._layerElement);
            var parentNode = this._layerElement.parentNode;
            if (parentNode) {
                parentNode.removeChild(this._layerElement);
            }
            this._layerElement = undefined;
            this._hasMounted = false;
        }
    };
    Layer.prototype._getHost = function () {
        var hostId = this.props.hostId;
        var doc = Utilities_1.getDocument(this._rootElement);
        if (hostId) {
            return doc.getElementById(hostId);
        }
        else {
            return _defaultHostSelector ? doc.querySelector(_defaultHostSelector) : doc.body;
        }
    };
    Layer.defaultProps = {
        onLayerDidMount: function () { return undefined; },
        onLayerWillUnmount: function () { return undefined; }
    };
    return Layer;
}(Utilities_1.BaseComponent));
exports.Layer = Layer;

},{"../../Fabric":81,"../../Utilities":87,"./Layer.scss":138,"react":"react","react-dom":"react-dom","tslib":155}],138:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/* tslint:disable */
var load_themed_styles_1 = require("@microsoft/load-themed-styles");
load_themed_styles_1.loadStyles([{ "rawString": ".rootIsFixed_05e049f6{position:fixed;z-index:1000000;top:0;left:0;width:100vw;height:100vh;visibility:hidden}.content_05e049f6{visibility:visible}\n" }]);
exports.rootIsFixed = "rootIsFixed_05e049f6";
exports.content = "content_05e049f6";

},{"@microsoft/load-themed-styles":2}],139:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var React = require("react");
var Utilities_1 = require("../../Utilities");
var Layer_1 = require("./Layer");
var LayerHost = /** @class */ (function (_super) {
    tslib_1.__extends(LayerHost, _super);
    function LayerHost() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    LayerHost.prototype.shouldComponentUpdate = function () {
        return false;
    };
    LayerHost.prototype.componentDidMount = function () {
        Layer_1.Layer.notifyHostChanged(this.props.id);
    };
    LayerHost.prototype.componentWillUnmount = function () {
        Layer_1.Layer.notifyHostChanged(this.props.id);
    };
    LayerHost.prototype.render = function () {
        return (React.createElement("div", tslib_1.__assign({}, this.props, { className: Utilities_1.css('ms-LayerHost', this.props.className) })));
    };
    return LayerHost;
}(Utilities_1.BaseComponent));
exports.LayerHost = LayerHost;

},{"../../Utilities":87,"./Layer":137,"react":"react","tslib":155}],140:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
tslib_1.__exportStar(require("./Layer"), exports);
tslib_1.__exportStar(require("./LayerHost"), exports);

},{"./Layer":137,"./LayerHost":139,"tslib":155}],141:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var React = require("react");
var Utilities_1 = require("../../Utilities");
/**
 * This adds accessibility to Dialog and Panel controls
 */
var Popup = /** @class */ (function (_super) {
    tslib_1.__extends(Popup, _super);
    function Popup() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    Popup.prototype.componentWillMount = function () {
        this._originalFocusedElement = Utilities_1.getDocument().activeElement;
    };
    Popup.prototype.componentDidMount = function () {
        this._events.on(this.refs.root, 'focus', this._onFocus, true);
        this._events.on(this.refs.root, 'blur', this._onBlur, true);
        if (Utilities_1.doesElementContainFocus(this.refs.root)) {
            this._containsFocus = true;
        }
    };
    Popup.prototype.componentWillUnmount = function () {
        if (this.props.shouldRestoreFocus &&
            this._originalFocusedElement &&
            this._containsFocus &&
            this._originalFocusedElement !== window) {
            // This slight delay is required so that we can unwind the stack, let react try to mess with focus, and then
            // apply the correct focus. Without the setTimeout, we end up focusing the correct thing, and then React wants
            // to reset the focus back to the thing it thinks should have been focused.
            if (this._originalFocusedElement) {
                this._originalFocusedElement.focus();
            }
        }
    };
    Popup.prototype.render = function () {
        var _a = this.props, role = _a.role, className = _a.className, ariaLabel = _a.ariaLabel, ariaLabelledBy = _a.ariaLabelledBy, ariaDescribedBy = _a.ariaDescribedBy;
        return (React.createElement("div", tslib_1.__assign({ ref: 'root' }, Utilities_1.getNativeProps(this.props, Utilities_1.divProperties), { className: className, role: role, "aria-label": ariaLabel, "aria-labelledby": ariaLabelledBy, "aria-describedby": ariaDescribedBy, onKeyDown: this._onKeyDown }), this.props.children));
    };
    Popup.prototype._onKeyDown = function (ev) {
        switch (ev.which) {
            case 27 /* escape */:
                if (this.props.onDismiss) {
                    this.props.onDismiss(ev);
                    ev.preventDefault();
                    ev.stopPropagation();
                }
                break;
        }
    };
    Popup.prototype._onFocus = function () {
        this._containsFocus = true;
    };
    Popup.prototype._onBlur = function () {
        this._containsFocus = false;
    };
    Popup.defaultProps = {
        shouldRestoreFocus: true
    };
    tslib_1.__decorate([
        Utilities_1.autobind
    ], Popup.prototype, "_onKeyDown", null);
    return Popup;
}(Utilities_1.BaseComponent));
exports.Popup = Popup;

},{"../../Utilities":87,"react":"react","tslib":155}],142:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
tslib_1.__exportStar(require("./Popup"), exports);

},{"./Popup":141,"tslib":155}],143:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var Utilities_1 = require("../../Utilities");
var BaseDecorator = /** @class */ (function (_super) {
    tslib_1.__extends(BaseDecorator, _super);
    function BaseDecorator(props) {
        var _this = _super.call(this, props) || this;
        _this._shouldUpdateComponentRef = false;
        _this._updateComposedComponentRef = _this._updateComposedComponentRef.bind(_this);
        return _this;
    }
    /**
     * Updates the ref to the component composed by the decorator, which will also take care of hoisting
     * (and unhoisting as appropriate) methods from said component.
     *
     * Pass this method as the argument to the 'ref' property of the composed component.
     */
    BaseDecorator.prototype._updateComposedComponentRef = function (composedComponentInstance) {
        this._composedComponentInstance = composedComponentInstance;
        if (composedComponentInstance) {
            this._hoisted = Utilities_1.hoistMethods(this, composedComponentInstance);
        }
        else if (this._hoisted) {
            Utilities_1.unhoistMethods(this, this._hoisted);
        }
    };
    return BaseDecorator;
}(Utilities_1.BaseComponent));
exports.BaseDecorator = BaseDecorator;

},{"../../Utilities":87,"tslib":155}],144:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var React = require("react");
var BaseDecorator_1 = require("./BaseDecorator");
var Utilities_1 = require("../../Utilities");
var ResponsiveMode;
(function (ResponsiveMode) {
    ResponsiveMode[ResponsiveMode["small"] = 0] = "small";
    ResponsiveMode[ResponsiveMode["medium"] = 1] = "medium";
    ResponsiveMode[ResponsiveMode["large"] = 2] = "large";
    ResponsiveMode[ResponsiveMode["xLarge"] = 3] = "xLarge";
    ResponsiveMode[ResponsiveMode["xxLarge"] = 4] = "xxLarge";
    ResponsiveMode[ResponsiveMode["xxxLarge"] = 5] = "xxxLarge";
})(ResponsiveMode = exports.ResponsiveMode || (exports.ResponsiveMode = {}));
var RESPONSIVE_MAX_CONSTRAINT = [
    479,
    639,
    1023,
    1365,
    1919,
    99999999
];
var _defaultMode;
/**
 * Allows a server rendered scenario to provide a default responsive mode.
 */
function setResponsiveMode(responsiveMode) {
    _defaultMode = responsiveMode;
}
exports.setResponsiveMode = setResponsiveMode;
function withResponsiveMode(ComposedComponent) {
    return /** @class */ (function (_super) {
        tslib_1.__extends(WithResponsiveMode, _super);
        function WithResponsiveMode(props) {
            var _this = _super.call(this, props) || this;
            _this._updateComposedComponentRef = _this._updateComposedComponentRef.bind(_this);
            _this.state = {
                responsiveMode: _this._getResponsiveMode()
            };
            return _this;
        }
        WithResponsiveMode.prototype.componentDidMount = function () {
            var _this = this;
            this._events.on(window, 'resize', function () {
                var responsiveMode = _this._getResponsiveMode();
                if (responsiveMode !== _this.state.responsiveMode) {
                    _this.setState({
                        responsiveMode: responsiveMode
                    });
                }
            });
        };
        WithResponsiveMode.prototype.componentWillUnmount = function () {
            this._events.dispose();
        };
        WithResponsiveMode.prototype.render = function () {
            var responsiveMode = this.state.responsiveMode;
            return (React.createElement(ComposedComponent, tslib_1.__assign({ ref: this._updateComposedComponentRef, responsiveMode: responsiveMode }, this.props)));
        };
        WithResponsiveMode.prototype._getResponsiveMode = function () {
            var responsiveMode = ResponsiveMode.small;
            var win = Utilities_1.getWindow();
            if (typeof win !== 'undefined') {
                try {
                    while (win.innerWidth > RESPONSIVE_MAX_CONSTRAINT[responsiveMode]) {
                        responsiveMode++;
                    }
                }
                catch (e) {
                    // Return a best effort result in cases where we're in the browser but it throws on getting innerWidth.
                    responsiveMode = ResponsiveMode.large;
                }
            }
            else {
                if (_defaultMode !== undefined) {
                    responsiveMode = _defaultMode;
                }
                else {
                    throw new Error('Content was rendered in a server environment without providing a default responsive mode. ' +
                        'Call setResponsiveMode to define what the responsive mode is.');
                }
            }
            return responsiveMode;
        };
        return WithResponsiveMode;
    }(BaseDecorator_1.BaseDecorator));
}
exports.withResponsiveMode = withResponsiveMode;

},{"../../Utilities":87,"./BaseDecorator":143,"react":"react","tslib":155}],145:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
tslib_1.__exportStar(require("./positioning/index"), exports);

},{"./positioning/index":146,"tslib":155}],146:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
tslib_1.__exportStar(require("./positioning"), exports);
tslib_1.__exportStar(require("./positioning.types"), exports);

},{"./positioning":147,"./positioning.types":148,"tslib":155}],147:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = require("tslib");
var Utilities_1 = require("../../Utilities");
var positioning_types_1 = require("./positioning.types");
var Rectangle = /** @class */ (function (_super) {
    tslib_1.__extends(Rectangle, _super);
    function Rectangle() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return Rectangle;
}(Utilities_1.Rectangle));
exports.Rectangle = Rectangle;
function _createPositionData(targetEdge, alignmentEdge, isAuto) {
    return {
        targetEdge: targetEdge,
        alignmentEdge: alignmentEdge,
        isAuto: isAuto
    };
}
// Currently the beakPercent is set to 50 for all positions meaning that it should tend to the center of the target
var DirectionalDictionary = (_a = {},
    _a[0 /* topLeftEdge */] = _createPositionData(positioning_types_1.RectangleEdge.top, positioning_types_1.RectangleEdge.left),
    _a[1 /* topCenter */] = _createPositionData(positioning_types_1.RectangleEdge.top),
    _a[2 /* topRightEdge */] = _createPositionData(positioning_types_1.RectangleEdge.top, positioning_types_1.RectangleEdge.right),
    _a[3 /* topAutoEdge */] = _createPositionData(positioning_types_1.RectangleEdge.top, undefined, true),
    _a[4 /* bottomLeftEdge */] = _createPositionData(positioning_types_1.RectangleEdge.bottom, positioning_types_1.RectangleEdge.left),
    _a[5 /* bottomCenter */] = _createPositionData(positioning_types_1.RectangleEdge.bottom),
    _a[6 /* bottomRightEdge */] = _createPositionData(positioning_types_1.RectangleEdge.bottom, positioning_types_1.RectangleEdge.right),
    _a[7 /* bottomAutoEdge */] = _createPositionData(positioning_types_1.RectangleEdge.bottom, undefined, true),
    _a[8 /* leftTopEdge */] = _createPositionData(positioning_types_1.RectangleEdge.left, positioning_types_1.RectangleEdge.top),
    _a[9 /* leftCenter */] = _createPositionData(positioning_types_1.RectangleEdge.left),
    _a[10 /* leftBottomEdge */] = _createPositionData(positioning_types_1.RectangleEdge.left, positioning_types_1.RectangleEdge.bottom),
    _a[11 /* rightTopEdge */] = _createPositionData(positioning_types_1.RectangleEdge.right, positioning_types_1.RectangleEdge.top),
    _a[12 /* rightCenter */] = _createPositionData(positioning_types_1.RectangleEdge.right),
    _a[13 /* rightBottomEdge */] = _createPositionData(positioning_types_1.RectangleEdge.right, positioning_types_1.RectangleEdge.bottom),
    _a);
/**
 * @deprecated will be removed in 6.0.
 */
var SLIDE_ANIMATIONS = (_b = {},
    _b[positioning_types_1.RectangleEdge.top] = 'slideUpIn20',
    _b[positioning_types_1.RectangleEdge.bottom] = 'slideDownIn20',
    _b[positioning_types_1.RectangleEdge.left] = 'slideLeftIn20',
    _b[positioning_types_1.RectangleEdge.right] = 'slideRightIn20',
    _b);
/**
 * Do not call methods from this directly, use either positionCallout or positionElement or make another function that
 * utilizes them.
 */
var positioningFunctions;
(function (positioningFunctions) {
    function _isRectangleWithinBounds(rect, boundingRect) {
        if (rect.top < boundingRect.top) {
            return false;
        }
        if (rect.bottom > boundingRect.bottom) {
            return false;
        }
        if (rect.left < boundingRect.left) {
            return false;
        }
        if (rect.right > boundingRect.right) {
            return false;
        }
        return true;
    }
    /**
     * Gets all of the edges of a rectangle that are outside of the given bounds.
     * If there are no out of bounds edges it returns an empty array.
     */
    function _getOutOfBoundsEdges(rect, boundingRect) {
        var outOfBounds = new Array();
        if (rect.top < boundingRect.top) {
            outOfBounds.push(positioning_types_1.RectangleEdge.top);
        }
        if (rect.bottom > boundingRect.bottom) {
            outOfBounds.push(positioning_types_1.RectangleEdge.bottom);
        }
        if (rect.left < boundingRect.left) {
            outOfBounds.push(positioning_types_1.RectangleEdge.left);
        }
        if (rect.right > boundingRect.right) {
            outOfBounds.push(positioning_types_1.RectangleEdge.right);
        }
        return outOfBounds;
    }
    function _getEdgeValue(rect, edge) {
        return rect[positioning_types_1.RectangleEdge[edge]];
    }
    function _setEdgeValue(rect, edge, value) {
        rect[positioning_types_1.RectangleEdge[edge]] = value;
        return rect;
    }
    /**
     * Returns the middle value of an edge. Only returns 1 value rather than xy coordinates as
     * the itself already contains the other coordinate.
     * For instance, a bottom edge's current value is it's y coordinate, so the number returned is the x.
     *
     * @param {Rectangle} rect
     * @param {RectangleEdge} edge
     * @returns {number}
     */
    function _getCenterValue(rect, edge) {
        var edges = _getFlankingEdges(edge);
        return (_getEdgeValue(rect, edges.positiveEdge) + _getEdgeValue(rect, edges.negativeEdge)) / 2;
    }
    /**
     * Flips the value depending on the edge.
     * If the edge is a "positive" edge, Top or Left, then the value should stay as it is.
     * If the edge is a "negative" edge, Bottom or Right, then the value should be flipped.
     * This is to account for the fact that the coordinates are effectively reveserved in certain cases for the "negative" edges.
     * For example, when testing to see if a bottom edge 1 is within the bounds of another bottom edge 2.
     * If edge 1 is greater than edge 2 then it is out of bounds. This is reversed for top edge 1 and top edge 2.
     * If top edge 1 is less than edge 2 then it is out of bounds.
     *
     *
     * @param {RectangleEdge} edge
     * @param {number} value
     * @returns {number}
     */
    function _getRelativeEdgeValue(edge, value) {
        if (edge > 0) {
            return value;
        }
        else {
            return value * -1;
        }
    }
    function _getRelativeRectEdgeValue(edge, rect) {
        return _getRelativeEdgeValue(edge, _getEdgeValue(rect, edge));
    }
    function _getRelativeEdgeDifference(rect, hostRect, edge) {
        var edgeDifference = _getEdgeValue(rect, edge) - _getEdgeValue(hostRect, edge);
        return _getRelativeEdgeValue(edge, edgeDifference);
    }
    /**
     * Moves the edge of a rectangle to the value given. It only moves the edge in a linear direction based on that edge.
     * For example, if it's a bottom edge it will only change y coordinates.
     *
     * @param {Rectangle} rect
     * @param {RectangleEdge} edge
     * @param {number} newValue
     * @returns {Rectangle}
     */
    function _moveEdge(rect, edge, newValue) {
        var difference = _getEdgeValue(rect, edge) - newValue;
        rect = _setEdgeValue(rect, edge, newValue);
        rect = _setEdgeValue(rect, edge * -1, _getEdgeValue(rect, edge * -1) - difference);
        return rect;
    }
    /**
     * Aligns the edge on the passed in rect to the target. If there is a gap then it will have that space between the two.
     *
     * @param {Rectangle} rect
     * @param {Rectangle} target
     * @param {RectangleEdge} edge
     * @param {number} [gap=0]
     * @returns {Rectangle}
     */
    function _alignEdges(rect, target, edge, gap) {
        if (gap === void 0) { gap = 0; }
        return _moveEdge(rect, edge, _getEdgeValue(target, edge) + _getRelativeEdgeValue(edge, gap));
    }
    /**
     * Aligns the targetEdge on the passed in target to the rects corresponding opposite edge.
     * For instance if targetEdge is bottom, then the rects top will be moved to match it.
     *
     * @param {Rectangle} rect
     * @param {Rectangle} target
     * @param {RectangleEdge} targetEdge
     * @param {number} [gap=0]
     * @returns {Rectangle}
     */
    function _alignOppositeEdges(rect, target, targetEdge, gap) {
        if (gap === void 0) { gap = 0; }
        var oppositeEdge = targetEdge * -1;
        var adjustedGap = _getRelativeEdgeValue(oppositeEdge, gap);
        return _moveEdge(rect, targetEdge * -1, _getEdgeValue(target, targetEdge) + adjustedGap);
    }
    /**
     * Tests to see if the given edge is within the bounds of the given rectangle.
     *
     * @param {Rectangle} rect
     * @param {Rectangle} bounds
     * @param {RectangleEdge} edge
     * @returns {boolean}
     */
    function _isEdgeInBounds(rect, bounds, edge) {
        var adjustedRectValue = _getRelativeRectEdgeValue(edge, rect);
        return adjustedRectValue > _getRelativeRectEdgeValue(edge, bounds);
    }
    /**
     * Attempts to move the rectangle through various sides of the target to find a place to fit.
     * If no fit is found, the original position should be returned.
     *
     * @param {Rectangle} rect
     * @param {Rectangle} target
     * @param {Rectangle} bounding
     * @param {IPositionDirectionalHintData} positionData
     * @param {number} [gap=0]
     * @returns {IElementPosition}
     */
    function _flipToFit(rect, target, bounding, positionData, gap) {
        if (gap === void 0) { gap = 0; }
        var directions = [positioning_types_1.RectangleEdge.left, positioning_types_1.RectangleEdge.right, positioning_types_1.RectangleEdge.bottom, positioning_types_1.RectangleEdge.top];
        var currentEstimate = rect;
        var currentEdge = positionData.targetEdge;
        var currentAlignment = positionData.alignmentEdge;
        // Keep switching sides until one is found with enough space. If all sides don't fit then return the unmodified element.
        for (var i = 0; i < 4; i++) {
            if (!_isEdgeInBounds(currentEstimate, bounding, currentEdge)) {
                directions.splice(directions.indexOf(currentEdge), 1);
                if (directions.indexOf(currentEdge * -1) > -1) {
                    currentEdge = currentEdge * -1;
                }
                else {
                    currentAlignment = currentEdge;
                    currentEdge = directions.slice(-1)[0];
                }
                currentEstimate = _estimatePosition(rect, target, { targetEdge: currentEdge, alignmentEdge: currentAlignment }, gap);
            }
            else {
                return {
                    elementRectangle: currentEstimate,
                    targetEdge: currentEdge,
                    alignmentEdge: currentAlignment
                };
            }
        }
        return {
            elementRectangle: rect,
            targetEdge: positionData.targetEdge,
            alignmentEdge: currentAlignment
        };
    }
    /**
     * Adjusts a element rectangle to fit within the bounds given. If directionalHintFixed or covertarget is passed in
     * then the element will not flip sides on the target. They will, however, be nudged to fit within the bounds given.
     *
     * @param {Rectangle} element
     * @param {Rectangle} target
     * @param {Rectangle} bounding
     * @param {IPositionDirectionalHintData} positionData
     * @param {number} [gap=0]
     * @param {boolean} [directionalHintFixed]
     * @param {boolean} [coverTarget]
     * @returns {IElementPosition}
     */
    function _adjustFitWithinBounds(element, target, bounding, positionData, gap, directionalHintFixed, coverTarget) {
        if (gap === void 0) { gap = 0; }
        var alignmentEdge = positionData.alignmentEdge;
        var elementEstimate = {
            elementRectangle: element,
            targetEdge: positionData.targetEdge,
            alignmentEdge: alignmentEdge
        };
        if (!directionalHintFixed && !coverTarget) {
            elementEstimate = _flipToFit(element, target, bounding, positionData, gap);
        }
        var outOfBounds = _getOutOfBoundsEdges(element, bounding);
        for (var _i = 0, outOfBounds_1 = outOfBounds; _i < outOfBounds_1.length; _i++) {
            var direction = outOfBounds_1[_i];
            elementEstimate.elementRectangle = _alignEdges(elementEstimate.elementRectangle, bounding, direction);
        }
        return elementEstimate;
    }
    /**
     * Moves the middle point on an edge to the point given.
     * Only moves in one direction. For instance if a bottom edge is passed in, then
     * the bottom edge will be moved in the x axis to match the point.
     *
     * @param {Rectangle} rect
     * @param {RectangleEdge} edge
     * @param {number} point
     * @returns {Rectangle}
     */
    function _centerEdgeToPoint(rect, edge, point) {
        var positiveEdge = _getFlankingEdges(edge).positiveEdge;
        var elementMiddle = _getCenterValue(rect, edge);
        var distanceToMiddle = elementMiddle - _getEdgeValue(rect, positiveEdge);
        return _moveEdge(rect, positiveEdge, point - distanceToMiddle);
    }
    /**
     * Moves the element rectangle to be appropriately positioned relative to a given target.
     * Does not flip or adjust the element.
     *
     * @param {Rectangle} elementToPosition
     * @param {Rectangle} target
     * @param {IPositionDirectionalHintData} positionData
     * @param {number} [gap=0]
     * @param {boolean} [coverTarget]
     * @returns {Rectangle}
     */
    function _estimatePosition(elementToPosition, target, positionData, gap, coverTarget) {
        if (gap === void 0) { gap = 0; }
        var estimatedElementPosition;
        var alignmentEdge = positionData.alignmentEdge, targetEdge = positionData.targetEdge;
        var elementEdge = coverTarget ? targetEdge : targetEdge * -1;
        estimatedElementPosition = coverTarget ? _alignEdges(elementToPosition, target, targetEdge, gap) :
            _alignOppositeEdges(elementToPosition, target, targetEdge, gap);
        // if no alignment edge is provided it's supposed to be centered.
        if (!alignmentEdge) {
            var targetMiddlePoint = _getCenterValue(target, targetEdge);
            estimatedElementPosition = _centerEdgeToPoint(estimatedElementPosition, elementEdge, targetMiddlePoint);
        }
        else {
            estimatedElementPosition = _alignEdges(estimatedElementPosition, target, alignmentEdge);
        }
        return estimatedElementPosition;
    }
    /**
     * Returns the non-opposite edges of the target edge.
     * For instance if bottom is passed in then left and right will be returned.
     *
     * @param {RectangleEdge} edge
     * @returns {{ firstEdge: RectangleEdge, secondEdge: RectangleEdge }}
     */
    function _getFlankingEdges(edge) {
        if (edge === positioning_types_1.RectangleEdge.top || edge === positioning_types_1.RectangleEdge.bottom) {
            return {
                positiveEdge: positioning_types_1.RectangleEdge.left,
                negativeEdge: positioning_types_1.RectangleEdge.right
            };
        }
        else {
            return {
                positiveEdge: positioning_types_1.RectangleEdge.top,
                negativeEdge: positioning_types_1.RectangleEdge.bottom
            };
        }
    }
    /**
     * Finalizes the element positon based on the hostElement. Only returns the
     * rectangle values to position such that they are anchored to the target.
     * This helps prevent resizing from looking very strange.
     * For instance, if the target edge is top and aligned with the left side then
     * the bottom and left values are returned so as the callou shrinks it shrinks towards that corner.
     *
     * @param {Rectangle} elementRectangle
     * @param {HTMLElement} hostElement
     * @param {RectangleEdge} targetEdge
     * @param {RectangleEdge} [alignmentEdge]
     * @returns {IPartialIRectangle}
     */
    function _finalizeElementPosition(elementRectangle, hostElement, targetEdge, alignmentEdge) {
        var returnValue = {};
        var hostRect = _getRectangleFromHTMLElement(hostElement);
        var elementEdge = targetEdge * -1;
        var elementEdgeString = positioning_types_1.RectangleEdge[elementEdge];
        var returnEdge = alignmentEdge ? alignmentEdge : _getFlankingEdges(targetEdge).positiveEdge;
        returnValue[elementEdgeString] = _getRelativeEdgeDifference(elementRectangle, hostRect, elementEdge);
        returnValue[positioning_types_1.RectangleEdge[returnEdge]] = _getRelativeEdgeDifference(elementRectangle, hostRect, returnEdge);
        return returnValue;
    }
    // Since the beak is rotated 45 degrees the actual height/width is the length of the diagonal.
    // We still want to position the beak based on it's midpoint which does not change. It will
    // be at (beakwidth / 2, beakwidth / 2)
    function _calculateActualBeakWidthInPixels(beakWidth) {
        return Math.sqrt(beakWidth * beakWidth * 2);
    }
    positioningFunctions._calculateActualBeakWidthInPixels = _calculateActualBeakWidthInPixels;
    /**
     * Returns the appropriate IPositionData based on the props altered for RTL.
     * If directionalHintForRTL is passed in that is used if the page is RTL.
     * If a directionalHint is specified and no directionalHintForRTL is available and the page is RTL the hint will be flipped.
     * For instance bottomLeftEdge would become bottomRightEdge.
     * If there is no directionalHint passed in bottomAutoEdge is chosen automatically.
     *
     * @param {IPositionProps} props
     * @returns {IPositionDirectionalHintData}
     */
    function _getPositionData(directionalHint, directionalHintForRTL) {
        if (directionalHint === void 0) { directionalHint = 7 /* bottomAutoEdge */; }
        var positionInformation = tslib_1.__assign({}, DirectionalDictionary[directionalHint]);
        if (Utilities_1.getRTL()) {
            // If alignment edge exists and that alignment edge is -2 or 2, right or left, then flip it.
            positionInformation.alignmentEdge = positionInformation.alignmentEdge && positionInformation.alignmentEdge % 2 === 0
                ? positionInformation.alignmentEdge * -1 : undefined;
            return directionalHintForRTL !== undefined ?
                DirectionalDictionary[directionalHintForRTL] :
                positionInformation;
        }
        return positionInformation;
    }
    positioningFunctions._getPositionData = _getPositionData;
    /**
     * Get's the alignment data for the given information. This only really matters if the positioning is Auto.
     * If it is auto then the alignmentEdge should be chosen based on the target edge's position relative to
     * the center of the page.
     *
     * @param {IPositionDirectionalHintData} positionData
     * @param {Rectangle} target
     * @param {Rectangle} boundingRect
     * @param {boolean} [coverTarget]
     * @returns {IPositionDirectionalHintData}
     */
    function _getAlignmentData(positionData, target, boundingRect, coverTarget) {
        if (positionData.isAuto) {
            positionData.alignmentEdge = getClosestEdge(positionData.targetEdge, target, boundingRect);
        }
        return positionData;
    }
    function getClosestEdge(targetEdge, target, boundingRect) {
        var targetCenter = _getCenterValue(target, targetEdge);
        var boundingCenter = _getCenterValue(boundingRect, targetEdge);
        var _a = _getFlankingEdges(targetEdge), positiveEdge = _a.positiveEdge, negativeEdge = _a.negativeEdge;
        if (targetCenter <= boundingCenter) {
            return positiveEdge;
        }
        else {
            return negativeEdge;
        }
    }
    function _positionElementWithinBounds(elementToPosition, target, bounding, positionData, gap, directionalHintFixed, coverTarget) {
        var estimatedElementPosition = _estimatePosition(elementToPosition, target, positionData, gap, coverTarget);
        if (_isRectangleWithinBounds(estimatedElementPosition, bounding)) {
            return {
                elementRectangle: estimatedElementPosition,
                targetEdge: positionData.targetEdge,
                alignmentEdge: positionData.alignmentEdge
            };
        }
        else {
            return _adjustFitWithinBounds(elementToPosition, target, bounding, positionData, gap, directionalHintFixed, coverTarget);
        }
    }
    positioningFunctions._positionElementWithinBounds = _positionElementWithinBounds;
    function _finalizeBeakPosition(elementPosition, positionedBeak) {
        var targetEdge = elementPosition.targetEdge * -1;
        // The "host" element that we will use to help position the beak.
        var actualElement = new Rectangle(0, elementPosition.elementRectangle.width, 0, elementPosition.elementRectangle.height);
        var returnEdge = elementPosition.alignmentEdge ? elementPosition.alignmentEdge : _getFlankingEdges(targetEdge).positiveEdge;
        var returnValue = {};
        returnValue[positioning_types_1.RectangleEdge[targetEdge]] = _getEdgeValue(positionedBeak, targetEdge);
        returnValue[positioning_types_1.RectangleEdge[returnEdge]] = _getRelativeEdgeDifference(positionedBeak, actualElement, returnEdge);
        return {
            elementPosition: tslib_1.__assign({}, returnValue),
            closestEdge: getClosestEdge(elementPosition.targetEdge, positionedBeak, actualElement),
            targetEdge: targetEdge
        };
    }
    positioningFunctions._finalizeBeakPosition = _finalizeBeakPosition;
    function _positionBeak(beakWidth, elementPosition) {
        var target = elementPosition.targetRectangle;
        /** Note about beak positioning: The actual beak width only matters for getting the gap between the callout and target, it does not impact the beak placement within the callout. For example example, if the beakWidth is 8, then the actual beakWidth is sqrroot(8^2 + 8^2) = 11.31x11.31. So the callout will need to be an extra 3 pixels away from its target. While the beak is being positioned in the callout it still acts as though it were 8x8.*/
        var _a = _getFlankingEdges(elementPosition.targetEdge), positiveEdge = _a.positiveEdge, negativeEdge = _a.negativeEdge;
        var beakTargetPoint = _getCenterValue(target, elementPosition.targetEdge);
        var elementBounds = new Rectangle(beakWidth / 2, elementPosition.elementRectangle.width - beakWidth / 2, beakWidth / 2, elementPosition.elementRectangle.height - beakWidth / 2);
        var beakPositon = new Rectangle(0, beakWidth, 0, beakWidth);
        beakPositon = _moveEdge(beakPositon, (elementPosition.targetEdge * -1), -beakWidth / 2);
        beakPositon = _centerEdgeToPoint(beakPositon, elementPosition.targetEdge * -1, beakTargetPoint - _getRelativeRectEdgeValue(positiveEdge, elementPosition.elementRectangle));
        if (!_isEdgeInBounds(beakPositon, elementBounds, positiveEdge)) {
            beakPositon = _alignEdges(beakPositon, elementBounds, positiveEdge);
        }
        else if (!_isEdgeInBounds(beakPositon, elementBounds, negativeEdge)) {
            beakPositon = _alignEdges(beakPositon, elementBounds, negativeEdge);
        }
        return beakPositon;
    }
    positioningFunctions._positionBeak = _positionBeak;
    function _getRectangleFromHTMLElement(element) {
        var clientRect = element.getBoundingClientRect();
        return new Rectangle(clientRect.left, clientRect.right, clientRect.top, clientRect.bottom);
    }
    positioningFunctions._getRectangleFromHTMLElement = _getRectangleFromHTMLElement;
    function _getRectangleFromIRect(rect) {
        return new Rectangle(rect.left, rect.right, rect.top, rect.bottom);
    }
    positioningFunctions._getRectangleFromIRect = _getRectangleFromIRect;
    function _getTargetRect(bounds, target) {
        var targetRectangle;
        if (target) {
            if (target.preventDefault) {
                var ev = target;
                targetRectangle = new Rectangle(ev.clientX, ev.clientX, ev.clientY, ev.clientY);
            }
            else if (target.x !== undefined) {
                var point = target;
                targetRectangle = new Rectangle(point.x, point.x, point.y, point.y);
            }
            else {
                targetRectangle = _getRectangleFromHTMLElement(target);
            }
            if (!_isRectangleWithinBounds(targetRectangle, bounds)) {
                var outOfBounds = _getOutOfBoundsEdges(targetRectangle, bounds);
                for (var _i = 0, outOfBounds_2 = outOfBounds; _i < outOfBounds_2.length; _i++) {
                    var direction = outOfBounds_2[_i];
                    targetRectangle[positioning_types_1.RectangleEdge[direction]] = bounds[positioning_types_1.RectangleEdge[direction]];
                }
            }
        }
        else {
            targetRectangle = new Rectangle(0, 0, 0, 0);
        }
        return targetRectangle;
    }
    positioningFunctions._getTargetRect = _getTargetRect;
    /**
     * If max height is less than zero it returns the bounds height instead.
     */
    function _getMaxHeightFromTargetRectangle(targetRectangle, targetEdge, gapSpace, bounds) {
        var maxHeight = 0;
        switch (targetEdge) {
            case 7 /* bottomAutoEdge */:
            case 5 /* bottomCenter */:
            case 4 /* bottomLeftEdge */:
            case 6 /* bottomRightEdge */:
                maxHeight = bounds.bottom - targetRectangle.bottom - gapSpace;
                break;
            case 3 /* topAutoEdge */:
            case 1 /* topCenter */:
            case 0 /* topLeftEdge */:
            case 2 /* topRightEdge */:
                maxHeight = targetRectangle.top - bounds.top - gapSpace;
                break;
            default:
                maxHeight = bounds.bottom - targetRectangle.top - gapSpace;
                break;
        }
        return maxHeight > 0 ? maxHeight : bounds.height;
    }
    positioningFunctions._getMaxHeightFromTargetRectangle = _getMaxHeightFromTargetRectangle;
    function _positionElementRelative(props, hostElement, elementToPosition) {
        var gap = props.gapSpace ? props.gapSpace : 0;
        var boundingRect = props.bounds ?
            _getRectangleFromIRect(props.bounds) :
            new Rectangle(0, window.innerWidth - Utilities_1.getScrollbarWidth(), 0, window.innerHeight);
        var targetRect = _getTargetRect(boundingRect, props.target);
        var positionData = _getAlignmentData(_getPositionData(props.directionalHint, props.directionalHintForRTL), targetRect, boundingRect, props.coverTarget);
        var positionedElement = _positionElementWithinBounds(_getRectangleFromHTMLElement(elementToPosition), targetRect, boundingRect, positionData, gap, props.directionalHintFixed, props.coverTarget);
        return tslib_1.__assign({}, positionedElement, { targetRectangle: targetRect });
    }
    positioningFunctions._positionElementRelative = _positionElementRelative;
    function _finalizePositionData(positionedElement, hostElement) {
        var finalizedElement = _finalizeElementPosition(positionedElement.elementRectangle, hostElement, positionedElement.targetEdge, positionedElement.alignmentEdge);
        return {
            elementPosition: finalizedElement,
            targetEdge: positionedElement.targetEdge
        };
    }
    positioningFunctions._finalizePositionData = _finalizePositionData;
    function _positionElement(props, hostElement, elementToPosition) {
        var positionedElement = _positionElementRelative(props, hostElement, elementToPosition);
        return _finalizePositionData(positionedElement, hostElement);
    }
    positioningFunctions._positionElement = _positionElement;
    function _positionCallout(props, hostElement, callout) {
        var beakWidth = !props.isBeakVisible ? 0 : (props.beakWidth || 0);
        var gap = _calculateActualBeakWidthInPixels(beakWidth) / 2 + (props.gapSpace ? props.gapSpace : 0);
        var positionProps = props;
        positionProps.gapSpace = gap;
        var positionedElement = _positionElementRelative(positionProps, hostElement, callout);
        var beakPositioned = _positionBeak(beakWidth, positionedElement);
        var finalizedBeakPosition = _finalizeBeakPosition(positionedElement, beakPositioned);
        return tslib_1.__assign({}, _finalizePositionData(positionedElement, hostElement), { beakPosition: finalizedBeakPosition });
    }
    positioningFunctions._positionCallout = _positionCallout;
    /**
     * @deprecated Do not use, this will be removed in 6.0
     * use either _positionCallout or _positionElement.
     * @export
     * @param {IPositionProps} props
     * @param {HTMLElement} hostElement
     * @param {HTMLElement} elementToPosition
     * @returns
     */
    function _getRelativePositions(props, hostElement, elementToPosition) {
        var positions = _positionCallout(props, hostElement, elementToPosition);
        var beakPosition = positions && positions.beakPosition ? positions.beakPosition.elementPosition : undefined;
        return {
            calloutPosition: positions.elementPosition,
            beakPosition: { position: tslib_1.__assign({}, beakPosition), display: 'block' },
            directionalClassName: SLIDE_ANIMATIONS[positions.targetEdge],
            submenuDirection: (positions.targetEdge * -1) === positioning_types_1.RectangleEdge.right ? 10 /* leftBottomEdge */ : 13 /* rightBottomEdge */
        };
    }
    positioningFunctions._getRelativePositions = _getRelativePositions;
})(positioningFunctions = exports.positioningFunctions || (exports.positioningFunctions = {}));
/**
 * @deprecated Do not use, this will be removed in 6.0.
 * Use either positionElement, or positionCallout
 *
 * @export
 * @param {IPositionProps} props
 * @param {HTMLElement} hostElement
 * @param {HTMLElement} calloutElement
 * @returns
 */
function getRelativePositions(props, hostElement, calloutElement) {
    return positioningFunctions._getRelativePositions(props, hostElement, calloutElement);
}
exports.getRelativePositions = getRelativePositions;
/**
 * Used to position an element relative to the given positioning props.
 *
 * @export
 * @param {IPositionProps} props
 * @param {HTMLElement} hostElement
 * @param {HTMLElement} elementToPosition
 * @returns
 */
function positionElement(props, hostElement, elementToPosition) {
    return positioningFunctions._positionElement(props, hostElement, elementToPosition);
}
exports.positionElement = positionElement;
function positionCallout(props, hostElement, elementToPosition) {
    return positioningFunctions._positionCallout(props, hostElement, elementToPosition);
}
exports.positionCallout = positionCallout;
/**
 * Get's the maximum height that a rectangle can have in order to fit below or above a target.
 * If the directional hint specifies a left or right edge (i.e. leftCenter) it will limit the height to the topBorder
 * of the target given.
 * If no bounds are provided then the window is treated as the bounds.
 */
function getMaxHeight(target, targetEdge, gapSpace, bounds) {
    if (gapSpace === void 0) { gapSpace = 0; }
    var mouseTarget = target;
    var elementTarget = target;
    var pointTarget = target;
    var targetRect;
    var boundingRectangle = bounds ?
        positioningFunctions._getRectangleFromIRect(bounds) :
        new Rectangle(0, window.innerWidth - Utilities_1.getScrollbarWidth(), 0, window.innerHeight);
    if (mouseTarget.stopPropagation) {
        targetRect = new Rectangle(mouseTarget.clientX, mouseTarget.clientX, mouseTarget.clientY, mouseTarget.clientY);
    }
    else if (pointTarget.x !== undefined && pointTarget.y !== undefined) {
        targetRect = new Rectangle(pointTarget.x, pointTarget.x, pointTarget.y, pointTarget.y);
    }
    else {
        targetRect = positioningFunctions._getRectangleFromHTMLElement(elementTarget);
    }
    return positioningFunctions._getMaxHeightFromTargetRectangle(targetRect, targetEdge, gapSpace, boundingRectangle);
}
exports.getMaxHeight = getMaxHeight;
var _a, _b;

},{"../../Utilities":87,"./positioning.types":148,"tslib":155}],148:[function(require,module,exports){
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
var RectangleEdge;
(function (RectangleEdge) {
    RectangleEdge[RectangleEdge["top"] = 1] = "top";
    RectangleEdge[RectangleEdge["bottom"] = -1] = "bottom";
    RectangleEdge[RectangleEdge["left"] = 2] = "left";
    RectangleEdge[RectangleEdge["right"] = -2] = "right";
})(RectangleEdge = exports.RectangleEdge || (exports.RectangleEdge = {}));
var Position;
(function (Position) {
    Position[Position["top"] = 0] = "top";
    Position[Position["bottom"] = 1] = "bottom";
    Position[Position["start"] = 2] = "start";
    Position[Position["end"] = 3] = "end";
})(Position = exports.Position || (exports.Position = {}));

},{}],149:[function(require,module,exports){
// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) { return [] }

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],150:[function(require,module,exports){
(function (process){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

'use strict';

if (process.env.NODE_ENV !== 'production') {
  var invariant = require('fbjs/lib/invariant');
  var warning = require('fbjs/lib/warning');
  var ReactPropTypesSecret = require('./lib/ReactPropTypesSecret');
  var loggedTypeFailures = {};
}

/**
 * Assert that the values match with the type specs.
 * Error messages are memorized and will only be shown once.
 *
 * @param {object} typeSpecs Map of name to a ReactPropType
 * @param {object} values Runtime values that need to be type-checked
 * @param {string} location e.g. "prop", "context", "child context"
 * @param {string} componentName Name of the component for error messages.
 * @param {?Function} getStack Returns the component stack.
 * @private
 */
function checkPropTypes(typeSpecs, values, location, componentName, getStack) {
  if (process.env.NODE_ENV !== 'production') {
    for (var typeSpecName in typeSpecs) {
      if (typeSpecs.hasOwnProperty(typeSpecName)) {
        var error;
        // Prop type validation may throw. In case they do, we don't want to
        // fail the render phase where it didn't fail before. So we log it.
        // After these have been cleaned up, we'll let them throw.
        try {
          // This is intentionally an invariant that gets caught. It's the same
          // behavior as without this statement except with a better message.
          invariant(typeof typeSpecs[typeSpecName] === 'function', '%s: %s type `%s` is invalid; it must be a function, usually from ' + 'the `prop-types` package, but received `%s`.', componentName || 'React class', location, typeSpecName, typeof typeSpecs[typeSpecName]);
          error = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, ReactPropTypesSecret);
        } catch (ex) {
          error = ex;
        }
        warning(!error || error instanceof Error, '%s: type specification of %s `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error);
        if (error instanceof Error && !(error.message in loggedTypeFailures)) {
          // Only monitor this failure once because there tends to be a lot of the
          // same error.
          loggedTypeFailures[error.message] = true;

          var stack = getStack ? getStack() : '';

          warning(false, 'Failed %s type: %s%s', location, error.message, stack != null ? stack : '');
        }
      }
    }
  }
}

module.exports = checkPropTypes;

}).call(this,require('_process'))

},{"./lib/ReactPropTypesSecret":154,"_process":149,"fbjs/lib/invariant":74,"fbjs/lib/warning":75}],151:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

'use strict';

var emptyFunction = require('fbjs/lib/emptyFunction');
var invariant = require('fbjs/lib/invariant');
var ReactPropTypesSecret = require('./lib/ReactPropTypesSecret');

module.exports = function() {
  function shim(props, propName, componentName, location, propFullName, secret) {
    if (secret === ReactPropTypesSecret) {
      // It is still safe when called from React.
      return;
    }
    invariant(
      false,
      'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
      'Use PropTypes.checkPropTypes() to call them. ' +
      'Read more at http://fb.me/use-check-prop-types'
    );
  };
  shim.isRequired = shim;
  function getShim() {
    return shim;
  };
  // Important!
  // Keep this list in sync with production version in `./factoryWithTypeCheckers.js`.
  var ReactPropTypes = {
    array: shim,
    bool: shim,
    func: shim,
    number: shim,
    object: shim,
    string: shim,
    symbol: shim,

    any: shim,
    arrayOf: getShim,
    element: shim,
    instanceOf: getShim,
    node: shim,
    objectOf: getShim,
    oneOf: getShim,
    oneOfType: getShim,
    shape: getShim,
    exact: getShim
  };

  ReactPropTypes.checkPropTypes = emptyFunction;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};

},{"./lib/ReactPropTypesSecret":154,"fbjs/lib/emptyFunction":73,"fbjs/lib/invariant":74}],152:[function(require,module,exports){
(function (process){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

'use strict';

var emptyFunction = require('fbjs/lib/emptyFunction');
var invariant = require('fbjs/lib/invariant');
var warning = require('fbjs/lib/warning');
var assign = require('object-assign');

var ReactPropTypesSecret = require('./lib/ReactPropTypesSecret');
var checkPropTypes = require('./checkPropTypes');

module.exports = function(isValidElement, throwOnDirectAccess) {
  /* global Symbol */
  var ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;
  var FAUX_ITERATOR_SYMBOL = '@@iterator'; // Before Symbol spec.

  /**
   * Returns the iterator method function contained on the iterable object.
   *
   * Be sure to invoke the function with the iterable as context:
   *
   *     var iteratorFn = getIteratorFn(myIterable);
   *     if (iteratorFn) {
   *       var iterator = iteratorFn.call(myIterable);
   *       ...
   *     }
   *
   * @param {?object} maybeIterable
   * @return {?function}
   */
  function getIteratorFn(maybeIterable) {
    var iteratorFn = maybeIterable && (ITERATOR_SYMBOL && maybeIterable[ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL]);
    if (typeof iteratorFn === 'function') {
      return iteratorFn;
    }
  }

  /**
   * Collection of methods that allow declaration and validation of props that are
   * supplied to React components. Example usage:
   *
   *   var Props = require('ReactPropTypes');
   *   var MyArticle = React.createClass({
   *     propTypes: {
   *       // An optional string prop named "description".
   *       description: Props.string,
   *
   *       // A required enum prop named "category".
   *       category: Props.oneOf(['News','Photos']).isRequired,
   *
   *       // A prop named "dialog" that requires an instance of Dialog.
   *       dialog: Props.instanceOf(Dialog).isRequired
   *     },
   *     render: function() { ... }
   *   });
   *
   * A more formal specification of how these methods are used:
   *
   *   type := array|bool|func|object|number|string|oneOf([...])|instanceOf(...)
   *   decl := ReactPropTypes.{type}(.isRequired)?
   *
   * Each and every declaration produces a function with the same signature. This
   * allows the creation of custom validation functions. For example:
   *
   *  var MyLink = React.createClass({
   *    propTypes: {
   *      // An optional string or URI prop named "href".
   *      href: function(props, propName, componentName) {
   *        var propValue = props[propName];
   *        if (propValue != null && typeof propValue !== 'string' &&
   *            !(propValue instanceof URI)) {
   *          return new Error(
   *            'Expected a string or an URI for ' + propName + ' in ' +
   *            componentName
   *          );
   *        }
   *      }
   *    },
   *    render: function() {...}
   *  });
   *
   * @internal
   */

  var ANONYMOUS = '<<anonymous>>';

  // Important!
  // Keep this list in sync with production version in `./factoryWithThrowingShims.js`.
  var ReactPropTypes = {
    array: createPrimitiveTypeChecker('array'),
    bool: createPrimitiveTypeChecker('boolean'),
    func: createPrimitiveTypeChecker('function'),
    number: createPrimitiveTypeChecker('number'),
    object: createPrimitiveTypeChecker('object'),
    string: createPrimitiveTypeChecker('string'),
    symbol: createPrimitiveTypeChecker('symbol'),

    any: createAnyTypeChecker(),
    arrayOf: createArrayOfTypeChecker,
    element: createElementTypeChecker(),
    instanceOf: createInstanceTypeChecker,
    node: createNodeChecker(),
    objectOf: createObjectOfTypeChecker,
    oneOf: createEnumTypeChecker,
    oneOfType: createUnionTypeChecker,
    shape: createShapeTypeChecker,
    exact: createStrictShapeTypeChecker,
  };

  /**
   * inlined Object.is polyfill to avoid requiring consumers ship their own
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
   */
  /*eslint-disable no-self-compare*/
  function is(x, y) {
    // SameValue algorithm
    if (x === y) {
      // Steps 1-5, 7-10
      // Steps 6.b-6.e: +0 != -0
      return x !== 0 || 1 / x === 1 / y;
    } else {
      // Step 6.a: NaN == NaN
      return x !== x && y !== y;
    }
  }
  /*eslint-enable no-self-compare*/

  /**
   * We use an Error-like object for backward compatibility as people may call
   * PropTypes directly and inspect their output. However, we don't use real
   * Errors anymore. We don't inspect their stack anyway, and creating them
   * is prohibitively expensive if they are created too often, such as what
   * happens in oneOfType() for any type before the one that matched.
   */
  function PropTypeError(message) {
    this.message = message;
    this.stack = '';
  }
  // Make `instanceof Error` still work for returned errors.
  PropTypeError.prototype = Error.prototype;

  function createChainableTypeChecker(validate) {
    if (process.env.NODE_ENV !== 'production') {
      var manualPropTypeCallCache = {};
      var manualPropTypeWarningCount = 0;
    }
    function checkType(isRequired, props, propName, componentName, location, propFullName, secret) {
      componentName = componentName || ANONYMOUS;
      propFullName = propFullName || propName;

      if (secret !== ReactPropTypesSecret) {
        if (throwOnDirectAccess) {
          // New behavior only for users of `prop-types` package
          invariant(
            false,
            'Calling PropTypes validators directly is not supported by the `prop-types` package. ' +
            'Use `PropTypes.checkPropTypes()` to call them. ' +
            'Read more at http://fb.me/use-check-prop-types'
          );
        } else if (process.env.NODE_ENV !== 'production' && typeof console !== 'undefined') {
          // Old behavior for people using React.PropTypes
          var cacheKey = componentName + ':' + propName;
          if (
            !manualPropTypeCallCache[cacheKey] &&
            // Avoid spamming the console because they are often not actionable except for lib authors
            manualPropTypeWarningCount < 3
          ) {
            warning(
              false,
              'You are manually calling a React.PropTypes validation ' +
              'function for the `%s` prop on `%s`. This is deprecated ' +
              'and will throw in the standalone `prop-types` package. ' +
              'You may be seeing this warning due to a third-party PropTypes ' +
              'library. See https://fb.me/react-warning-dont-call-proptypes ' + 'for details.',
              propFullName,
              componentName
            );
            manualPropTypeCallCache[cacheKey] = true;
            manualPropTypeWarningCount++;
          }
        }
      }
      if (props[propName] == null) {
        if (isRequired) {
          if (props[propName] === null) {
            return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required ' + ('in `' + componentName + '`, but its value is `null`.'));
          }
          return new PropTypeError('The ' + location + ' `' + propFullName + '` is marked as required in ' + ('`' + componentName + '`, but its value is `undefined`.'));
        }
        return null;
      } else {
        return validate(props, propName, componentName, location, propFullName);
      }
    }

    var chainedCheckType = checkType.bind(null, false);
    chainedCheckType.isRequired = checkType.bind(null, true);

    return chainedCheckType;
  }

  function createPrimitiveTypeChecker(expectedType) {
    function validate(props, propName, componentName, location, propFullName, secret) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== expectedType) {
        // `propValue` being instance of, say, date/regexp, pass the 'object'
        // check, but we can offer a more precise error message here rather than
        // 'of type `object`'.
        var preciseType = getPreciseType(propValue);

        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + preciseType + '` supplied to `' + componentName + '`, expected ') + ('`' + expectedType + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createAnyTypeChecker() {
    return createChainableTypeChecker(emptyFunction.thatReturnsNull);
  }

  function createArrayOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside arrayOf.');
      }
      var propValue = props[propName];
      if (!Array.isArray(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an array.'));
      }
      for (var i = 0; i < propValue.length; i++) {
        var error = typeChecker(propValue, i, componentName, location, propFullName + '[' + i + ']', ReactPropTypesSecret);
        if (error instanceof Error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createElementTypeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      if (!isValidElement(propValue)) {
        var propType = getPropType(propValue);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected a single ReactElement.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createInstanceTypeChecker(expectedClass) {
    function validate(props, propName, componentName, location, propFullName) {
      if (!(props[propName] instanceof expectedClass)) {
        var expectedClassName = expectedClass.name || ANONYMOUS;
        var actualClassName = getClassName(props[propName]);
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + actualClassName + '` supplied to `' + componentName + '`, expected ') + ('instance of `' + expectedClassName + '`.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createEnumTypeChecker(expectedValues) {
    if (!Array.isArray(expectedValues)) {
      process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid argument supplied to oneOf, expected an instance of array.') : void 0;
      return emptyFunction.thatReturnsNull;
    }

    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      for (var i = 0; i < expectedValues.length; i++) {
        if (is(propValue, expectedValues[i])) {
          return null;
        }
      }

      var valuesString = JSON.stringify(expectedValues);
      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of value `' + propValue + '` ' + ('supplied to `' + componentName + '`, expected one of ' + valuesString + '.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createObjectOfTypeChecker(typeChecker) {
    function validate(props, propName, componentName, location, propFullName) {
      if (typeof typeChecker !== 'function') {
        return new PropTypeError('Property `' + propFullName + '` of component `' + componentName + '` has invalid PropType notation inside objectOf.');
      }
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type ' + ('`' + propType + '` supplied to `' + componentName + '`, expected an object.'));
      }
      for (var key in propValue) {
        if (propValue.hasOwnProperty(key)) {
          var error = typeChecker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
          if (error instanceof Error) {
            return error;
          }
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createUnionTypeChecker(arrayOfTypeCheckers) {
    if (!Array.isArray(arrayOfTypeCheckers)) {
      process.env.NODE_ENV !== 'production' ? warning(false, 'Invalid argument supplied to oneOfType, expected an instance of array.') : void 0;
      return emptyFunction.thatReturnsNull;
    }

    for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
      var checker = arrayOfTypeCheckers[i];
      if (typeof checker !== 'function') {
        warning(
          false,
          'Invalid argument supplied to oneOfType. Expected an array of check functions, but ' +
          'received %s at index %s.',
          getPostfixForTypeWarning(checker),
          i
        );
        return emptyFunction.thatReturnsNull;
      }
    }

    function validate(props, propName, componentName, location, propFullName) {
      for (var i = 0; i < arrayOfTypeCheckers.length; i++) {
        var checker = arrayOfTypeCheckers[i];
        if (checker(props, propName, componentName, location, propFullName, ReactPropTypesSecret) == null) {
          return null;
        }
      }

      return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`.'));
    }
    return createChainableTypeChecker(validate);
  }

  function createNodeChecker() {
    function validate(props, propName, componentName, location, propFullName) {
      if (!isNode(props[propName])) {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` supplied to ' + ('`' + componentName + '`, expected a ReactNode.'));
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      for (var key in shapeTypes) {
        var checker = shapeTypes[key];
        if (!checker) {
          continue;
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }
    return createChainableTypeChecker(validate);
  }

  function createStrictShapeTypeChecker(shapeTypes) {
    function validate(props, propName, componentName, location, propFullName) {
      var propValue = props[propName];
      var propType = getPropType(propValue);
      if (propType !== 'object') {
        return new PropTypeError('Invalid ' + location + ' `' + propFullName + '` of type `' + propType + '` ' + ('supplied to `' + componentName + '`, expected `object`.'));
      }
      // We need to check all keys in case some are required but missing from
      // props.
      var allKeys = assign({}, props[propName], shapeTypes);
      for (var key in allKeys) {
        var checker = shapeTypes[key];
        if (!checker) {
          return new PropTypeError(
            'Invalid ' + location + ' `' + propFullName + '` key `' + key + '` supplied to `' + componentName + '`.' +
            '\nBad object: ' + JSON.stringify(props[propName], null, '  ') +
            '\nValid keys: ' +  JSON.stringify(Object.keys(shapeTypes), null, '  ')
          );
        }
        var error = checker(propValue, key, componentName, location, propFullName + '.' + key, ReactPropTypesSecret);
        if (error) {
          return error;
        }
      }
      return null;
    }

    return createChainableTypeChecker(validate);
  }

  function isNode(propValue) {
    switch (typeof propValue) {
      case 'number':
      case 'string':
      case 'undefined':
        return true;
      case 'boolean':
        return !propValue;
      case 'object':
        if (Array.isArray(propValue)) {
          return propValue.every(isNode);
        }
        if (propValue === null || isValidElement(propValue)) {
          return true;
        }

        var iteratorFn = getIteratorFn(propValue);
        if (iteratorFn) {
          var iterator = iteratorFn.call(propValue);
          var step;
          if (iteratorFn !== propValue.entries) {
            while (!(step = iterator.next()).done) {
              if (!isNode(step.value)) {
                return false;
              }
            }
          } else {
            // Iterator will provide entry [k,v] tuples rather than values.
            while (!(step = iterator.next()).done) {
              var entry = step.value;
              if (entry) {
                if (!isNode(entry[1])) {
                  return false;
                }
              }
            }
          }
        } else {
          return false;
        }

        return true;
      default:
        return false;
    }
  }

  function isSymbol(propType, propValue) {
    // Native Symbol.
    if (propType === 'symbol') {
      return true;
    }

    // 19.4.3.5 Symbol.prototype[@@toStringTag] === 'Symbol'
    if (propValue['@@toStringTag'] === 'Symbol') {
      return true;
    }

    // Fallback for non-spec compliant Symbols which are polyfilled.
    if (typeof Symbol === 'function' && propValue instanceof Symbol) {
      return true;
    }

    return false;
  }

  // Equivalent of `typeof` but with special handling for array and regexp.
  function getPropType(propValue) {
    var propType = typeof propValue;
    if (Array.isArray(propValue)) {
      return 'array';
    }
    if (propValue instanceof RegExp) {
      // Old webkits (at least until Android 4.0) return 'function' rather than
      // 'object' for typeof a RegExp. We'll normalize this here so that /bla/
      // passes PropTypes.object.
      return 'object';
    }
    if (isSymbol(propType, propValue)) {
      return 'symbol';
    }
    return propType;
  }

  // This handles more types than `getPropType`. Only used for error messages.
  // See `createPrimitiveTypeChecker`.
  function getPreciseType(propValue) {
    if (typeof propValue === 'undefined' || propValue === null) {
      return '' + propValue;
    }
    var propType = getPropType(propValue);
    if (propType === 'object') {
      if (propValue instanceof Date) {
        return 'date';
      } else if (propValue instanceof RegExp) {
        return 'regexp';
      }
    }
    return propType;
  }

  // Returns a string that is postfixed to a warning about an invalid type.
  // For example, "undefined" or "of type array"
  function getPostfixForTypeWarning(value) {
    var type = getPreciseType(value);
    switch (type) {
      case 'array':
      case 'object':
        return 'an ' + type;
      case 'boolean':
      case 'date':
      case 'regexp':
        return 'a ' + type;
      default:
        return type;
    }
  }

  // Returns class name of the object, if any.
  function getClassName(propValue) {
    if (!propValue.constructor || !propValue.constructor.name) {
      return ANONYMOUS;
    }
    return propValue.constructor.name;
  }

  ReactPropTypes.checkPropTypes = checkPropTypes;
  ReactPropTypes.PropTypes = ReactPropTypes;

  return ReactPropTypes;
};

}).call(this,require('_process'))

},{"./checkPropTypes":150,"./lib/ReactPropTypesSecret":154,"_process":149,"fbjs/lib/emptyFunction":73,"fbjs/lib/invariant":74,"fbjs/lib/warning":75,"object-assign":76}],153:[function(require,module,exports){
(function (process){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

if (process.env.NODE_ENV !== 'production') {
  var REACT_ELEMENT_TYPE = (typeof Symbol === 'function' &&
    Symbol.for &&
    Symbol.for('react.element')) ||
    0xeac7;

  var isValidElement = function(object) {
    return typeof object === 'object' &&
      object !== null &&
      object.$$typeof === REACT_ELEMENT_TYPE;
  };

  // By explicitly using `prop-types` you are opting into new development behavior.
  // http://fb.me/prop-types-in-prod
  var throwOnDirectAccess = true;
  module.exports = require('./factoryWithTypeCheckers')(isValidElement, throwOnDirectAccess);
} else {
  // By explicitly using `prop-types` you are opting into new production behavior.
  // http://fb.me/prop-types-in-prod
  module.exports = require('./factoryWithThrowingShims')();
}

}).call(this,require('_process'))

},{"./factoryWithThrowingShims":151,"./factoryWithTypeCheckers":152,"_process":149}],154:[function(require,module,exports){
/**
 * Copyright (c) 2013-present, Facebook, Inc.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */

'use strict';

var ReactPropTypesSecret = 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED';

module.exports = ReactPropTypesSecret;

},{}],155:[function(require,module,exports){
(function (global){
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global global, define, System, Reflect, Promise */
var __extends;
var __assign;
var __rest;
var __decorate;
var __param;
var __metadata;
var __awaiter;
var __generator;
var __exportStar;
var __values;
var __read;
var __spread;
var __await;
var __asyncGenerator;
var __asyncDelegator;
var __asyncValues;
var __makeTemplateObject;
(function (factory) {
    var root = typeof global === "object" ? global : typeof self === "object" ? self : typeof this === "object" ? this : {};
    if (typeof define === "function" && define.amd) {
        define("tslib", ["exports"], function (exports) { factory(createExporter(root, createExporter(exports))); });
    }
    else if (typeof module === "object" && typeof module.exports === "object") {
        factory(createExporter(root, createExporter(module.exports)));
    }
    else {
        factory(createExporter(root));
    }
    function createExporter(exports, previous) {
        if (exports !== root) {
            if (typeof Object.create === "function") {
                Object.defineProperty(exports, "__esModule", { value: true });
            }
            else {
                exports.__esModule = true;
            }
        }
        return function (id, v) { return exports[id] = previous ? previous(id, v) : v; };
    }
})
(function (exporter) {
    var extendStatics = Object.setPrototypeOf ||
        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
        function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };

    __extends = function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };

    __assign = Object.assign || function (t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
        }
        return t;
    };

    __rest = function (s, e) {
        var t = {};
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
            t[p] = s[p];
        if (s != null && typeof Object.getOwnPropertySymbols === "function")
            for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
                t[p[i]] = s[p[i]];
        return t;
    };

    __decorate = function (decorators, target, key, desc) {
        var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
        if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
        else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
        return c > 3 && r && Object.defineProperty(target, key, r), r;
    };

    __param = function (paramIndex, decorator) {
        return function (target, key) { decorator(target, key, paramIndex); }
    };

    __metadata = function (metadataKey, metadataValue) {
        if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
    };

    __awaiter = function (thisArg, _arguments, P, generator) {
        return new (P || (P = Promise))(function (resolve, reject) {
            function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
            function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
            function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
            step((generator = generator.apply(thisArg, _arguments || [])).next());
        });
    };

    __generator = function (thisArg, body) {
        var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
        return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
        function verb(n) { return function (v) { return step([n, v]); }; }
        function step(op) {
            if (f) throw new TypeError("Generator is already executing.");
            while (_) try {
                if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
                if (y = 0, t) op = [0, t.value];
                switch (op[0]) {
                    case 0: case 1: t = op; break;
                    case 4: _.label++; return { value: op[1], done: false };
                    case 5: _.label++; y = op[1]; op = [0]; continue;
                    case 7: op = _.ops.pop(); _.trys.pop(); continue;
                    default:
                        if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                        if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                        if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                        if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                        if (t[2]) _.ops.pop();
                        _.trys.pop(); continue;
                }
                op = body.call(thisArg, _);
            } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
            if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
        }
    };

    __exportStar = function (m, exports) {
        for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
    };

    __values = function (o) {
        var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
        if (m) return m.call(o);
        return {
            next: function () {
                if (o && i >= o.length) o = void 0;
                return { value: o && o[i++], done: !o };
            }
        };
    };

    __read = function (o, n) {
        var m = typeof Symbol === "function" && o[Symbol.iterator];
        if (!m) return o;
        var i = m.call(o), r, ar = [], e;
        try {
            while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
        }
        catch (error) { e = { error: error }; }
        finally {
            try {
                if (r && !r.done && (m = i["return"])) m.call(i);
            }
            finally { if (e) throw e.error; }
        }
        return ar;
    };

    __spread = function () {
        for (var ar = [], i = 0; i < arguments.length; i++)
            ar = ar.concat(__read(arguments[i]));
        return ar;
    };

    __await = function (v) {
        return this instanceof __await ? (this.v = v, this) : new __await(v);
    };

    __asyncGenerator = function (thisArg, _arguments, generator) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var g = generator.apply(thisArg, _arguments || []), i, q = [];
        return i = {}, verb("next"), verb("throw"), verb("return"), i[Symbol.asyncIterator] = function () { return this; }, i;
        function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }
        function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }
        function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r);  }
        function fulfill(value) { resume("next", value); }
        function reject(value) { resume("throw", value); }
        function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }
    };

    __asyncDelegator = function (o) {
        var i, p;
        return i = {}, verb("next"), verb("throw", function (e) { throw e; }), verb("return"), i[Symbol.iterator] = function () { return this; }, i;
        function verb(n, f) { if (o[n]) i[n] = function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === "return" } : f ? f(v) : v; }; }
    };

    __asyncValues = function (o) {
        if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
        var m = o[Symbol.asyncIterator];
        return m ? m.call(o) : typeof __values === "function" ? __values(o) : o[Symbol.iterator]();
    };

    __makeTemplateObject = function (cooked, raw) {
        if (Object.defineProperty) { Object.defineProperty(cooked, "raw", { value: raw }); } else { cooked.raw = raw; }
        return cooked;
    };

    exporter("__extends", __extends);
    exporter("__assign", __assign);
    exporter("__rest", __rest);
    exporter("__decorate", __decorate);
    exporter("__param", __param);
    exporter("__metadata", __metadata);
    exporter("__awaiter", __awaiter);
    exporter("__generator", __generator);
    exporter("__exportStar", __exportStar);
    exporter("__values", __values);
    exporter("__read", __read);
    exporter("__spread", __spread);
    exporter("__await", __await);
    exporter("__asyncGenerator", __asyncGenerator);
    exporter("__asyncDelegator", __asyncDelegator);
    exporter("__asyncValues", __asyncValues);
    exporter("__makeTemplateObject", __makeTemplateObject);
});

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}]},{},[1])
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJSZWFjdFxcb2ZmaWNlLWZhYnJpYy11aS5qcyIsIm5vZGVfbW9kdWxlcy9AbWljcm9zb2Z0L2xvYWQtdGhlbWVkLXN0eWxlcy9saWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQHVpZmFicmljL21lcmdlLXN0eWxlcy9saWIvU3R5bGVzaGVldC5qcyIsIm5vZGVfbW9kdWxlcy9AdWlmYWJyaWMvbWVyZ2Utc3R5bGVzL2xpYi9jb25jYXRTdHlsZVNldHMuanMiLCJub2RlX21vZHVsZXMvQHVpZmFicmljL21lcmdlLXN0eWxlcy9saWIvZXh0cmFjdFN0eWxlUGFydHMuanMiLCJub2RlX21vZHVsZXMvQHVpZmFicmljL21lcmdlLXN0eWxlcy9saWIvZm9udEZhY2UuanMiLCJub2RlX21vZHVsZXMvQHVpZmFicmljL21lcmdlLXN0eWxlcy9saWIvZ2V0VmVuZG9yU2V0dGluZ3MuanMiLCJub2RlX21vZHVsZXMvQHVpZmFicmljL21lcmdlLXN0eWxlcy9saWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQHVpZmFicmljL21lcmdlLXN0eWxlcy9saWIva2V5ZnJhbWVzLmpzIiwibm9kZV9tb2R1bGVzL0B1aWZhYnJpYy9tZXJnZS1zdHlsZXMvbGliL21lcmdlU3R5bGVTZXRzLmpzIiwibm9kZV9tb2R1bGVzL0B1aWZhYnJpYy9tZXJnZS1zdHlsZXMvbGliL21lcmdlU3R5bGVzLmpzIiwibm9kZV9tb2R1bGVzL0B1aWZhYnJpYy9tZXJnZS1zdHlsZXMvbGliL3N0eWxlVG9DbGFzc05hbWUuanMiLCJub2RlX21vZHVsZXMvQHVpZmFicmljL21lcmdlLXN0eWxlcy9saWIvdHJhbnNmb3Jtcy9rZWJhYlJ1bGVzLmpzIiwibm9kZV9tb2R1bGVzL0B1aWZhYnJpYy9tZXJnZS1zdHlsZXMvbGliL3RyYW5zZm9ybXMvcHJlZml4UnVsZXMuanMiLCJub2RlX21vZHVsZXMvQHVpZmFicmljL21lcmdlLXN0eWxlcy9saWIvdHJhbnNmb3Jtcy9wcm92aWRlVW5pdHMuanMiLCJub2RlX21vZHVsZXMvQHVpZmFicmljL21lcmdlLXN0eWxlcy9saWIvdHJhbnNmb3Jtcy9ydGxpZnlSdWxlcy5qcyIsIm5vZGVfbW9kdWxlcy9AdWlmYWJyaWMvc3R5bGluZy9saWIvTWVyZ2VTdHlsZXMuanMiLCJub2RlX21vZHVsZXMvQHVpZmFicmljL3N0eWxpbmcvbGliL2NsYXNzTmFtZXMvQW5pbWF0aW9uQ2xhc3NOYW1lcy5qcyIsIm5vZGVfbW9kdWxlcy9AdWlmYWJyaWMvc3R5bGluZy9saWIvY2xhc3NOYW1lcy9Db2xvckNsYXNzTmFtZXMuanMiLCJub2RlX21vZHVsZXMvQHVpZmFicmljL3N0eWxpbmcvbGliL2NsYXNzTmFtZXMvRm9udENsYXNzTmFtZXMuanMiLCJub2RlX21vZHVsZXMvQHVpZmFicmljL3N0eWxpbmcvbGliL2NsYXNzTmFtZXMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQHVpZmFicmljL3N0eWxpbmcvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0B1aWZhYnJpYy9zdHlsaW5nL2xpYi9zdHlsZXMvQW5pbWF0aW9uU3R5bGVzLmpzIiwibm9kZV9tb2R1bGVzL0B1aWZhYnJpYy9zdHlsaW5nL2xpYi9zdHlsZXMvQ29tbW9uU3R5bGVzLmpzIiwibm9kZV9tb2R1bGVzL0B1aWZhYnJpYy9zdHlsaW5nL2xpYi9zdHlsZXMvRGVmYXVsdEZvbnRTdHlsZXMuanMiLCJub2RlX21vZHVsZXMvQHVpZmFicmljL3N0eWxpbmcvbGliL3N0eWxlcy9EZWZhdWx0UGFsZXR0ZS5qcyIsIm5vZGVfbW9kdWxlcy9AdWlmYWJyaWMvc3R5bGluZy9saWIvc3R5bGVzL2ZvbnRzLmpzIiwibm9kZV9tb2R1bGVzL0B1aWZhYnJpYy9zdHlsaW5nL2xpYi9zdHlsZXMvZ2V0Rm9jdXNTdHlsZS5qcyIsIm5vZGVfbW9kdWxlcy9AdWlmYWJyaWMvc3R5bGluZy9saWIvc3R5bGVzL2hpZGRlbkNvbnRlbnRTdHlsZS5qcyIsIm5vZGVfbW9kdWxlcy9AdWlmYWJyaWMvc3R5bGluZy9saWIvc3R5bGVzL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL0B1aWZhYnJpYy9zdHlsaW5nL2xpYi9zdHlsZXMvdGhlbWUuanMiLCJub2RlX21vZHVsZXMvQHVpZmFicmljL3N0eWxpbmcvbGliL3V0aWxpdGllcy9idWlsZENsYXNzTWFwLmpzIiwibm9kZV9tb2R1bGVzL0B1aWZhYnJpYy9zdHlsaW5nL2xpYi91dGlsaXRpZXMvZ2V0SWNvbkNsYXNzTmFtZS5qcyIsIm5vZGVfbW9kdWxlcy9AdWlmYWJyaWMvc3R5bGluZy9saWIvdXRpbGl0aWVzL2ljb25zLmpzIiwibm9kZV9tb2R1bGVzL0B1aWZhYnJpYy9zdHlsaW5nL2xpYi91dGlsaXRpZXMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQHVpZmFicmljL3V0aWxpdGllcy9saWIvQXN5bmMuanMiLCJub2RlX21vZHVsZXMvQHVpZmFicmljL3V0aWxpdGllcy9saWIvQXV0b1Njcm9sbC5qcyIsIm5vZGVfbW9kdWxlcy9AdWlmYWJyaWMvdXRpbGl0aWVzL2xpYi9CYXNlQ29tcG9uZW50LmpzIiwibm9kZV9tb2R1bGVzL0B1aWZhYnJpYy91dGlsaXRpZXMvbGliL0N1c3RvbWl6YXRpb25zLmpzIiwibm9kZV9tb2R1bGVzL0B1aWZhYnJpYy91dGlsaXRpZXMvbGliL0N1c3RvbWl6ZXIuanMiLCJub2RlX21vZHVsZXMvQHVpZmFicmljL3V0aWxpdGllcy9saWIvRGVsYXllZFJlbmRlci5qcyIsIm5vZGVfbW9kdWxlcy9AdWlmYWJyaWMvdXRpbGl0aWVzL2xpYi9FdmVudEdyb3VwLmpzIiwibm9kZV9tb2R1bGVzL0B1aWZhYnJpYy91dGlsaXRpZXMvbGliL0ZhYnJpY1BlcmZvcm1hbmNlLmpzIiwibm9kZV9tb2R1bGVzL0B1aWZhYnJpYy91dGlsaXRpZXMvbGliL0dsb2JhbFNldHRpbmdzLmpzIiwibm9kZV9tb2R1bGVzL0B1aWZhYnJpYy91dGlsaXRpZXMvbGliL0tleUNvZGVzLmpzIiwibm9kZV9tb2R1bGVzL0B1aWZhYnJpYy91dGlsaXRpZXMvbGliL1JlY3RhbmdsZS5qcyIsIm5vZGVfbW9kdWxlcy9AdWlmYWJyaWMvdXRpbGl0aWVzL2xpYi9hcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9AdWlmYWJyaWMvdXRpbGl0aWVzL2xpYi9hc3NlcnROZXZlci5qcyIsIm5vZGVfbW9kdWxlcy9AdWlmYWJyaWMvdXRpbGl0aWVzL2xpYi9hdXRvYmluZC5qcyIsIm5vZGVfbW9kdWxlcy9AdWlmYWJyaWMvdXRpbGl0aWVzL2xpYi9jbGFzc05hbWVzRnVuY3Rpb24uanMiLCJub2RlX21vZHVsZXMvQHVpZmFicmljL3V0aWxpdGllcy9saWIvY3NzLmpzIiwibm9kZV9tb2R1bGVzL0B1aWZhYnJpYy91dGlsaXRpZXMvbGliL2N1c3RvbWl6YWJsZS5qcyIsIm5vZGVfbW9kdWxlcy9AdWlmYWJyaWMvdXRpbGl0aWVzL2xpYi9kb20uanMiLCJub2RlX21vZHVsZXMvQHVpZmFicmljL3V0aWxpdGllcy9saWIvZm9jdXMuanMiLCJub2RlX21vZHVsZXMvQHVpZmFicmljL3V0aWxpdGllcy9saWIvaG9pc3QuanMiLCJub2RlX21vZHVsZXMvQHVpZmFicmljL3V0aWxpdGllcy9saWIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvQHVpZmFicmljL3V0aWxpdGllcy9saWIvaW5pdGlhbHMuanMiLCJub2RlX21vZHVsZXMvQHVpZmFicmljL3V0aWxpdGllcy9saWIvbGFuZ3VhZ2UuanMiLCJub2RlX21vZHVsZXMvQHVpZmFicmljL3V0aWxpdGllcy9saWIvbG9jYWxTdG9yYWdlLmpzIiwibm9kZV9tb2R1bGVzL0B1aWZhYnJpYy91dGlsaXRpZXMvbGliL21hdGguanMiLCJub2RlX21vZHVsZXMvQHVpZmFicmljL3V0aWxpdGllcy9saWIvbWVtb2l6ZS5qcyIsIm5vZGVfbW9kdWxlcy9AdWlmYWJyaWMvdXRpbGl0aWVzL2xpYi9vYmplY3QuanMiLCJub2RlX21vZHVsZXMvQHVpZmFicmljL3V0aWxpdGllcy9saWIvb3ZlcmZsb3cuanMiLCJub2RlX21vZHVsZXMvQHVpZmFicmljL3V0aWxpdGllcy9saWIvcHJvcGVydGllcy5qcyIsIm5vZGVfbW9kdWxlcy9AdWlmYWJyaWMvdXRpbGl0aWVzL2xpYi9yZXNvdXJjZXMuanMiLCJub2RlX21vZHVsZXMvQHVpZmFicmljL3V0aWxpdGllcy9saWIvcnRsLmpzIiwibm9kZV9tb2R1bGVzL0B1aWZhYnJpYy91dGlsaXRpZXMvbGliL3Njcm9sbC5qcyIsIm5vZGVfbW9kdWxlcy9AdWlmYWJyaWMvdXRpbGl0aWVzL2xpYi9zY3JvbGwuc2Nzcy5qcyIsIm5vZGVfbW9kdWxlcy9AdWlmYWJyaWMvdXRpbGl0aWVzL2xpYi9zZXNzaW9uU3RvcmFnZS5qcyIsIm5vZGVfbW9kdWxlcy9AdWlmYWJyaWMvdXRpbGl0aWVzL2xpYi9zdHJpbmcuanMiLCJub2RlX21vZHVsZXMvQHVpZmFicmljL3V0aWxpdGllcy9saWIvc3R5bGVkLmpzIiwibm9kZV9tb2R1bGVzL0B1aWZhYnJpYy91dGlsaXRpZXMvbGliL3dhcm4uanMiLCJub2RlX21vZHVsZXMvZmJqcy9saWIvZW1wdHlGdW5jdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9mYmpzL2xpYi9pbnZhcmlhbnQuanMiLCJub2RlX21vZHVsZXMvZmJqcy9saWIvd2FybmluZy5qcyIsIm5vZGVfbW9kdWxlcy9vYmplY3QtYXNzaWduL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL29mZmljZS11aS1mYWJyaWMtcmVhY3QvbGliL0J1dHRvbi5qcyIsIm5vZGVfbW9kdWxlcy9vZmZpY2UtdWktZmFicmljLXJlYWN0L2xpYi9DYWxsb3V0LmpzIiwibm9kZV9tb2R1bGVzL29mZmljZS11aS1mYWJyaWMtcmVhY3QvbGliL0NvbnRleHR1YWxNZW51LmpzIiwibm9kZV9tb2R1bGVzL29mZmljZS11aS1mYWJyaWMtcmVhY3QvbGliL0RpdmlkZXIuanMiLCJub2RlX21vZHVsZXMvb2ZmaWNlLXVpLWZhYnJpYy1yZWFjdC9saWIvRmFicmljLmpzIiwibm9kZV9tb2R1bGVzL29mZmljZS11aS1mYWJyaWMtcmVhY3QvbGliL0ZvY3VzWm9uZS5qcyIsIm5vZGVfbW9kdWxlcy9vZmZpY2UtdWktZmFicmljLXJlYWN0L2xpYi9JY29uLmpzIiwibm9kZV9tb2R1bGVzL29mZmljZS11aS1mYWJyaWMtcmVhY3QvbGliL0xheWVyLmpzIiwibm9kZV9tb2R1bGVzL29mZmljZS11aS1mYWJyaWMtcmVhY3QvbGliL1BvcHVwLmpzIiwibm9kZV9tb2R1bGVzL29mZmljZS11aS1mYWJyaWMtcmVhY3QvbGliL1N0eWxpbmcuanMiLCJub2RlX21vZHVsZXMvb2ZmaWNlLXVpLWZhYnJpYy1yZWFjdC9saWIvVXRpbGl0aWVzLmpzIiwibm9kZV9tb2R1bGVzL29mZmljZS11aS1mYWJyaWMtcmVhY3QvbGliL2NvbW1vbi9EaXJlY3Rpb25hbEhpbnQuanMiLCJub2RlX21vZHVsZXMvb2ZmaWNlLXVpLWZhYnJpYy1yZWFjdC9saWIvY29tcG9uZW50cy9CdXR0b24vQWN0aW9uQnV0dG9uL0FjdGlvbkJ1dHRvbi5qcyIsIm5vZGVfbW9kdWxlcy9vZmZpY2UtdWktZmFicmljLXJlYWN0L2xpYi9jb21wb25lbnRzL0J1dHRvbi9BY3Rpb25CdXR0b24vQWN0aW9uQnV0dG9uLnN0eWxlcy5qcyIsIm5vZGVfbW9kdWxlcy9vZmZpY2UtdWktZmFicmljLXJlYWN0L2xpYi9jb21wb25lbnRzL0J1dHRvbi9CYXNlQnV0dG9uLmNsYXNzTmFtZXMuanMiLCJub2RlX21vZHVsZXMvb2ZmaWNlLXVpLWZhYnJpYy1yZWFjdC9saWIvY29tcG9uZW50cy9CdXR0b24vQmFzZUJ1dHRvbi5qcyIsIm5vZGVfbW9kdWxlcy9vZmZpY2UtdWktZmFicmljLXJlYWN0L2xpYi9jb21wb25lbnRzL0J1dHRvbi9CYXNlQnV0dG9uLnN0eWxlcy5qcyIsIm5vZGVfbW9kdWxlcy9vZmZpY2UtdWktZmFicmljLXJlYWN0L2xpYi9jb21wb25lbnRzL0J1dHRvbi9CdXR0b24uanMiLCJub2RlX21vZHVsZXMvb2ZmaWNlLXVpLWZhYnJpYy1yZWFjdC9saWIvY29tcG9uZW50cy9CdXR0b24vQnV0dG9uLnR5cGVzLmpzIiwibm9kZV9tb2R1bGVzL29mZmljZS11aS1mYWJyaWMtcmVhY3QvbGliL2NvbXBvbmVudHMvQnV0dG9uL0J1dHRvblRoZW1lcy5qcyIsIm5vZGVfbW9kdWxlcy9vZmZpY2UtdWktZmFicmljLXJlYWN0L2xpYi9jb21wb25lbnRzL0J1dHRvbi9Db21tYW5kQmFyQnV0dG9uL0NvbW1hbmRCYXJCdXR0b24uanMiLCJub2RlX21vZHVsZXMvb2ZmaWNlLXVpLWZhYnJpYy1yZWFjdC9saWIvY29tcG9uZW50cy9CdXR0b24vQ29tbWFuZEJhckJ1dHRvbi9Db21tYW5kQmFyQnV0dG9uLnN0eWxlcy5qcyIsIm5vZGVfbW9kdWxlcy9vZmZpY2UtdWktZmFicmljLXJlYWN0L2xpYi9jb21wb25lbnRzL0J1dHRvbi9Db21tYW5kQnV0dG9uL0NvbW1hbmRCdXR0b24uanMiLCJub2RlX21vZHVsZXMvb2ZmaWNlLXVpLWZhYnJpYy1yZWFjdC9saWIvY29tcG9uZW50cy9CdXR0b24vQ29tcG91bmRCdXR0b24vQ29tcG91bmRCdXR0b24uanMiLCJub2RlX21vZHVsZXMvb2ZmaWNlLXVpLWZhYnJpYy1yZWFjdC9saWIvY29tcG9uZW50cy9CdXR0b24vQ29tcG91bmRCdXR0b24vQ29tcG91bmRCdXR0b24uc3R5bGVzLmpzIiwibm9kZV9tb2R1bGVzL29mZmljZS11aS1mYWJyaWMtcmVhY3QvbGliL2NvbXBvbmVudHMvQnV0dG9uL0RlZmF1bHRCdXR0b24vRGVmYXVsdEJ1dHRvbi5qcyIsIm5vZGVfbW9kdWxlcy9vZmZpY2UtdWktZmFicmljLXJlYWN0L2xpYi9jb21wb25lbnRzL0J1dHRvbi9EZWZhdWx0QnV0dG9uL0RlZmF1bHRCdXR0b24uc3R5bGVzLmpzIiwibm9kZV9tb2R1bGVzL29mZmljZS11aS1mYWJyaWMtcmVhY3QvbGliL2NvbXBvbmVudHMvQnV0dG9uL0ljb25CdXR0b24vSWNvbkJ1dHRvbi5qcyIsIm5vZGVfbW9kdWxlcy9vZmZpY2UtdWktZmFicmljLXJlYWN0L2xpYi9jb21wb25lbnRzL0J1dHRvbi9JY29uQnV0dG9uL0ljb25CdXR0b24uc3R5bGVzLmpzIiwibm9kZV9tb2R1bGVzL29mZmljZS11aS1mYWJyaWMtcmVhY3QvbGliL2NvbXBvbmVudHMvQnV0dG9uL01lc3NhZ2VCYXJCdXR0b24vTWVzc2FnZUJhckJ1dHRvbi5qcyIsIm5vZGVfbW9kdWxlcy9vZmZpY2UtdWktZmFicmljLXJlYWN0L2xpYi9jb21wb25lbnRzL0J1dHRvbi9NZXNzYWdlQmFyQnV0dG9uL01lc3NhZ2VCYXJCdXR0b24uc3R5bGVzLmpzIiwibm9kZV9tb2R1bGVzL29mZmljZS11aS1mYWJyaWMtcmVhY3QvbGliL2NvbXBvbmVudHMvQnV0dG9uL1ByaW1hcnlCdXR0b24vUHJpbWFyeUJ1dHRvbi5qcyIsIm5vZGVfbW9kdWxlcy9vZmZpY2UtdWktZmFicmljLXJlYWN0L2xpYi9jb21wb25lbnRzL0J1dHRvbi9TcGxpdEJ1dHRvbi9TcGxpdEJ1dHRvbi5jbGFzc05hbWVzLmpzIiwibm9kZV9tb2R1bGVzL29mZmljZS11aS1mYWJyaWMtcmVhY3QvbGliL2NvbXBvbmVudHMvQnV0dG9uL1NwbGl0QnV0dG9uL1NwbGl0QnV0dG9uLnN0eWxlcy5qcyIsIm5vZGVfbW9kdWxlcy9vZmZpY2UtdWktZmFicmljLXJlYWN0L2xpYi9jb21wb25lbnRzL0J1dHRvbi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9vZmZpY2UtdWktZmFicmljLXJlYWN0L2xpYi9jb21wb25lbnRzL0NhbGxvdXQvQ2FsbG91dC5qcyIsIm5vZGVfbW9kdWxlcy9vZmZpY2UtdWktZmFicmljLXJlYWN0L2xpYi9jb21wb25lbnRzL0NhbGxvdXQvQ2FsbG91dC5zY3NzLmpzIiwibm9kZV9tb2R1bGVzL29mZmljZS11aS1mYWJyaWMtcmVhY3QvbGliL2NvbXBvbmVudHMvQ2FsbG91dC9DYWxsb3V0Q29udGVudC5qcyIsIm5vZGVfbW9kdWxlcy9vZmZpY2UtdWktZmFicmljLXJlYWN0L2xpYi9jb21wb25lbnRzL0NhbGxvdXQvaW5kZXguanMiLCJub2RlX21vZHVsZXMvb2ZmaWNlLXVpLWZhYnJpYy1yZWFjdC9saWIvY29tcG9uZW50cy9Db250ZXh0dWFsTWVudS9Db250ZXh0dWFsTWVudS5jbGFzc05hbWVzLmpzIiwibm9kZV9tb2R1bGVzL29mZmljZS11aS1mYWJyaWMtcmVhY3QvbGliL2NvbXBvbmVudHMvQ29udGV4dHVhbE1lbnUvQ29udGV4dHVhbE1lbnUuanMiLCJub2RlX21vZHVsZXMvb2ZmaWNlLXVpLWZhYnJpYy1yZWFjdC9saWIvY29tcG9uZW50cy9Db250ZXh0dWFsTWVudS9Db250ZXh0dWFsTWVudS5zdHlsZXMuanMiLCJub2RlX21vZHVsZXMvb2ZmaWNlLXVpLWZhYnJpYy1yZWFjdC9saWIvY29tcG9uZW50cy9Db250ZXh0dWFsTWVudS9Db250ZXh0dWFsTWVudS50eXBlcy5qcyIsIm5vZGVfbW9kdWxlcy9vZmZpY2UtdWktZmFicmljLXJlYWN0L2xpYi9jb21wb25lbnRzL0NvbnRleHR1YWxNZW51L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL29mZmljZS11aS1mYWJyaWMtcmVhY3QvbGliL2NvbXBvbmVudHMvRGl2aWRlci9WZXJ0aWNhbERpdmlkZXIuY2xhc3NOYW1lcy5qcyIsIm5vZGVfbW9kdWxlcy9vZmZpY2UtdWktZmFicmljLXJlYWN0L2xpYi9jb21wb25lbnRzL0RpdmlkZXIvVmVydGljYWxEaXZpZGVyLmpzIiwibm9kZV9tb2R1bGVzL29mZmljZS11aS1mYWJyaWMtcmVhY3QvbGliL2NvbXBvbmVudHMvRGl2aWRlci9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9vZmZpY2UtdWktZmFicmljLXJlYWN0L2xpYi9jb21wb25lbnRzL0ZhYnJpYy9GYWJyaWMuY2xhc3NOYW1lcy5qcyIsIm5vZGVfbW9kdWxlcy9vZmZpY2UtdWktZmFicmljLXJlYWN0L2xpYi9jb21wb25lbnRzL0ZhYnJpYy9GYWJyaWMuanMiLCJub2RlX21vZHVsZXMvb2ZmaWNlLXVpLWZhYnJpYy1yZWFjdC9saWIvY29tcG9uZW50cy9GYWJyaWMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvb2ZmaWNlLXVpLWZhYnJpYy1yZWFjdC9saWIvY29tcG9uZW50cy9Gb2N1c1pvbmUvRm9jdXNab25lLmpzIiwibm9kZV9tb2R1bGVzL29mZmljZS11aS1mYWJyaWMtcmVhY3QvbGliL2NvbXBvbmVudHMvRm9jdXNab25lL0ZvY3VzWm9uZS50eXBlcy5qcyIsIm5vZGVfbW9kdWxlcy9vZmZpY2UtdWktZmFicmljLXJlYWN0L2xpYi9jb21wb25lbnRzL0ZvY3VzWm9uZS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9vZmZpY2UtdWktZmFicmljLXJlYWN0L2xpYi9jb21wb25lbnRzL0ljb24vSWNvbi5jbGFzc05hbWVzLmpzIiwibm9kZV9tb2R1bGVzL29mZmljZS11aS1mYWJyaWMtcmVhY3QvbGliL2NvbXBvbmVudHMvSWNvbi9JY29uLmpzIiwibm9kZV9tb2R1bGVzL29mZmljZS11aS1mYWJyaWMtcmVhY3QvbGliL2NvbXBvbmVudHMvSWNvbi9JY29uLnR5cGVzLmpzIiwibm9kZV9tb2R1bGVzL29mZmljZS11aS1mYWJyaWMtcmVhY3QvbGliL2NvbXBvbmVudHMvSWNvbi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9vZmZpY2UtdWktZmFicmljLXJlYWN0L2xpYi9jb21wb25lbnRzL0ltYWdlL0ltYWdlLmpzIiwibm9kZV9tb2R1bGVzL29mZmljZS11aS1mYWJyaWMtcmVhY3QvbGliL2NvbXBvbmVudHMvSW1hZ2UvSW1hZ2Uuc2Nzcy5qcyIsIm5vZGVfbW9kdWxlcy9vZmZpY2UtdWktZmFicmljLXJlYWN0L2xpYi9jb21wb25lbnRzL0ltYWdlL0ltYWdlLnR5cGVzLmpzIiwibm9kZV9tb2R1bGVzL29mZmljZS11aS1mYWJyaWMtcmVhY3QvbGliL2NvbXBvbmVudHMvTGF5ZXIvTGF5ZXIuanMiLCJub2RlX21vZHVsZXMvb2ZmaWNlLXVpLWZhYnJpYy1yZWFjdC9saWIvY29tcG9uZW50cy9MYXllci9MYXllci5zY3NzLmpzIiwibm9kZV9tb2R1bGVzL29mZmljZS11aS1mYWJyaWMtcmVhY3QvbGliL2NvbXBvbmVudHMvTGF5ZXIvTGF5ZXJIb3N0LmpzIiwibm9kZV9tb2R1bGVzL29mZmljZS11aS1mYWJyaWMtcmVhY3QvbGliL2NvbXBvbmVudHMvTGF5ZXIvaW5kZXguanMiLCJub2RlX21vZHVsZXMvb2ZmaWNlLXVpLWZhYnJpYy1yZWFjdC9saWIvY29tcG9uZW50cy9Qb3B1cC9Qb3B1cC5qcyIsIm5vZGVfbW9kdWxlcy9vZmZpY2UtdWktZmFicmljLXJlYWN0L2xpYi9jb21wb25lbnRzL1BvcHVwL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL29mZmljZS11aS1mYWJyaWMtcmVhY3QvbGliL3V0aWxpdGllcy9kZWNvcmF0b3JzL0Jhc2VEZWNvcmF0b3IuanMiLCJub2RlX21vZHVsZXMvb2ZmaWNlLXVpLWZhYnJpYy1yZWFjdC9saWIvdXRpbGl0aWVzL2RlY29yYXRvcnMvd2l0aFJlc3BvbnNpdmVNb2RlLmpzIiwibm9kZV9tb2R1bGVzL29mZmljZS11aS1mYWJyaWMtcmVhY3QvbGliL3V0aWxpdGllcy9wb3NpdGlvbmluZy5qcyIsIm5vZGVfbW9kdWxlcy9vZmZpY2UtdWktZmFicmljLXJlYWN0L2xpYi91dGlsaXRpZXMvcG9zaXRpb25pbmcvaW5kZXguanMiLCJub2RlX21vZHVsZXMvb2ZmaWNlLXVpLWZhYnJpYy1yZWFjdC9saWIvdXRpbGl0aWVzL3Bvc2l0aW9uaW5nL3Bvc2l0aW9uaW5nLmpzIiwibm9kZV9tb2R1bGVzL29mZmljZS11aS1mYWJyaWMtcmVhY3QvbGliL3V0aWxpdGllcy9wb3NpdGlvbmluZy9wb3NpdGlvbmluZy50eXBlcy5qcyIsIm5vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcHJvcC10eXBlcy9jaGVja1Byb3BUeXBlcy5qcyIsIm5vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2ZhY3RvcnlXaXRoVGhyb3dpbmdTaGltcy5qcyIsIm5vZGVfbW9kdWxlcy9wcm9wLXR5cGVzL2ZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzLmpzIiwibm9kZV9tb2R1bGVzL3Byb3AtdHlwZXMvaW5kZXguanMiLCJub2RlX21vZHVsZXMvcHJvcC10eXBlcy9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQuanMiLCJub2RlX21vZHVsZXMvdHNsaWIvdHNsaWIuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7OztBQ0FDOzs7O0FBQ0Q7Ozs7QUFDQTs7QUFDQTs7OztBQUVBLElBQU0sU0FBUyxTQUFULE1BQVM7QUFBQSxXQUNYO0FBQUE7QUFBQTtBQUNJO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFESixLQURXO0FBQUEsQ0FBZjs7QUFNQSxtQkFBUyxNQUFULENBQWdCLDhCQUFDLE1BQUQsT0FBaEIsRUFBNEIsU0FBUyxjQUFULENBQXdCLEtBQXhCLENBQTVCOzs7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzFWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUxBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDUEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9JQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25JQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0lBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2phQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlPQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pRQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3REE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3RHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUMzR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25DQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNiQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeERBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25HQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQy9CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNuQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUNwREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQzdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqVEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25GQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDL0NBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDektBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDM0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzdvQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcExBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNYQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN2QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDSkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RtQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDakJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDeENBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMvREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1SEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNKQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3pGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOW5CQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2hCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN4TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDM0RBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzFEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDOWhCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDNUJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNaQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCLvu79pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xyXG5pbXBvcnQgUmVhY3RET00gZnJvbSAncmVhY3QtZG9tJztcclxuaW1wb3J0IHsgRmFicmljIH0gZnJvbSAnb2ZmaWNlLXVpLWZhYnJpYy1yZWFjdC9saWIvRmFicmljJztcclxuaW1wb3J0IHsgRGVmYXVsdEJ1dHRvbiB9IGZyb20gJ29mZmljZS11aS1mYWJyaWMtcmVhY3QvbGliL0J1dHRvbic7XHJcblxyXG5jb25zdCBNeVBhZ2UgPSAoKSA9PiAoXHJcbiAgICA8RmFicmljPlxyXG4gICAgICAgIDxEZWZhdWx0QnV0dG9uPkkgYW0gYSBidXR0b248L0RlZmF1bHRCdXR0b24+XHJcbiAgICA8L0ZhYnJpYz5cclxuKTtcclxuXHJcblJlYWN0RE9NLnJlbmRlcig8TXlQYWdlIC8+LCBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYXBwJykpOyIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBBbiBJVGhlbWluZ0luc3RydWN0aW9uIGNhbiBzcGVjaWZ5IGEgcmF3U3RyaW5nIHRvIGJlIHByZXNlcnZlZCBvciBhIHRoZW1lIHNsb3QgYW5kIGEgZGVmYXVsdCB2YWx1ZVxuICogdG8gdXNlIGlmIHRoYXQgc2xvdCBpcyBub3Qgc3BlY2lmaWVkIGJ5IHRoZSB0aGVtZS5cbiAqL1xudmFyIF9fYXNzaWduID0gKHRoaXMgJiYgdGhpcy5fX2Fzc2lnbikgfHwgT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbih0KSB7XG4gICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XG4gICAgICAgIHMgPSBhcmd1bWVudHNbaV07XG4gICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSlcbiAgICAgICAgICAgIHRbcF0gPSBzW3BdO1xuICAgIH1cbiAgICByZXR1cm4gdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4vLyBJRSBuZWVkcyB0byBpbmplY3Qgc3R5bGVzIHVzaW5nIGNzc1RleHQuIEhvd2V2ZXIsIHdlIG5lZWQgdG8gZXZhbHVhdGUgdGhpcyBsYXppbHksIHNvIHRoaXNcbi8vIHZhbHVlIHdpbGwgaW5pdGlhbGl6ZSBhcyB1bmRlZmluZWQsIGFuZCBsYXRlciB3aWxsIGJlIHNldCBvbmNlIG9uIGZpcnN0IGxvYWRTdHlsZXMgaW5qZWN0aW9uLlxudmFyIF9pbmplY3RTdHlsZXNXaXRoQ3NzVGV4dDtcbi8vIFN0b3JlIHRoZSB0aGVtaW5nIHN0YXRlIGluIF9fdGhlbWVTdGF0ZV9fIGdsb2JhbCBzY29wZSBmb3IgcmV1c2UgaW4gdGhlIGNhc2Ugb2YgZHVwbGljYXRlXG4vLyBsb2FkLXRoZW1lZC1zdHlsZXMgaG9zdGVkIG9uIHRoZSBwYWdlLlxudmFyIF9yb290ID0gKHR5cGVvZiB3aW5kb3cgPT09ICd1bmRlZmluZWQnKSA/IGdsb2JhbCA6IHdpbmRvdzsgLy8gdHNsaW50OmRpc2FibGUtbGluZTpuby1hbnlcbnZhciBfdGhlbWVTdGF0ZSA9IGluaXRpYWxpemVUaGVtZVN0YXRlKCk7XG4vKipcbiAqIE1hdGNoZXMgdGhlbWluZyB0b2tlbnMuIEZvciBleGFtcGxlLCBcIlt0aGVtZTogdGhlbWVTbG90TmFtZSwgZGVmYXVsdDogI0ZGRl1cIiAoaW5jbHVkaW5nIHRoZSBxdW90ZXMpLlxuICovXG4vLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bWF4LWxpbmUtbGVuZ3RoXG52YXIgX3RoZW1lVG9rZW5SZWdleCA9IC9bXFwnXFxcIl1cXFt0aGVtZTpcXHMqKFxcdyspXFxzKig/OlxcLFxccypkZWZhdWx0OlxccyooW1xcXFxcIlxcJ10/W1xcLlxcLFxcKFxcKVxcI1xcLVxcc1xcd10qW1xcLlxcLFxcKFxcKVxcI1xcLVxcd11bXFxcIlxcJ10/KSk/XFxzKlxcXVtcXCdcXFwiXS9nO1xuLyoqIE1heGltdW0gc3R5bGUgdGV4dCBsZW5ndGgsIGZvciBzdXBwb3J0aW5nIElFIHN0eWxlIHJlc3RyaWN0aW9ucy4gKi9cbnZhciBNQVhfU1RZTEVfQ09OVEVOVF9TSVpFID0gMTAwMDA7XG52YXIgbm93ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKHR5cGVvZiBwZXJmb3JtYW5jZSAhPT0gJ3VuZGVmaW5lZCcgJiYgISFwZXJmb3JtYW5jZS5ub3cpID8gcGVyZm9ybWFuY2Uubm93KCkgOiBEYXRlLm5vdygpOyB9O1xuZnVuY3Rpb24gbWVhc3VyZShmdW5jKSB7XG4gICAgdmFyIHN0YXJ0ID0gbm93KCk7XG4gICAgZnVuYygpO1xuICAgIHZhciBlbmQgPSBub3coKTtcbiAgICBfdGhlbWVTdGF0ZS5wZXJmLmR1cmF0aW9uICs9IGVuZCAtIHN0YXJ0O1xufVxuLyoqXG4gKiBpbml0aWFsaXplIGdsb2JhbCBzdGF0ZSBvYmplY3RcbiAqL1xuZnVuY3Rpb24gaW5pdGlhbGl6ZVRoZW1lU3RhdGUoKSB7XG4gICAgdmFyIHN0YXRlID0gX3Jvb3QuX190aGVtZVN0YXRlX18gfHwge1xuICAgICAgICB0aGVtZTogdW5kZWZpbmVkLFxuICAgICAgICBsYXN0U3R5bGVFbGVtZW50OiB1bmRlZmluZWQsXG4gICAgICAgIHJlZ2lzdGVyZWRTdHlsZXM6IFtdXG4gICAgfTtcbiAgICBpZiAoIXN0YXRlLnJ1blN0YXRlKSB7XG4gICAgICAgIHN0YXRlID0gX19hc3NpZ24oe30sIChzdGF0ZSksIHsgcGVyZjoge1xuICAgICAgICAgICAgICAgIGNvdW50OiAwLFxuICAgICAgICAgICAgICAgIGR1cmF0aW9uOiAwXG4gICAgICAgICAgICB9LCBydW5TdGF0ZToge1xuICAgICAgICAgICAgICAgIGZsdXNoVGltZXI6IDAsXG4gICAgICAgICAgICAgICAgbW9kZTogMCAvKiBzeW5jICovLFxuICAgICAgICAgICAgICAgIGJ1ZmZlcjogW11cbiAgICAgICAgICAgIH0gfSk7XG4gICAgfVxuICAgIGlmICghc3RhdGUucmVnaXN0ZXJlZFRoZW1hYmxlU3R5bGVzKSB7XG4gICAgICAgIHN0YXRlID0gX19hc3NpZ24oe30sIChzdGF0ZSksIHsgcmVnaXN0ZXJlZFRoZW1hYmxlU3R5bGVzOiBbXSB9KTtcbiAgICB9XG4gICAgX3Jvb3QuX190aGVtZVN0YXRlX18gPSBzdGF0ZTtcbiAgICByZXR1cm4gc3RhdGU7XG59XG4vKipcbiAqIExvYWRzIGEgc2V0IG9mIHN0eWxlIHRleHQuIElmIGl0IGlzIHJlZ2lzdGVyZWQgdG9vIGVhcmx5LCB3ZSB3aWxsIHJlZ2lzdGVyIGl0IHdoZW4gdGhlIHdpbmRvdy5sb2FkXG4gKiBldmVudCBpcyBmaXJlZC5cbiAqIEBwYXJhbSB7c3RyaW5nIHwgVGhlbWFibGVBcnJheX0gc3R5bGVzIFRoZW1hYmxlIHN0eWxlIHRleHQgdG8gcmVnaXN0ZXIuXG4gKiBAcGFyYW0ge2Jvb2xlYW59IGxvYWRBc3luYyBXaGVuIHRydWUsIGFsd2F5cyBsb2FkIHN0eWxlcyBpbiBhc3luYyBtb2RlLCBpcnJlc3BlY3RpdmUgb2YgY3VycmVudCBzeW5jIG1vZGUuXG4gKi9cbmZ1bmN0aW9uIGxvYWRTdHlsZXMoc3R5bGVzLCBsb2FkQXN5bmMpIHtcbiAgICBpZiAobG9hZEFzeW5jID09PSB2b2lkIDApIHsgbG9hZEFzeW5jID0gZmFsc2U7IH1cbiAgICBtZWFzdXJlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHN0eWxlUGFydHMgPSBBcnJheS5pc0FycmF5KHN0eWxlcykgPyBzdHlsZXMgOiBzcGxpdFN0eWxlcyhzdHlsZXMpO1xuICAgICAgICBpZiAoX2luamVjdFN0eWxlc1dpdGhDc3NUZXh0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIF9pbmplY3RTdHlsZXNXaXRoQ3NzVGV4dCA9IHNob3VsZFVzZUNzc1RleHQoKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgX2EgPSBfdGhlbWVTdGF0ZS5ydW5TdGF0ZSwgbW9kZSA9IF9hLm1vZGUsIGJ1ZmZlciA9IF9hLmJ1ZmZlciwgZmx1c2hUaW1lciA9IF9hLmZsdXNoVGltZXI7XG4gICAgICAgIGlmIChsb2FkQXN5bmMgfHwgbW9kZSA9PT0gMSAvKiBhc3luYyAqLykge1xuICAgICAgICAgICAgYnVmZmVyLnB1c2goc3R5bGVQYXJ0cyk7XG4gICAgICAgICAgICBpZiAoIWZsdXNoVGltZXIpIHtcbiAgICAgICAgICAgICAgICBfdGhlbWVTdGF0ZS5ydW5TdGF0ZS5mbHVzaFRpbWVyID0gYXN5bmNMb2FkU3R5bGVzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBhcHBseVRoZW1hYmxlU3R5bGVzKHN0eWxlUGFydHMpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5leHBvcnRzLmxvYWRTdHlsZXMgPSBsb2FkU3R5bGVzO1xuLyoqXG4gKiBBbGxvd3MgZm9yIGN1c3RvbWl6YWJsZSBsb2FkU3R5bGVzIGxvZ2ljLiBlLmcuIGZvciBzZXJ2ZXIgc2lkZSByZW5kZXJpbmcgYXBwbGljYXRpb25cbiAqIEBwYXJhbSB7KHByb2Nlc3NlZFN0eWxlczogc3RyaW5nLCByYXdTdHlsZXM/OiBzdHJpbmcgfCBUaGVtYWJsZUFycmF5KSA9PiB2b2lkfVxuICogYSBsb2FkU3R5bGVzIGNhbGxiYWNrIHRoYXQgZ2V0cyBjYWxsZWQgd2hlbiBzdHlsZXMgYXJlIGxvYWRlZCBvciByZWxvYWRlZFxuICovXG5mdW5jdGlvbiBjb25maWd1cmVMb2FkU3R5bGVzKGxvYWRTdHlsZXNGbikge1xuICAgIF90aGVtZVN0YXRlLmxvYWRTdHlsZXMgPSBsb2FkU3R5bGVzRm47XG59XG5leHBvcnRzLmNvbmZpZ3VyZUxvYWRTdHlsZXMgPSBjb25maWd1cmVMb2FkU3R5bGVzO1xuLyoqXG4gKiBDb25maWd1cmUgcnVuIG1vZGUgb2YgbG9hZC10aGVtYWJsZS1zdHlsZXNcbiAqIEBwYXJhbSBtb2RlIGxvYWQtdGhlbWFibGUtc3R5bGVzIHJ1biBtb2RlLCBhc3luYyBvciBzeW5jXG4gKi9cbmZ1bmN0aW9uIGNvbmZpZ3VyZVJ1bk1vZGUobW9kZSkge1xuICAgIF90aGVtZVN0YXRlLnJ1blN0YXRlLm1vZGUgPSBtb2RlO1xufVxuZXhwb3J0cy5jb25maWd1cmVSdW5Nb2RlID0gY29uZmlndXJlUnVuTW9kZTtcbi8qKlxuICogZXh0ZXJuYWwgY29kZSBjYW4gY2FsbCBmbHVzaCB0byBzeW5jaHJvbm91c2x5IGZvcmNlIHByb2Nlc3Npbmcgb2YgY3VycmVudGx5IGJ1ZmZlcmVkIHN0eWxlc1xuICovXG5mdW5jdGlvbiBmbHVzaCgpIHtcbiAgICBtZWFzdXJlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHN0eWxlQXJyYXlzID0gX3RoZW1lU3RhdGUucnVuU3RhdGUuYnVmZmVyLnNsaWNlKCk7XG4gICAgICAgIF90aGVtZVN0YXRlLnJ1blN0YXRlLmJ1ZmZlciA9IFtdO1xuICAgICAgICB2YXIgbWVyZ2VkU3R5bGVBcnJheSA9IFtdLmNvbmNhdC5hcHBseShbXSwgc3R5bGVBcnJheXMpO1xuICAgICAgICBpZiAobWVyZ2VkU3R5bGVBcnJheS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBhcHBseVRoZW1hYmxlU3R5bGVzKG1lcmdlZFN0eWxlQXJyYXkpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG5leHBvcnRzLmZsdXNoID0gZmx1c2g7XG4vKipcbiAqIHJlZ2lzdGVyIGFzeW5jIGxvYWRTdHlsZXNcbiAqL1xuZnVuY3Rpb24gYXN5bmNMb2FkU3R5bGVzKCkge1xuICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgX3RoZW1lU3RhdGUucnVuU3RhdGUuZmx1c2hUaW1lciA9IDA7XG4gICAgICAgIGZsdXNoKCk7XG4gICAgfSwgMCk7XG59XG4vKipcbiAqIExvYWRzIGEgc2V0IG9mIHN0eWxlIHRleHQuIElmIGl0IGlzIHJlZ2lzdGVyZWQgdG9vIGVhcmx5LCB3ZSB3aWxsIHJlZ2lzdGVyIGl0IHdoZW4gdGhlIHdpbmRvdy5sb2FkIGV2ZW50XG4gKiBpcyBmaXJlZC5cbiAqIEBwYXJhbSB7c3RyaW5nfSBzdHlsZVRleHQgU3R5bGUgdG8gcmVnaXN0ZXIuXG4gKiBAcGFyYW0ge0lTdHlsZVJlY29yZH0gc3R5bGVSZWNvcmQgRXhpc3Rpbmcgc3R5bGUgcmVjb3JkIHRvIHJlLWFwcGx5LlxuICovXG5mdW5jdGlvbiBhcHBseVRoZW1hYmxlU3R5bGVzKHN0eWxlc0FycmF5LCBzdHlsZVJlY29yZCkge1xuICAgIGlmIChfdGhlbWVTdGF0ZS5sb2FkU3R5bGVzKSB7XG4gICAgICAgIF90aGVtZVN0YXRlLmxvYWRTdHlsZXMocmVzb2x2ZVRoZW1hYmxlQXJyYXkoc3R5bGVzQXJyYXkpLnN0eWxlU3RyaW5nLCBzdHlsZXNBcnJheSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBfaW5qZWN0U3R5bGVzV2l0aENzc1RleHQgP1xuICAgICAgICAgICAgcmVnaXN0ZXJTdHlsZXNJRShzdHlsZXNBcnJheSwgc3R5bGVSZWNvcmQpIDpcbiAgICAgICAgICAgIHJlZ2lzdGVyU3R5bGVzKHN0eWxlc0FycmF5KTtcbiAgICB9XG59XG4vKipcbiAqIFJlZ2lzdGVycyBhIHNldCB0aGVtZSB0b2tlbnMgdG8gZmluZCBhbmQgcmVwbGFjZS4gSWYgc3R5bGVzIHdlcmUgYWxyZWFkeSByZWdpc3RlcmVkLCB0aGV5IHdpbGwgYmVcbiAqIHJlcGxhY2VkLlxuICogQHBhcmFtIHt0aGVtZX0gdGhlbWUgSlNPTiBvYmplY3Qgb2YgdGhlbWUgdG9rZW5zIHRvIHZhbHVlcy5cbiAqL1xuZnVuY3Rpb24gbG9hZFRoZW1lKHRoZW1lKSB7XG4gICAgX3RoZW1lU3RhdGUudGhlbWUgPSB0aGVtZTtcbiAgICAvLyByZWxvYWQgc3R5bGVzLlxuICAgIHJlbG9hZFN0eWxlcygpO1xufVxuZXhwb3J0cy5sb2FkVGhlbWUgPSBsb2FkVGhlbWU7XG4vKipcbiAqIENsZWFyIGFscmVhZHkgcmVnaXN0ZXJlZCBzdHlsZSBlbGVtZW50cyBhbmQgc3R5bGUgcmVjb3JkcyBpbiB0aGVtZV9TdGF0ZSBvYmplY3RcbiAqIEBvcHRpb246IHNwZWNpZnkgd2hpY2ggZ3JvdXAgb2YgcmVnaXN0ZXJlZCBzdHlsZXMgc2hvdWxkIGJlIGNsZWFyZWQuXG4gKiBEZWZhdWx0IHRvIGJlIGJvdGggdGhlbWFibGUgYW5kIG5vbi10aGVtYWJsZSBzdHlsZXMgd2lsbCBiZSBjbGVhcmVkXG4gKi9cbmZ1bmN0aW9uIGNsZWFyU3R5bGVzKG9wdGlvbikge1xuICAgIGlmIChvcHRpb24gPT09IHZvaWQgMCkgeyBvcHRpb24gPSAzIC8qIGFsbCAqLzsgfVxuICAgIGlmIChvcHRpb24gPT09IDMgLyogYWxsICovIHx8IG9wdGlvbiA9PT0gMiAvKiBvbmx5Tm9uVGhlbWFibGUgKi8pIHtcbiAgICAgICAgY2xlYXJTdHlsZXNJbnRlcm5hbChfdGhlbWVTdGF0ZS5yZWdpc3RlcmVkU3R5bGVzKTtcbiAgICAgICAgX3RoZW1lU3RhdGUucmVnaXN0ZXJlZFN0eWxlcyA9IFtdO1xuICAgIH1cbiAgICBpZiAob3B0aW9uID09PSAzIC8qIGFsbCAqLyB8fCBvcHRpb24gPT09IDEgLyogb25seVRoZW1hYmxlICovKSB7XG4gICAgICAgIGNsZWFyU3R5bGVzSW50ZXJuYWwoX3RoZW1lU3RhdGUucmVnaXN0ZXJlZFRoZW1hYmxlU3R5bGVzKTtcbiAgICAgICAgX3RoZW1lU3RhdGUucmVnaXN0ZXJlZFRoZW1hYmxlU3R5bGVzID0gW107XG4gICAgfVxufVxuZXhwb3J0cy5jbGVhclN0eWxlcyA9IGNsZWFyU3R5bGVzO1xuZnVuY3Rpb24gY2xlYXJTdHlsZXNJbnRlcm5hbChyZWNvcmRzKSB7XG4gICAgcmVjb3Jkcy5mb3JFYWNoKGZ1bmN0aW9uIChzdHlsZVJlY29yZCkge1xuICAgICAgICB2YXIgc3R5bGVFbGVtZW50ID0gc3R5bGVSZWNvcmQgJiYgc3R5bGVSZWNvcmQuc3R5bGVFbGVtZW50O1xuICAgICAgICBpZiAoc3R5bGVFbGVtZW50ICYmIHN0eWxlRWxlbWVudC5wYXJlbnRFbGVtZW50KSB7XG4gICAgICAgICAgICBzdHlsZUVsZW1lbnQucGFyZW50RWxlbWVudC5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQpO1xuICAgICAgICB9XG4gICAgfSk7XG59XG4vKipcbiAqIFJlbG9hZHMgc3R5bGVzLlxuICovXG5mdW5jdGlvbiByZWxvYWRTdHlsZXMoKSB7XG4gICAgaWYgKF90aGVtZVN0YXRlLnRoZW1lKSB7XG4gICAgICAgIHZhciB0aGVtYWJsZVN0eWxlcyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gX3RoZW1lU3RhdGUucmVnaXN0ZXJlZFRoZW1hYmxlU3R5bGVzOyBfaSA8IF9hLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgdmFyIHN0eWxlUmVjb3JkID0gX2FbX2ldO1xuICAgICAgICAgICAgdGhlbWFibGVTdHlsZXMucHVzaChzdHlsZVJlY29yZC50aGVtYWJsZVN0eWxlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhlbWFibGVTdHlsZXMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgY2xlYXJTdHlsZXMoMSAvKiBvbmx5VGhlbWFibGUgKi8pO1xuICAgICAgICAgICAgYXBwbHlUaGVtYWJsZVN0eWxlcyhbXS5jb25jYXQuYXBwbHkoW10sIHRoZW1hYmxlU3R5bGVzKSk7XG4gICAgICAgIH1cbiAgICB9XG59XG4vKipcbiAqIEZpbmQgdGhlbWUgdG9rZW5zIGFuZCByZXBsYWNlcyB0aGVtIHdpdGggcHJvdmlkZWQgdGhlbWUgdmFsdWVzLlxuICogQHBhcmFtIHtzdHJpbmd9IHN0eWxlcyBUb2tlbml6ZWQgc3R5bGVzIHRvIGZpeC5cbiAqL1xuZnVuY3Rpb24gZGV0b2tlbml6ZShzdHlsZXMpIHtcbiAgICBpZiAoc3R5bGVzKSB7XG4gICAgICAgIHN0eWxlcyA9IHJlc29sdmVUaGVtYWJsZUFycmF5KHNwbGl0U3R5bGVzKHN0eWxlcykpLnN0eWxlU3RyaW5nO1xuICAgIH1cbiAgICByZXR1cm4gc3R5bGVzO1xufVxuZXhwb3J0cy5kZXRva2VuaXplID0gZGV0b2tlbml6ZTtcbi8qKlxuICogUmVzb2x2ZXMgVGhlbWluZ0luc3RydWN0aW9uIG9iamVjdHMgaW4gYW4gYXJyYXkgYW5kIGpvaW5zIHRoZSByZXN1bHQgaW50byBhIHN0cmluZy5cbiAqIEBwYXJhbSB7VGhlbWFibGVBcnJheX0gc3BsaXRTdHlsZUFycmF5IFRoZW1hYmxlQXJyYXkgdG8gcmVzb2x2ZSBhbmQgam9pbi5cbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZVRoZW1hYmxlQXJyYXkoc3BsaXRTdHlsZUFycmF5KSB7XG4gICAgdmFyIHRoZW1lID0gX3RoZW1lU3RhdGUudGhlbWU7XG4gICAgdmFyIHRoZW1hYmxlID0gZmFsc2U7XG4gICAgLy8gUmVzb2x2ZSB0aGUgYXJyYXkgb2YgdGhlbWluZyBpbnN0cnVjdGlvbnMgdG8gYW4gYXJyYXkgb2Ygc3RyaW5ncy5cbiAgICAvLyBUaGVuIGpvaW4gdGhlIGFycmF5IHRvIHByb2R1Y2UgdGhlIGZpbmFsIENTUyBzdHJpbmcuXG4gICAgdmFyIHJlc29sdmVkQXJyYXkgPSAoc3BsaXRTdHlsZUFycmF5IHx8IFtdKS5tYXAoZnVuY3Rpb24gKGN1cnJlbnRWYWx1ZSkge1xuICAgICAgICB2YXIgdGhlbWVTbG90ID0gY3VycmVudFZhbHVlLnRoZW1lO1xuICAgICAgICBpZiAodGhlbWVTbG90KSB7XG4gICAgICAgICAgICB0aGVtYWJsZSA9IHRydWU7XG4gICAgICAgICAgICAvLyBBIHRoZW1pbmcgYW5ub3RhdGlvbi4gUmVzb2x2ZSBpdC5cbiAgICAgICAgICAgIHZhciB0aGVtZWRWYWx1ZSA9IHRoZW1lID8gdGhlbWVbdGhlbWVTbG90XSA6IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIHZhciBkZWZhdWx0VmFsdWUgPSBjdXJyZW50VmFsdWUuZGVmYXVsdFZhbHVlIHx8ICdpbmhlcml0JztcbiAgICAgICAgICAgIC8vIFdhcm4gdG8gY29uc29sZSBpZiB3ZSBoaXQgYW4gdW50aGVtZWQgdmFsdWUgZXZlbiB3aGVuIHRoZW1lcyBhcmUgcHJvdmlkZWQsIGJ1dCBvbmx5IGlmIFwiREVCVUdcIiBpcyB0cnVlLlxuICAgICAgICAgICAgLy8gQWxsb3cgdGhlIHRoZW1lZFZhbHVlIHRvIGJlIHVuZGVmaW5lZCB0byBleHBsaWNpdGx5IHJlcXVlc3QgdGhlIGRlZmF1bHQgdmFsdWUuXG4gICAgICAgICAgICBpZiAodGhlbWUgJiYgIXRoZW1lZFZhbHVlICYmIGNvbnNvbGUgJiYgISh0aGVtZVNsb3QgaW4gdGhlbWUpICYmIHR5cGVvZiBERUJVRyAhPT0gJ3VuZGVmaW5lZCcgJiYgREVCVUcpIHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJUaGVtaW5nIHZhbHVlIG5vdCBwcm92aWRlZCBmb3IgXFxcIlwiICsgdGhlbWVTbG90ICsgXCJcXFwiLiBGYWxsaW5nIGJhY2sgdG8gXFxcIlwiICsgZGVmYXVsdFZhbHVlICsgXCJcXFwiLlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0aGVtZWRWYWx1ZSB8fCBkZWZhdWx0VmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBBIG5vbi10aGVtYWJsZSBzdHJpbmcuIFByZXNlcnZlIGl0LlxuICAgICAgICAgICAgcmV0dXJuIGN1cnJlbnRWYWx1ZS5yYXdTdHJpbmc7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4ge1xuICAgICAgICBzdHlsZVN0cmluZzogcmVzb2x2ZWRBcnJheS5qb2luKCcnKSxcbiAgICAgICAgdGhlbWFibGU6IHRoZW1hYmxlXG4gICAgfTtcbn1cbi8qKlxuICogU3BsaXQgdG9rZW5pemVkIENTUyBpbnRvIGFuIGFycmF5IG9mIHN0cmluZ3MgYW5kIHRoZW1lIHNwZWNpZmljYXRpb24gb2JqZWN0c1xuICogQHBhcmFtIHtzdHJpbmd9IHN0eWxlcyBUb2tlbml6ZWQgc3R5bGVzIHRvIHNwbGl0LlxuICovXG5mdW5jdGlvbiBzcGxpdFN0eWxlcyhzdHlsZXMpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgaWYgKHN0eWxlcykge1xuICAgICAgICB2YXIgcG9zID0gMDsgLy8gQ3VycmVudCBwb3NpdGlvbiBpbiBzdHlsZXMuXG4gICAgICAgIHZhciB0b2tlbk1hdGNoID0gdm9pZCAwOyAvLyB0c2xpbnQ6ZGlzYWJsZS1saW5lOm5vLW51bGwta2V5d29yZFxuICAgICAgICB3aGlsZSAodG9rZW5NYXRjaCA9IF90aGVtZVRva2VuUmVnZXguZXhlYyhzdHlsZXMpKSB7XG4gICAgICAgICAgICB2YXIgbWF0Y2hJbmRleCA9IHRva2VuTWF0Y2guaW5kZXg7XG4gICAgICAgICAgICBpZiAobWF0Y2hJbmRleCA+IHBvcykge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgcmF3U3RyaW5nOiBzdHlsZXMuc3Vic3RyaW5nKHBvcywgbWF0Y2hJbmRleClcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgICAgICB0aGVtZTogdG9rZW5NYXRjaFsxXSxcbiAgICAgICAgICAgICAgICBkZWZhdWx0VmFsdWU6IHRva2VuTWF0Y2hbMl0gLy8gTWF5IGJlIHVuZGVmaW5lZFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAvLyBpbmRleCBvZiB0aGUgZmlyc3QgY2hhcmFjdGVyIGFmdGVyIHRoZSBjdXJyZW50IG1hdGNoXG4gICAgICAgICAgICBwb3MgPSBfdGhlbWVUb2tlblJlZ2V4Lmxhc3RJbmRleDtcbiAgICAgICAgfVxuICAgICAgICAvLyBQdXNoIHRoZSByZXN0IG9mIHRoZSBzdHJpbmcgYWZ0ZXIgdGhlIGxhc3QgbWF0Y2guXG4gICAgICAgIHJlc3VsdC5wdXNoKHtcbiAgICAgICAgICAgIHJhd1N0cmluZzogc3R5bGVzLnN1YnN0cmluZyhwb3MpXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5zcGxpdFN0eWxlcyA9IHNwbGl0U3R5bGVzO1xuLyoqXG4gKiBSZWdpc3RlcnMgYSBzZXQgb2Ygc3R5bGUgdGV4dC4gSWYgaXQgaXMgcmVnaXN0ZXJlZCB0b28gZWFybHksIHdlIHdpbGwgcmVnaXN0ZXIgaXQgd2hlbiB0aGVcbiAqIHdpbmRvdy5sb2FkIGV2ZW50IGlzIGZpcmVkLlxuICogQHBhcmFtIHtUaGVtYWJsZUFycmF5fSBzdHlsZUFycmF5IEFycmF5IG9mIElUaGVtaW5nSW5zdHJ1Y3Rpb24gb2JqZWN0cyB0byByZWdpc3Rlci5cbiAqIEBwYXJhbSB7SVN0eWxlUmVjb3JkfSBzdHlsZVJlY29yZCBNYXkgc3BlY2lmeSBhIHN0eWxlIEVsZW1lbnQgdG8gdXBkYXRlLlxuICovXG5mdW5jdGlvbiByZWdpc3RlclN0eWxlcyhzdHlsZUFycmF5KSB7XG4gICAgdmFyIGhlYWQgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdO1xuICAgIHZhciBzdHlsZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgIHZhciBfYSA9IHJlc29sdmVUaGVtYWJsZUFycmF5KHN0eWxlQXJyYXkpLCBzdHlsZVN0cmluZyA9IF9hLnN0eWxlU3RyaW5nLCB0aGVtYWJsZSA9IF9hLnRoZW1hYmxlO1xuICAgIHN0eWxlRWxlbWVudC50eXBlID0gJ3RleHQvY3NzJztcbiAgICBzdHlsZUVsZW1lbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoc3R5bGVTdHJpbmcpKTtcbiAgICBfdGhlbWVTdGF0ZS5wZXJmLmNvdW50Kys7XG4gICAgaGVhZC5hcHBlbmRDaGlsZChzdHlsZUVsZW1lbnQpO1xuICAgIHZhciByZWNvcmQgPSB7XG4gICAgICAgIHN0eWxlRWxlbWVudDogc3R5bGVFbGVtZW50LFxuICAgICAgICB0aGVtYWJsZVN0eWxlOiBzdHlsZUFycmF5XG4gICAgfTtcbiAgICBpZiAodGhlbWFibGUpIHtcbiAgICAgICAgX3RoZW1lU3RhdGUucmVnaXN0ZXJlZFRoZW1hYmxlU3R5bGVzLnB1c2gocmVjb3JkKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIF90aGVtZVN0YXRlLnJlZ2lzdGVyZWRTdHlsZXMucHVzaChyZWNvcmQpO1xuICAgIH1cbn1cbi8qKlxuICogUmVnaXN0ZXJzIGEgc2V0IG9mIHN0eWxlIHRleHQsIGZvciBJRSA5IGFuZCBiZWxvdywgd2hpY2ggaGFzIGEgfjMwIHN0eWxlIGVsZW1lbnQgbGltaXQgc28gd2UgbmVlZFxuICogdG8gcmVnaXN0ZXIgc2xpZ2h0bHkgZGlmZmVyZW50bHkuXG4gKiBAcGFyYW0ge1RoZW1hYmxlQXJyYXl9IHN0eWxlQXJyYXkgQXJyYXkgb2YgSVRoZW1pbmdJbnN0cnVjdGlvbiBvYmplY3RzIHRvIHJlZ2lzdGVyLlxuICogQHBhcmFtIHtJU3R5bGVSZWNvcmR9IHN0eWxlUmVjb3JkIE1heSBzcGVjaWZ5IGEgc3R5bGUgRWxlbWVudCB0byB1cGRhdGUuXG4gKi9cbmZ1bmN0aW9uIHJlZ2lzdGVyU3R5bGVzSUUoc3R5bGVBcnJheSwgc3R5bGVSZWNvcmQpIHtcbiAgICB2YXIgaGVhZCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdoZWFkJylbMF07XG4gICAgdmFyIHJlZ2lzdGVyZWRTdHlsZXMgPSBfdGhlbWVTdGF0ZS5yZWdpc3RlcmVkU3R5bGVzO1xuICAgIHZhciBsYXN0U3R5bGVFbGVtZW50ID0gX3RoZW1lU3RhdGUubGFzdFN0eWxlRWxlbWVudDtcbiAgICB2YXIgc3R5bGVzaGVldCA9IGxhc3RTdHlsZUVsZW1lbnQgPyBsYXN0U3R5bGVFbGVtZW50LnN0eWxlU2hlZXQgOiB1bmRlZmluZWQ7XG4gICAgdmFyIGxhc3RTdHlsZUNvbnRlbnQgPSBzdHlsZXNoZWV0ID8gc3R5bGVzaGVldC5jc3NUZXh0IDogJyc7XG4gICAgdmFyIGxhc3RSZWdpc3RlcmVkU3R5bGUgPSByZWdpc3RlcmVkU3R5bGVzW3JlZ2lzdGVyZWRTdHlsZXMubGVuZ3RoIC0gMV07XG4gICAgdmFyIHJlc29sdmVkU3R5bGVUZXh0ID0gcmVzb2x2ZVRoZW1hYmxlQXJyYXkoc3R5bGVBcnJheSkuc3R5bGVTdHJpbmc7XG4gICAgaWYgKCFsYXN0U3R5bGVFbGVtZW50IHx8IChsYXN0U3R5bGVDb250ZW50Lmxlbmd0aCArIHJlc29sdmVkU3R5bGVUZXh0Lmxlbmd0aCkgPiBNQVhfU1RZTEVfQ09OVEVOVF9TSVpFKSB7XG4gICAgICAgIGxhc3RTdHlsZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xuICAgICAgICBsYXN0U3R5bGVFbGVtZW50LnR5cGUgPSAndGV4dC9jc3MnO1xuICAgICAgICBpZiAoc3R5bGVSZWNvcmQpIHtcbiAgICAgICAgICAgIGhlYWQucmVwbGFjZUNoaWxkKGxhc3RTdHlsZUVsZW1lbnQsIHN0eWxlUmVjb3JkLnN0eWxlRWxlbWVudCk7XG4gICAgICAgICAgICBzdHlsZVJlY29yZC5zdHlsZUVsZW1lbnQgPSBsYXN0U3R5bGVFbGVtZW50O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaGVhZC5hcHBlbmRDaGlsZChsYXN0U3R5bGVFbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXN0eWxlUmVjb3JkKSB7XG4gICAgICAgICAgICBsYXN0UmVnaXN0ZXJlZFN0eWxlID0ge1xuICAgICAgICAgICAgICAgIHN0eWxlRWxlbWVudDogbGFzdFN0eWxlRWxlbWVudCxcbiAgICAgICAgICAgICAgICB0aGVtYWJsZVN0eWxlOiBzdHlsZUFycmF5XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcmVnaXN0ZXJlZFN0eWxlcy5wdXNoKGxhc3RSZWdpc3RlcmVkU3R5bGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGxhc3RTdHlsZUVsZW1lbnQuc3R5bGVTaGVldC5jc3NUZXh0ICs9IGRldG9rZW5pemUocmVzb2x2ZWRTdHlsZVRleHQpO1xuICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGxhc3RSZWdpc3RlcmVkU3R5bGUudGhlbWFibGVTdHlsZSwgc3R5bGVBcnJheSk7IC8vIGNvbmNhdCBpbi1wbGFjZVxuICAgIC8vIFByZXNlcnZlIHRoZSB0aGVtZSBzdGF0ZS5cbiAgICBfdGhlbWVTdGF0ZS5sYXN0U3R5bGVFbGVtZW50ID0gbGFzdFN0eWxlRWxlbWVudDtcbn1cbi8qKlxuICogQ2hlY2tzIHRvIHNlZSBpZiBzdHlsZVNoZWV0IGV4aXN0cyBhcyBhIHByb3BlcnR5IG9mZiBvZiBhIHN0eWxlIGVsZW1lbnQuXG4gKiBUaGlzIHdpbGwgZGV0ZXJtaW5lIGlmIHN0eWxlIHJlZ2lzdHJhdGlvbiBzaG91bGQgYmUgZG9uZSB2aWEgY3NzVGV4dCAoPD0gSUU5KSBvciBub3RcbiAqL1xuZnVuY3Rpb24gc2hvdWxkVXNlQ3NzVGV4dCgpIHtcbiAgICB2YXIgdXNlQ1NTVGV4dCA9IGZhbHNlO1xuICAgIGlmICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHZhciBlbXB0eVN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc3R5bGUnKTtcbiAgICAgICAgZW1wdHlTdHlsZS50eXBlID0gJ3RleHQvY3NzJztcbiAgICAgICAgdXNlQ1NTVGV4dCA9ICEhZW1wdHlTdHlsZS5zdHlsZVNoZWV0O1xuICAgIH1cbiAgICByZXR1cm4gdXNlQ1NTVGV4dDtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwXG4iLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcclxuLyoqXHJcbiAqIEluamVjdGlvbiBtb2RlIGZvciB0aGUgc3R5bGVzaGVldC5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxudmFyIEluamVjdGlvbk1vZGU7XHJcbihmdW5jdGlvbiAoSW5qZWN0aW9uTW9kZSkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBBdm9pZHMgc3R5bGUgaW5qZWN0aW9uLCB1c2UgZ2V0UnVsZXMoKSB0byByZWFkIHRoZSBzdHlsZXMuXHJcbiAgICAgKi9cclxuICAgIEluamVjdGlvbk1vZGVbSW5qZWN0aW9uTW9kZVtcIm5vbmVcIl0gPSAwXSA9IFwibm9uZVwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBJbnNlcnRzIHJ1bGVzIHVzaW5nIHRoZSBpbnNlcnRSdWxlIGFwaS5cclxuICAgICAqL1xyXG4gICAgSW5qZWN0aW9uTW9kZVtJbmplY3Rpb25Nb2RlW1wiaW5zZXJ0Tm9kZVwiXSA9IDFdID0gXCJpbnNlcnROb2RlXCI7XHJcbiAgICAvKipcclxuICAgICAqIEFwcGVuZHMgcnVsZXMgdXNpbmcgYXBwZW5kQ2hpbGQuXHJcbiAgICAgKi9cclxuICAgIEluamVjdGlvbk1vZGVbSW5qZWN0aW9uTW9kZVtcImFwcGVuZENoaWxkXCJdID0gMl0gPSBcImFwcGVuZENoaWxkXCI7XHJcbn0pKEluamVjdGlvbk1vZGUgPSBleHBvcnRzLkluamVjdGlvbk1vZGUgfHwgKGV4cG9ydHMuSW5qZWN0aW9uTW9kZSA9IHt9KSk7XHJcbnZhciBTVFlMRVNIRUVUX1NFVFRJTkcgPSAnX19zdHlsZXNoZWV0X18nO1xyXG52YXIgX3N0eWxlc2hlZXQ7XHJcbi8qKlxyXG4gKiBSZXByZXNlbnRzIHRoZSBzdGF0ZSBvZiBzdHlsZXMgcmVnaXN0ZXJlZCBpbiB0aGUgcGFnZS4gQWJzdHJhY3RzXHJcbiAqIHRoZSBzdXJmYWNlIGZvciBhZGRpbmcgc3R5bGVzIHRvIHRoZSBzdHlsZXNoZWV0LCBleHBvc2VzIGhlbHBlcnNcclxuICogZm9yIHJlYWRpbmcgdGhlIHN0eWxlcyByZWdpc3RlcmVkIGluIHNlcnZlciByZW5kZXJlZCBzY2VuYXJpb3MuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbnZhciBTdHlsZXNoZWV0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gU3R5bGVzaGVldChjb25maWcpIHtcclxuICAgICAgICB0aGlzLl9jb25maWcgPSB0c2xpYl8xLl9fYXNzaWduKHsgaW5qZWN0aW9uTW9kZTogMSAvKiBpbnNlcnROb2RlICovIH0sIGNvbmZpZyk7XHJcbiAgICAgICAgdGhpcy5yZXNldCgpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBHZXRzIHRoZSBzaW5nbGV0b24gaW5zdGFuY2UuXHJcbiAgICAgKi9cclxuICAgIFN0eWxlc2hlZXQuZ2V0SW5zdGFuY2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueVxyXG4gICAgICAgIHZhciB3aW4gPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHt9O1xyXG4gICAgICAgIF9zdHlsZXNoZWV0ID0gd2luW1NUWUxFU0hFRVRfU0VUVElOR107XHJcbiAgICAgICAgaWYgKCFfc3R5bGVzaGVldCkge1xyXG4gICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tc3RyaW5nLWxpdGVyYWxcclxuICAgICAgICAgICAgdmFyIGZhYnJpY0NvbmZpZyA9ICh3aW4gJiYgd2luWydGYWJyaWNDb25maWcnXSkgfHwge307XHJcbiAgICAgICAgICAgIF9zdHlsZXNoZWV0ID0gd2luW1NUWUxFU0hFRVRfU0VUVElOR10gPSBuZXcgU3R5bGVzaGVldChmYWJyaWNDb25maWcubWVyZ2VTdHlsZXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gX3N0eWxlc2hlZXQ7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDb25maWd1cmVzIHRoZSBzdHlsZXNoZWV0LlxyXG4gICAgICovXHJcbiAgICBTdHlsZXNoZWV0LnByb3RvdHlwZS5zZXRDb25maWcgPSBmdW5jdGlvbiAoY29uZmlnKSB7XHJcbiAgICAgICAgdGhpcy5fY29uZmlnID0gdHNsaWJfMS5fX2Fzc2lnbih7fSwgdGhpcy5fY29uZmlnLCBjb25maWcpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogR2VuZXJhdGVzIGEgdW5pcXVlIGNsYXNzbmFtZS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZGlzcGxheU5hbWUgLSBPcHRpb25hbCB2YWx1ZSB0byB1c2UgYXMgYSBwcmVmaXguXHJcbiAgICAgKi9cclxuICAgIFN0eWxlc2hlZXQucHJvdG90eXBlLmdldENsYXNzTmFtZSA9IGZ1bmN0aW9uIChkaXNwbGF5TmFtZSkge1xyXG4gICAgICAgIHZhciBwcmVmaXggPSBkaXNwbGF5TmFtZSB8fCAnY3NzJztcclxuICAgICAgICByZXR1cm4gcHJlZml4ICsgXCItXCIgKyB0aGlzLl9jb3VudGVyKys7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBVc2VkIGludGVybmFsbHkgdG8gY2FjaGUgaW5mb3JtYXRpb24gYWJvdXQgYSBjbGFzcyB3aGljaCB3YXNcclxuICAgICAqIHJlZ2lzdGVyZWQgd2l0aCB0aGUgc3R5bGVzaGVldC5cclxuICAgICAqL1xyXG4gICAgU3R5bGVzaGVldC5wcm90b3R5cGUuY2FjaGVDbGFzc05hbWUgPSBmdW5jdGlvbiAoY2xhc3NOYW1lLCBrZXksIGFyZ3MsIHJ1bGVzKSB7XHJcbiAgICAgICAgdGhpcy5fa2V5VG9DbGFzc05hbWVba2V5XSA9IGNsYXNzTmFtZTtcclxuICAgICAgICB0aGlzLl9jbGFzc05hbWVUb0FyZ3NbY2xhc3NOYW1lXSA9IHtcclxuICAgICAgICAgICAgYXJnczogYXJncyxcclxuICAgICAgICAgICAgcnVsZXM6IHJ1bGVzXHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIGFwcHJvcHJpYXRlIGNsYXNzbmFtZSBnaXZlbiBhIGtleSB3aGljaCB3YXMgcHJldmlvdXNseVxyXG4gICAgICogcmVnaXN0ZXJlZCB1c2luZyBjYWNoZUNsYXNzTmFtZS5cclxuICAgICAqL1xyXG4gICAgU3R5bGVzaGVldC5wcm90b3R5cGUuY2xhc3NOYW1lRnJvbUtleSA9IGZ1bmN0aW9uIChrZXkpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fa2V5VG9DbGFzc05hbWVba2V5XTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgdGhlIGFyZ3VtZW50cyBhc3NvY2lhdGVkIHdpdGggYSBnaXZlbiBjbGFzc25hbWUgd2hpY2ggd2FzXHJcbiAgICAgKiBwcmV2aW91c2x5IHJlZ2lzdGVyZWQgdXNpbmcgY2FjaGVDbGFzc05hbWUuXHJcbiAgICAgKi9cclxuICAgIFN0eWxlc2hlZXQucHJvdG90eXBlLmFyZ3NGcm9tQ2xhc3NOYW1lID0gZnVuY3Rpb24gKGNsYXNzTmFtZSkge1xyXG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMuX2NsYXNzTmFtZVRvQXJnc1tjbGFzc05hbWVdO1xyXG4gICAgICAgIHJldHVybiAoZW50cnkgJiYgZW50cnkuYXJncyk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICogR2V0cyB0aGUgYXJndW1lbnRzIGFzc29jaWF0ZWQgd2l0aCBhIGdpdmVuIGNsYXNzbmFtZSB3aGljaCB3YXNcclxuICAgKiBwcmV2aW91c2x5IHJlZ2lzdGVyZWQgdXNpbmcgY2FjaGVDbGFzc05hbWUuXHJcbiAgICovXHJcbiAgICBTdHlsZXNoZWV0LnByb3RvdHlwZS5pbnNlcnRlZFJ1bGVzRnJvbUNsYXNzTmFtZSA9IGZ1bmN0aW9uIChjbGFzc05hbWUpIHtcclxuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLl9jbGFzc05hbWVUb0FyZ3NbY2xhc3NOYW1lXTtcclxuICAgICAgICByZXR1cm4gKGVudHJ5ICYmIGVudHJ5LnJ1bGVzKTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEluc2VydHMgYSBjc3MgcnVsZSBpbnRvIHRoZSBzdHlsZXNoZWV0LlxyXG4gICAgICovXHJcbiAgICBTdHlsZXNoZWV0LnByb3RvdHlwZS5pbnNlcnRSdWxlID0gZnVuY3Rpb24gKHJ1bGUpIHtcclxuICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMuX2dldEVsZW1lbnQoKTtcclxuICAgICAgICB2YXIgaW5qZWN0aW9uTW9kZSA9IGVsZW1lbnQgPyB0aGlzLl9jb25maWcuaW5qZWN0aW9uTW9kZSA6IDAgLyogbm9uZSAqLztcclxuICAgICAgICBzd2l0Y2ggKGluamVjdGlvbk1vZGUpIHtcclxuICAgICAgICAgICAgY2FzZSAxIC8qIGluc2VydE5vZGUgKi86XHJcbiAgICAgICAgICAgICAgICB2YXIgc2hlZXQgPSBlbGVtZW50LnNoZWV0O1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYW55XHJcbiAgICAgICAgICAgICAgICAgICAgc2hlZXQuaW5zZXJ0UnVsZShydWxlLCBzaGVldC5jc3NSdWxlcy5sZW5ndGgpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAvKiBuby1vcCBvbiBlcnJvcnMgKi9cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICBjYXNlIDIgLyogYXBwZW5kQ2hpbGQgKi86XHJcbiAgICAgICAgICAgICAgICBfY3JlYXRlU3R5bGVFbGVtZW50KHJ1bGUpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9ydWxlcy5wdXNoKHJ1bGUpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLl9jb25maWcub25JbnNlcnRSdWxlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2NvbmZpZy5vbkluc2VydFJ1bGUocnVsZSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogR2V0cyBhbGwgcnVsZXMgcmVnaXN0ZXJlZCB3aXRoIHRoZSBzdHlsZXNoZWV0OyBvbmx5IHZhbGlkIHdoZW5cclxuICAgICAqIHVzaW5nIEluc2VydGlvbk1vZGUubm9uZS5cclxuICAgICAqL1xyXG4gICAgU3R5bGVzaGVldC5wcm90b3R5cGUuZ2V0UnVsZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuICh0aGlzLl9ydWxlcy5qb2luKCcnKSB8fCAnJykgKyAodGhpcy5fcnVsZXNUb0luc2VydC5qb2luKCcnKSB8fCAnJyk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNldHMgdGhlIGludGVybmFsIHN0YXRlIG9mIHRoZSBzdHlsZXNoZWV0LiBPbmx5IHVzZWQgaW4gc2VydmVyXHJcbiAgICAgKiByZW5kZXJlZCBzY2VuYXJpb3Mgd2hlcmUgd2UncmUgdXNpbmcgSW5zZXJ0aW9uTW9kZS5ub25lLlxyXG4gICAgICovXHJcbiAgICBTdHlsZXNoZWV0LnByb3RvdHlwZS5yZXNldCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLl9ydWxlcyA9IFtdO1xyXG4gICAgICAgIHRoaXMuX3J1bGVzVG9JbnNlcnQgPSBbXTtcclxuICAgICAgICB0aGlzLl9jb3VudGVyID0gMDtcclxuICAgICAgICB0aGlzLl9jbGFzc05hbWVUb0FyZ3MgPSB7fTtcclxuICAgICAgICB0aGlzLl9rZXlUb0NsYXNzTmFtZSA9IHt9O1xyXG4gICAgICAgIGlmICh0aGlzLl90aW1lcklkKSB7XHJcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lcklkKTtcclxuICAgICAgICAgICAgdGhpcy5fdGltZXJJZCA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFN0eWxlc2hlZXQucHJvdG90eXBlLl9nZXRFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5fc3R5bGVFbGVtZW50ICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICAgICAgdGhpcy5fc3R5bGVFbGVtZW50ID0gX2NyZWF0ZVN0eWxlRWxlbWVudCgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fc3R5bGVFbGVtZW50O1xyXG4gICAgfTtcclxuICAgIHJldHVybiBTdHlsZXNoZWV0O1xyXG59KCkpO1xyXG5leHBvcnRzLlN0eWxlc2hlZXQgPSBTdHlsZXNoZWV0O1xyXG5mdW5jdGlvbiBfY3JlYXRlU3R5bGVFbGVtZW50KGNvbnRlbnQpIHtcclxuICAgIHZhciBzdHlsZUVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzdHlsZScpO1xyXG4gICAgc3R5bGVFbGVtZW50LnNldEF0dHJpYnV0ZSgnZGF0YS1tZXJnZS1zdHlsZXMnLCAndHJ1ZScpO1xyXG4gICAgc3R5bGVFbGVtZW50LnR5cGUgPSAndGV4dC9jc3MnO1xyXG4gICAgaWYgKGNvbnRlbnQpIHtcclxuICAgICAgICBzdHlsZUVsZW1lbnQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY29udGVudCkpO1xyXG4gICAgfVxyXG4gICAgZG9jdW1lbnQuaGVhZC5hcHBlbmRDaGlsZChzdHlsZUVsZW1lbnQpO1xyXG4gICAgcmV0dXJuIHN0eWxlRWxlbWVudDtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1TdHlsZXNoZWV0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbi8qKlxyXG4gKiBDb21iaW5lIGEgc2V0IG9mIHN0eWxlcyB0b2dldGhlciAoYnV0IGRvZXMgbm90IHJlZ2lzdGVyIGNzcyBjbGFzc2VzLilcclxuICogQHB1YmxpY1xyXG4gKi9cclxuZnVuY3Rpb24gY29uY2F0U3R5bGVTZXRzKCkge1xyXG4gICAgdmFyIGFyZ3MgPSBbXTtcclxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgfVxyXG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueVxyXG4gICAgdmFyIG1lcmdlZFNldCA9IHt9O1xyXG4gICAgZm9yICh2YXIgX2EgPSAwLCBhcmdzXzEgPSBhcmdzOyBfYSA8IGFyZ3NfMS5sZW5ndGg7IF9hKyspIHtcclxuICAgICAgICB2YXIgY3VycmVudFNldCA9IGFyZ3NfMVtfYV07XHJcbiAgICAgICAgaWYgKGN1cnJlbnRTZXQpIHtcclxuICAgICAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBjdXJyZW50U2V0KSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudFNldC5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBtZXJnZWRWYWx1ZSA9IG1lcmdlZFNldFtwcm9wXTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgY3VycmVudFZhbHVlID0gY3VycmVudFNldFtwcm9wXTtcclxuICAgICAgICAgICAgICAgICAgICBpZiAobWVyZ2VkVmFsdWUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXJnZWRTZXRbcHJvcF0gPSBjdXJyZW50VmFsdWU7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBtZXJnZWRTZXRbcHJvcF0gPSAoQXJyYXkuaXNBcnJheShtZXJnZWRWYWx1ZSkgPyBtZXJnZWRWYWx1ZSA6IFttZXJnZWRWYWx1ZV0pLmNvbmNhdCgoQXJyYXkuaXNBcnJheShjdXJyZW50VmFsdWUpID8gY3VycmVudFZhbHVlIDogW2N1cnJlbnRWYWx1ZV0pKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbWVyZ2VkU2V0O1xyXG59XHJcbmV4cG9ydHMuY29uY2F0U3R5bGVTZXRzID0gY29uY2F0U3R5bGVTZXRzO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jb25jYXRTdHlsZVNldHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIFN0eWxlc2hlZXRfMSA9IHJlcXVpcmUoXCIuL1N0eWxlc2hlZXRcIik7XHJcbi8qKlxyXG4gKiBTZXBhcmF0ZXMgdGhlIGNsYXNzZXMgYW5kIHN0eWxlIG9iamVjdHMuIEFueSBjbGFzc2VzIHRoYXQgYXJlIHByZS1yZWdpc3RlcmVkXHJcbiAqIGFyZ3MgYXJlIGF1dG8gZXhwYW5kZWQgaW50byBvYmplY3RzLlxyXG4gKi9cclxuZnVuY3Rpb24gZXh0cmFjdFN0eWxlUGFydHMoKSB7XHJcbiAgICB2YXIgYXJncyA9IFtdO1xyXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICB9XHJcbiAgICB2YXIgY2xhc3NlcyA9IFtdO1xyXG4gICAgdmFyIG9iamVjdHMgPSBbXTtcclxuICAgIHZhciBzdHlsZXNoZWV0ID0gU3R5bGVzaGVldF8xLlN0eWxlc2hlZXQuZ2V0SW5zdGFuY2UoKTtcclxuICAgIGZ1bmN0aW9uIF9wcm9jZXNzQXJncyhhcmdzTGlzdCkge1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgYXJnc0xpc3RfMSA9IGFyZ3NMaXN0OyBfaSA8IGFyZ3NMaXN0XzEubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBhcmcgPSBhcmdzTGlzdF8xW19pXTtcclxuICAgICAgICAgICAgaWYgKGFyZykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGFyZy5pbmRleE9mKCcgJykgPj0gMCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfcHJvY2Vzc0FyZ3MoYXJnLnNwbGl0KCcgJykpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRyYW5zbGF0ZWRBcmdzID0gc3R5bGVzaGVldC5hcmdzRnJvbUNsYXNzTmFtZShhcmcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodHJhbnNsYXRlZEFyZ3MpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9wcm9jZXNzQXJncyh0cmFuc2xhdGVkQXJncyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBdm9pZCBhZGRpbmcgdGhlIHNhbWUgY2xhc3MgdHdpY2UuXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY2xhc3Nlcy5pbmRleE9mKGFyZykgPT09IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3Nlcy5wdXNoKGFyZyk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGFyZykpIHtcclxuICAgICAgICAgICAgICAgICAgICBfcHJvY2Vzc0FyZ3MoYXJnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBhcmcgPT09ICdvYmplY3QnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgb2JqZWN0cy5wdXNoKGFyZyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBfcHJvY2Vzc0FyZ3MoYXJncyk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGNsYXNzZXM6IGNsYXNzZXMsXHJcbiAgICAgICAgb2JqZWN0czogb2JqZWN0c1xyXG4gICAgfTtcclxufVxyXG5leHBvcnRzLmV4dHJhY3RTdHlsZVBhcnRzID0gZXh0cmFjdFN0eWxlUGFydHM7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWV4dHJhY3RTdHlsZVBhcnRzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBTdHlsZXNoZWV0XzEgPSByZXF1aXJlKFwiLi9TdHlsZXNoZWV0XCIpO1xyXG52YXIgc3R5bGVUb0NsYXNzTmFtZV8xID0gcmVxdWlyZShcIi4vc3R5bGVUb0NsYXNzTmFtZVwiKTtcclxuLyoqXHJcbiAqIFJlZ2lzdGVycyBhIGZvbnQgZmFjZS5cclxuICogQHB1YmxpY1xyXG4gKi9cclxuZnVuY3Rpb24gZm9udEZhY2UoZm9udCkge1xyXG4gICAgU3R5bGVzaGVldF8xLlN0eWxlc2hlZXQuZ2V0SW5zdGFuY2UoKS5pbnNlcnRSdWxlKFwiQGZvbnQtZmFjZXtcIiArIHN0eWxlVG9DbGFzc05hbWVfMS5zZXJpYWxpemVSdWxlRW50cmllcyhmb250KSArIFwifVwiKTtcclxufVxyXG5leHBvcnRzLmZvbnRGYWNlID0gZm9udEZhY2U7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZvbnRGYWNlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBfdmVuZG9yU2V0dGluZ3M7XHJcbmZ1bmN0aW9uIGdldFZlbmRvclNldHRpbmdzKCkge1xyXG4gICAgaWYgKCFfdmVuZG9yU2V0dGluZ3MpIHtcclxuICAgICAgICB2YXIgZG9jID0gdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJyA/IGRvY3VtZW50IDogdW5kZWZpbmVkO1xyXG4gICAgICAgIHZhciBuYXYgPSB0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyA/IG5hdmlnYXRvciA6IHVuZGVmaW5lZDtcclxuICAgICAgICB2YXIgdXNlckFnZW50ID0gbmF2ID8gbmF2LnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpIDogdW5kZWZpbmVkO1xyXG4gICAgICAgIGlmICghZG9jKSB7XHJcbiAgICAgICAgICAgIF92ZW5kb3JTZXR0aW5ncyA9IHtcclxuICAgICAgICAgICAgICAgIGlzV2Via2l0OiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgaXNNb3o6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBpc09wZXJhOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgaXNNczogdHJ1ZVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgX3ZlbmRvclNldHRpbmdzID0ge1xyXG4gICAgICAgICAgICAgICAgaXNXZWJraXQ6ICEhKGRvYyAmJiAnV2Via2l0QXBwZWFyYW5jZScgaW4gZG9jLmRvY3VtZW50RWxlbWVudC5zdHlsZSksXHJcbiAgICAgICAgICAgICAgICBpc01vejogISEodXNlckFnZW50ICYmIHVzZXJBZ2VudC5pbmRleE9mKCdmaXJlZm94JykgPiAtMSksXHJcbiAgICAgICAgICAgICAgICBpc09wZXJhOiAhISh1c2VyQWdlbnQgJiYgdXNlckFnZW50LmluZGV4T2YoJ29wZXJhJykgPiAtMSksXHJcbiAgICAgICAgICAgICAgICBpc01zOiAhIShuYXYgJiYgKC9ydjoxMS4wL2kudGVzdChuYXYudXNlckFnZW50KSB8fCAvRWRnZVxcL1xcZC4vaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpKSlcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gX3ZlbmRvclNldHRpbmdzO1xyXG59XHJcbmV4cG9ydHMuZ2V0VmVuZG9yU2V0dGluZ3MgPSBnZXRWZW5kb3JTZXR0aW5ncztcclxuLyoqXHJcbiAqIFNldHMgdGhlIHZlbmRvciBzZXR0aW5ncyBmb3IgcHJlZml4aW5nIGFuZCB2ZW5kb3Igc3BlY2lmaWMgb3BlcmF0aW9ucy5cclxuICovXHJcbmZ1bmN0aW9uIHNldFZlbmRvclNldHRpbmdzKHZlbmRvclNldHRpbmdzKSB7XHJcbiAgICBfdmVuZG9yU2V0dGluZ3MgPSB2ZW5kb3JTZXR0aW5ncztcclxufVxyXG5leHBvcnRzLnNldFZlbmRvclNldHRpbmdzID0gc2V0VmVuZG9yU2V0dGluZ3M7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWdldFZlbmRvclNldHRpbmdzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBtZXJnZVN0eWxlc18xID0gcmVxdWlyZShcIi4vbWVyZ2VTdHlsZXNcIik7XHJcbmV4cG9ydHMubWVyZ2VTdHlsZXMgPSBtZXJnZVN0eWxlc18xLm1lcmdlU3R5bGVzO1xyXG52YXIgbWVyZ2VTdHlsZVNldHNfMSA9IHJlcXVpcmUoXCIuL21lcmdlU3R5bGVTZXRzXCIpO1xyXG5leHBvcnRzLm1lcmdlU3R5bGVTZXRzID0gbWVyZ2VTdHlsZVNldHNfMS5tZXJnZVN0eWxlU2V0cztcclxudmFyIGNvbmNhdFN0eWxlU2V0c18xID0gcmVxdWlyZShcIi4vY29uY2F0U3R5bGVTZXRzXCIpO1xyXG5leHBvcnRzLmNvbmNhdFN0eWxlU2V0cyA9IGNvbmNhdFN0eWxlU2V0c18xLmNvbmNhdFN0eWxlU2V0cztcclxudmFyIGZvbnRGYWNlXzEgPSByZXF1aXJlKFwiLi9mb250RmFjZVwiKTtcclxuZXhwb3J0cy5mb250RmFjZSA9IGZvbnRGYWNlXzEuZm9udEZhY2U7XHJcbnZhciBrZXlmcmFtZXNfMSA9IHJlcXVpcmUoXCIuL2tleWZyYW1lc1wiKTtcclxuZXhwb3J0cy5rZXlmcmFtZXMgPSBrZXlmcmFtZXNfMS5rZXlmcmFtZXM7XHJcbnZhciBTdHlsZXNoZWV0XzEgPSByZXF1aXJlKFwiLi9TdHlsZXNoZWV0XCIpO1xyXG5leHBvcnRzLkluamVjdGlvbk1vZGUgPSBTdHlsZXNoZWV0XzEuSW5qZWN0aW9uTW9kZTtcclxuZXhwb3J0cy5TdHlsZXNoZWV0ID0gU3R5bGVzaGVldF8xLlN0eWxlc2hlZXQ7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBTdHlsZXNoZWV0XzEgPSByZXF1aXJlKFwiLi9TdHlsZXNoZWV0XCIpO1xyXG52YXIgc3R5bGVUb0NsYXNzTmFtZV8xID0gcmVxdWlyZShcIi4vc3R5bGVUb0NsYXNzTmFtZVwiKTtcclxuLyoqXHJcbiAqIFJlZ2lzdGVycyBrZXlmcmFtZSBkZWZpbml0aW9ucy5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuZnVuY3Rpb24ga2V5ZnJhbWVzKHRpbWVsaW5lKSB7XHJcbiAgICB2YXIgc3R5bGVzaGVldCA9IFN0eWxlc2hlZXRfMS5TdHlsZXNoZWV0LmdldEluc3RhbmNlKCk7XHJcbiAgICB2YXIgbmFtZSA9IHN0eWxlc2hlZXQuZ2V0Q2xhc3NOYW1lKCk7XHJcbiAgICB2YXIgcnVsZXNBcnJheSA9IFtdO1xyXG4gICAgZm9yICh2YXIgcHJvcCBpbiB0aW1lbGluZSkge1xyXG4gICAgICAgIGlmICh0aW1lbGluZS5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xyXG4gICAgICAgICAgICBydWxlc0FycmF5LnB1c2gocHJvcCwgJ3snLCBzdHlsZVRvQ2xhc3NOYW1lXzEuc2VyaWFsaXplUnVsZUVudHJpZXModGltZWxpbmVbcHJvcF0pLCAnfScpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHZhciBydWxlcyA9IHJ1bGVzQXJyYXkuam9pbignJyk7XHJcbiAgICBzdHlsZXNoZWV0Lmluc2VydFJ1bGUoXCJAa2V5ZnJhbWVzIFwiICsgbmFtZSArIFwie1wiICsgcnVsZXMgKyBcIn1cIik7XHJcbiAgICAvLyBJZiBuZWVkZWQgbGF0ZXIsIHdlIHdvdWxkIGFkZCB2ZW5kb3IgcHJlZml4ZXMgaGVyZS5cclxuICAgIHJldHVybiBuYW1lO1xyXG59XHJcbmV4cG9ydHMua2V5ZnJhbWVzID0ga2V5ZnJhbWVzO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1rZXlmcmFtZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIGV4dHJhY3RTdHlsZVBhcnRzXzEgPSByZXF1aXJlKFwiLi9leHRyYWN0U3R5bGVQYXJ0c1wiKTtcclxudmFyIGNvbmNhdFN0eWxlU2V0c18xID0gcmVxdWlyZShcIi4vY29uY2F0U3R5bGVTZXRzXCIpO1xyXG52YXIgc3R5bGVUb0NsYXNzTmFtZV8xID0gcmVxdWlyZShcIi4vc3R5bGVUb0NsYXNzTmFtZVwiKTtcclxuLyoqXHJcbiAqIEFsbG93cyB5b3UgdG8gcGFzcyBpbiAxIG9yIG1vcmUgc2V0cyBvZiBhcmVhcyB3aGljaCB3aWxsIHJldHVybiBhIG1lcmdlZFxyXG4gKiBzZXQgb2YgY2xhc3Nlcy5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuZnVuY3Rpb24gbWVyZ2VTdHlsZVNldHMoKSB7XHJcbiAgICB2YXIgY3NzU2V0cyA9IFtdO1xyXG4gICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICBjc3NTZXRzW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICB9XHJcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYW55XHJcbiAgICB2YXIgY2xhc3NOYW1lU2V0ID0ge307XHJcbiAgICB2YXIgY2xhc3NNYXAgPSB7fTtcclxuICAgIHZhciBjc3NTZXQgPSBjc3NTZXRzWzBdO1xyXG4gICAgaWYgKGNzc1NldCkge1xyXG4gICAgICAgIGlmIChjc3NTZXRzLmxlbmd0aCA+IDEpIHtcclxuICAgICAgICAgICAgY3NzU2V0ID0gY29uY2F0U3R5bGVTZXRzXzEuY29uY2F0U3R5bGVTZXRzLmFwcGx5KHZvaWQgMCwgY3NzU2V0cyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciByZWdpc3RyYXRpb25zID0gW107XHJcbiAgICAgICAgZm9yICh2YXIgcHJvcCBpbiBjc3NTZXQpIHtcclxuICAgICAgICAgICAgaWYgKGNzc1NldC5oYXNPd25Qcm9wZXJ0eShwcm9wKSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBjc3NTZXRbcHJvcF07XHJcbiAgICAgICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYW55XHJcbiAgICAgICAgICAgICAgICB2YXIgX2EgPSBleHRyYWN0U3R5bGVQYXJ0c18xLmV4dHJhY3RTdHlsZVBhcnRzKGFyZ3MpLCBjbGFzc2VzID0gX2EuY2xhc3Nlcywgb2JqZWN0cyA9IF9hLm9iamVjdHM7XHJcbiAgICAgICAgICAgICAgICB2YXIgcmVnaXN0cmF0aW9uID0gc3R5bGVUb0NsYXNzTmFtZV8xLnN0eWxlVG9SZWdpc3RyYXRpb24oeyBkaXNwbGF5TmFtZTogcHJvcCB9LCBvYmplY3RzKTtcclxuICAgICAgICAgICAgICAgIHJlZ2lzdHJhdGlvbnMucHVzaChyZWdpc3RyYXRpb24pO1xyXG4gICAgICAgICAgICAgICAgaWYgKHJlZ2lzdHJhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzTWFwW3Byb3BdID0gcmVnaXN0cmF0aW9uLmNsYXNzTmFtZTtcclxuICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWVTZXRbcHJvcF0gPSBjbGFzc2VzLmNvbmNhdChbcmVnaXN0cmF0aW9uLmNsYXNzTmFtZV0pLmpvaW4oJyAnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBmb3IgKHZhciBfYiA9IDAsIHJlZ2lzdHJhdGlvbnNfMSA9IHJlZ2lzdHJhdGlvbnM7IF9iIDwgcmVnaXN0cmF0aW9uc18xLmxlbmd0aDsgX2IrKykge1xyXG4gICAgICAgICAgICB2YXIgcmVnaXN0cmF0aW9uID0gcmVnaXN0cmF0aW9uc18xW19iXTtcclxuICAgICAgICAgICAgaWYgKHJlZ2lzdHJhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgc3R5bGVUb0NsYXNzTmFtZV8xLmFwcGx5UmVnaXN0cmF0aW9uKHJlZ2lzdHJhdGlvbiwgY2xhc3NNYXApO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNsYXNzTmFtZVNldDtcclxufVxyXG5leHBvcnRzLm1lcmdlU3R5bGVTZXRzID0gbWVyZ2VTdHlsZVNldHM7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW1lcmdlU3R5bGVTZXRzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBzdHlsZVRvQ2xhc3NOYW1lXzEgPSByZXF1aXJlKFwiLi9zdHlsZVRvQ2xhc3NOYW1lXCIpO1xyXG52YXIgZXh0cmFjdFN0eWxlUGFydHNfMSA9IHJlcXVpcmUoXCIuL2V4dHJhY3RTdHlsZVBhcnRzXCIpO1xyXG4vKipcclxuICogQ29uY2F0aW5hdGlvbiBoZWxwZXIsIHdoaWNoIGNhbiBtZXJnZSBjbGFzcyBuYW1lcyB0b2dldGhlci4gU2tpcHMgb3ZlciBmYWxzZXkgdmFsdWVzLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5mdW5jdGlvbiBtZXJnZVN0eWxlcygpIHtcclxuICAgIHZhciBhcmdzID0gW107XHJcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgIH1cclxuICAgIHZhciBfYSA9IGV4dHJhY3RTdHlsZVBhcnRzXzEuZXh0cmFjdFN0eWxlUGFydHMoYXJncyksIGNsYXNzZXMgPSBfYS5jbGFzc2VzLCBvYmplY3RzID0gX2Eub2JqZWN0cztcclxuICAgIGlmIChvYmplY3RzLmxlbmd0aCkge1xyXG4gICAgICAgIGNsYXNzZXMucHVzaChzdHlsZVRvQ2xhc3NOYW1lXzEuc3R5bGVUb0NsYXNzTmFtZShvYmplY3RzKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY2xhc3Nlcy5qb2luKCcgJyk7XHJcbn1cclxuZXhwb3J0cy5tZXJnZVN0eWxlcyA9IG1lcmdlU3R5bGVzO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZXJnZVN0eWxlcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgU3R5bGVzaGVldF8xID0gcmVxdWlyZShcIi4vU3R5bGVzaGVldFwiKTtcclxudmFyIGtlYmFiUnVsZXNfMSA9IHJlcXVpcmUoXCIuL3RyYW5zZm9ybXMva2ViYWJSdWxlc1wiKTtcclxudmFyIHByZWZpeFJ1bGVzXzEgPSByZXF1aXJlKFwiLi90cmFuc2Zvcm1zL3ByZWZpeFJ1bGVzXCIpO1xyXG52YXIgcHJvdmlkZVVuaXRzXzEgPSByZXF1aXJlKFwiLi90cmFuc2Zvcm1zL3Byb3ZpZGVVbml0c1wiKTtcclxudmFyIHJ0bGlmeVJ1bGVzXzEgPSByZXF1aXJlKFwiLi90cmFuc2Zvcm1zL3J0bGlmeVJ1bGVzXCIpO1xyXG52YXIgRElTUExBWV9OQU1FID0gJ2Rpc3BsYXlOYW1lJztcclxuZnVuY3Rpb24gZ2V0RGlzcGxheU5hbWUocnVsZXMpIHtcclxuICAgIHZhciByb290U3R5bGUgPSBydWxlcyAmJiBydWxlc1snJiddO1xyXG4gICAgcmV0dXJuIHJvb3RTdHlsZSA/IHJvb3RTdHlsZS5kaXNwbGF5TmFtZSA6IHVuZGVmaW5lZDtcclxufVxyXG5mdW5jdGlvbiBleHRyYWN0UnVsZXMoYXJncywgcnVsZXMsIGN1cnJlbnRTZWxlY3Rvcikge1xyXG4gICAgaWYgKHJ1bGVzID09PSB2b2lkIDApIHsgcnVsZXMgPSB7IF9fb3JkZXI6IFtdIH07IH1cclxuICAgIGlmIChjdXJyZW50U2VsZWN0b3IgPT09IHZvaWQgMCkgeyBjdXJyZW50U2VsZWN0b3IgPSAnJic7IH1cclxuICAgIHZhciBzdHlsZXNoZWV0ID0gU3R5bGVzaGVldF8xLlN0eWxlc2hlZXQuZ2V0SW5zdGFuY2UoKTtcclxuICAgIHZhciBjdXJyZW50UnVsZXMgPSBydWxlc1tjdXJyZW50U2VsZWN0b3JdO1xyXG4gICAgaWYgKCFjdXJyZW50UnVsZXMpIHtcclxuICAgICAgICBjdXJyZW50UnVsZXMgPSB7fTtcclxuICAgICAgICBydWxlc1tjdXJyZW50U2VsZWN0b3JdID0gY3VycmVudFJ1bGVzO1xyXG4gICAgICAgIHJ1bGVzLl9fb3JkZXIucHVzaChjdXJyZW50U2VsZWN0b3IpO1xyXG4gICAgfVxyXG4gICAgZm9yICh2YXIgX2kgPSAwLCBhcmdzXzEgPSBhcmdzOyBfaSA8IGFyZ3NfMS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICB2YXIgYXJnID0gYXJnc18xW19pXTtcclxuICAgICAgICAvLyBJZiB0aGUgYXJnIGlzIGEgc3RyaW5nLCB3ZSBuZWVkIHRvIGxvb2sgdXAgdGhlIGNsYXNzIG1hcCBhbmQgbWVyZ2UuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIHZhciBleHBhbmRlZFJ1bGVzID0gc3R5bGVzaGVldC5hcmdzRnJvbUNsYXNzTmFtZShhcmcpO1xyXG4gICAgICAgICAgICBpZiAoZXhwYW5kZWRSdWxlcykge1xyXG4gICAgICAgICAgICAgICAgZXh0cmFjdFJ1bGVzKGV4cGFuZGVkUnVsZXMsIHJ1bGVzLCBjdXJyZW50U2VsZWN0b3IpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIEVsc2UgaWYgdGhlIGFyZyBpcyBhbiBhcnJheSwgd2UgbmVlZCB0byByZWN1cnNlIGluLlxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChBcnJheS5pc0FycmF5KGFyZykpIHtcclxuICAgICAgICAgICAgZXh0cmFjdFJ1bGVzKGFyZywgcnVsZXMsIGN1cnJlbnRTZWxlY3Rvcik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYW55XHJcbiAgICAgICAgICAgIGZvciAodmFyIHByb3AgaW4gYXJnKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAocHJvcCA9PT0gJ3NlbGVjdG9ycycpIHtcclxuICAgICAgICAgICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYW55XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIHNlbGVjdG9ycyA9IGFyZy5zZWxlY3RvcnM7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgbmV3U2VsZWN0b3IgaW4gc2VsZWN0b3JzKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxlY3RvcnMuaGFzT3duUHJvcGVydHkobmV3U2VsZWN0b3IpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgc2VsZWN0b3JWYWx1ZSA9IHNlbGVjdG9yc1tuZXdTZWxlY3Rvcl07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobmV3U2VsZWN0b3IuaW5kZXhPZignQG1lZGlhJykgPT09IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdTZWxlY3RvciA9IG5ld1NlbGVjdG9yICsgJ3snICsgY3VycmVudFNlbGVjdG9yO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAobmV3U2VsZWN0b3IuaW5kZXhPZignOicpID09PSAwKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmV3U2VsZWN0b3IgPSBjdXJyZW50U2VsZWN0b3IgKyBuZXdTZWxlY3RvcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKG5ld1NlbGVjdG9yLmluZGV4T2YoJyYnKSA8IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXdTZWxlY3RvciA9IGN1cnJlbnRTZWxlY3RvciArICcgJyArIG5ld1NlbGVjdG9yO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZXh0cmFjdFJ1bGVzKFtzZWxlY3RvclZhbHVlXSwgcnVsZXMsIG5ld1NlbGVjdG9yKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIEVsc2UsIGFkZCB0aGUgcnVsZSB0byB0aGUgY3VycmVudFNlbGVjdG9yLlxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChwcm9wID09PSAnbWFyZ2luJyB8fCBwcm9wID09PSAncGFkZGluZycpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBleHBhbmRRdWFkcyhjdXJyZW50UnVsZXMsIHByb3AsIGFyZ1twcm9wXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYW55XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGN1cnJlbnRSdWxlc1twcm9wXSA9IGFyZ1twcm9wXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gcnVsZXM7XHJcbn1cclxuZnVuY3Rpb24gZXhwYW5kUXVhZHMoY3VycmVudFJ1bGVzLCBuYW1lLCB2YWx1ZSkge1xyXG4gICAgdmFyIHBhcnRzID0gKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpID8gdmFsdWUuc3BsaXQoJyAnKSA6IFt2YWx1ZV07XHJcbiAgICBjdXJyZW50UnVsZXNbbmFtZSArICdUb3AnXSA9IHBhcnRzWzBdO1xyXG4gICAgY3VycmVudFJ1bGVzW25hbWUgKyAnUmlnaHQnXSA9IHBhcnRzWzFdIHx8IHBhcnRzWzBdO1xyXG4gICAgY3VycmVudFJ1bGVzW25hbWUgKyAnQm90dG9tJ10gPSBwYXJ0c1syXSB8fCBwYXJ0c1swXTtcclxuICAgIGN1cnJlbnRSdWxlc1tuYW1lICsgJ0xlZnQnXSA9IHBhcnRzWzNdIHx8IHBhcnRzWzFdIHx8IHBhcnRzWzBdO1xyXG59XHJcbmZ1bmN0aW9uIGdldEtleUZvclJ1bGVzKHJ1bGVzKSB7XHJcbiAgICB2YXIgc2VyaWFsaXplZCA9IFtdO1xyXG4gICAgdmFyIGhhc1Byb3BzID0gZmFsc2U7XHJcbiAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gcnVsZXMuX19vcmRlcjsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICB2YXIgc2VsZWN0b3IgPSBfYVtfaV07XHJcbiAgICAgICAgc2VyaWFsaXplZC5wdXNoKHNlbGVjdG9yKTtcclxuICAgICAgICB2YXIgcnVsZXNGb3JTZWxlY3RvciA9IHJ1bGVzW3NlbGVjdG9yXTtcclxuICAgICAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiBydWxlc0ZvclNlbGVjdG9yKSB7XHJcbiAgICAgICAgICAgIGlmIChydWxlc0ZvclNlbGVjdG9yLmhhc093blByb3BlcnR5KHByb3BOYW1lKSkge1xyXG4gICAgICAgICAgICAgICAgaGFzUHJvcHMgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgc2VyaWFsaXplZC5wdXNoKHByb3BOYW1lLCBydWxlc0ZvclNlbGVjdG9yW3Byb3BOYW1lXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaGFzUHJvcHMgPyBzZXJpYWxpemVkLmpvaW4oJycpIDogdW5kZWZpbmVkO1xyXG59XHJcbmZ1bmN0aW9uIHNlcmlhbGl6ZVJ1bGVFbnRyaWVzKHJ1bGVFbnRyaWVzKSB7XHJcbiAgICBpZiAoIXJ1bGVFbnRyaWVzKSB7XHJcbiAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgfVxyXG4gICAgdmFyIGFsbEVudHJpZXMgPSBbXTtcclxuICAgIGZvciAodmFyIGVudHJ5IGluIHJ1bGVFbnRyaWVzKSB7XHJcbiAgICAgICAgaWYgKHJ1bGVFbnRyaWVzLmhhc093blByb3BlcnR5KGVudHJ5KSAmJiBlbnRyeSAhPT0gRElTUExBWV9OQU1FKSB7XHJcbiAgICAgICAgICAgIGFsbEVudHJpZXMucHVzaChlbnRyeSwgcnVsZUVudHJpZXNbZW50cnldKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICAvLyBBcHBseSB0cmFuc2Zvcm1zLlxyXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhbGxFbnRyaWVzLmxlbmd0aDsgaSArPSAyKSB7XHJcbiAgICAgICAga2ViYWJSdWxlc18xLmtlYmFiUnVsZXMoYWxsRW50cmllcywgaSk7XHJcbiAgICAgICAgcHJvdmlkZVVuaXRzXzEucHJvdmlkZVVuaXRzKGFsbEVudHJpZXMsIGkpO1xyXG4gICAgICAgIHJ0bGlmeVJ1bGVzXzEucnRsaWZ5UnVsZXMoYWxsRW50cmllcywgaSk7XHJcbiAgICAgICAgcHJlZml4UnVsZXNfMS5wcmVmaXhSdWxlcyhhbGxFbnRyaWVzLCBpKTtcclxuICAgIH1cclxuICAgIC8vIEFwcGx5IHB1bmN0dWF0aW9uLlxyXG4gICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhbGxFbnRyaWVzLmxlbmd0aDsgaSArPSA0KSB7XHJcbiAgICAgICAgYWxsRW50cmllcy5zcGxpY2UoaSwgMSwgJzonLCBhbGxFbnRyaWVzW2ldLCAnOycpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGFsbEVudHJpZXMuam9pbignJyk7XHJcbn1cclxuZXhwb3J0cy5zZXJpYWxpemVSdWxlRW50cmllcyA9IHNlcmlhbGl6ZVJ1bGVFbnRyaWVzO1xyXG5mdW5jdGlvbiBzdHlsZVRvUmVnaXN0cmF0aW9uKCkge1xyXG4gICAgdmFyIGFyZ3MgPSBbXTtcclxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgfVxyXG4gICAgdmFyIHJ1bGVzID0gZXh0cmFjdFJ1bGVzKGFyZ3MpO1xyXG4gICAgdmFyIGtleSA9IGdldEtleUZvclJ1bGVzKHJ1bGVzKTtcclxuICAgIGlmIChrZXkpIHtcclxuICAgICAgICB2YXIgc3R5bGVzaGVldCA9IFN0eWxlc2hlZXRfMS5TdHlsZXNoZWV0LmdldEluc3RhbmNlKCk7XHJcbiAgICAgICAgdmFyIHJlZ2lzdHJhdGlvbiA9IHtcclxuICAgICAgICAgICAgY2xhc3NOYW1lOiBzdHlsZXNoZWV0LmNsYXNzTmFtZUZyb21LZXkoa2V5KSxcclxuICAgICAgICAgICAga2V5OiBrZXksXHJcbiAgICAgICAgICAgIGFyZ3M6IGFyZ3NcclxuICAgICAgICB9O1xyXG4gICAgICAgIGlmICghcmVnaXN0cmF0aW9uLmNsYXNzTmFtZSkge1xyXG4gICAgICAgICAgICByZWdpc3RyYXRpb24uY2xhc3NOYW1lID0gc3R5bGVzaGVldC5nZXRDbGFzc05hbWUoZ2V0RGlzcGxheU5hbWUocnVsZXMpKTtcclxuICAgICAgICAgICAgdmFyIHJ1bGVzVG9JbnNlcnQgPSBbXTtcclxuICAgICAgICAgICAgZm9yICh2YXIgX2EgPSAwLCBfYiA9IHJ1bGVzLl9fb3JkZXI7IF9hIDwgX2IubGVuZ3RoOyBfYSsrKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2VsZWN0b3IgPSBfYltfYV07XHJcbiAgICAgICAgICAgICAgICBydWxlc1RvSW5zZXJ0LnB1c2goc2VsZWN0b3IsIHNlcmlhbGl6ZVJ1bGVFbnRyaWVzKHJ1bGVzW3NlbGVjdG9yXSkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJlZ2lzdHJhdGlvbi5ydWxlc1RvSW5zZXJ0ID0gcnVsZXNUb0luc2VydDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJlZ2lzdHJhdGlvbjtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLnN0eWxlVG9SZWdpc3RyYXRpb24gPSBzdHlsZVRvUmVnaXN0cmF0aW9uO1xyXG5mdW5jdGlvbiBhcHBseVJlZ2lzdHJhdGlvbihyZWdpc3RyYXRpb24sIGNsYXNzTWFwKSB7XHJcbiAgICB2YXIgc3R5bGVzaGVldCA9IFN0eWxlc2hlZXRfMS5TdHlsZXNoZWV0LmdldEluc3RhbmNlKCk7XHJcbiAgICB2YXIgY2xhc3NOYW1lID0gcmVnaXN0cmF0aW9uLmNsYXNzTmFtZSwga2V5ID0gcmVnaXN0cmF0aW9uLmtleSwgYXJncyA9IHJlZ2lzdHJhdGlvbi5hcmdzLCBydWxlc1RvSW5zZXJ0ID0gcmVnaXN0cmF0aW9uLnJ1bGVzVG9JbnNlcnQ7XHJcbiAgICBpZiAocnVsZXNUb0luc2VydCkge1xyXG4gICAgICAgIC8vIHJ1bGVzVG9JbnNlcnQgaXMgYW4gb3JkZXJlZCBhcnJheSBvZiBzZWxlY3Rvci9ydWxlIHBhaXJzLlxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcnVsZXNUb0luc2VydC5sZW5ndGg7IGkgKz0gMikge1xyXG4gICAgICAgICAgICB2YXIgcnVsZXMgPSBydWxlc1RvSW5zZXJ0W2kgKyAxXTtcclxuICAgICAgICAgICAgaWYgKHJ1bGVzKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgc2VsZWN0b3IgPSBydWxlc1RvSW5zZXJ0W2ldO1xyXG4gICAgICAgICAgICAgICAgLy8gRml4IHNlbGVjdG9yIHVzaW5nIG1hcC5cclxuICAgICAgICAgICAgICAgIHNlbGVjdG9yID0gc2VsZWN0b3IucmVwbGFjZSgvKCYpfFxcJChbXFx3LV0rKVxcYi9nLCBmdW5jdGlvbiAobWF0Y2gsIGFtcCwgY24pIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoYW1wKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiAnLicgKyByZWdpc3RyYXRpb24uY2xhc3NOYW1lO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChjbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gJy4nICsgKChjbGFzc01hcCAmJiBjbGFzc01hcFtjbl0pIHx8IGNuKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICAvLyBJbnNlcnQuIE5vdGUgaWYgYSBtZWRpYSBxdWVyeSwgd2UgbXVzdCBjbG9zZSB0aGUgcXVlcnkgd2l0aCBhIGZpbmFsIGJyYWNrZXQuXHJcbiAgICAgICAgICAgICAgICB2YXIgcHJvY2Vzc2VkUnVsZSA9IHNlbGVjdG9yICsgXCJ7XCIgKyBydWxlcyArIFwifVwiICsgKChzZWxlY3Rvci5pbmRleE9mKCdAbWVkaWEnKSA9PT0gMCkgPyAnfScgOiAnJyk7XHJcbiAgICAgICAgICAgICAgICBzdHlsZXNoZWV0Lmluc2VydFJ1bGUocHJvY2Vzc2VkUnVsZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgc3R5bGVzaGVldC5jYWNoZUNsYXNzTmFtZShjbGFzc05hbWUsIGtleSwgYXJncywgcnVsZXNUb0luc2VydCk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5hcHBseVJlZ2lzdHJhdGlvbiA9IGFwcGx5UmVnaXN0cmF0aW9uO1xyXG5mdW5jdGlvbiBzdHlsZVRvQ2xhc3NOYW1lKCkge1xyXG4gICAgdmFyIGFyZ3MgPSBbXTtcclxuICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgfVxyXG4gICAgdmFyIHJlZ2lzdHJhdGlvbiA9IHN0eWxlVG9SZWdpc3RyYXRpb24uYXBwbHkodm9pZCAwLCBhcmdzKTtcclxuICAgIGlmIChyZWdpc3RyYXRpb24pIHtcclxuICAgICAgICBhcHBseVJlZ2lzdHJhdGlvbihyZWdpc3RyYXRpb24pO1xyXG4gICAgICAgIHJldHVybiByZWdpc3RyYXRpb24uY2xhc3NOYW1lO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuICcnO1xyXG59XHJcbmV4cG9ydHMuc3R5bGVUb0NsYXNzTmFtZSA9IHN0eWxlVG9DbGFzc05hbWU7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0eWxlVG9DbGFzc05hbWUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuZnVuY3Rpb24ga2ViYWJSdWxlcyhydWxlUGFpcnMsIGluZGV4KSB7XHJcbiAgICBydWxlUGFpcnNbaW5kZXhdID0gcnVsZVBhaXJzW2luZGV4XS5yZXBsYWNlKC8oW0EtWl0pL2csICctJDEnKS50b0xvd2VyQ2FzZSgpO1xyXG59XHJcbmV4cG9ydHMua2ViYWJSdWxlcyA9IGtlYmFiUnVsZXM7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWtlYmFiUnVsZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIGdldFZlbmRvclNldHRpbmdzXzEgPSByZXF1aXJlKFwiLi4vZ2V0VmVuZG9yU2V0dGluZ3NcIik7XHJcbnZhciBhdXRvUHJlZml4TmFtZXMgPSB7XHJcbiAgICAndXNlci1zZWxlY3QnOiAxXHJcbn07XHJcbmZ1bmN0aW9uIHByZWZpeFJ1bGVzKHJ1bGVQYWlycywgaW5kZXgpIHtcclxuICAgIHZhciB2ZW5kb3JTZXR0aW5ncyA9IGdldFZlbmRvclNldHRpbmdzXzEuZ2V0VmVuZG9yU2V0dGluZ3MoKTtcclxuICAgIHZhciBuYW1lID0gcnVsZVBhaXJzW2luZGV4XTtcclxuICAgIGlmIChhdXRvUHJlZml4TmFtZXNbbmFtZV0pIHtcclxuICAgICAgICB2YXIgdmFsdWUgPSBydWxlUGFpcnNbaW5kZXggKyAxXTtcclxuICAgICAgICBpZiAoYXV0b1ByZWZpeE5hbWVzW25hbWVdKSB7XHJcbiAgICAgICAgICAgIGlmICh2ZW5kb3JTZXR0aW5ncy5pc1dlYmtpdCkge1xyXG4gICAgICAgICAgICAgICAgcnVsZVBhaXJzLnB1c2goJy13ZWJraXQtJyArIG5hbWUsIHZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodmVuZG9yU2V0dGluZ3MuaXNNb3opIHtcclxuICAgICAgICAgICAgICAgIHJ1bGVQYWlycy5wdXNoKCctbW96LScgKyBuYW1lLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKHZlbmRvclNldHRpbmdzLmlzTXMpIHtcclxuICAgICAgICAgICAgICAgIHJ1bGVQYWlycy5wdXNoKCctbXMtJyArIG5hbWUsIHZhbHVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAodmVuZG9yU2V0dGluZ3MuaXNPcGVyYSkge1xyXG4gICAgICAgICAgICAgICAgcnVsZVBhaXJzLnB1c2goJy1vLScgKyBuYW1lLCB2YWx1ZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5wcmVmaXhSdWxlcyA9IHByZWZpeFJ1bGVzO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wcmVmaXhSdWxlcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgTk9OX1BJWEVMX05VTUJFUl9QUk9QUyA9IFtcclxuICAgICdjb2x1bW4tY291bnQnLFxyXG4gICAgJ2ZvbnQtd2VpZ2h0JyxcclxuICAgICdmbGV4LWJhc2lzJyxcclxuICAgICdmbGV4JyxcclxuICAgICdmbGV4LWdyb3cnLFxyXG4gICAgJ2ZsZXgtc2hyaW5rJyxcclxuICAgICdvcGFjaXR5JyxcclxuICAgICdvcmRlcicsXHJcbiAgICAnei1pbmRleCcsXHJcbiAgICAnem9vbSdcclxuXTtcclxuZnVuY3Rpb24gcHJvdmlkZVVuaXRzKHJ1bGVQYWlycywgaW5kZXgpIHtcclxuICAgIHZhciBuYW1lID0gcnVsZVBhaXJzW2luZGV4XTtcclxuICAgIHZhciB2YWx1ZSA9IHJ1bGVQYWlyc1tpbmRleCArIDFdO1xyXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICB2YXIgdW5pdCA9IChOT05fUElYRUxfTlVNQkVSX1BST1BTLmluZGV4T2YobmFtZSkgPT09IC0xKSA/ICdweCcgOiAnJztcclxuICAgICAgICBydWxlUGFpcnNbaW5kZXggKyAxXSA9IFwiXCIgKyB2YWx1ZSArIHVuaXQ7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5wcm92aWRlVW5pdHMgPSBwcm92aWRlVW5pdHM7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXByb3ZpZGVVbml0cy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgX25hbWVSZXBsYWNlbWVudHMgPSB7XHJcbiAgICAnbGVmdCc6ICdyaWdodCcsXHJcbiAgICAncmlnaHQnOiAnbGVmdCdcclxufTtcclxudmFyIF92YWx1ZVJlcGxhY2VtZW50cyA9IHtcclxuICAgICd3LXJlc2l6ZSc6ICdlLXJlc2l6ZScsXHJcbiAgICAnc3ctcmVzaXplJzogJ3NlLXJlc2l6ZScsXHJcbiAgICAnbnctcmVzaXplJzogJ25lLXJlc2l6ZSdcclxufTtcclxudmFyIE5PX0ZMSVAgPSAnQG5vZmxpcCc7XHJcbnZhciBfcnRsID0gZ2V0UlRMKCk7XHJcbmZ1bmN0aW9uIHNldFJUTChpc1JUTCkge1xyXG4gICAgX3J0bCA9IGlzUlRMO1xyXG59XHJcbmV4cG9ydHMuc2V0UlRMID0gc2V0UlRMO1xyXG5mdW5jdGlvbiBnZXRSVEwoKSB7XHJcbiAgICBpZiAoX3J0bCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgX3J0bCA9ICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmXHJcbiAgICAgICAgICAgICEhZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmXHJcbiAgICAgICAgICAgIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RpcicpID09PSAncnRsJyk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gX3J0bDtcclxufVxyXG5leHBvcnRzLmdldFJUTCA9IGdldFJUTDtcclxuZnVuY3Rpb24gcnRsaWZ5UnVsZXMocnVsZVBhaXJzLCBpbmRleCkge1xyXG4gICAgaWYgKGdldFJUTCgpKSB7XHJcbiAgICAgICAgdmFyIG5hbWVfMSA9IHJ1bGVQYWlyc1tpbmRleF07XHJcbiAgICAgICAgdmFyIHZhbHVlID0gcnVsZVBhaXJzW2luZGV4ICsgMV07XHJcbiAgICAgICAgaWYgKHZhbHVlLmluZGV4T2YoTk9fRkxJUCkgPj0gMCkge1xyXG4gICAgICAgICAgICBydWxlUGFpcnNbaW5kZXggKyAxXSA9IHZhbHVlLnJlcGxhY2UoL1xccyooPzpcXC9cXCpcXHMqKT9cXEBub2ZsaXBcXGIoPzpcXHMqXFwqXFwvKT9cXHMqPy9nLCAnJyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG5hbWVfMS5pbmRleE9mKCdsZWZ0JykgPj0gMCkge1xyXG4gICAgICAgICAgICBydWxlUGFpcnNbaW5kZXhdID0gbmFtZV8xLnJlcGxhY2UoJ2xlZnQnLCAncmlnaHQnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAobmFtZV8xLmluZGV4T2YoJ3JpZ2h0JykgPj0gMCkge1xyXG4gICAgICAgICAgICBydWxlUGFpcnNbaW5kZXhdID0gbmFtZV8xLnJlcGxhY2UoJ3JpZ2h0JywgJ2xlZnQnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoU3RyaW5nKHZhbHVlKS5pbmRleE9mKCdsZWZ0JykgPj0gMCkge1xyXG4gICAgICAgICAgICBydWxlUGFpcnNbaW5kZXggKyAxXSA9IHZhbHVlLnJlcGxhY2UoJ2xlZnQnLCAncmlnaHQnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoU3RyaW5nKHZhbHVlKS5pbmRleE9mKCdyaWdodCcpID49IDApIHtcclxuICAgICAgICAgICAgcnVsZVBhaXJzW2luZGV4ICsgMV0gPSB2YWx1ZS5yZXBsYWNlKCdyaWdodCcsICdsZWZ0Jyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKF9uYW1lUmVwbGFjZW1lbnRzW25hbWVfMV0pIHtcclxuICAgICAgICAgICAgcnVsZVBhaXJzW2luZGV4XSA9IF9uYW1lUmVwbGFjZW1lbnRzW25hbWVfMV07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKF92YWx1ZVJlcGxhY2VtZW50c1t2YWx1ZV0pIHtcclxuICAgICAgICAgICAgcnVsZVBhaXJzW2luZGV4ICsgMV0gPSBfdmFsdWVSZXBsYWNlbWVudHNbdmFsdWVdO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgc3dpdGNoIChuYW1lXzEpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgJ21hcmdpbic6XHJcbiAgICAgICAgICAgICAgICBjYXNlICdwYWRkaW5nJzpcclxuICAgICAgICAgICAgICAgICAgICBydWxlUGFpcnNbaW5kZXggKyAxXSA9IGZsaXBRdWFkKHZhbHVlKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgIGNhc2UgJ2JveC1zaGFkb3cnOlxyXG4gICAgICAgICAgICAgICAgICAgIHJ1bGVQYWlyc1tpbmRleCArIDFdID0gbmVnYXRlTnVtKHZhbHVlLCAwKTtcclxuICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5leHBvcnRzLnJ0bGlmeVJ1bGVzID0gcnRsaWZ5UnVsZXM7XHJcbmZ1bmN0aW9uIG5lZ2F0ZU51bSh2YWx1ZSwgcGFydEluZGV4KSB7XHJcbiAgICB2YXIgcGFydHMgPSB2YWx1ZS5zcGxpdCgnICcpO1xyXG4gICAgdmFyIG51bWJlclZhbCA9IHBhcnNlSW50KHBhcnRzW3BhcnRJbmRleF0sIDEwKTtcclxuICAgIHBhcnRzWzBdID0gcGFydHNbMF0ucmVwbGFjZShTdHJpbmcobnVtYmVyVmFsKSwgU3RyaW5nKG51bWJlclZhbCAqIC0xKSk7XHJcbiAgICByZXR1cm4gcGFydHMuam9pbignICcpO1xyXG59XHJcbmZ1bmN0aW9uIGZsaXBRdWFkKHZhbHVlKSB7XHJcbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIHZhciBwYXJ0cyA9IHZhbHVlLnNwbGl0KCcgJyk7XHJcbiAgICAgICAgaWYgKHBhcnRzLmxlbmd0aCA9PT0gNCkge1xyXG4gICAgICAgICAgICByZXR1cm4gcGFydHNbMF0gKyBcIiBcIiArIHBhcnRzWzNdICsgXCIgXCIgKyBwYXJ0c1syXSArIFwiIFwiICsgcGFydHNbMV07XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHZhbHVlO1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJ0bGlmeVJ1bGVzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBpbmRleF8xID0gcmVxdWlyZShcIkB1aWZhYnJpYy9tZXJnZS1zdHlsZXMvbGliL2luZGV4XCIpO1xyXG5leHBvcnRzLkluamVjdGlvbk1vZGUgPSBpbmRleF8xLkluamVjdGlvbk1vZGU7XHJcbmV4cG9ydHMuU3R5bGVzaGVldCA9IGluZGV4XzEuU3R5bGVzaGVldDtcclxuZXhwb3J0cy5jb25jYXRTdHlsZVNldHMgPSBpbmRleF8xLmNvbmNhdFN0eWxlU2V0cztcclxuZXhwb3J0cy5mb250RmFjZSA9IGluZGV4XzEuZm9udEZhY2U7XHJcbmV4cG9ydHMua2V5ZnJhbWVzID0gaW5kZXhfMS5rZXlmcmFtZXM7XHJcbmV4cG9ydHMubWVyZ2VTdHlsZVNldHMgPSBpbmRleF8xLm1lcmdlU3R5bGVTZXRzO1xyXG5leHBvcnRzLm1lcmdlU3R5bGVzID0gaW5kZXhfMS5tZXJnZVN0eWxlcztcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TWVyZ2VTdHlsZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIGluZGV4XzEgPSByZXF1aXJlKFwiLi4vdXRpbGl0aWVzL2luZGV4XCIpO1xyXG52YXIgaW5kZXhfMiA9IHJlcXVpcmUoXCIuLi9zdHlsZXMvaW5kZXhcIik7XHJcbmV4cG9ydHMuQW5pbWF0aW9uQ2xhc3NOYW1lcyA9IGluZGV4XzEuYnVpbGRDbGFzc01hcChpbmRleF8yLkFuaW1hdGlvblN0eWxlcyk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFuaW1hdGlvbkNsYXNzTmFtZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIGluZGV4XzEgPSByZXF1aXJlKFwiQHVpZmFicmljL21lcmdlLXN0eWxlcy9saWIvaW5kZXhcIik7XHJcbnZhciBEZWZhdWx0UGFsZXR0ZV8xID0gcmVxdWlyZShcIi4uL3N0eWxlcy9EZWZhdWx0UGFsZXR0ZVwiKTtcclxudmFyIGluZGV4XzIgPSByZXF1aXJlKFwiLi4vc3R5bGVzL2luZGV4XCIpO1xyXG5leHBvcnRzLkNvbG9yQ2xhc3NOYW1lcyA9IHt9O1xyXG5mb3IgKHZhciBjb2xvck5hbWUgaW4gRGVmYXVsdFBhbGV0dGVfMS5EZWZhdWx0UGFsZXR0ZSkge1xyXG4gICAgaWYgKERlZmF1bHRQYWxldHRlXzEuRGVmYXVsdFBhbGV0dGUuaGFzT3duUHJvcGVydHkoY29sb3JOYW1lKSkge1xyXG4gICAgICAgIC8vIEZvcmVncm91bmQgY29sb3JcclxuICAgICAgICBfZGVmaW5lR2V0dGVyKGV4cG9ydHMuQ29sb3JDbGFzc05hbWVzLCBjb2xvck5hbWUsICcnLCBmYWxzZSwgJ2NvbG9yJyk7XHJcbiAgICAgICAgLy8gSG92ZXIgY29sb3JcclxuICAgICAgICBfZGVmaW5lR2V0dGVyKGV4cG9ydHMuQ29sb3JDbGFzc05hbWVzLCBjb2xvck5hbWUsICdIb3ZlcicsIHRydWUsICdjb2xvcicpO1xyXG4gICAgICAgIC8vIEJhY2tncm91bmQgY29sb3JcclxuICAgICAgICBfZGVmaW5lR2V0dGVyKGV4cG9ydHMuQ29sb3JDbGFzc05hbWVzLCBjb2xvck5hbWUsICdCYWNrZ3JvdW5kJywgZmFsc2UsICdiYWNrZ3JvdW5kJyk7XHJcbiAgICAgICAgLy8gQmFja2dyb3VuZCBob3ZlclxyXG4gICAgICAgIF9kZWZpbmVHZXR0ZXIoZXhwb3J0cy5Db2xvckNsYXNzTmFtZXMsIGNvbG9yTmFtZSwgJ0JhY2tncm91bmRIb3ZlcicsIHRydWUsICdiYWNrZ3JvdW5kJyk7XHJcbiAgICAgICAgLy8gQm9yZGVyIGNvbG9yXHJcbiAgICAgICAgX2RlZmluZUdldHRlcihleHBvcnRzLkNvbG9yQ2xhc3NOYW1lcywgY29sb3JOYW1lLCAnQm9yZGVyJywgZmFsc2UsICdib3JkZXJDb2xvcicpO1xyXG4gICAgICAgIC8vIEJvcmRlciBob3ZlciBjb2xvclxyXG4gICAgICAgIF9kZWZpbmVHZXR0ZXIoZXhwb3J0cy5Db2xvckNsYXNzTmFtZXMsIGNvbG9yTmFtZSwgJ0JvcmRlckhvdmVyJywgdHJ1ZSwgJ2JvcmRlckNvbG9yJyk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIERlZmluZXMgYSBnZXR0ZXIgZm9yIHRoZSBnaXZlbiBjbGFzcyBjb25maWd1cmF0aW9uLlxyXG4gKi9cclxuZnVuY3Rpb24gX2RlZmluZUdldHRlcihvYmosIGNvbG9yTmFtZSwgc3VmZml4LCBpc0hvdmVyLCBjc3NQcm9wZXJ0eSkge1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwgY29sb3JOYW1lICsgc3VmZml4LCB7XHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1hbnlcclxuICAgICAgICAgICAgdmFyIHN0eWxlID0gKF9hID0ge30sIF9hW2Nzc1Byb3BlcnR5XSA9IGluZGV4XzIuZ2V0VGhlbWUoKS5wYWxldHRlW2NvbG9yTmFtZV0sIF9hKTtcclxuICAgICAgICAgICAgcmV0dXJuIGluZGV4XzEubWVyZ2VTdHlsZXMoaXNIb3ZlciA/IHsgc2VsZWN0b3JzOiB7ICc6aG92ZXInOiBzdHlsZSB9IH0gOiBzdHlsZSkudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG59XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNvbG9yQ2xhc3NOYW1lcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgaW5kZXhfMSA9IHJlcXVpcmUoXCIuLi91dGlsaXRpZXMvaW5kZXhcIik7XHJcbnZhciBpbmRleF8yID0gcmVxdWlyZShcIi4uL3N0eWxlcy9pbmRleFwiKTtcclxuZXhwb3J0cy5Gb250Q2xhc3NOYW1lcyA9IGluZGV4XzEuYnVpbGRDbGFzc01hcChpbmRleF8yLkRlZmF1bHRGb250U3R5bGVzKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Rm9udENsYXNzTmFtZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIEFuaW1hdGlvbkNsYXNzTmFtZXNfMSA9IHJlcXVpcmUoXCIuL0FuaW1hdGlvbkNsYXNzTmFtZXNcIik7XHJcbmV4cG9ydHMuQW5pbWF0aW9uQ2xhc3NOYW1lcyA9IEFuaW1hdGlvbkNsYXNzTmFtZXNfMS5BbmltYXRpb25DbGFzc05hbWVzO1xyXG52YXIgRm9udENsYXNzTmFtZXNfMSA9IHJlcXVpcmUoXCIuL0ZvbnRDbGFzc05hbWVzXCIpO1xyXG5leHBvcnRzLkZvbnRDbGFzc05hbWVzID0gRm9udENsYXNzTmFtZXNfMS5Gb250Q2xhc3NOYW1lcztcclxudmFyIENvbG9yQ2xhc3NOYW1lc18xID0gcmVxdWlyZShcIi4vQ29sb3JDbGFzc05hbWVzXCIpO1xyXG5leHBvcnRzLkNvbG9yQ2xhc3NOYW1lcyA9IENvbG9yQ2xhc3NOYW1lc18xLkNvbG9yQ2xhc3NOYW1lcztcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XHJcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2NsYXNzTmFtZXMvaW5kZXhcIiksIGV4cG9ydHMpO1xyXG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9zdHlsZXMvaW5kZXhcIiksIGV4cG9ydHMpO1xyXG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi91dGlsaXRpZXMvaW5kZXhcIiksIGV4cG9ydHMpO1xyXG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9NZXJnZVN0eWxlc1wiKSwgZXhwb3J0cyk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBpbmRleF8xID0gcmVxdWlyZShcIkB1aWZhYnJpYy9tZXJnZS1zdHlsZXMvbGliL2luZGV4XCIpO1xyXG4vKiBSZWdpc3RlciB0aGUga2V5ZnJhbWVzICovXHJcbnZhciBFQVNJTkdfRlVOQ1RJT05fMSA9ICdjdWJpYy1iZXppZXIoLjEsLjksLjIsMSknO1xyXG52YXIgRUFTSU5HX0ZVTkNUSU9OXzIgPSAnY3ViaWMtYmV6aWVyKC4xLC4yNSwuNzUsLjkpJztcclxudmFyIERVUkFUSU9OXzEgPSAnMC4xNjdzJztcclxudmFyIERVUkFUSU9OXzIgPSAnMC4yNjdzJztcclxudmFyIERVUkFUSU9OXzMgPSAnMC4zNjdzJztcclxudmFyIERVUkFUSU9OXzQgPSAnMC40NjdzJztcclxudmFyIEZBREVfSU4gPSBpbmRleF8xLmtleWZyYW1lcyh7XHJcbiAgICBmcm9tOiB7IG9wYWNpdHk6IDAgfSxcclxuICAgIHRvOiB7IG9wYWNpdHk6IDEgfVxyXG59KTtcclxudmFyIEZBREVfT1VUID0gaW5kZXhfMS5rZXlmcmFtZXMoe1xyXG4gICAgZnJvbTogeyBvcGFjaXR5OiAxIH0sXHJcbiAgICB0bzogeyBvcGFjaXR5OiAwIH1cclxufSk7XHJcbnZhciBTTElERV9SSUdIVF9JTjEwID0gX2NyZWF0ZVNsaWRlSW5YKC0xMCk7XHJcbnZhciBTTElERV9SSUdIVF9JTjIwID0gX2NyZWF0ZVNsaWRlSW5YKC0yMCk7XHJcbnZhciBTTElERV9SSUdIVF9JTjQwID0gX2NyZWF0ZVNsaWRlSW5YKC00MCk7XHJcbnZhciBTTElERV9SSUdIVF9JTjQwMCA9IF9jcmVhdGVTbGlkZUluWCgtNDAwKTtcclxudmFyIFNMSURFX0xFRlRfSU4xMCA9IF9jcmVhdGVTbGlkZUluWCgxMCk7XHJcbnZhciBTTElERV9MRUZUX0lOMjAgPSBfY3JlYXRlU2xpZGVJblgoMjApO1xyXG52YXIgU0xJREVfTEVGVF9JTjQwID0gX2NyZWF0ZVNsaWRlSW5YKDQwKTtcclxudmFyIFNMSURFX0xFRlRfSU40MDAgPSBfY3JlYXRlU2xpZGVJblgoNDAwKTtcclxudmFyIFNMSURFX1VQX0lOMTAgPSBfY3JlYXRlU2xpZGVJblkoMTApO1xyXG52YXIgU0xJREVfVVBfSU4yMCA9IF9jcmVhdGVTbGlkZUluWSgyMCk7XHJcbnZhciBTTElERV9ET1dOX0lOMTAgPSBfY3JlYXRlU2xpZGVJblkoLTEwKTtcclxudmFyIFNMSURFX0RPV05fSU4yMCA9IF9jcmVhdGVTbGlkZUluWSgtMjApO1xyXG52YXIgU0xJREVfUklHSFRfT1VUMTAgPSBfY3JlYXRlU2xpZGVPdXRYKDEwKTtcclxudmFyIFNMSURFX1JJR0hUX09VVDIwID0gX2NyZWF0ZVNsaWRlT3V0WCgyMCk7XHJcbnZhciBTTElERV9SSUdIVF9PVVQ0MCA9IF9jcmVhdGVTbGlkZU91dFgoNDApO1xyXG52YXIgU0xJREVfUklHSFRfT1VUNDAwID0gX2NyZWF0ZVNsaWRlT3V0WCg0MDApO1xyXG52YXIgU0xJREVfTEVGVF9PVVQxMCA9IF9jcmVhdGVTbGlkZU91dFgoLTEwKTtcclxudmFyIFNMSURFX0xFRlRfT1VUMjAgPSBfY3JlYXRlU2xpZGVPdXRYKC0yMCk7XHJcbnZhciBTTElERV9MRUZUX09VVDQwID0gX2NyZWF0ZVNsaWRlT3V0WCgtNDApO1xyXG52YXIgU0xJREVfTEVGVF9PVVQ0MDAgPSBfY3JlYXRlU2xpZGVPdXRYKC00MDApO1xyXG52YXIgU0xJREVfVVBfT1VUMTAgPSBfY3JlYXRlU2xpZGVPdXRZKC0xMCk7XHJcbnZhciBTTElERV9VUF9PVVQyMCA9IF9jcmVhdGVTbGlkZU91dFkoLTIwKTtcclxudmFyIFNMSURFX0RPV05fT1VUMTAgPSBfY3JlYXRlU2xpZGVPdXRZKDEwKTtcclxudmFyIFNMSURFX0RPV05fT1VUMjAgPSBfY3JlYXRlU2xpZGVPdXRZKDIwKTtcclxudmFyIFNDQUxFX1VQMTAwID0gaW5kZXhfMS5rZXlmcmFtZXMoe1xyXG4gICAgZnJvbTogeyB0cmFuc2Zvcm06ICdzY2FsZTNkKC45OCwuOTgsMSknIH0sXHJcbiAgICB0bzogeyB0cmFuc2Zvcm06ICdzY2FsZTNkKDEsMSwxKScgfVxyXG59KTtcclxudmFyIFNDQUxFX0RPV045OCA9IGluZGV4XzEua2V5ZnJhbWVzKHtcclxuICAgIGZyb206IHsgdHJhbnNmb3JtOiAnc2NhbGUzZCgxLDEsMSknIH0sXHJcbiAgICB0bzogeyB0cmFuc2Zvcm06ICdzY2FsZTNkKC45OCwuOTgsMSknIH0sXHJcbn0pO1xyXG52YXIgU0NBTEVfRE9XTjEwMCA9IGluZGV4XzEua2V5ZnJhbWVzKHtcclxuICAgIGZyb206IHsgdHJhbnNmb3JtOiAnc2NhbGUzZCgxLjAzLDEuMDMsMSknIH0sXHJcbiAgICB0bzogeyB0cmFuc2Zvcm06ICdzY2FsZTNkKDEsMSwxKScgfVxyXG59KTtcclxudmFyIFNDQUxFX1VQMTAzID0gaW5kZXhfMS5rZXlmcmFtZXMoe1xyXG4gICAgZnJvbTogeyB0cmFuc2Zvcm06ICdzY2FsZTNkKDEsMSwxKScgfSxcclxuICAgIHRvOiB7IHRyYW5zZm9ybTogJ3NjYWxlM2QoMS4wMywxLjAzLDEpJyB9XHJcbn0pO1xyXG52YXIgUk9UQVRFOTAgPSBpbmRleF8xLmtleWZyYW1lcyh7XHJcbiAgICBmcm9tOiB7IHRyYW5zZm9ybTogJ3JvdGF0ZVooMGRlZyknIH0sXHJcbiAgICB0bzogeyB0cmFuc2Zvcm06ICdyb3RhdGVaKDkwZGVnKScgfVxyXG59KTtcclxudmFyIFJPVEFURV9OOTAgPSBpbmRleF8xLmtleWZyYW1lcyh7XHJcbiAgICBmcm9tOiB7IHRyYW5zZm9ybTogJ3JvdGF0ZVooMGRlZyknIH0sXHJcbiAgICB0bzogeyB0cmFuc2Zvcm06ICdyb3RhdGVaKC05MGRlZyknIH1cclxufSk7XHJcbi8qKlxyXG4gKiBBbGwgRmFicmljIHN0YW5kYXJkIGFuaW1hdGlvbnMsIGV4cG9zZWQgYXMganNvbiBvYmplY3RzIHJlZmVyZW5jaW5nIHByZWRlZmluZWRcclxuICoga2V5ZnJhbWVzLiBUaGVzZSBvYmplY3RzIGNhbiBiZSBtaXhlZCBpbiB3aXRoIG90aGVyIGNsYXNzIGRlZmluaXRpb25zLlxyXG4gKi9cclxuZXhwb3J0cy5BbmltYXRpb25TdHlsZXMgPSB7XHJcbiAgICBzbGlkZVJpZ2h0SW4xMDogX2NyZWF0ZUFuaW1hdGlvbihGQURFX0lOICsgXCIsXCIgKyBTTElERV9SSUdIVF9JTjEwLCBEVVJBVElPTl8zLCBFQVNJTkdfRlVOQ1RJT05fMSksXHJcbiAgICBzbGlkZVJpZ2h0SW4yMDogX2NyZWF0ZUFuaW1hdGlvbihGQURFX0lOICsgXCIsXCIgKyBTTElERV9SSUdIVF9JTjIwLCBEVVJBVElPTl8zLCBFQVNJTkdfRlVOQ1RJT05fMSksXHJcbiAgICBzbGlkZVJpZ2h0SW40MDogX2NyZWF0ZUFuaW1hdGlvbihGQURFX0lOICsgXCIsXCIgKyBTTElERV9SSUdIVF9JTjQwLCBEVVJBVElPTl8zLCBFQVNJTkdfRlVOQ1RJT05fMSksXHJcbiAgICBzbGlkZVJpZ2h0SW40MDA6IF9jcmVhdGVBbmltYXRpb24oRkFERV9JTiArIFwiLFwiICsgU0xJREVfUklHSFRfSU40MDAsIERVUkFUSU9OXzMsIEVBU0lOR19GVU5DVElPTl8xKSxcclxuICAgIHNsaWRlTGVmdEluMTA6IF9jcmVhdGVBbmltYXRpb24oRkFERV9JTiArIFwiLFwiICsgU0xJREVfTEVGVF9JTjEwLCBEVVJBVElPTl8zLCBFQVNJTkdfRlVOQ1RJT05fMSksXHJcbiAgICBzbGlkZUxlZnRJbjIwOiBfY3JlYXRlQW5pbWF0aW9uKEZBREVfSU4gKyBcIixcIiArIFNMSURFX0xFRlRfSU4yMCwgRFVSQVRJT05fMywgRUFTSU5HX0ZVTkNUSU9OXzEpLFxyXG4gICAgc2xpZGVMZWZ0SW40MDogX2NyZWF0ZUFuaW1hdGlvbihGQURFX0lOICsgXCIsXCIgKyBTTElERV9MRUZUX0lONDAsIERVUkFUSU9OXzMsIEVBU0lOR19GVU5DVElPTl8xKSxcclxuICAgIHNsaWRlTGVmdEluNDAwOiBfY3JlYXRlQW5pbWF0aW9uKEZBREVfSU4gKyBcIixcIiArIFNMSURFX0xFRlRfSU40MDAsIERVUkFUSU9OXzMsIEVBU0lOR19GVU5DVElPTl8xKSxcclxuICAgIHNsaWRlVXBJbjEwOiBfY3JlYXRlQW5pbWF0aW9uKEZBREVfSU4gKyBcIixcIiArIFNMSURFX1VQX0lOMTAsIERVUkFUSU9OXzMsIEVBU0lOR19GVU5DVElPTl8xKSxcclxuICAgIHNsaWRlVXBJbjIwOiBfY3JlYXRlQW5pbWF0aW9uKEZBREVfSU4gKyBcIixcIiArIFNMSURFX1VQX0lOMjAsIERVUkFUSU9OXzMsIEVBU0lOR19GVU5DVElPTl8xKSxcclxuICAgIHNsaWRlRG93bkluMTA6IF9jcmVhdGVBbmltYXRpb24oRkFERV9JTiArIFwiLFwiICsgU0xJREVfRE9XTl9JTjEwLCBEVVJBVElPTl8zLCBFQVNJTkdfRlVOQ1RJT05fMSksXHJcbiAgICBzbGlkZURvd25JbjIwOiBfY3JlYXRlQW5pbWF0aW9uKEZBREVfSU4gKyBcIixcIiArIFNMSURFX0RPV05fSU4yMCwgRFVSQVRJT05fMywgRUFTSU5HX0ZVTkNUSU9OXzEpLFxyXG4gICAgc2xpZGVSaWdodE91dDEwOiBfY3JlYXRlQW5pbWF0aW9uKEZBREVfT1VUICsgXCIsXCIgKyBTTElERV9SSUdIVF9PVVQxMCwgRFVSQVRJT05fMywgRUFTSU5HX0ZVTkNUSU9OXzEpLFxyXG4gICAgc2xpZGVSaWdodE91dDIwOiBfY3JlYXRlQW5pbWF0aW9uKEZBREVfT1VUICsgXCIsXCIgKyBTTElERV9SSUdIVF9PVVQyMCwgRFVSQVRJT05fMywgRUFTSU5HX0ZVTkNUSU9OXzEpLFxyXG4gICAgc2xpZGVSaWdodE91dDQwOiBfY3JlYXRlQW5pbWF0aW9uKEZBREVfT1VUICsgXCIsXCIgKyBTTElERV9SSUdIVF9PVVQ0MCwgRFVSQVRJT05fMywgRUFTSU5HX0ZVTkNUSU9OXzEpLFxyXG4gICAgc2xpZGVSaWdodE91dDQwMDogX2NyZWF0ZUFuaW1hdGlvbihGQURFX09VVCArIFwiLFwiICsgU0xJREVfUklHSFRfT1VUNDAwLCBEVVJBVElPTl8zLCBFQVNJTkdfRlVOQ1RJT05fMSksXHJcbiAgICBzbGlkZUxlZnRPdXQxMDogX2NyZWF0ZUFuaW1hdGlvbihGQURFX09VVCArIFwiLFwiICsgU0xJREVfTEVGVF9PVVQxMCwgRFVSQVRJT05fMywgRUFTSU5HX0ZVTkNUSU9OXzEpLFxyXG4gICAgc2xpZGVMZWZ0T3V0MjA6IF9jcmVhdGVBbmltYXRpb24oRkFERV9PVVQgKyBcIixcIiArIFNMSURFX0xFRlRfT1VUMjAsIERVUkFUSU9OXzMsIEVBU0lOR19GVU5DVElPTl8xKSxcclxuICAgIHNsaWRlTGVmdE91dDQwOiBfY3JlYXRlQW5pbWF0aW9uKEZBREVfT1VUICsgXCIsXCIgKyBTTElERV9MRUZUX09VVDQwLCBEVVJBVElPTl8zLCBFQVNJTkdfRlVOQ1RJT05fMSksXHJcbiAgICBzbGlkZUxlZnRPdXQ0MDA6IF9jcmVhdGVBbmltYXRpb24oRkFERV9PVVQgKyBcIixcIiArIFNMSURFX0xFRlRfT1VUNDAwLCBEVVJBVElPTl8zLCBFQVNJTkdfRlVOQ1RJT05fMSksXHJcbiAgICBzbGlkZVVwT3V0MTA6IF9jcmVhdGVBbmltYXRpb24oRkFERV9PVVQgKyBcIixcIiArIFNMSURFX1VQX09VVDEwLCBEVVJBVElPTl8zLCBFQVNJTkdfRlVOQ1RJT05fMSksXHJcbiAgICBzbGlkZVVwT3V0MjA6IF9jcmVhdGVBbmltYXRpb24oRkFERV9PVVQgKyBcIixcIiArIFNMSURFX1VQX09VVDIwLCBEVVJBVElPTl8zLCBFQVNJTkdfRlVOQ1RJT05fMSksXHJcbiAgICBzbGlkZURvd25PdXQxMDogX2NyZWF0ZUFuaW1hdGlvbihGQURFX09VVCArIFwiLFwiICsgU0xJREVfRE9XTl9PVVQxMCwgRFVSQVRJT05fMywgRUFTSU5HX0ZVTkNUSU9OXzEpLFxyXG4gICAgc2xpZGVEb3duT3V0MjA6IF9jcmVhdGVBbmltYXRpb24oRkFERV9PVVQgKyBcIixcIiArIFNMSURFX0RPV05fT1VUMjAsIERVUkFUSU9OXzMsIEVBU0lOR19GVU5DVElPTl8xKSxcclxuICAgIHNjYWxlVXBJbjEwMDogX2NyZWF0ZUFuaW1hdGlvbihGQURFX0lOICsgXCIsXCIgKyBTQ0FMRV9VUDEwMCwgRFVSQVRJT05fMywgRUFTSU5HX0ZVTkNUSU9OXzEpLFxyXG4gICAgc2NhbGVEb3duSW4xMDA6IF9jcmVhdGVBbmltYXRpb24oRkFERV9JTiArIFwiLFwiICsgU0NBTEVfRE9XTjEwMCwgRFVSQVRJT05fMywgRUFTSU5HX0ZVTkNUSU9OXzEpLFxyXG4gICAgc2NhbGVVcE91dDEwMzogX2NyZWF0ZUFuaW1hdGlvbihGQURFX09VVCArIFwiLFwiICsgU0NBTEVfVVAxMDMsIERVUkFUSU9OXzEsIEVBU0lOR19GVU5DVElPTl8yKSxcclxuICAgIHNjYWxlRG93bk91dDk4OiBfY3JlYXRlQW5pbWF0aW9uKEZBREVfT1VUICsgXCIsXCIgKyBTQ0FMRV9ET1dOOTgsIERVUkFUSU9OXzEsIEVBU0lOR19GVU5DVElPTl8yKSxcclxuICAgIGZhZGVJbjEwMDogX2NyZWF0ZUFuaW1hdGlvbihGQURFX0lOLCBEVVJBVElPTl8xLCBFQVNJTkdfRlVOQ1RJT05fMiksXHJcbiAgICBmYWRlSW4yMDA6IF9jcmVhdGVBbmltYXRpb24oRkFERV9JTiwgRFVSQVRJT05fMiwgRUFTSU5HX0ZVTkNUSU9OXzIpLFxyXG4gICAgZmFkZUluNDAwOiBfY3JlYXRlQW5pbWF0aW9uKEZBREVfSU4sIERVUkFUSU9OXzMsIEVBU0lOR19GVU5DVElPTl8yKSxcclxuICAgIGZhZGVJbjUwMDogX2NyZWF0ZUFuaW1hdGlvbihGQURFX0lOLCBEVVJBVElPTl80LCBFQVNJTkdfRlVOQ1RJT05fMiksXHJcbiAgICBmYWRlT3V0MTAwOiBfY3JlYXRlQW5pbWF0aW9uKEZBREVfT1VULCBEVVJBVElPTl8xLCBFQVNJTkdfRlVOQ1RJT05fMiksXHJcbiAgICBmYWRlT3V0MjAwOiBfY3JlYXRlQW5pbWF0aW9uKEZBREVfT1VULCBEVVJBVElPTl8yLCBFQVNJTkdfRlVOQ1RJT05fMiksXHJcbiAgICBmYWRlT3V0NDAwOiBfY3JlYXRlQW5pbWF0aW9uKEZBREVfT1VULCBEVVJBVElPTl8zLCBFQVNJTkdfRlVOQ1RJT05fMiksXHJcbiAgICBmYWRlT3V0NTAwOiBfY3JlYXRlQW5pbWF0aW9uKEZBREVfT1VULCBEVVJBVElPTl80LCBFQVNJTkdfRlVOQ1RJT05fMiksXHJcbiAgICByb3RhdGU5MGRlZzogX2NyZWF0ZUFuaW1hdGlvbihST1RBVEU5MCwgJzAuMXMnLCBFQVNJTkdfRlVOQ1RJT05fMiksXHJcbiAgICByb3RhdGVOOTBkZWc6IF9jcmVhdGVBbmltYXRpb24oUk9UQVRFX045MCwgJzAuMXMnLCBFQVNJTkdfRlVOQ1RJT05fMilcclxuICAgIC8vIGV4cGFuZENvbGxhcHNlIDEwMC8yMDAvNDAwLCBkZWxheSAxMDAvMjAwXHJcbn07XHJcbmZ1bmN0aW9uIF9jcmVhdGVBbmltYXRpb24oYW5pbWF0aW9uTmFtZSwgYW5pbWF0aW9uRHVyYXRpb24sIGFuaW1hdGlvblRpbWluZ0Z1bmN0aW9uKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGFuaW1hdGlvbk5hbWU6IGFuaW1hdGlvbk5hbWUsXHJcbiAgICAgICAgYW5pbWF0aW9uRHVyYXRpb246IGFuaW1hdGlvbkR1cmF0aW9uLFxyXG4gICAgICAgIGFuaW1hdGlvblRpbWluZ0Z1bmN0aW9uOiBhbmltYXRpb25UaW1pbmdGdW5jdGlvbixcclxuICAgICAgICBhbmltYXRpb25GaWxsTW9kZTogJ2JvdGgnXHJcbiAgICB9O1xyXG59XHJcbmZ1bmN0aW9uIF9jcmVhdGVTbGlkZUluWChmcm9tWCkge1xyXG4gICAgcmV0dXJuIGluZGV4XzEua2V5ZnJhbWVzKHtcclxuICAgICAgICBmcm9tOiB7IHRyYW5zZm9ybTogXCJ0cmFuc2xhdGUzZChcIiArIGZyb21YICsgXCJweCwwLDApXCIgfSxcclxuICAgICAgICB0bzogeyB0cmFuc2Zvcm06IFwidHJhbnNsYXRlM2QoMCwwLDApXCIgfVxyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gX2NyZWF0ZVNsaWRlSW5ZKGZyb21ZKSB7XHJcbiAgICByZXR1cm4gaW5kZXhfMS5rZXlmcmFtZXMoe1xyXG4gICAgICAgIGZyb206IHsgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZTNkKDAsXCIgKyBmcm9tWSArIFwicHgsMClcIiB9LFxyXG4gICAgICAgIHRvOiB7IHRyYW5zZm9ybTogXCJ0cmFuc2xhdGUzZCgwLDAsMClcIiB9XHJcbiAgICB9KTtcclxufVxyXG5mdW5jdGlvbiBfY3JlYXRlU2xpZGVPdXRYKHRvWCkge1xyXG4gICAgcmV0dXJuIGluZGV4XzEua2V5ZnJhbWVzKHtcclxuICAgICAgICBmcm9tOiB7IHRyYW5zZm9ybTogXCJ0cmFuc2xhdGUzZCgwLDAsMClcIiB9LFxyXG4gICAgICAgIHRvOiB7IHRyYW5zZm9ybTogXCJ0cmFuc2xhdGUzZChcIiArIHRvWCArIFwicHgsMCwwKVwiIH1cclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIF9jcmVhdGVTbGlkZU91dFkodG9ZKSB7XHJcbiAgICByZXR1cm4gaW5kZXhfMS5rZXlmcmFtZXMoe1xyXG4gICAgICAgIGZyb206IHsgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZTNkKDAsMCwwKVwiIH0sXHJcbiAgICAgICAgdG86IHsgdHJhbnNmb3JtOiBcInRyYW5zbGF0ZTNkKDAsXCIgKyB0b1kgKyBcInB4LDApXCIgfVxyXG4gICAgfSk7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QW5pbWF0aW9uU3R5bGVzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuSGlnaENvbnRyYXN0U2VsZWN0b3IgPSAnQG1lZGlhIHNjcmVlbiBhbmQgKC1tcy1oaWdoLWNvbnRyYXN0OiBhY3RpdmUpJztcclxuZXhwb3J0cy5TY3JlZW5XaWR0aE1pblNtYWxsID0gMzIwO1xyXG5leHBvcnRzLlNjcmVlbldpZHRoTWluTWVkaXVtID0gNDgwO1xyXG5leHBvcnRzLlNjcmVlbldpZHRoTWluTGFyZ2UgPSA2NDA7XHJcbmV4cG9ydHMuU2NyZWVuV2lkdGhNaW5YTGFyZ2UgPSAxMDI0O1xyXG5leHBvcnRzLlNjcmVlbldpZHRoTWluWFhMYXJnZSA9IDEzNjY7XHJcbmV4cG9ydHMuU2NyZWVuV2lkdGhNaW5YWFhMYXJnZSA9IDE5MjA7XHJcbmV4cG9ydHMuU2NyZWVuV2lkdGhNYXhTbWFsbCA9IGV4cG9ydHMuU2NyZWVuV2lkdGhNaW5NZWRpdW0gLSAxO1xyXG5leHBvcnRzLlNjcmVlbldpZHRoTWF4TWVkaXVtID0gZXhwb3J0cy5TY3JlZW5XaWR0aE1pbkxhcmdlIC0gMTtcclxuZXhwb3J0cy5TY3JlZW5XaWR0aE1heExhcmdlID0gZXhwb3J0cy5TY3JlZW5XaWR0aE1pblhMYXJnZSAtIDE7XHJcbmV4cG9ydHMuU2NyZWVuV2lkdGhNYXhYTGFyZ2UgPSBleHBvcnRzLlNjcmVlbldpZHRoTWluWFhMYXJnZSAtIDE7XHJcbmV4cG9ydHMuU2NyZWVuV2lkdGhNYXhYWExhcmdlID0gZXhwb3J0cy5TY3JlZW5XaWR0aE1pblhYWExhcmdlIC0gMTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q29tbW9uU3R5bGVzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBpbmRleF8xID0gcmVxdWlyZShcIkB1aWZhYnJpYy9tZXJnZS1zdHlsZXMvbGliL2luZGV4XCIpO1xyXG52YXIgZm9udHNfMSA9IHJlcXVpcmUoXCIuL2ZvbnRzXCIpO1xyXG52YXIgbGFuZ3VhZ2VfMSA9IHJlcXVpcmUoXCJAdWlmYWJyaWMvdXRpbGl0aWVzL2xpYi9sYW5ndWFnZVwiKTtcclxuLy8gRGVmYXVsdCB1cmxzLlxyXG52YXIgRGVmYXVsdEJhc2VVcmwgPSAnaHR0cHM6Ly9zdGF0aWMyLnNoYXJlcG9pbnRvbmxpbmUuY29tL2ZpbGVzL2ZhYnJpYy9hc3NldHMnO1xyXG4vLyBTdGFuZGFyZCBmb250IHN0eWxpbmcuXHJcbmV4cG9ydHMuRGVmYXVsdEZvbnRTdHlsZXMgPSBmb250c18xLmNyZWF0ZUZvbnRTdHlsZXMobGFuZ3VhZ2VfMS5nZXRMYW5ndWFnZSgpKTtcclxuZnVuY3Rpb24gX3JlZ2lzdGVyRm9udEZhY2UoZm9udEZhbWlseSwgdXJsLCBmb250V2VpZ2h0KSB7XHJcbiAgICBmb250RmFtaWx5ID0gXCInXCIgKyBmb250RmFtaWx5ICsgXCInXCI7XHJcbiAgICBpbmRleF8xLmZvbnRGYWNlKHtcclxuICAgICAgICBmb250RmFtaWx5OiBmb250RmFtaWx5LFxyXG4gICAgICAgIHNyYzogXCJ1cmwoJ1wiICsgdXJsICsgXCIud29mZjInKSBmb3JtYXQoJ3dvZmYyJyksXCIgK1xyXG4gICAgICAgICAgICAoXCJ1cmwoJ1wiICsgdXJsICsgXCIud29mZicpIGZvcm1hdCgnd29mZicpXCIpLFxyXG4gICAgICAgIGZvbnRXZWlnaHQ6IGZvbnRXZWlnaHQsXHJcbiAgICAgICAgZm9udFN0eWxlOiAnbm9ybWFsJ1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gX3JlZ2lzdGVyRm9udEZhY2VTZXQoYmFzZVVybCwgZm9udEZhbWlseSwgY2RuRm9sZGVyLCBjZG5Gb250TmFtZSkge1xyXG4gICAgaWYgKGNkbkZvbnROYW1lID09PSB2b2lkIDApIHsgY2RuRm9udE5hbWUgPSAnc2Vnb2V1aSc7IH1cclxuICAgIHZhciB1cmxCYXNlID0gYmFzZVVybCArIFwiL1wiICsgY2RuRm9sZGVyICsgXCIvXCIgKyBjZG5Gb250TmFtZTtcclxuICAgIF9yZWdpc3RlckZvbnRGYWNlKGZvbnRGYW1pbHksIHVybEJhc2UgKyAnLWxpZ2h0JywgZm9udHNfMS5Gb250V2VpZ2h0cy5saWdodCk7XHJcbiAgICBfcmVnaXN0ZXJGb250RmFjZShmb250RmFtaWx5LCB1cmxCYXNlICsgJy1zZW1pbGlnaHQnLCBmb250c18xLkZvbnRXZWlnaHRzLnNlbWlsaWdodCk7XHJcbiAgICBfcmVnaXN0ZXJGb250RmFjZShmb250RmFtaWx5LCB1cmxCYXNlICsgJy1yZWd1bGFyJywgZm9udHNfMS5Gb250V2VpZ2h0cy5yZWd1bGFyKTtcclxuICAgIF9yZWdpc3RlckZvbnRGYWNlKGZvbnRGYW1pbHksIHVybEJhc2UgKyAnLXNlbWlib2xkJywgZm9udHNfMS5Gb250V2VpZ2h0cy5zZW1pYm9sZCk7XHJcbn1cclxuZnVuY3Rpb24gcmVnaXN0ZXJEZWZhdWx0Rm9udEZhY2VzKGJhc2VVcmwpIHtcclxuICAgIGlmIChiYXNlVXJsKSB7XHJcbiAgICAgICAgdmFyIGZvbnRVcmwgPSBiYXNlVXJsICsgXCIvZm9udHNcIjtcclxuICAgICAgICAvLyBQcm9kdWNlIEBmb250LWZhY2UgZGVmaW5pdGlvbnMgZm9yIGFsbCBzdXBwb3J0ZWQgd2ViIGZvbnRzLlxyXG4gICAgICAgIF9yZWdpc3RlckZvbnRGYWNlU2V0KGZvbnRVcmwsIGZvbnRzXzEuTG9jYWxpemVkRm9udE5hbWVzLlRoYWksICdsZWVsYXdhZGVldWktdGhhaScsICdsZWVsYXdhZGVldWknKTtcclxuICAgICAgICBfcmVnaXN0ZXJGb250RmFjZVNldChmb250VXJsLCBmb250c18xLkxvY2FsaXplZEZvbnROYW1lcy5BcmFiaWMsICdzZWdvZXVpLWFyYWJpYycpO1xyXG4gICAgICAgIF9yZWdpc3RlckZvbnRGYWNlU2V0KGZvbnRVcmwsIGZvbnRzXzEuTG9jYWxpemVkRm9udE5hbWVzLkN5cmlsbGljLCAnc2Vnb2V1aS1jeXJpbGxpYycpO1xyXG4gICAgICAgIF9yZWdpc3RlckZvbnRGYWNlU2V0KGZvbnRVcmwsIGZvbnRzXzEuTG9jYWxpemVkRm9udE5hbWVzLkVhc3RFdXJvcGVhbiwgJ3NlZ29ldWktZWFzdGV1cm9wZWFuJyk7XHJcbiAgICAgICAgX3JlZ2lzdGVyRm9udEZhY2VTZXQoZm9udFVybCwgZm9udHNfMS5Mb2NhbGl6ZWRGb250TmFtZXMuR3JlZWssICdzZWdvZXVpLWdyZWVrJyk7XHJcbiAgICAgICAgX3JlZ2lzdGVyRm9udEZhY2VTZXQoZm9udFVybCwgZm9udHNfMS5Mb2NhbGl6ZWRGb250TmFtZXMuSGVicmV3LCAnc2Vnb2V1aS1oZWJyZXcnKTtcclxuICAgICAgICBfcmVnaXN0ZXJGb250RmFjZVNldChmb250VXJsLCBmb250c18xLkxvY2FsaXplZEZvbnROYW1lcy5WaWV0bmFtZXNlLCAnc2Vnb2V1aS12aWV0bmFtZXNlJyk7XHJcbiAgICAgICAgX3JlZ2lzdGVyRm9udEZhY2VTZXQoZm9udFVybCwgZm9udHNfMS5Mb2NhbGl6ZWRGb250TmFtZXMuV2VzdEV1cm9wZWFuLCAnc2Vnb2V1aS13ZXN0ZXVyb3BlYW4nKTtcclxuICAgICAgICBfcmVnaXN0ZXJGb250RmFjZVNldChmb250VXJsLCBmb250c18xLkxvY2FsaXplZEZvbnRGYW1pbGllcy5TZWxhd2lrLCAnc2VsYXdpaycsICdzZWxhd2lrJyk7XHJcbiAgICAgICAgLy8gTGVlbGF3YWRlZSBVSSAoVGhhaSkgZG9lcyBub3QgaGF2ZSBhICdsaWdodCcgd2VpZ2h0LCBzbyB3ZSBvdmVycmlkZVxyXG4gICAgICAgIC8vIHRoZSBmb250LWZhY2UgZ2VuZXJhdGVkIGFib3ZlIHRvIHVzZSB0aGUgJ3NlbWlsaWdodCcgd2VpZ2h0IGluc3RlYWQuXHJcbiAgICAgICAgX3JlZ2lzdGVyRm9udEZhY2UoJ0xlZWxhd2FkZWUgVUkgV2ViJywgZm9udFVybCArIFwiL2xlZWxhd2FkZWV1aS10aGFpL2xlZWxhd2FkZWV1aS1zZW1pbGlnaHRcIiwgZm9udHNfMS5Gb250V2VpZ2h0cy5saWdodCk7XHJcbiAgICAgICAgLy8gTGVlbGF3YWRlZSBVSSAoVGhhaSkgZG9lcyBub3QgaGF2ZSBhICdzZW1pYm9sZCcgd2VpZ2h0LCBzbyB3ZSBvdmVycmlkZVxyXG4gICAgICAgIC8vIHRoZSBmb250LWZhY2UgZ2VuZXJhdGVkIGFib3ZlIHRvIHVzZSB0aGUgJ2JvbGQnIHdlaWdodCBpbnN0ZWFkLlxyXG4gICAgICAgIF9yZWdpc3RlckZvbnRGYWNlKCdMZWVsYXdhZGVlIFVJIFdlYicsIGZvbnRVcmwgKyBcIi9sZWVsYXdhZGVldWktdGhhaS9sZWVsYXdhZGVldWktYm9sZFwiLCBmb250c18xLkZvbnRXZWlnaHRzLnNlbWlib2xkKTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLnJlZ2lzdGVyRGVmYXVsdEZvbnRGYWNlcyA9IHJlZ2lzdGVyRGVmYXVsdEZvbnRGYWNlcztcclxuLyoqXHJcbiAqIFJlYWRzIHRoZSBmb250QmFzZVVybCBmcm9tIHdpbmRvdy5GYWJyaWNDb25maWcuZm9udEJhc2VVcmwgb3IgZmFsbHMgYmFjayB0byBhIGRlZmF1bHQuXHJcbiAqL1xyXG5mdW5jdGlvbiBfZ2V0Rm9udEJhc2VVcmwoKSB7XHJcbiAgICB2YXIgd2luID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgPyB3aW5kb3cgOiB1bmRlZmluZWQ7XHJcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tc3RyaW5nLWxpdGVyYWwgbm8tYW55XHJcbiAgICB2YXIgZmFicmljQ29uZmlnID0gd2luID8gd2luWydGYWJyaWNDb25maWcnXSA6IHVuZGVmaW5lZDtcclxuICAgIHJldHVybiAoZmFicmljQ29uZmlnICYmIGZhYnJpY0NvbmZpZy5mb250QmFzZVVybCAhPT0gdW5kZWZpbmVkKSA/IGZhYnJpY0NvbmZpZy5mb250QmFzZVVybCA6IERlZmF1bHRCYXNlVXJsO1xyXG59XHJcbi8qKlxyXG4gKiBSZWdpc3RlciB0aGUgZm9udCBmYWNlcy5cclxuICovXHJcbnJlZ2lzdGVyRGVmYXVsdEZvbnRGYWNlcyhfZ2V0Rm9udEJhc2VVcmwoKSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPURlZmF1bHRGb250U3R5bGVzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuRGVmYXVsdFBhbGV0dGUgPSB7XHJcbiAgICB0aGVtZURhcmtlcjogJyMwMDQ1NzgnLFxyXG4gICAgdGhlbWVEYXJrOiAnIzAwNWE5ZScsXHJcbiAgICB0aGVtZURhcmtBbHQ6ICcjMTA2ZWJlJyxcclxuICAgIHRoZW1lUHJpbWFyeTogJyMwMDc4ZDcnLFxyXG4gICAgdGhlbWVTZWNvbmRhcnk6ICcjMmI4OGQ4JyxcclxuICAgIHRoZW1lVGVydGlhcnk6ICcjNzFhZmU1JyxcclxuICAgIHRoZW1lTGlnaHQ6ICcjYzdlMGY0JyxcclxuICAgIHRoZW1lTGlnaHRlcjogJyNkZWVjZjknLFxyXG4gICAgdGhlbWVMaWdodGVyQWx0OiAnI2VmZjZmYycsXHJcbiAgICBibGFjazogJyMwMDAwMDAnLFxyXG4gICAgYmxhY2tUcmFuc2x1Y2VudDQwOiAncmdiYSgwLDAsMCwuNCknLFxyXG4gICAgbmV1dHJhbERhcms6ICcjMjEyMTIxJyxcclxuICAgIG5ldXRyYWxQcmltYXJ5OiAnIzMzMzMzMycsXHJcbiAgICBuZXV0cmFsUHJpbWFyeUFsdDogJyMzYzNjM2MnLFxyXG4gICAgbmV1dHJhbFNlY29uZGFyeTogJyM2NjY2NjYnLFxyXG4gICAgbmV1dHJhbFRlcnRpYXJ5OiAnI2E2YTZhNicsXHJcbiAgICBuZXV0cmFsVGVydGlhcnlBbHQ6ICcjYzhjOGM4JyxcclxuICAgIG5ldXRyYWxRdWF0ZXJuYXJ5OiAnI2QwZDBkMCcsXHJcbiAgICBuZXV0cmFsUXVhdGVybmFyeUFsdDogJyNkYWRhZGEnLFxyXG4gICAgbmV1dHJhbExpZ2h0OiAnI2VhZWFlYScsXHJcbiAgICBuZXV0cmFsTGlnaHRlcjogJyNmNGY0ZjQnLFxyXG4gICAgbmV1dHJhbExpZ2h0ZXJBbHQ6ICcjZjhmOGY4JyxcclxuICAgIGFjY2VudDogJyMwMDc4ZDcnLFxyXG4gICAgd2hpdGU6ICcjZmZmZmZmJyxcclxuICAgIHllbGxvdzogJyNmZmI5MDAnLFxyXG4gICAgeWVsbG93TGlnaHQ6ICcjZmZmMTAwJyxcclxuICAgIG9yYW5nZTogJyNkODNiMDEnLFxyXG4gICAgb3JhbmdlTGlnaHQ6ICcjZWE0MzAwJyxcclxuICAgIG9yYW5nZUxpZ2h0ZXI6ICcjZmY4YzAwJyxcclxuICAgIHJlZERhcms6ICcjYTgwMDAwJyxcclxuICAgIHJlZDogJyNlODExMjMnLFxyXG4gICAgbWFnZW50YURhcms6ICcjNWMwMDVjJyxcclxuICAgIG1hZ2VudGE6ICcjYjQwMDllJyxcclxuICAgIG1hZ2VudGFMaWdodDogJyNlMzAwOGMnLFxyXG4gICAgcHVycGxlRGFyazogJyMzMjE0NWEnLFxyXG4gICAgcHVycGxlOiAnIzVjMmQ5MScsXHJcbiAgICBwdXJwbGVMaWdodDogJyNiNGEwZmYnLFxyXG4gICAgYmx1ZURhcms6ICcjMDAyMDUwJyxcclxuICAgIGJsdWVNaWQ6ICcjMDAxODhmJyxcclxuICAgIGJsdWU6ICcjMDA3OGQ3JyxcclxuICAgIGJsdWVMaWdodDogJyMwMGJjZjInLFxyXG4gICAgdGVhbERhcms6ICcjMDA0YjUwJyxcclxuICAgIHRlYWw6ICcjMDA4MjcyJyxcclxuICAgIHRlYWxMaWdodDogJyMwMGIyOTQnLFxyXG4gICAgZ3JlZW5EYXJrOiAnIzAwNGIxYycsXHJcbiAgICBncmVlbjogJyMxMDdjMTAnLFxyXG4gICAgZ3JlZW5MaWdodDogJyNiYWQ4MGEnLFxyXG59O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1EZWZhdWx0UGFsZXR0ZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4vLyBGYWxsYmFjayBmb250cywgaWYgc3BlY2lmaWVkIHN5c3RlbSBvciB3ZWIgZm9udHMgYXJlIHVuYXZhaWxhYmxlLlxyXG52YXIgRm9udEZhbWlseUZhbGxiYWNrcyA9IFwiJ1NlZ29lIFVJJywgLWFwcGxlLXN5c3RlbSwgQmxpbmtNYWNTeXN0ZW1Gb250LCAnUm9ib3RvJywgJ0hlbHZldGljYSBOZXVlJywgc2Fucy1zZXJpZlwiO1xyXG4vLyBGb250IGZhY2UgbmFtZXMgdG8gYmUgcmVnaXN0ZXJlZC5cclxudmFyIExvY2FsaXplZEZvbnROYW1lcztcclxuKGZ1bmN0aW9uIChMb2NhbGl6ZWRGb250TmFtZXMpIHtcclxuICAgIExvY2FsaXplZEZvbnROYW1lcy5BcmFiaWMgPSAnU2Vnb2UgVUkgV2ViIChBcmFiaWMpJztcclxuICAgIExvY2FsaXplZEZvbnROYW1lcy5DeXJpbGxpYyA9ICdTZWdvZSBVSSBXZWIgKEN5cmlsbGljKSc7XHJcbiAgICBMb2NhbGl6ZWRGb250TmFtZXMuRWFzdEV1cm9wZWFuID0gJ1NlZ29lIFVJIFdlYiAoRWFzdCBFdXJvcGVhbiknO1xyXG4gICAgTG9jYWxpemVkRm9udE5hbWVzLkdyZWVrID0gJ1NlZ29lIFVJIFdlYiAoR3JlZWspJztcclxuICAgIExvY2FsaXplZEZvbnROYW1lcy5IZWJyZXcgPSAnU2Vnb2UgVUkgV2ViIChIZWJyZXcpJztcclxuICAgIExvY2FsaXplZEZvbnROYW1lcy5UaGFpID0gJ0xlZWxhd2FkZWUgVUkgV2ViJztcclxuICAgIExvY2FsaXplZEZvbnROYW1lcy5WaWV0bmFtZXNlID0gJ1NlZ29lIFVJIFdlYiAoVmlldG5hbWVzZSknO1xyXG4gICAgTG9jYWxpemVkRm9udE5hbWVzLldlc3RFdXJvcGVhbiA9ICdTZWdvZSBVSSBXZWIgKFdlc3QgRXVyb3BlYW4pJztcclxuICAgIExvY2FsaXplZEZvbnROYW1lcy5TZWxhd2lrID0gJ1NlbGF3aWsgV2ViJztcclxufSkoTG9jYWxpemVkRm9udE5hbWVzID0gZXhwb3J0cy5Mb2NhbGl6ZWRGb250TmFtZXMgfHwgKGV4cG9ydHMuTG9jYWxpemVkRm9udE5hbWVzID0ge30pKTtcclxuLy8gRm9udCBmYW1pbGllcyB3aXRoIGZhbGxiYWNrcywgZm9yIHRoZSBnZW5lcmFsIHJlZ2lvbnMuXHJcbnZhciBMb2NhbGl6ZWRGb250RmFtaWxpZXM7XHJcbihmdW5jdGlvbiAoTG9jYWxpemVkRm9udEZhbWlsaWVzKSB7XHJcbiAgICBMb2NhbGl6ZWRGb250RmFtaWxpZXMuQXJhYmljID0gXCInXCIgKyBMb2NhbGl6ZWRGb250TmFtZXMuQXJhYmljICsgXCInXCI7XHJcbiAgICBMb2NhbGl6ZWRGb250RmFtaWxpZXMuQ2hpbmVzZVNpbXBsaWZpZWQgPSBcIidNaWNyb3NvZnQgWWFoZWkgVUknLCBWZXJkYW5hLCBTaW1zdW5cIjtcclxuICAgIExvY2FsaXplZEZvbnRGYW1pbGllcy5DaGluZXNlVHJhZGl0aW9uYWwgPSBcIidNaWNyb3NvZnQgSmhlbmdoZWkgVUknLCBQbWluZ2xpdVwiO1xyXG4gICAgTG9jYWxpemVkRm9udEZhbWlsaWVzLkN5cmlsbGljID0gXCInXCIgKyBMb2NhbGl6ZWRGb250TmFtZXMuQ3lyaWxsaWMgKyBcIidcIjtcclxuICAgIExvY2FsaXplZEZvbnRGYW1pbGllcy5FYXN0RXVyb3BlYW4gPSBcIidcIiArIExvY2FsaXplZEZvbnROYW1lcy5FYXN0RXVyb3BlYW4gKyBcIidcIjtcclxuICAgIExvY2FsaXplZEZvbnRGYW1pbGllcy5HcmVlayA9IFwiJ1wiICsgTG9jYWxpemVkRm9udE5hbWVzLkdyZWVrICsgXCInXCI7XHJcbiAgICBMb2NhbGl6ZWRGb250RmFtaWxpZXMuSGVicmV3ID0gXCInXCIgKyBMb2NhbGl6ZWRGb250TmFtZXMuSGVicmV3ICsgXCInXCI7XHJcbiAgICBMb2NhbGl6ZWRGb250RmFtaWxpZXMuSGluZGkgPSBcIidOaXJtYWxhIFVJJ1wiO1xyXG4gICAgTG9jYWxpemVkRm9udEZhbWlsaWVzLkphcGFuZXNlID0gXCInWXUgR290aGljIFVJJywgJ01laXJ5byBVSScsIE1laXJ5bywgJ01TIFBnb3RoaWMnLCBPc2FrYVwiO1xyXG4gICAgTG9jYWxpemVkRm9udEZhbWlsaWVzLktvcmVhbiA9IFwiJ01hbGd1biBHb3RoaWMnLCBHdWxpbVwiO1xyXG4gICAgTG9jYWxpemVkRm9udEZhbWlsaWVzLlNlbGF3aWsgPSBcIidcIiArIExvY2FsaXplZEZvbnROYW1lcy5TZWxhd2lrICsgXCInXCI7XHJcbiAgICBMb2NhbGl6ZWRGb250RmFtaWxpZXMuVGhhaSA9IFwiJ0xlZWxhd2FkZWUgVUkgV2ViJywgJ0ttZXIgVUknXCI7XHJcbiAgICBMb2NhbGl6ZWRGb250RmFtaWxpZXMuVmlldG5hbWVzZSA9IFwiJ1wiICsgTG9jYWxpemVkRm9udE5hbWVzLlZpZXRuYW1lc2UgKyBcIidcIjtcclxuICAgIExvY2FsaXplZEZvbnRGYW1pbGllcy5XZXN0RXVyb3BlYW4gPSBcIidcIiArIExvY2FsaXplZEZvbnROYW1lcy5XZXN0RXVyb3BlYW4gKyBcIidcIjtcclxufSkoTG9jYWxpemVkRm9udEZhbWlsaWVzID0gZXhwb3J0cy5Mb2NhbGl6ZWRGb250RmFtaWxpZXMgfHwgKGV4cG9ydHMuTG9jYWxpemVkRm9udEZhbWlsaWVzID0ge30pKTtcclxuLy8gTWFwcGluZyBvZiBsYW5ndWFnZSBwcmVmaXggdG8gdG8gZm9udCBmYW1pbHkuXHJcbnZhciBMYW5ndWFnZVRvRm9udE1hcCA9IHtcclxuICAgICdhcic6IExvY2FsaXplZEZvbnRGYW1pbGllcy5BcmFiaWMsXHJcbiAgICAnYmcnOiBMb2NhbGl6ZWRGb250RmFtaWxpZXMuQ3lyaWxsaWMsXHJcbiAgICAnY3MnOiBMb2NhbGl6ZWRGb250RmFtaWxpZXMuRWFzdEV1cm9wZWFuLFxyXG4gICAgJ2VsJzogTG9jYWxpemVkRm9udEZhbWlsaWVzLkdyZWVrLFxyXG4gICAgJ2V0JzogTG9jYWxpemVkRm9udEZhbWlsaWVzLkVhc3RFdXJvcGVhbixcclxuICAgICdoZSc6IExvY2FsaXplZEZvbnRGYW1pbGllcy5IZWJyZXcsXHJcbiAgICAnaGknOiBMb2NhbGl6ZWRGb250RmFtaWxpZXMuSGluZGksXHJcbiAgICAnaHInOiBMb2NhbGl6ZWRGb250RmFtaWxpZXMuRWFzdEV1cm9wZWFuLFxyXG4gICAgJ2h1JzogTG9jYWxpemVkRm9udEZhbWlsaWVzLkVhc3RFdXJvcGVhbixcclxuICAgICdqYSc6IExvY2FsaXplZEZvbnRGYW1pbGllcy5KYXBhbmVzZSxcclxuICAgICdrayc6IExvY2FsaXplZEZvbnRGYW1pbGllcy5FYXN0RXVyb3BlYW4sXHJcbiAgICAna28nOiBMb2NhbGl6ZWRGb250RmFtaWxpZXMuS29yZWFuLFxyXG4gICAgJ2x0JzogTG9jYWxpemVkRm9udEZhbWlsaWVzLkVhc3RFdXJvcGVhbixcclxuICAgICdsdic6IExvY2FsaXplZEZvbnRGYW1pbGllcy5FYXN0RXVyb3BlYW4sXHJcbiAgICAncGwnOiBMb2NhbGl6ZWRGb250RmFtaWxpZXMuRWFzdEV1cm9wZWFuLFxyXG4gICAgJ3J1JzogTG9jYWxpemVkRm9udEZhbWlsaWVzLkN5cmlsbGljLFxyXG4gICAgJ3NrJzogTG9jYWxpemVkRm9udEZhbWlsaWVzLkVhc3RFdXJvcGVhbixcclxuICAgICdzci1sYXRuJzogTG9jYWxpemVkRm9udEZhbWlsaWVzLkVhc3RFdXJvcGVhbixcclxuICAgICd0aCc6IExvY2FsaXplZEZvbnRGYW1pbGllcy5UaGFpLFxyXG4gICAgJ3RyJzogTG9jYWxpemVkRm9udEZhbWlsaWVzLkVhc3RFdXJvcGVhbixcclxuICAgICd1ayc6IExvY2FsaXplZEZvbnRGYW1pbGllcy5DeXJpbGxpYyxcclxuICAgICd2aSc6IExvY2FsaXplZEZvbnRGYW1pbGllcy5WaWV0bmFtZXNlLFxyXG4gICAgJ3poLWhhbnMnOiBMb2NhbGl6ZWRGb250RmFtaWxpZXMuQ2hpbmVzZVNpbXBsaWZpZWQsXHJcbiAgICAnemgtaGFudCc6IExvY2FsaXplZEZvbnRGYW1pbGllcy5DaGluZXNlVHJhZGl0aW9uYWwsXHJcbn07XHJcbi8vIFN0YW5kYXJkIGZvbnQgc2l6ZXMuXHJcbnZhciBGb250U2l6ZXM7XHJcbihmdW5jdGlvbiAoRm9udFNpemVzKSB7XHJcbiAgICBGb250U2l6ZXMubWluaSA9ICcxMHB4JztcclxuICAgIEZvbnRTaXplcy54U21hbGwgPSAnMTFweCc7XHJcbiAgICBGb250U2l6ZXMuc21hbGwgPSAnMTJweCc7XHJcbiAgICBGb250U2l6ZXMuc21hbGxQbHVzID0gJzEzcHgnO1xyXG4gICAgRm9udFNpemVzLm1lZGl1bSA9ICcxNHB4JztcclxuICAgIEZvbnRTaXplcy5tZWRpdW1QbHVzID0gJzE1cHgnO1xyXG4gICAgRm9udFNpemVzLmljb24gPSAnMTZweCc7XHJcbiAgICBGb250U2l6ZXMubGFyZ2UgPSAnMTdweCc7XHJcbiAgICBGb250U2l6ZXMueExhcmdlID0gJzIxcHgnO1xyXG4gICAgRm9udFNpemVzLnh4TGFyZ2UgPSAnMjhweCc7XHJcbiAgICBGb250U2l6ZXMuc3VwZXJMYXJnZSA9ICc0MnB4JztcclxuICAgIEZvbnRTaXplcy5tZWdhID0gJzcycHgnO1xyXG59KShGb250U2l6ZXMgPSBleHBvcnRzLkZvbnRTaXplcyB8fCAoZXhwb3J0cy5Gb250U2l6ZXMgPSB7fSkpO1xyXG4vLyBTdGFuZGFyZCBmb250IHdlaWdodHMuXHJcbnZhciBGb250V2VpZ2h0cztcclxuKGZ1bmN0aW9uIChGb250V2VpZ2h0cykge1xyXG4gICAgRm9udFdlaWdodHMubGlnaHQgPSAxMDA7XHJcbiAgICBGb250V2VpZ2h0cy5zZW1pbGlnaHQgPSAzMDA7XHJcbiAgICBGb250V2VpZ2h0cy5yZWd1bGFyID0gNDAwO1xyXG4gICAgRm9udFdlaWdodHMuc2VtaWJvbGQgPSA2MDA7XHJcbiAgICBGb250V2VpZ2h0cy5ib2xkID0gNzAwO1xyXG59KShGb250V2VpZ2h0cyA9IGV4cG9ydHMuRm9udFdlaWdodHMgfHwgKGV4cG9ydHMuRm9udFdlaWdodHMgPSB7fSkpO1xyXG4vLyBTdGFuZGFyZCBJY29uIFNpemVzLlxyXG52YXIgSWNvbkZvbnRTaXplcztcclxuKGZ1bmN0aW9uIChJY29uRm9udFNpemVzKSB7XHJcbiAgICBJY29uRm9udFNpemVzLnhTbWFsbCA9ICcxMHB4JztcclxuICAgIEljb25Gb250U2l6ZXMuc21hbGwgPSAnMTJweCc7XHJcbiAgICBJY29uRm9udFNpemVzLm1lZGl1bSA9ICcxNnB4JztcclxuICAgIEljb25Gb250U2l6ZXMubGFyZ2UgPSAnMjBweCc7XHJcbn0pKEljb25Gb250U2l6ZXMgPSBleHBvcnRzLkljb25Gb250U2l6ZXMgfHwgKGV4cG9ydHMuSWNvbkZvbnRTaXplcyA9IHt9KSk7XHJcbmZ1bmN0aW9uIGNyZWF0ZUZvbnRTdHlsZXMobG9jYWxlQ29kZSkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICB0aW55OiBfY3JlYXRlRm9udChGb250U2l6ZXMubWluaSwgRm9udFdlaWdodHMuc2VtaWJvbGQsIGxvY2FsZUNvZGUpLFxyXG4gICAgICAgIHhTbWFsbDogX2NyZWF0ZUZvbnQoRm9udFNpemVzLnhTbWFsbCwgRm9udFdlaWdodHMucmVndWxhciwgbG9jYWxlQ29kZSksXHJcbiAgICAgICAgc21hbGw6IF9jcmVhdGVGb250KEZvbnRTaXplcy5zbWFsbCwgRm9udFdlaWdodHMucmVndWxhciwgbG9jYWxlQ29kZSksXHJcbiAgICAgICAgc21hbGxQbHVzOiBfY3JlYXRlRm9udChGb250U2l6ZXMuc21hbGxQbHVzLCBGb250V2VpZ2h0cy5yZWd1bGFyLCBsb2NhbGVDb2RlKSxcclxuICAgICAgICBtZWRpdW06IF9jcmVhdGVGb250KEZvbnRTaXplcy5tZWRpdW0sIEZvbnRXZWlnaHRzLnJlZ3VsYXIsIGxvY2FsZUNvZGUpLFxyXG4gICAgICAgIG1lZGl1bVBsdXM6IF9jcmVhdGVGb250KEZvbnRTaXplcy5tZWRpdW1QbHVzLCBGb250V2VpZ2h0cy5yZWd1bGFyLCBsb2NhbGVDb2RlKSxcclxuICAgICAgICBsYXJnZTogX2NyZWF0ZUZvbnQoRm9udFNpemVzLmxhcmdlLCBGb250V2VpZ2h0cy5zZW1pbGlnaHQsIGxvY2FsZUNvZGUpLFxyXG4gICAgICAgIHhMYXJnZTogX2NyZWF0ZUZvbnQoRm9udFNpemVzLnhMYXJnZSwgRm9udFdlaWdodHMubGlnaHQsIGxvY2FsZUNvZGUpLFxyXG4gICAgICAgIHh4TGFyZ2U6IF9jcmVhdGVGb250KEZvbnRTaXplcy54eExhcmdlLCBGb250V2VpZ2h0cy5saWdodCwgbG9jYWxlQ29kZSksXHJcbiAgICAgICAgc3VwZXJMYXJnZTogX2NyZWF0ZUZvbnQoRm9udFNpemVzLnN1cGVyTGFyZ2UsIEZvbnRXZWlnaHRzLmxpZ2h0LCBsb2NhbGVDb2RlKSxcclxuICAgICAgICBtZWdhOiBfY3JlYXRlRm9udChGb250U2l6ZXMubWVnYSwgRm9udFdlaWdodHMubGlnaHQsIGxvY2FsZUNvZGUpXHJcbiAgICB9O1xyXG59XHJcbmV4cG9ydHMuY3JlYXRlRm9udFN0eWxlcyA9IGNyZWF0ZUZvbnRTdHlsZXM7XHJcbmZ1bmN0aW9uIF9nZXRGb250RmFtaWx5KGxhbmd1YWdlKSB7XHJcbiAgICB2YXIgZm9udEZhbWlseSA9IExvY2FsaXplZEZvbnRGYW1pbGllcy5XZXN0RXVyb3BlYW47XHJcbiAgICBmb3IgKHZhciBsYW5nIGluIExhbmd1YWdlVG9Gb250TWFwKSB7XHJcbiAgICAgICAgaWYgKExhbmd1YWdlVG9Gb250TWFwLmhhc093blByb3BlcnR5KGxhbmcpICYmIGxhbmd1YWdlICYmIGxhbmcuaW5kZXhPZihsYW5ndWFnZSkgPT09IDApIHtcclxuICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueVxyXG4gICAgICAgICAgICBmb250RmFtaWx5ID0gTGFuZ3VhZ2VUb0ZvbnRNYXBbbGFuZ107XHJcbiAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBmb250RmFtaWx5ICsgXCIsIFwiICsgRm9udEZhbWlseUZhbGxiYWNrcztcclxufVxyXG5mdW5jdGlvbiBfY3JlYXRlRm9udChzaXplLCB3ZWlnaHQsIGxvY2FsZUNvZGUpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgZm9udEZhbWlseTogX2dldEZvbnRGYW1pbHkobG9jYWxlQ29kZSksXHJcbiAgICAgICAgTW96T3N4Rm9udFNtb290aGluZzogJ2dyYXlzY2FsZScsXHJcbiAgICAgICAgV2Via2l0Rm9udFNtb290aGluZzogJ2FudGlhbGlhc2VkJyxcclxuICAgICAgICBmb250U2l6ZTogc2l6ZSxcclxuICAgICAgICBmb250V2VpZ2h0OiB3ZWlnaHRcclxuICAgIH07XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Zm9udHMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuLyoqXHJcbiAqIEdlbmVyYXRlcyBhIGZvY3VzIHN0eWxlIHdoaWNoIGNhbiBiZSB1c2VkIHRvIGRlZmluZSBhbiA6YWZ0ZXIgZm9jdXMgYm9yZGVyLlxyXG4gKlxyXG4gKiBAcGFyYW0gdGhlbWUgLSBUaGUgdGhlbWUgb2JqZWN0IHRvIHVzZS5cclxuICogQHBhcmFtIGluc2V0IC0gVGhlIG51bWJlciBvZiBwaXhlbHMgdG8gaW5zZXQgdGhlIGJvcmRlci5cclxuICogQHBhcmFtIGNvbG9yIC0gVGhlIGNvbG9yIGZvciB0aGUgYm9yZGVyLlxyXG4gKiBAcGFyYW0gcG9zaXRpb24gLSBUaGUgcG9zaXRpb25pbmcgYXBwbGllZCB0byB0aGUgY29udGFpbmVyLiBNdXN0XHJcbiAqIGJlICdyZWxhdGl2ZScgb3IgJ2Fic29sdXRlJyBzbyB0aGF0IHRoZSBmb2N1cyBib3JkZXIgY2FuIGxpdmUgYXJvdW5kIGl0LlxyXG4gKiBAcmV0dXJucyBUaGUgc3R5bGUgb2JqZWN0LlxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0Rm9jdXNTdHlsZSh0aGVtZSwgaW5zZXQsIHBvc2l0aW9uKSB7XHJcbiAgICBpZiAoaW5zZXQgPT09IHZvaWQgMCkgeyBpbnNldCA9IDA7IH1cclxuICAgIGlmIChwb3NpdGlvbiA9PT0gdm9pZCAwKSB7IHBvc2l0aW9uID0gJ3JlbGF0aXZlJzsgfVxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBvdXRsaW5lOiAndHJhbnNwYXJlbnQnLFxyXG4gICAgICAgIHBvc2l0aW9uOiBwb3NpdGlvbixcclxuICAgICAgICBzZWxlY3RvcnM6IHtcclxuICAgICAgICAgICAgJzo6LW1vei1mb2N1cy1pbm5lcic6IHtcclxuICAgICAgICAgICAgICAgIGJvcmRlcjogJzAnXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICcubXMtRmFicmljLmlzLWZvY3VzVmlzaWJsZSAmOmZvY3VzOmFmdGVyJzoge1xyXG4gICAgICAgICAgICAgICAgY29udGVudDogJ1wiXCInLFxyXG4gICAgICAgICAgICAgICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXHJcbiAgICAgICAgICAgICAgICBsZWZ0OiBpbnNldCArIDEsXHJcbiAgICAgICAgICAgICAgICB0b3A6IGluc2V0ICsgMSxcclxuICAgICAgICAgICAgICAgIGJvdHRvbTogaW5zZXQgKyAxLFxyXG4gICAgICAgICAgICAgICAgcmlnaHQ6IGluc2V0ICsgMSxcclxuICAgICAgICAgICAgICAgIGJvcmRlcjogJzFweCBzb2xpZCAnICsgdGhlbWUucGFsZXR0ZS53aGl0ZSxcclxuICAgICAgICAgICAgICAgIG91dGxpbmU6ICcxcHggc29saWQgJyArIHRoZW1lLnBhbGV0dGUubmV1dHJhbFNlY29uZGFyeSxcclxuICAgICAgICAgICAgICAgIHpJbmRleDogMVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG5leHBvcnRzLmdldEZvY3VzU3R5bGUgPSBnZXRGb2N1c1N0eWxlO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1nZXRGb2N1c1N0eWxlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbmV4cG9ydHMuaGlkZGVuQ29udGVudFN0eWxlID0ge1xyXG4gICAgcG9zaXRpb246ICdhYnNvbHV0ZScsXHJcbiAgICB3aWR0aDogMSxcclxuICAgIGhlaWdodDogMSxcclxuICAgIG1hcmdpbjogLTEsXHJcbiAgICBwYWRkaW5nOiAwLFxyXG4gICAgYm9yZGVyOiAwLFxyXG4gICAgb3ZlcmZsb3c6ICdoaWRkZW4nXHJcbn07XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhpZGRlbkNvbnRlbnRTdHlsZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcclxudmFyIEFuaW1hdGlvblN0eWxlc18xID0gcmVxdWlyZShcIi4vQW5pbWF0aW9uU3R5bGVzXCIpO1xyXG5leHBvcnRzLkFuaW1hdGlvblN0eWxlcyA9IEFuaW1hdGlvblN0eWxlc18xLkFuaW1hdGlvblN0eWxlcztcclxudmFyIERlZmF1bHRQYWxldHRlXzEgPSByZXF1aXJlKFwiLi9EZWZhdWx0UGFsZXR0ZVwiKTtcclxuZXhwb3J0cy5EZWZhdWx0UGFsZXR0ZSA9IERlZmF1bHRQYWxldHRlXzEuRGVmYXVsdFBhbGV0dGU7XHJcbnZhciBEZWZhdWx0Rm9udFN0eWxlc18xID0gcmVxdWlyZShcIi4vRGVmYXVsdEZvbnRTdHlsZXNcIik7XHJcbmV4cG9ydHMuRGVmYXVsdEZvbnRTdHlsZXMgPSBEZWZhdWx0Rm9udFN0eWxlc18xLkRlZmF1bHRGb250U3R5bGVzO1xyXG5leHBvcnRzLnJlZ2lzdGVyRGVmYXVsdEZvbnRGYWNlcyA9IERlZmF1bHRGb250U3R5bGVzXzEucmVnaXN0ZXJEZWZhdWx0Rm9udEZhY2VzO1xyXG52YXIgZm9udHNfMSA9IHJlcXVpcmUoXCIuL2ZvbnRzXCIpO1xyXG5leHBvcnRzLkZvbnRTaXplcyA9IGZvbnRzXzEuRm9udFNpemVzO1xyXG5leHBvcnRzLkZvbnRXZWlnaHRzID0gZm9udHNfMS5Gb250V2VpZ2h0cztcclxuZXhwb3J0cy5JY29uRm9udFNpemVzID0gZm9udHNfMS5JY29uRm9udFNpemVzO1xyXG5leHBvcnRzLmNyZWF0ZUZvbnRTdHlsZXMgPSBmb250c18xLmNyZWF0ZUZvbnRTdHlsZXM7XHJcbnZhciBnZXRGb2N1c1N0eWxlXzEgPSByZXF1aXJlKFwiLi9nZXRGb2N1c1N0eWxlXCIpO1xyXG5leHBvcnRzLmdldEZvY3VzU3R5bGUgPSBnZXRGb2N1c1N0eWxlXzEuZ2V0Rm9jdXNTdHlsZTtcclxudmFyIGhpZGRlbkNvbnRlbnRTdHlsZV8xID0gcmVxdWlyZShcIi4vaGlkZGVuQ29udGVudFN0eWxlXCIpO1xyXG5leHBvcnRzLmhpZGRlbkNvbnRlbnRTdHlsZSA9IGhpZGRlbkNvbnRlbnRTdHlsZV8xLmhpZGRlbkNvbnRlbnRTdHlsZTtcclxudmFyIHRoZW1lXzEgPSByZXF1aXJlKFwiLi90aGVtZVwiKTtcclxuZXhwb3J0cy5UaGVtZVNldHRpbmdOYW1lID0gdGhlbWVfMS5UaGVtZVNldHRpbmdOYW1lO1xyXG5leHBvcnRzLmdldFRoZW1lID0gdGhlbWVfMS5nZXRUaGVtZTtcclxuZXhwb3J0cy5sb2FkVGhlbWUgPSB0aGVtZV8xLmxvYWRUaGVtZTtcclxuZXhwb3J0cy5jcmVhdGVUaGVtZSA9IHRoZW1lXzEuY3JlYXRlVGhlbWU7XHJcbmV4cG9ydHMucmVnaXN0ZXJPblRoZW1lQ2hhbmdlQ2FsbGJhY2sgPSB0aGVtZV8xLnJlZ2lzdGVyT25UaGVtZUNoYW5nZUNhbGxiYWNrO1xyXG5leHBvcnRzLnJlbW92ZU9uVGhlbWVDaGFuZ2VDYWxsYmFjayA9IHRoZW1lXzEucmVtb3ZlT25UaGVtZUNoYW5nZUNhbGxiYWNrO1xyXG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9Db21tb25TdHlsZXNcIiksIGV4cG9ydHMpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcclxudmFyIEN1c3RvbWl6YXRpb25zXzEgPSByZXF1aXJlKFwiQHVpZmFicmljL3V0aWxpdGllcy9saWIvQ3VzdG9taXphdGlvbnNcIik7XHJcbnZhciBEZWZhdWx0Rm9udFN0eWxlc18xID0gcmVxdWlyZShcIi4vRGVmYXVsdEZvbnRTdHlsZXNcIik7XHJcbnZhciBEZWZhdWx0UGFsZXR0ZV8xID0gcmVxdWlyZShcIi4vRGVmYXVsdFBhbGV0dGVcIik7XHJcbnZhciBsb2FkX3RoZW1lZF9zdHlsZXNfMSA9IHJlcXVpcmUoXCJAbWljcm9zb2Z0L2xvYWQtdGhlbWVkLXN0eWxlc1wiKTtcclxudmFyIF90aGVtZSA9IHtcclxuICAgIHBhbGV0dGU6IERlZmF1bHRQYWxldHRlXzEuRGVmYXVsdFBhbGV0dGUsXHJcbiAgICBzZW1hbnRpY0NvbG9yczogX21ha2VTZW1hbnRpY0NvbG9yc0Zyb21QYWxldHRlKERlZmF1bHRQYWxldHRlXzEuRGVmYXVsdFBhbGV0dGUsIGZhbHNlKSxcclxuICAgIGZvbnRzOiBEZWZhdWx0Rm9udFN0eWxlc18xLkRlZmF1bHRGb250U3R5bGVzLFxyXG4gICAgaXNJbnZlcnRlZDogZmFsc2VcclxufTtcclxudmFyIF9vblRoZW1lQ2hhbmdlQ2FsbGJhY2tzID0gW107XHJcbmV4cG9ydHMuVGhlbWVTZXR0aW5nTmFtZSA9ICd0aGVtZSc7XHJcbmlmICghQ3VzdG9taXphdGlvbnNfMS5DdXN0b21pemF0aW9ucy5nZXRTZXR0aW5ncyhbZXhwb3J0cy5UaGVtZVNldHRpbmdOYW1lXSkudGhlbWUpIHtcclxuICAgIHZhciB3aW4gPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IHdpbmRvdyA6IHVuZGVmaW5lZDtcclxuICAgIC8vIHRzbGludDpkaXNhYmxlOm5vLXN0cmluZy1saXRlcmFsIG5vLWFueVxyXG4gICAgaWYgKHdpbiAmJiB3aW5bJ0ZhYnJpY0NvbmZpZyddICYmIHdpblsnRmFicmljQ29uZmlnJ10udGhlbWUpIHtcclxuICAgICAgICBfdGhlbWUgPSBjcmVhdGVUaGVtZSh3aW5bJ0ZhYnJpY0NvbmZpZyddLnRoZW1lKTtcclxuICAgIH1cclxuICAgIC8vIHRzbGludDplbmFibGU6bm8tc3RyaW5nLWxpdGVyYWwgbm8tYW55XHJcbiAgICAvLyBTZXQgdGhlIGRlZmF1bHQgdGhlbWUuXHJcbiAgICBDdXN0b21pemF0aW9uc18xLkN1c3RvbWl6YXRpb25zLmFwcGx5U2V0dGluZ3MoKF9hID0ge30sIF9hW2V4cG9ydHMuVGhlbWVTZXR0aW5nTmFtZV0gPSBfdGhlbWUsIF9hKSk7XHJcbn1cclxuLyoqXHJcbiAqIEdldHMgdGhlIHRoZW1lIG9iamVjdC5cclxuICovXHJcbmZ1bmN0aW9uIGdldFRoZW1lKCkge1xyXG4gICAgcmV0dXJuIF90aGVtZTtcclxufVxyXG5leHBvcnRzLmdldFRoZW1lID0gZ2V0VGhlbWU7XHJcbi8qKlxyXG4gKiBSZWdpc3RlcnMgYSBjYWxsYmFjayB0aGF0IGdldHMgY2FsbGVkIHdoZW5ldmVyIHRoZSB0aGVtZSBjaGFuZ2VzLlxyXG4gKiBUaGlzIHNob3VsZCBvbmx5IGJlIHVzZWQgd2hlbiB0aGUgY29tcG9uZW50IGNhbm5vdCBhdXRvbWF0aWNhbGx5IGdldCB0aGVtZSBjaGFuZ2VzIHRocm91Z2ggaXRzIHN0YXRlLlxyXG4gKiBUaGlzIHdpbGwgbm90IHJlZ2lzdGVyIGR1cGxpY2F0ZSBjYWxsYmFja3MuXHJcbiAqL1xyXG5mdW5jdGlvbiByZWdpc3Rlck9uVGhlbWVDaGFuZ2VDYWxsYmFjayhjYWxsYmFjaykge1xyXG4gICAgaWYgKF9vblRoZW1lQ2hhbmdlQ2FsbGJhY2tzLmluZGV4T2YoY2FsbGJhY2spID09PSAtMSkge1xyXG4gICAgICAgIF9vblRoZW1lQ2hhbmdlQ2FsbGJhY2tzLnB1c2goY2FsbGJhY2spO1xyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMucmVnaXN0ZXJPblRoZW1lQ2hhbmdlQ2FsbGJhY2sgPSByZWdpc3Rlck9uVGhlbWVDaGFuZ2VDYWxsYmFjaztcclxuLyoqXHJcbiAqIFNlZSByZWdpc3Rlck9uVGhlbWVDaGFuZ2VDYWxsYmFjaygpLlxyXG4gKiBSZW1vdmVzIHByZXZpb3VzbHkgcmVnaXN0ZXJlZCBjYWxsYmFja3MuXHJcbiAqL1xyXG5mdW5jdGlvbiByZW1vdmVPblRoZW1lQ2hhbmdlQ2FsbGJhY2soY2FsbGJhY2spIHtcclxuICAgIHZhciBpID0gX29uVGhlbWVDaGFuZ2VDYWxsYmFja3MuaW5kZXhPZihjYWxsYmFjayk7XHJcbiAgICBpZiAoaSA9PT0gLTEpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICB9XHJcbiAgICBfb25UaGVtZUNoYW5nZUNhbGxiYWNrcy5zcGxpY2UoaSwgMSk7XHJcbn1cclxuZXhwb3J0cy5yZW1vdmVPblRoZW1lQ2hhbmdlQ2FsbGJhY2sgPSByZW1vdmVPblRoZW1lQ2hhbmdlQ2FsbGJhY2s7XHJcbi8qKlxyXG4gKiBBcHBsaWVzIHRoZSB0aGVtZSwgd2hpbGUgZmlsbGluZyBpbiBtaXNzaW5nIHNsb3RzLlxyXG4gKi9cclxuZnVuY3Rpb24gbG9hZFRoZW1lKHRoZW1lKSB7XHJcbiAgICBfdGhlbWUgPSBjcmVhdGVUaGVtZSh0aGVtZSk7XHJcbiAgICAvLyBJbnZva2UgdGhlIGxlZ2FjeSBtZXRob2Qgb2YgdGhlbWluZyB0aGUgcGFnZSBhcyB3ZWxsLlxyXG4gICAgbG9hZF90aGVtZWRfc3R5bGVzXzEubG9hZFRoZW1lKHRzbGliXzEuX19hc3NpZ24oe30sIF90aGVtZS5wYWxldHRlLCBfdGhlbWUuc2VtYW50aWNDb2xvcnMpKTtcclxuICAgIEN1c3RvbWl6YXRpb25zXzEuQ3VzdG9taXphdGlvbnMuYXBwbHlTZXR0aW5ncygoX2EgPSB7fSwgX2FbZXhwb3J0cy5UaGVtZVNldHRpbmdOYW1lXSA9IF90aGVtZSwgX2EpKTtcclxuICAgIF9vblRoZW1lQ2hhbmdlQ2FsbGJhY2tzLmZvckVhY2goZnVuY3Rpb24gKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgY2FsbGJhY2soX3RoZW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgLy8gZG9uJ3QgbGV0IGEgYmFkIGNhbGxiYWNrIGJyZWFrIGV2ZXJ5dGhpbmcgZWxzZVxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIF90aGVtZTtcclxuICAgIHZhciBfYTtcclxufVxyXG5leHBvcnRzLmxvYWRUaGVtZSA9IGxvYWRUaGVtZTtcclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBjdXN0b20gdGhlbWUgZGVmaW5pdGlvbiB3aGljaCBjYW4gYmUgdXNlZCB3aXRoIHRoZSBDdXN0b21pemVyLlxyXG4gKi9cclxuZnVuY3Rpb24gY3JlYXRlVGhlbWUodGhlbWUpIHtcclxuICAgIHZhciBuZXdQYWxldHRlID0gdHNsaWJfMS5fX2Fzc2lnbih7fSwgRGVmYXVsdFBhbGV0dGVfMS5EZWZhdWx0UGFsZXR0ZSwgdGhlbWUucGFsZXR0ZSk7XHJcbiAgICBpZiAoIXRoZW1lLnBhbGV0dGUgfHwgIXRoZW1lLnBhbGV0dGUuYWNjZW50KSB7XHJcbiAgICAgICAgbmV3UGFsZXR0ZS5hY2NlbnQgPSBuZXdQYWxldHRlLnRoZW1lUHJpbWFyeTtcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcGFsZXR0ZTogbmV3UGFsZXR0ZSxcclxuICAgICAgICBmb250czogdHNsaWJfMS5fX2Fzc2lnbih7fSwgRGVmYXVsdEZvbnRTdHlsZXNfMS5EZWZhdWx0Rm9udFN0eWxlcywgdGhlbWUuZm9udHMpLFxyXG4gICAgICAgIHNlbWFudGljQ29sb3JzOiB0c2xpYl8xLl9fYXNzaWduKHt9LCBfbWFrZVNlbWFudGljQ29sb3JzRnJvbVBhbGV0dGUobmV3UGFsZXR0ZSwgISF0aGVtZS5pc0ludmVydGVkKSwgdGhlbWUuc2VtYW50aWNDb2xvcnMpLFxyXG4gICAgICAgIGlzSW52ZXJ0ZWQ6ICEhdGhlbWUuaXNJbnZlcnRlZFxyXG4gICAgfTtcclxufVxyXG5leHBvcnRzLmNyZWF0ZVRoZW1lID0gY3JlYXRlVGhlbWU7XHJcbi8vIEdlbmVyYXRlcyBhbGwgdGhlIHNlbWFudGljIHNsb3QgY29sb3JzIGJhc2VkIG9uIHRoZSBGYWJyaWMgcGFsZXR0ZS5cclxuLy8gV2UnbGwgdXNlIHRoZXNlIGFzIGZhbGxiYWNrcyBmb3Igc2VtYW50aWMgc2xvdHMgdGhhdCB0aGUgcGFzc2VkIGluIHRoZW1lIGRpZCBub3QgZGVmaW5lLlxyXG5mdW5jdGlvbiBfbWFrZVNlbWFudGljQ29sb3JzRnJvbVBhbGV0dGUocCwgaXNJbnZlcnRlZCkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBib2R5QmFja2dyb3VuZDogcC53aGl0ZSxcclxuICAgICAgICBib2R5VGV4dDogcC5uZXV0cmFsUHJpbWFyeSxcclxuICAgICAgICBib2R5VGV4dENoZWNrZWQ6IHAuYmxhY2ssXHJcbiAgICAgICAgYm9keVN1YnRleHQ6IHAubmV1dHJhbFNlY29uZGFyeSxcclxuICAgICAgICBib2R5RGl2aWRlcjogcC5uZXV0cmFsTGlnaHQsXHJcbiAgICAgICAgZGlzYWJsZWRCYWNrZ3JvdW5kOiBwLm5ldXRyYWxMaWdodGVyLFxyXG4gICAgICAgIGRpc2FibGVkVGV4dDogcC5uZXV0cmFsVGVydGlhcnksXHJcbiAgICAgICAgZGlzYWJsZWRCb2R5VGV4dDogcC5uZXV0cmFsVGVydGlhcnlBbHQsXHJcbiAgICAgICAgZGlzYWJsZWRTdWJ0ZXh0OiBwLm5ldXRyYWxRdWF0ZXJuYXJ5LFxyXG4gICAgICAgIGZvY3VzQm9yZGVyOiBwLmJsYWNrLFxyXG4gICAgICAgIGVycm9yVGV4dDogIWlzSW52ZXJ0ZWQgPyBwLnJlZERhcmsgOiAnI2ZmNWY1ZicsXHJcbiAgICAgICAgd2FybmluZ1RleHQ6ICFpc0ludmVydGVkID8gJyMzMzMzMzMnIDogJyNmZmZmZmYnLFxyXG4gICAgICAgIGVycm9yQmFja2dyb3VuZDogIWlzSW52ZXJ0ZWQgPyAncmdiYSgyMzIsIDE3LCAzNSwgLjIpJyA6ICdyZ2JhKDIzMiwgMTcsIDM1LCAuNSknLFxyXG4gICAgICAgIGJsb2NraW5nQmFja2dyb3VuZDogIWlzSW52ZXJ0ZWQgPyAncmdiYSgyMzQsIDY3LCAwLCAuMiknIDogJ3JnYmEoMjM0LCA2NywgMCwgLjUpJyxcclxuICAgICAgICB3YXJuaW5nQmFja2dyb3VuZDogIWlzSW52ZXJ0ZWQgPyAncmdiYSgyNTUsIDE4NSwgMCwgLjIpJyA6ICdyZ2JhKDI1NSwgMjUxLCAwLCAuNiknLFxyXG4gICAgICAgIHdhcm5pbmdIaWdobGlnaHQ6ICFpc0ludmVydGVkID8gJyNmZmI5MDAnIDogJyNmZmYxMDAnLFxyXG4gICAgICAgIHN1Y2Nlc3NCYWNrZ3JvdW5kOiAhaXNJbnZlcnRlZCA/ICdyZ2JhKDE4NiwgMjE2LCAxMCwgLjIpJyA6ICdyZ2JhKDE4NiwgMjE2LCAxMCwgLjQpJyxcclxuICAgICAgICBpbnB1dEJvcmRlcjogcC5uZXV0cmFsVGVydGlhcnksXHJcbiAgICAgICAgaW5wdXRCb3JkZXJIb3ZlcmVkOiBwLm5ldXRyYWxEYXJrLFxyXG4gICAgICAgIGlucHV0QmFja2dyb3VuZENoZWNrZWQ6IHAudGhlbWVQcmltYXJ5LFxyXG4gICAgICAgIGlucHV0QmFja2dyb3VuZENoZWNrZWRIb3ZlcmVkOiBwLnRoZW1lRGFya0FsdCxcclxuICAgICAgICBpbnB1dEZvcmVncm91bmRDaGVja2VkOiBwLndoaXRlLFxyXG4gICAgICAgIGlucHV0Rm9jdXNCb3JkZXJBbHQ6IHAudGhlbWVQcmltYXJ5LFxyXG4gICAgICAgIGJ1dHRvbkJhY2tncm91bmQ6IHAubmV1dHJhbExpZ2h0ZXIsXHJcbiAgICAgICAgYnV0dG9uQmFja2dyb3VuZENoZWNrZWQ6IHAubmV1dHJhbFRlcnRpYXJ5QWx0LFxyXG4gICAgICAgIGJ1dHRvbkJhY2tncm91bmRIb3ZlcmVkOiBwLm5ldXRyYWxMaWdodCxcclxuICAgICAgICBidXR0b25CYWNrZ3JvdW5kQ2hlY2tlZEhvdmVyZWQ6IHAubmV1dHJhbExpZ2h0LFxyXG4gICAgICAgIGJ1dHRvbkJvcmRlcjogJ3RyYW5zcGFyZW50JyxcclxuICAgICAgICBidXR0b25UZXh0OiBwLm5ldXRyYWxQcmltYXJ5LFxyXG4gICAgICAgIGJ1dHRvblRleHRIb3ZlcmVkOiBwLmJsYWNrLFxyXG4gICAgICAgIGJ1dHRvblRleHRDaGVja2VkOiBwLm5ldXRyYWxEYXJrLFxyXG4gICAgICAgIGJ1dHRvblRleHRDaGVja2VkSG92ZXJlZDogcC5ibGFjayxcclxuICAgICAgICBtZW51SXRlbUJhY2tncm91bmRIb3ZlcmVkOiBwLm5ldXRyYWxMaWdodGVyLFxyXG4gICAgICAgIG1lbnVJdGVtQmFja2dyb3VuZENoZWNrZWQ6IHAubmV1dHJhbExpZ2h0LFxyXG4gICAgICAgIG1lbnVJY29uOiBwLnRoZW1lUHJpbWFyeSxcclxuICAgICAgICBtZW51SGVhZGVyOiBwLnRoZW1lUHJpbWFyeSxcclxuICAgICAgICBsaXN0QmFja2dyb3VuZDogcC53aGl0ZSxcclxuICAgICAgICBsaXN0VGV4dENvbG9yOiBwLm5ldXRyYWxQcmltYXJ5LFxyXG4gICAgICAgIGxpc3RJdGVtQmFja2dyb3VuZEhvdmVyZWQ6IHAubmV1dHJhbExpZ2h0ZXIsXHJcbiAgICAgICAgbGlzdEl0ZW1CYWNrZ3JvdW5kQ2hlY2tlZDogcC5uZXV0cmFsTGlnaHQsXHJcbiAgICAgICAgbGlzdEl0ZW1CYWNrZ3JvdW5kQ2hlY2tlZEhvdmVyZWQ6IHAubmV1dHJhbFF1YXRlcm5hcnlBbHRcclxuICAgIH07XHJcbn1cclxudmFyIF9hO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD10aGVtZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgTWVyZ2VTdHlsZXNfMSA9IHJlcXVpcmUoXCIuLi9NZXJnZVN0eWxlc1wiKTtcclxuLyoqXHJcbiAqIEJ1aWxkcyBhIGNsYXNzIG5hbWVzIG9iamVjdCBmcm9tIGEgZ2l2ZW4gbWFwLlxyXG4gKlxyXG4gKiBAcGFyYW0gc3R5bGVzIC0gTWFwIG9mIHVucHJvY2Vzc2VkIHN0eWxlcy5cclxuICogQHJldHVybnMgTWFwIG9mIHByb3BlcnR5IG5hbWUgdG8gY2xhc3MgbmFtZS5cclxuICovXHJcbmZ1bmN0aW9uIGJ1aWxkQ2xhc3NNYXAoc3R5bGVzKSB7XHJcbiAgICB2YXIgY2xhc3NlcyA9IHt9O1xyXG4gICAgdmFyIF9sb29wXzEgPSBmdW5jdGlvbiAoc3R5bGVOYW1lKSB7XHJcbiAgICAgICAgaWYgKHN0eWxlcy5oYXNPd25Qcm9wZXJ0eShzdHlsZU5hbWUpKSB7XHJcbiAgICAgICAgICAgIHZhciBjbGFzc05hbWVfMTtcclxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGNsYXNzZXMsIHN0eWxlTmFtZSwge1xyXG4gICAgICAgICAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGNsYXNzTmFtZV8xID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc05hbWVfMSA9IE1lcmdlU3R5bGVzXzEubWVyZ2VTdHlsZXMoc3R5bGVzW3N0eWxlTmFtZV0pLnRvU3RyaW5nKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjbGFzc05hbWVfMTtcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBmb3IgKHZhciBzdHlsZU5hbWUgaW4gc3R5bGVzKSB7XHJcbiAgICAgICAgX2xvb3BfMShzdHlsZU5hbWUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNsYXNzZXM7XHJcbn1cclxuZXhwb3J0cy5idWlsZENsYXNzTWFwID0gYnVpbGRDbGFzc01hcDtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YnVpbGRDbGFzc01hcC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgaW5kZXhfMSA9IHJlcXVpcmUoXCJAdWlmYWJyaWMvbWVyZ2Utc3R5bGVzL2xpYi9pbmRleFwiKTtcclxudmFyIGljb25zXzEgPSByZXF1aXJlKFwiLi9pY29uc1wiKTtcclxudmFyIGRlZmF1bHRJY29uU3R5bGVzID0ge1xyXG4gICAgZGlzcGxheTogJ2lubGluZS1ibG9jaydcclxufTtcclxuLyoqXHJcbiAqIEdldHMgYW4gaWNvbiBjbGFzc25hbWUuIFlvdSBzaG91bGQgYmUgYWJsZSB0byBhZGQgdGhpcyBjbGFzc25hbWUgdG8gYW4gSSB0YWcgd2l0aCBub1xyXG4gKiBhZGRpdGlvbmFsIGNsYXNzbmFtZXMsIGFuZCByZW5kZXIgdGhlIGljb24uXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmZ1bmN0aW9uIGdldEljb25DbGFzc05hbWUobmFtZSkge1xyXG4gICAgdmFyIGNsYXNzTmFtZSA9ICcnO1xyXG4gICAgdmFyIGljb24gPSBpY29uc18xLmdldEljb24obmFtZSk7XHJcbiAgICBpZiAoaWNvbikge1xyXG4gICAgICAgIGNsYXNzTmFtZSA9IGluZGV4XzEubWVyZ2VTdHlsZXMoaWNvbi5zdWJzZXQuY2xhc3NOYW1lLCBkZWZhdWx0SWNvblN0eWxlcywge1xyXG4gICAgICAgICAgICBzZWxlY3RvcnM6IHtcclxuICAgICAgICAgICAgICAgICc6OmJlZm9yZSc6IHtcclxuICAgICAgICAgICAgICAgICAgICBjb250ZW50OiBcIlxcXCJcIiArIGljb24uY29kZSArIFwiXFxcIlwiXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH1cclxuICAgIHJldHVybiBjbGFzc05hbWU7XHJcbn1cclxuZXhwb3J0cy5nZXRJY29uQ2xhc3NOYW1lID0gZ2V0SWNvbkNsYXNzTmFtZTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Z2V0SWNvbkNsYXNzTmFtZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcclxudmFyIHdhcm5fMSA9IHJlcXVpcmUoXCJAdWlmYWJyaWMvdXRpbGl0aWVzL2xpYi93YXJuXCIpO1xyXG52YXIgR2xvYmFsU2V0dGluZ3NfMSA9IHJlcXVpcmUoXCJAdWlmYWJyaWMvdXRpbGl0aWVzL2xpYi9HbG9iYWxTZXR0aW5nc1wiKTtcclxudmFyIGluZGV4XzEgPSByZXF1aXJlKFwiQHVpZmFicmljL21lcmdlLXN0eWxlcy9saWIvaW5kZXhcIik7XHJcbnZhciBJQ09OX1NFVFRJTkdfTkFNRSA9ICdpY29ucyc7XHJcbnZhciBfaWNvblNldHRpbmdzID0gR2xvYmFsU2V0dGluZ3NfMS5HbG9iYWxTZXR0aW5ncy5nZXRWYWx1ZShJQ09OX1NFVFRJTkdfTkFNRSwge1xyXG4gICAgX19vcHRpb25zOiB7XHJcbiAgICAgICAgZGlzYWJsZVdhcm5pbmdzOiBmYWxzZSxcclxuICAgICAgICB3YXJuT25NaXNzaW5nSWNvbnM6IHRydWVcclxuICAgIH0sXHJcbiAgICBfX3JlbWFwcGVkOiB7fVxyXG59KTtcclxuLyoqXHJcbiAqIFJlZ2lzdGVycyBhIGdpdmVuIHN1YnNldCBvZiBpY29ucy5cclxuICpcclxuICogQHBhcmFtIGljb25TdWJzZXQgLSB0aGUgaWNvbiBzdWJzZXQgZGVmaW5pdGlvbi5cclxuICovXHJcbmZ1bmN0aW9uIHJlZ2lzdGVySWNvbnMoaWNvblN1YnNldCwgb3B0aW9ucykge1xyXG4gICAgdmFyIHN1YnNldCA9IHRzbGliXzEuX19hc3NpZ24oe30sIGljb25TdWJzZXQsIHsgaXNSZWdpc3RlcmVkOiBmYWxzZSwgY2xhc3NOYW1lOiB1bmRlZmluZWQgfSk7XHJcbiAgICB2YXIgaWNvbnMgPSBpY29uU3Vic2V0Lmljb25zO1xyXG4gICAgLy8gR3JhYiBvcHRpb25zLCBvcHRpb25hbGx5IG1peCB1c2VyIHByb3ZpZGVkIG9uZXMgb24gdG9wLlxyXG4gICAgb3B0aW9ucyA9IG9wdGlvbnMgPyB0c2xpYl8xLl9fYXNzaWduKHt9LCBfaWNvblNldHRpbmdzLl9fb3B0aW9ucywgb3B0aW9ucykgOiBfaWNvblNldHRpbmdzLl9fb3B0aW9ucztcclxuICAgIGZvciAodmFyIGljb25OYW1lIGluIGljb25zKSB7XHJcbiAgICAgICAgaWYgKGljb25zLmhhc093blByb3BlcnR5KGljb25OYW1lKSkge1xyXG4gICAgICAgICAgICB2YXIgY29kZSA9IGljb25zW2ljb25OYW1lXTtcclxuICAgICAgICAgICAgdmFyIG5vcm1hbGl6ZWRJY29uTmFtZSA9IGljb25OYW1lLnRvTG93ZXJDYXNlKCk7XHJcbiAgICAgICAgICAgIGlmIChfaWNvblNldHRpbmdzW25vcm1hbGl6ZWRJY29uTmFtZV0pIHtcclxuICAgICAgICAgICAgICAgIGlmICghb3B0aW9ucy5kaXNhYmxlV2FybmluZ3MpIHtcclxuICAgICAgICAgICAgICAgICAgICB3YXJuXzEud2FybihcIkljb24gJ1wiICsgaWNvbk5hbWUgKyBcIiBiZWluZyByZS1yZWdpc3RlcmVkLiBJZ25vcmluZyBkdXBsaWNhdGUgcmVnaXN0cmF0aW9uLlwiKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIF9pY29uU2V0dGluZ3Nbbm9ybWFsaXplZEljb25OYW1lXSA9IHtcclxuICAgICAgICAgICAgICAgICAgICBjb2RlOiBjb2RlLFxyXG4gICAgICAgICAgICAgICAgICAgIHN1YnNldDogc3Vic2V0XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMucmVnaXN0ZXJJY29ucyA9IHJlZ2lzdGVySWNvbnM7XHJcbi8qKlxyXG4gKiBSZW1hcHMgb25lIGljb24gbmFtZSB0byBhbm90aGVyLlxyXG4gKi9cclxuZnVuY3Rpb24gcmVnaXN0ZXJJY29uQWxpYXMoaWNvbk5hbWUsIG1hcHBlZFRvTmFtZSkge1xyXG4gICAgX2ljb25TZXR0aW5ncy5fX3JlbWFwcGVkW2ljb25OYW1lLnRvTG93ZXJDYXNlKCldID0gbWFwcGVkVG9OYW1lLnRvTG93ZXJDYXNlKCk7XHJcbn1cclxuZXhwb3J0cy5yZWdpc3Rlckljb25BbGlhcyA9IHJlZ2lzdGVySWNvbkFsaWFzO1xyXG4vKipcclxuICogR2V0cyBhbiBpY29uIGRlZmluaXRpb24uIElmIGFuIGljb24gaXMgcmVxdWVzdGVkIGJ1dCB0aGUgc3Vic2V0IGhhcyB5ZXQgdG8gYmUgcmVnaXN0ZXJlZCxcclxuICogaXQgd2lsbCBnZXQgcmVnaXN0ZXJlZCBpbW1lZGlhdGVseS5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKiBAcGFyYW0gbmFtZSAtIE5hbWUgb2YgaWNvbi5cclxuICovXHJcbmZ1bmN0aW9uIGdldEljb24obmFtZSkge1xyXG4gICAgdmFyIGljb24gPSB1bmRlZmluZWQ7XHJcbiAgICB2YXIgb3B0aW9ucyA9IF9pY29uU2V0dGluZ3MuX19vcHRpb25zO1xyXG4gICAgbmFtZSA9IG5hbWUgPyBuYW1lLnRvTG93ZXJDYXNlKCkgOiAnJztcclxuICAgIG5hbWUgPSBfaWNvblNldHRpbmdzLl9fcmVtYXBwZWRbbmFtZV0gfHwgbmFtZTtcclxuICAgIGlmIChuYW1lKSB7XHJcbiAgICAgICAgaWNvbiA9IF9pY29uU2V0dGluZ3NbbmFtZV07XHJcbiAgICAgICAgaWYgKGljb24pIHtcclxuICAgICAgICAgICAgdmFyIHN1YnNldCA9IGljb24uc3Vic2V0O1xyXG4gICAgICAgICAgICBpZiAoc3Vic2V0LmZvbnRGYWNlICYmICFzdWJzZXQuaXNSZWdpc3RlcmVkKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBSZWdpc3RlciBmb250IGZhY2UgZm9yIGdpdmVuIGljb25zLlxyXG4gICAgICAgICAgICAgICAgaW5kZXhfMS5mb250RmFjZShzdWJzZXQuZm9udEZhY2UpO1xyXG4gICAgICAgICAgICAgICAgLy8gR2VuZXJhdGUgYSBiYXNlIGNsYXNzIG5hbWUgZm9yIHRoZSBnaXZlbiBmb250LlxyXG4gICAgICAgICAgICAgICAgc3Vic2V0LmNsYXNzTmFtZSA9IGluZGV4XzEubWVyZ2VTdHlsZXMoc3Vic2V0LnN0eWxlLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgZm9udEZhbWlseTogc3Vic2V0LmZvbnRGYWNlLmZvbnRGYW1pbHksXHJcbiAgICAgICAgICAgICAgICAgICAgZm9udFdlaWdodDogc3Vic2V0LmZvbnRGYWNlLmZvbnRXZWlnaHQgfHwgJ25vcm1hbCcsXHJcbiAgICAgICAgICAgICAgICAgICAgZm9udFN0eWxlOiBzdWJzZXQuZm9udEZhY2UuZm9udFN0eWxlIHx8ICdub3JtYWwnXHJcbiAgICAgICAgICAgICAgICB9KS50b1N0cmluZygpO1xyXG4gICAgICAgICAgICAgICAgc3Vic2V0LmlzUmVnaXN0ZXJlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5kaXNhYmxlV2FybmluZ3MgJiYgb3B0aW9ucy53YXJuT25NaXNzaW5nSWNvbnMpIHtcclxuICAgICAgICAgICAgICAgIHdhcm5fMS53YXJuKFwiVGhlIGljb24gXFxcIlwiICsgbmFtZSArIFwiXFxcIiB3YXMgdXNlZCBidXQgbm90IHJlZ2lzdGVyZWQuIFNlZSBodHRwOi8vYWthLm1zL2ZhYnJpYy1pY29uLXVzYWdlIGZvciBtb3JlIGluZm9ybWF0aW9uLlwiKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBpY29uO1xyXG59XHJcbmV4cG9ydHMuZ2V0SWNvbiA9IGdldEljb247XHJcbi8qKlxyXG4gKiBTZXRzIHRoZSBpY29uIG9wdGlvbnMuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmZ1bmN0aW9uIHNldEljb25PcHRpb25zKG9wdGlvbnMpIHtcclxuICAgIF9pY29uU2V0dGluZ3MuX19vcHRpb25zID0gdHNsaWJfMS5fX2Fzc2lnbih7fSwgX2ljb25TZXR0aW5ncy5fX29wdGlvbnMsIG9wdGlvbnMpO1xyXG59XHJcbmV4cG9ydHMuc2V0SWNvbk9wdGlvbnMgPSBzZXRJY29uT3B0aW9ucztcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aWNvbnMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIGJ1aWxkQ2xhc3NNYXBfMSA9IHJlcXVpcmUoXCIuL2J1aWxkQ2xhc3NNYXBcIik7XHJcbmV4cG9ydHMuYnVpbGRDbGFzc01hcCA9IGJ1aWxkQ2xhc3NNYXBfMS5idWlsZENsYXNzTWFwO1xyXG52YXIgaWNvbnNfMSA9IHJlcXVpcmUoXCIuL2ljb25zXCIpO1xyXG5leHBvcnRzLmdldEljb24gPSBpY29uc18xLmdldEljb247XHJcbmV4cG9ydHMucmVnaXN0ZXJJY29ucyA9IGljb25zXzEucmVnaXN0ZXJJY29ucztcclxuZXhwb3J0cy5yZWdpc3Rlckljb25BbGlhcyA9IGljb25zXzEucmVnaXN0ZXJJY29uQWxpYXM7XHJcbmV4cG9ydHMuc2V0SWNvbk9wdGlvbnMgPSBpY29uc18xLnNldEljb25PcHRpb25zO1xyXG52YXIgZ2V0SWNvbkNsYXNzTmFtZV8xID0gcmVxdWlyZShcIi4vZ2V0SWNvbkNsYXNzTmFtZVwiKTtcclxuZXhwb3J0cy5nZXRJY29uQ2xhc3NOYW1lID0gZ2V0SWNvbkNsYXNzTmFtZV8xLmdldEljb25DbGFzc05hbWU7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbi8qKlxyXG4gKiBCdWdzIG9mdGVuIGFwcGVhciBpbiBhc3luYyBjb2RlIHdoZW4gc3R1ZmYgZ2V0cyBkaXNwb3NlZCwgYnV0IGFzeW5jIG9wZXJhdGlvbnMgZG9uJ3QgZ2V0IGNhbmNlbGVkLlxyXG4gKiBUaGlzIEFzeW5jIGhlbHBlciBjbGFzcyBzb2x2ZXMgdGhlc2UgaXNzdWVzIGJ5IHR5aW5nIGFzeW5jIGNvZGUgdG8gdGhlIGxpZmV0aW1lIG9mIGEgZGlzcG9zYWJsZSBvYmplY3QuXHJcbiAqXHJcbiAqIFVzYWdlOiBBbnl0aGluZyBjbGFzcyBleHRlbmRpbmcgZnJvbSBCYXNlTW9kZWwgY2FuIGFjY2VzcyB0aGlzIGhlbHBlciB2aWEgdGhpcy5hc3luYy4gT3RoZXJ3aXNlIGNyZWF0ZSBhXHJcbiAqIG5ldyBpbnN0YW5jZSBvZiB0aGUgY2xhc3MgYW5kIHJlbWVtYmVyIHRvIGNhbGwgZGlzcG9zZSgpIGR1cmluZyB5b3VyIGNvZGUncyBkaXNwb3NlIGhhbmRsZXIuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbnZhciBBc3luYyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1hbnlcclxuICAgIGZ1bmN0aW9uIEFzeW5jKHBhcmVudCwgb25FcnJvcikge1xyXG4gICAgICAgIHRoaXMuX3RpbWVvdXRJZHMgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX2ltbWVkaWF0ZUlkcyA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5faW50ZXJ2YWxJZHMgPSBudWxsO1xyXG4gICAgICAgIHRoaXMuX2FuaW1hdGlvbkZyYW1lSWRzID0gbnVsbDtcclxuICAgICAgICB0aGlzLl9pc0Rpc3Bvc2VkID0gZmFsc2U7XHJcbiAgICAgICAgdGhpcy5fcGFyZW50ID0gcGFyZW50IHx8IG51bGw7XHJcbiAgICAgICAgdGhpcy5fb25FcnJvckhhbmRsZXIgPSBvbkVycm9yO1xyXG4gICAgICAgIHRoaXMuX25vb3AgPSBmdW5jdGlvbiAoKSB7IH07XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIERpc3Bvc2UgZnVuY3Rpb24sIGNsZWFycyBhbGwgYXN5bmMgb3BlcmF0aW9ucy5cclxuICAgICAqL1xyXG4gICAgQXN5bmMucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGlkO1xyXG4gICAgICAgIHRoaXMuX2lzRGlzcG9zZWQgPSB0cnVlO1xyXG4gICAgICAgIHRoaXMuX3BhcmVudCA9IG51bGw7XHJcbiAgICAgICAgLy8gQ2xlYXIgdGltZW91dHMuXHJcbiAgICAgICAgaWYgKHRoaXMuX3RpbWVvdXRJZHMpIHtcclxuICAgICAgICAgICAgZm9yIChpZCBpbiB0aGlzLl90aW1lb3V0SWRzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fdGltZW91dElkcy5oYXNPd25Qcm9wZXJ0eShpZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsZWFyVGltZW91dChwYXJzZUludChpZCwgMTApKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl90aW1lb3V0SWRzID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQ2xlYXIgaW1tZWRpYXRlcy5cclxuICAgICAgICBpZiAodGhpcy5faW1tZWRpYXRlSWRzKSB7XHJcbiAgICAgICAgICAgIGZvciAoaWQgaW4gdGhpcy5faW1tZWRpYXRlSWRzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faW1tZWRpYXRlSWRzLmhhc093blByb3BlcnR5KGlkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xlYXJJbW1lZGlhdGUocGFyc2VJbnQoaWQsIDEwKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5faW1tZWRpYXRlSWRzID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQ2xlYXIgaW50ZXJ2YWxzLlxyXG4gICAgICAgIGlmICh0aGlzLl9pbnRlcnZhbElkcykge1xyXG4gICAgICAgICAgICBmb3IgKGlkIGluIHRoaXMuX2ludGVydmFsSWRzKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5faW50ZXJ2YWxJZHMuaGFzT3duUHJvcGVydHkoaWQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jbGVhckludGVydmFsKHBhcnNlSW50KGlkLCAxMCkpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2ludGVydmFsSWRzID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgLy8gQ2xlYXIgYW5pbWF0aW9uIGZyYW1lcy5cclxuICAgICAgICBpZiAodGhpcy5fYW5pbWF0aW9uRnJhbWVJZHMpIHtcclxuICAgICAgICAgICAgZm9yIChpZCBpbiB0aGlzLl9hbmltYXRpb25GcmFtZUlkcykge1xyXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuX2FuaW1hdGlvbkZyYW1lSWRzLmhhc093blByb3BlcnR5KGlkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2FuY2VsQW5pbWF0aW9uRnJhbWUocGFyc2VJbnQoaWQsIDEwKSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fYW5pbWF0aW9uRnJhbWVJZHMgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFNldFRpbWVvdXQgb3ZlcnJpZGUsIHdoaWNoIHdpbGwgYXV0byBjYW5jZWwgdGhlIHRpbWVvdXQgZHVyaW5nIGRpc3Bvc2UuXHJcbiAgICAgKiBAcGFyYW0gY2FsbGJhY2sgLSBDYWxsYmFjayB0byBleGVjdXRlLlxyXG4gICAgICogQHBhcmFtIGR1cmF0aW9uIC0gRHVyYXRpb24gaW4gbWlsbGlzZWNvbmRzLlxyXG4gICAgICogQHJldHVybnMgVGhlIHNldFRpbWVvdXQgaWQuXHJcbiAgICAgKi9cclxuICAgIEFzeW5jLnByb3RvdHlwZS5zZXRUaW1lb3V0ID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBkdXJhdGlvbikge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHRpbWVvdXRJZCA9IDA7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9pc0Rpc3Bvc2VkKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fdGltZW91dElkcykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdGltZW91dElkcyA9IHt9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8qIHRzbGludDpkaXNhYmxlOmJhbi1uYXRpdmUtZnVuY3Rpb25zICovXHJcbiAgICAgICAgICAgIHRpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgLy8gVGltZSB0byBleGVjdXRlIHRoZSB0aW1lb3V0LCBlbnF1ZXVlIGl0IGFzIGEgZm9yZWdyb3VuZCB0YXNrIHRvIGJlIGV4ZWN1dGVkLlxyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAvLyBOb3cgZGVsZXRlIHRoZSByZWNvcmQgYW5kIGNhbGwgdGhlIGNhbGxiYWNrLlxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5fdGltZW91dElkcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgX3RoaXMuX3RpbWVvdXRJZHNbdGltZW91dElkXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkoX3RoaXMuX3BhcmVudCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5fb25FcnJvckhhbmRsZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuX29uRXJyb3JIYW5kbGVyKGUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSwgZHVyYXRpb24pO1xyXG4gICAgICAgICAgICAvKiB0c2xpbnQ6ZW5hYmxlOmJhbi1uYXRpdmUtZnVuY3Rpb25zICovXHJcbiAgICAgICAgICAgIHRoaXMuX3RpbWVvdXRJZHNbdGltZW91dElkXSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aW1lb3V0SWQ7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDbGVhcnMgdGhlIHRpbWVvdXQuXHJcbiAgICAgKiBAcGFyYW0gaWQgLSBJZCB0byBjYW5jZWwuXHJcbiAgICAgKi9cclxuICAgIEFzeW5jLnByb3RvdHlwZS5jbGVhclRpbWVvdXQgPSBmdW5jdGlvbiAoaWQpIHtcclxuICAgICAgICBpZiAodGhpcy5fdGltZW91dElkcyAmJiB0aGlzLl90aW1lb3V0SWRzW2lkXSkge1xyXG4gICAgICAgICAgICAvKiB0c2xpbnQ6ZGlzYWJsZTpiYW4tbmF0aXZlLWZ1bmN0aW9ucyAqL1xyXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoaWQpO1xyXG4gICAgICAgICAgICBkZWxldGUgdGhpcy5fdGltZW91dElkc1tpZF07XHJcbiAgICAgICAgICAgIC8qIHRzbGludDplbmFibGU6YmFuLW5hdGl2ZS1mdW5jdGlvbnMgKi9cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRJbW1lZGlhdGUgb3ZlcnJpZGUsIHdoaWNoIHdpbGwgYXV0byBjYW5jZWwgdGhlIGltbWVkaWF0ZSBkdXJpbmcgZGlzcG9zZS5cclxuICAgICAqIEBwYXJhbSBjYWxsYmFjayAtIENhbGxiYWNrIHRvIGV4ZWN1dGUuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgc2V0VGltZW91dCBpZC5cclxuICAgICAqL1xyXG4gICAgQXN5bmMucHJvdG90eXBlLnNldEltbWVkaWF0ZSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIGltbWVkaWF0ZUlkID0gMDtcclxuICAgICAgICBpZiAoIXRoaXMuX2lzRGlzcG9zZWQpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9pbW1lZGlhdGVJZHMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2ltbWVkaWF0ZUlkcyA9IHt9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8qIHRzbGludDpkaXNhYmxlOmJhbi1uYXRpdmUtZnVuY3Rpb25zICovXHJcbiAgICAgICAgICAgIHZhciBzZXRJbW1lZGlhdGVDYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIC8vIFRpbWUgdG8gZXhlY3V0ZSB0aGUgdGltZW91dCwgZW5xdWV1ZSBpdCBhcyBhIGZvcmVncm91bmQgdGFzayB0byBiZSBleGVjdXRlZC5cclxuICAgICAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gTm93IGRlbGV0ZSB0aGUgcmVjb3JkIGFuZCBjYWxsIHRoZSBjYWxsYmFjay5cclxuICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuX2ltbWVkaWF0ZUlkcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgX3RoaXMuX2ltbWVkaWF0ZUlkc1tpbW1lZGlhdGVJZF07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KF90aGlzLl9wYXJlbnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5fbG9nRXJyb3IoZSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGltbWVkaWF0ZUlkID0gd2luZG93LnNldEltbWVkaWF0ZSA/IHdpbmRvdy5zZXRJbW1lZGlhdGUoc2V0SW1tZWRpYXRlQ2FsbGJhY2spIDogd2luZG93LnNldFRpbWVvdXQoc2V0SW1tZWRpYXRlQ2FsbGJhY2ssIDApO1xyXG4gICAgICAgICAgICAvKiB0c2xpbnQ6ZW5hYmxlOmJhbi1uYXRpdmUtZnVuY3Rpb25zICovXHJcbiAgICAgICAgICAgIHRoaXMuX2ltbWVkaWF0ZUlkc1tpbW1lZGlhdGVJZF0gPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaW1tZWRpYXRlSWQ7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDbGVhcnMgdGhlIGltbWVkaWF0ZS5cclxuICAgICAqIEBwYXJhbSBpZCAtIElkIHRvIGNhbmNlbC5cclxuICAgICAqL1xyXG4gICAgQXN5bmMucHJvdG90eXBlLmNsZWFySW1tZWRpYXRlID0gZnVuY3Rpb24gKGlkKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2ltbWVkaWF0ZUlkcyAmJiB0aGlzLl9pbW1lZGlhdGVJZHNbaWRdKSB7XHJcbiAgICAgICAgICAgIC8qIHRzbGludDpkaXNhYmxlOmJhbi1uYXRpdmUtZnVuY3Rpb25zICovXHJcbiAgICAgICAgICAgIHdpbmRvdy5jbGVhckltbWVkaWF0ZSA/IHdpbmRvdy5jbGVhckltbWVkaWF0ZShpZCkgOiB3aW5kb3cuY2xlYXJUaW1lb3V0KGlkKTtcclxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2ltbWVkaWF0ZUlkc1tpZF07XHJcbiAgICAgICAgICAgIC8qIHRzbGludDplbmFibGU6YmFuLW5hdGl2ZS1mdW5jdGlvbnMgKi9cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRJbnRlcnZhbCBvdmVycmlkZSwgd2hpY2ggd2lsbCBhdXRvIGNhbmNlbCB0aGUgdGltZW91dCBkdXJpbmcgZGlzcG9zZS5cclxuICAgICAqIEBwYXJhbSBjYWxsYmFjayAtIENhbGxiYWNrIHRvIGV4ZWN1dGUuXHJcbiAgICAgKiBAcGFyYW0gZHVyYXRpb24gLSBEdXJhdGlvbiBpbiBtaWxsaXNlY29uZHMuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgc2V0VGltZW91dCBpZC5cclxuICAgICAqL1xyXG4gICAgQXN5bmMucHJvdG90eXBlLnNldEludGVydmFsID0gZnVuY3Rpb24gKGNhbGxiYWNrLCBkdXJhdGlvbikge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIGludGVydmFsSWQgPSAwO1xyXG4gICAgICAgIGlmICghdGhpcy5faXNEaXNwb3NlZCkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2ludGVydmFsSWRzKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9pbnRlcnZhbElkcyA9IHt9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8qIHRzbGludDpkaXNhYmxlOmJhbi1uYXRpdmUtZnVuY3Rpb25zICovXHJcbiAgICAgICAgICAgIGludGVydmFsSWQgPSBzZXRJbnRlcnZhbChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAvLyBUaW1lIHRvIGV4ZWN1dGUgdGhlIGludGVydmFsIGNhbGxiYWNrLCBlbnF1ZXVlIGl0IGFzIGEgZm9yZWdyb3VuZCB0YXNrIHRvIGJlIGV4ZWN1dGVkLlxyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjay5hcHBseShfdGhpcy5fcGFyZW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2xvZ0Vycm9yKGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LCBkdXJhdGlvbik7XHJcbiAgICAgICAgICAgIC8qIHRzbGludDplbmFibGU6YmFuLW5hdGl2ZS1mdW5jdGlvbnMgKi9cclxuICAgICAgICAgICAgdGhpcy5faW50ZXJ2YWxJZHNbaW50ZXJ2YWxJZF0gPSB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaW50ZXJ2YWxJZDtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENsZWFycyB0aGUgaW50ZXJ2YWwuXHJcbiAgICAgKiBAcGFyYW0gaWQgLSBJZCB0byBjYW5jZWwuXHJcbiAgICAgKi9cclxuICAgIEFzeW5jLnByb3RvdHlwZS5jbGVhckludGVydmFsID0gZnVuY3Rpb24gKGlkKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2ludGVydmFsSWRzICYmIHRoaXMuX2ludGVydmFsSWRzW2lkXSkge1xyXG4gICAgICAgICAgICAvKiB0c2xpbnQ6ZGlzYWJsZTpiYW4tbmF0aXZlLWZ1bmN0aW9ucyAqL1xyXG4gICAgICAgICAgICBjbGVhckludGVydmFsKGlkKTtcclxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2ludGVydmFsSWRzW2lkXTtcclxuICAgICAgICAgICAgLyogdHNsaW50OmVuYWJsZTpiYW4tbmF0aXZlLWZ1bmN0aW9ucyAqL1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0LCB3aGVuIGV4ZWN1dGVkLCB3aWxsIG9ubHkgY2FsbCB0aGUgZnVuYyBmdW5jdGlvbiBhdCBtb3N0IG9uY2UgcGVyXHJcbiAgICAgKiBldmVyeSB3YWl0IG1pbGxpc2Vjb25kcy4gUHJvdmlkZSBhbiBvcHRpb25zIG9iamVjdCB0byBpbmRpY2F0ZSB0aGF0IGZ1bmMgc2hvdWxkIGJlIGludm9rZWRcclxuICAgICAqIG9uIHRoZSBsZWFkaW5nIGFuZC9vciB0cmFpbGluZyBlZGdlIG9mIHRoZSB3YWl0IHRpbWVvdXQuIFN1YnNlcXVlbnQgY2FsbHMgdG8gdGhlIHRocm90dGxlZFxyXG4gICAgICogZnVuY3Rpb24gd2lsbCByZXR1cm4gdGhlIHJlc3VsdCBvZiB0aGUgbGFzdCBmdW5jIGNhbGwuXHJcbiAgICAgKlxyXG4gICAgICogTm90ZTogSWYgbGVhZGluZyBhbmQgdHJhaWxpbmcgb3B0aW9ucyBhcmUgdHJ1ZSBmdW5jIHdpbGwgYmUgY2FsbGVkIG9uIHRoZSB0cmFpbGluZyBlZGdlIG9mXHJcbiAgICAgKiB0aGUgdGltZW91dCBvbmx5IGlmIHRoZSB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uIGlzIGludm9rZWQgbW9yZSB0aGFuIG9uY2UgZHVyaW5nIHRoZSB3YWl0IHRpbWVvdXQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGZ1bmMgLSBUaGUgZnVuY3Rpb24gdG8gdGhyb3R0bGUuXHJcbiAgICAgKiBAcGFyYW0gd2FpdCAtIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHRocm90dGxlIGV4ZWN1dGlvbnMgdG8uIERlZmF1bHRzIHRvIDAuXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRoZSBvcHRpb25zIG9iamVjdC5cclxuICAgICAqIEByZXR1cm5zIFRoZSBuZXcgdGhyb3R0bGVkIGZ1bmN0aW9uLlxyXG4gICAgICovXHJcbiAgICBBc3luYy5wcm90b3R5cGUudGhyb3R0bGUgPSBmdW5jdGlvbiAoZnVuYywgd2FpdCwgb3B0aW9ucykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgaWYgKHRoaXMuX2lzRGlzcG9zZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX25vb3A7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciB3YWl0TVMgPSB3YWl0IHx8IDA7XHJcbiAgICAgICAgdmFyIGxlYWRpbmcgPSB0cnVlO1xyXG4gICAgICAgIHZhciB0cmFpbGluZyA9IHRydWU7XHJcbiAgICAgICAgdmFyIGxhc3RFeGVjdXRlVGltZSA9IDA7XHJcbiAgICAgICAgdmFyIGxhc3RSZXN1bHQ7XHJcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueVxyXG4gICAgICAgIHZhciBsYXN0QXJncztcclxuICAgICAgICB2YXIgdGltZW91dElkID0gbnVsbDtcclxuICAgICAgICBpZiAob3B0aW9ucyAmJiB0eXBlb2YgKG9wdGlvbnMubGVhZGluZykgPT09ICdib29sZWFuJykge1xyXG4gICAgICAgICAgICBsZWFkaW5nID0gb3B0aW9ucy5sZWFkaW5nO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob3B0aW9ucyAmJiB0eXBlb2YgKG9wdGlvbnMudHJhaWxpbmcpID09PSAnYm9vbGVhbicpIHtcclxuICAgICAgICAgICAgdHJhaWxpbmcgPSBvcHRpb25zLnRyYWlsaW5nO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgY2FsbGJhY2sgPSBmdW5jdGlvbiAodXNlckNhbGwpIHtcclxuICAgICAgICAgICAgdmFyIG5vdyA9IChuZXcgRGF0ZSkuZ2V0VGltZSgpO1xyXG4gICAgICAgICAgICB2YXIgZGVsdGEgPSBub3cgLSBsYXN0RXhlY3V0ZVRpbWU7XHJcbiAgICAgICAgICAgIHZhciB3YWl0TGVuZ3RoID0gbGVhZGluZyA/IHdhaXRNUyAtIGRlbHRhIDogd2FpdE1TO1xyXG4gICAgICAgICAgICBpZiAoZGVsdGEgPj0gd2FpdE1TICYmICghdXNlckNhbGwgfHwgbGVhZGluZykpIHtcclxuICAgICAgICAgICAgICAgIGxhc3RFeGVjdXRlVGltZSA9IG5vdztcclxuICAgICAgICAgICAgICAgIGlmICh0aW1lb3V0SWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5jbGVhclRpbWVvdXQodGltZW91dElkKTtcclxuICAgICAgICAgICAgICAgICAgICB0aW1lb3V0SWQgPSBudWxsO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgbGFzdFJlc3VsdCA9IGZ1bmMuYXBwbHkoX3RoaXMuX3BhcmVudCwgbGFzdEFyZ3MpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHRpbWVvdXRJZCA9PT0gbnVsbCAmJiB0cmFpbGluZykge1xyXG4gICAgICAgICAgICAgICAgdGltZW91dElkID0gX3RoaXMuc2V0VGltZW91dChjYWxsYmFjaywgd2FpdExlbmd0aCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGxhc3RSZXN1bHQ7XHJcbiAgICAgICAgfTtcclxuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYW55XHJcbiAgICAgICAgdmFyIHJlc3VsdEZ1bmN0aW9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxhc3RBcmdzID0gYXJncztcclxuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHRydWUpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIHJlc3VsdEZ1bmN0aW9uO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBkZWxheSB0aGUgZXhlY3V0aW9uIG9mIGZ1bmMgdW50aWwgYWZ0ZXIgd2FpdCBtaWxsaXNlY29uZHMgaGF2ZVxyXG4gICAgICogZWxhcHNlZCBzaW5jZSB0aGUgbGFzdCB0aW1lIGl0IHdhcyBpbnZva2VkLiBQcm92aWRlIGFuIG9wdGlvbnMgb2JqZWN0IHRvIGluZGljYXRlIHRoYXQgZnVuY1xyXG4gICAgICogc2hvdWxkIGJlIGludm9rZWQgb24gdGhlIGxlYWRpbmcgYW5kL29yIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHdhaXQgdGltZW91dC4gU3Vic2VxdWVudCBjYWxsc1xyXG4gICAgICogdG8gdGhlIGRlYm91bmNlZCBmdW5jdGlvbiB3aWxsIHJldHVybiB0aGUgcmVzdWx0IG9mIHRoZSBsYXN0IGZ1bmMgY2FsbC5cclxuICAgICAqXHJcbiAgICAgKiBOb3RlOiBJZiBsZWFkaW5nIGFuZCB0cmFpbGluZyBvcHRpb25zIGFyZSB0cnVlIGZ1bmMgd2lsbCBiZSBjYWxsZWQgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2ZcclxuICAgICAqIHRoZSB0aW1lb3V0IG9ubHkgaWYgdGhlIHRoZSBkZWJvdW5jZWQgZnVuY3Rpb24gaXMgaW52b2tlZCBtb3JlIHRoYW4gb25jZSBkdXJpbmcgdGhlIHdhaXRcclxuICAgICAqIHRpbWVvdXQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGZ1bmMgLSBUaGUgZnVuY3Rpb24gdG8gZGVib3VuY2UuXHJcbiAgICAgKiBAcGFyYW0gd2FpdCAtIFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIGRlbGF5LlxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBUaGUgb3B0aW9ucyBvYmplY3QuXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgbmV3IGRlYm91bmNlZCBmdW5jdGlvbi5cclxuICAgICAqL1xyXG4gICAgQXN5bmMucHJvdG90eXBlLmRlYm91bmNlID0gZnVuY3Rpb24gKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGlmICh0aGlzLl9pc0Rpc3Bvc2VkKSB7XHJcbiAgICAgICAgICAgIHZhciBub09wRnVuY3Rpb24gPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgLyoqIERvIG5vdGhpbmcgKi9cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIG5vT3BGdW5jdGlvbi5jYW5jZWwgPSBmdW5jdGlvbiAoKSB7IHJldHVybjsgfTtcclxuICAgICAgICAgICAgLyogdHNsaW50OmRpc2FibGU6bm8tYW55ICovXHJcbiAgICAgICAgICAgIG5vT3BGdW5jdGlvbi5mbHVzaCA9IChmdW5jdGlvbiAoKSB7IHJldHVybiBudWxsOyB9KTtcclxuICAgICAgICAgICAgLyogdHNsaW50OmVuYWJsZTpuby1hbnkgKi9cclxuICAgICAgICAgICAgbm9PcEZ1bmN0aW9uLnBlbmRpbmcgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBmYWxzZTsgfTtcclxuICAgICAgICAgICAgcmV0dXJuIG5vT3BGdW5jdGlvbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHdhaXRNUyA9IHdhaXQgfHwgMDtcclxuICAgICAgICB2YXIgbGVhZGluZyA9IGZhbHNlO1xyXG4gICAgICAgIHZhciB0cmFpbGluZyA9IHRydWU7XHJcbiAgICAgICAgdmFyIG1heFdhaXQgPSBudWxsO1xyXG4gICAgICAgIHZhciBsYXN0Q2FsbFRpbWUgPSAwO1xyXG4gICAgICAgIHZhciBsYXN0RXhlY3V0ZVRpbWUgPSAobmV3IERhdGUpLmdldFRpbWUoKTtcclxuICAgICAgICB2YXIgbGFzdFJlc3VsdDtcclxuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYW55XHJcbiAgICAgICAgdmFyIGxhc3RBcmdzO1xyXG4gICAgICAgIHZhciB0aW1lb3V0SWQgPSBudWxsO1xyXG4gICAgICAgIGlmIChvcHRpb25zICYmIHR5cGVvZiAob3B0aW9ucy5sZWFkaW5nKSA9PT0gJ2Jvb2xlYW4nKSB7XHJcbiAgICAgICAgICAgIGxlYWRpbmcgPSBvcHRpb25zLmxlYWRpbmc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvcHRpb25zICYmIHR5cGVvZiAob3B0aW9ucy50cmFpbGluZykgPT09ICdib29sZWFuJykge1xyXG4gICAgICAgICAgICB0cmFpbGluZyA9IG9wdGlvbnMudHJhaWxpbmc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChvcHRpb25zICYmIHR5cGVvZiAob3B0aW9ucy5tYXhXYWl0KSA9PT0gJ251bWJlcicgJiYgIWlzTmFOKG9wdGlvbnMubWF4V2FpdCkpIHtcclxuICAgICAgICAgICAgbWF4V2FpdCA9IG9wdGlvbnMubWF4V2FpdDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGludm9rZUZ1bmN0aW9uID0gZnVuY3Rpb24gKHRpbWUpIHtcclxuICAgICAgICAgICAgaWYgKHRpbWVvdXRJZCkge1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XHJcbiAgICAgICAgICAgICAgICB0aW1lb3V0SWQgPSBudWxsO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxhc3RFeGVjdXRlVGltZSA9IHRpbWU7XHJcbiAgICAgICAgICAgIGxhc3RSZXN1bHQgPSBmdW5jLmFwcGx5KF90aGlzLl9wYXJlbnQsIGxhc3RBcmdzKTtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHZhciBjYWxsYmFjayA9IGZ1bmN0aW9uICh1c2VyQ2FsbCkge1xyXG4gICAgICAgICAgICB2YXIgbm93ID0gKG5ldyBEYXRlKS5nZXRUaW1lKCk7XHJcbiAgICAgICAgICAgIHZhciBleGVjdXRlSW1tZWRpYXRlbHkgPSBmYWxzZTtcclxuICAgICAgICAgICAgaWYgKHVzZXJDYWxsKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobGVhZGluZyAmJiBub3cgLSBsYXN0Q2FsbFRpbWUgPj0gd2FpdE1TKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZXhlY3V0ZUltbWVkaWF0ZWx5ID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGxhc3RDYWxsVGltZSA9IG5vdztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB2YXIgZGVsdGEgPSBub3cgLSBsYXN0Q2FsbFRpbWU7XHJcbiAgICAgICAgICAgIHZhciB3YWl0TGVuZ3RoID0gd2FpdE1TIC0gZGVsdGE7XHJcbiAgICAgICAgICAgIHZhciBtYXhXYWl0RGVsdGEgPSBub3cgLSBsYXN0RXhlY3V0ZVRpbWU7XHJcbiAgICAgICAgICAgIHZhciBtYXhXYWl0RXhwaXJlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgICBpZiAobWF4V2FpdCAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgICAgICAgLy8gbWF4V2FpdCBvbmx5IG1hdHRlcnMgd2hlbiB0aGVyZSBpcyBhIHBlbmRpbmcgY2FsbGJhY2tcclxuICAgICAgICAgICAgICAgIGlmIChtYXhXYWl0RGVsdGEgPj0gbWF4V2FpdCAmJiB0aW1lb3V0SWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBtYXhXYWl0RXhwaXJlZCA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICB3YWl0TGVuZ3RoID0gTWF0aC5taW4od2FpdExlbmd0aCwgbWF4V2FpdCAtIG1heFdhaXREZWx0YSk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGRlbHRhID49IHdhaXRNUyB8fCBtYXhXYWl0RXhwaXJlZCB8fCBleGVjdXRlSW1tZWRpYXRlbHkpIHtcclxuICAgICAgICAgICAgICAgIGludm9rZUZ1bmN0aW9uKG5vdyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoKHRpbWVvdXRJZCA9PT0gbnVsbCB8fCAhdXNlckNhbGwpICYmIHRyYWlsaW5nKSB7XHJcbiAgICAgICAgICAgICAgICB0aW1lb3V0SWQgPSBfdGhpcy5zZXRUaW1lb3V0KGNhbGxiYWNrLCB3YWl0TGVuZ3RoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gbGFzdFJlc3VsdDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIHZhciBjYW5jZWwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICh0aW1lb3V0SWQpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLmNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgICAgICB2YXIgZmx1c2ggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICh0aW1lb3V0SWQpIHtcclxuICAgICAgICAgICAgICAgIF90aGlzLmNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xyXG4gICAgICAgICAgICAgICAgaW52b2tlRnVuY3Rpb24obmV3IERhdGUoKS5nZXRUaW1lKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBsYXN0UmVzdWx0O1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgdmFyIHBlbmRpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAhIXRpbWVvdXRJZDtcclxuICAgICAgICB9O1xyXG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1hbnlcclxuICAgICAgICB2YXIgcmVzdWx0RnVuY3Rpb24gPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGxhc3RBcmdzID0gYXJncztcclxuICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrKHRydWUpO1xyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIHJlc3VsdEZ1bmN0aW9uLmNhbmNlbCA9IGNhbmNlbDtcclxuICAgICAgICByZXN1bHRGdW5jdGlvbi5mbHVzaCA9IGZsdXNoO1xyXG4gICAgICAgIHJlc3VsdEZ1bmN0aW9uLnBlbmRpbmcgPSBwZW5kaW5nO1xyXG4gICAgICAgIHJldHVybiByZXN1bHRGdW5jdGlvbjtcclxuICAgIH07XHJcbiAgICBBc3luYy5wcm90b3R5cGUucmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgYW5pbWF0aW9uRnJhbWVJZCA9IDA7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9pc0Rpc3Bvc2VkKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fYW5pbWF0aW9uRnJhbWVJZHMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FuaW1hdGlvbkZyYW1lSWRzID0ge307XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLyogdHNsaW50OmRpc2FibGU6YmFuLW5hdGl2ZS1mdW5jdGlvbnMgKi9cclxuICAgICAgICAgICAgdmFyIGFuaW1hdGlvbkZyYW1lQ2FsbGJhY2sgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdyBkZWxldGUgdGhlIHJlY29yZCBhbmQgY2FsbCB0aGUgY2FsbGJhY2suXHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLl9hbmltYXRpb25GcmFtZUlkcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgX3RoaXMuX2FuaW1hdGlvbkZyYW1lSWRzW2FuaW1hdGlvbkZyYW1lSWRdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjay5hcHBseShfdGhpcy5fcGFyZW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX2xvZ0Vycm9yKGUpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBhbmltYXRpb25GcmFtZUlkID0gd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSA/XHJcbiAgICAgICAgICAgICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGFuaW1hdGlvbkZyYW1lQ2FsbGJhY2spIDpcclxuICAgICAgICAgICAgICAgIHdpbmRvdy5zZXRUaW1lb3V0KGFuaW1hdGlvbkZyYW1lQ2FsbGJhY2ssIDApO1xyXG4gICAgICAgICAgICAvKiB0c2xpbnQ6ZW5hYmxlOmJhbi1uYXRpdmUtZnVuY3Rpb25zICovXHJcbiAgICAgICAgICAgIHRoaXMuX2FuaW1hdGlvbkZyYW1lSWRzW2FuaW1hdGlvbkZyYW1lSWRdID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGFuaW1hdGlvbkZyYW1lSWQ7XHJcbiAgICB9O1xyXG4gICAgQXN5bmMucHJvdG90eXBlLmNhbmNlbEFuaW1hdGlvbkZyYW1lID0gZnVuY3Rpb24gKGlkKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2FuaW1hdGlvbkZyYW1lSWRzICYmIHRoaXMuX2FuaW1hdGlvbkZyYW1lSWRzW2lkXSkge1xyXG4gICAgICAgICAgICAvKiB0c2xpbnQ6ZGlzYWJsZTpiYW4tbmF0aXZlLWZ1bmN0aW9ucyAqL1xyXG4gICAgICAgICAgICB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUgPyB3aW5kb3cuY2FuY2VsQW5pbWF0aW9uRnJhbWUoaWQpIDogd2luZG93LmNsZWFyVGltZW91dChpZCk7XHJcbiAgICAgICAgICAgIC8qIHRzbGludDplbmFibGU6YmFuLW5hdGl2ZS1mdW5jdGlvbnMgKi9cclxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX2FuaW1hdGlvbkZyYW1lSWRzW2lkXTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueVxyXG4gICAgQXN5bmMucHJvdG90eXBlLl9sb2dFcnJvciA9IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX29uRXJyb3JIYW5kbGVyKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX29uRXJyb3JIYW5kbGVyKGUpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICByZXR1cm4gQXN5bmM7XHJcbn0oKSk7XHJcbmV4cG9ydHMuQXN5bmMgPSBBc3luYztcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QXN5bmMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIEV2ZW50R3JvdXBfMSA9IHJlcXVpcmUoXCIuL0V2ZW50R3JvdXBcIik7XHJcbnZhciBzY3JvbGxfMSA9IHJlcXVpcmUoXCIuL3Njcm9sbFwiKTtcclxudmFyIGRvbV8xID0gcmVxdWlyZShcIi4vZG9tXCIpO1xyXG52YXIgU0NST0xMX0lURVJBVElPTl9ERUxBWSA9IDE2O1xyXG52YXIgU0NST0xMX0dVVFRFUl9IRUlHSFQgPSAxMDA7XHJcbnZhciBNQVhfU0NST0xMX1ZFTE9DSVRZID0gMTU7XHJcbi8qKlxyXG4gKiBBdXRvU2Nyb2xsIHNpbXBseSBob29rcyB1cCBtb3VzZSBldmVudHMgZ2l2ZW4gYSBwYXJlbnQgZWxlbWVudCwgYW5kIHNjcm9sbHMgdGhlIGNvbnRhaW5lclxyXG4gKiB1cC9kb3duIGRlcGVuZGluZyBvbiBob3cgY2xvc2UgdGhlIG1vdXNlIGlzIHRvIHRoZSB0b3AvYm90dG9tIG9mIHRoZSBjb250YWluZXIuXHJcbiAqXHJcbiAqIE9uY2UgeW91IGRvbid0IHdhbnQgYXV0b3Njcm9sbCBhbnkgbW9yZSwganVzdCBkaXNwb3NlIHRoZSBoZWxwZXIgYW5kIGl0IHdpbGwgdW5ob29rIGV2ZW50cy5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxudmFyIEF1dG9TY3JvbGwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBBdXRvU2Nyb2xsKGVsZW1lbnQpIHtcclxuICAgICAgICB0aGlzLl9ldmVudHMgPSBuZXcgRXZlbnRHcm91cF8xLkV2ZW50R3JvdXAodGhpcyk7XHJcbiAgICAgICAgdGhpcy5fc2Nyb2xsYWJsZVBhcmVudCA9IHNjcm9sbF8xLmZpbmRTY3JvbGxhYmxlUGFyZW50KGVsZW1lbnQpO1xyXG4gICAgICAgIHRoaXMuX2luY3JlbWVudFNjcm9sbCA9IHRoaXMuX2luY3JlbWVudFNjcm9sbC5iaW5kKHRoaXMpO1xyXG4gICAgICAgIHRoaXMuX3Njcm9sbFJlY3QgPSBkb21fMS5nZXRSZWN0KHRoaXMuX3Njcm9sbGFibGVQYXJlbnQpO1xyXG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1hbnlcclxuICAgICAgICBpZiAodGhpcy5fc2Nyb2xsYWJsZVBhcmVudCA9PT0gd2luZG93KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3Njcm9sbGFibGVQYXJlbnQgPSBkb2N1bWVudC5ib2R5O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5fc2Nyb2xsYWJsZVBhcmVudCkge1xyXG4gICAgICAgICAgICB0aGlzLl9ldmVudHMub24od2luZG93LCAnbW91c2Vtb3ZlJywgdGhpcy5fb25Nb3VzZU1vdmUsIHRydWUpO1xyXG4gICAgICAgICAgICB0aGlzLl9ldmVudHMub24od2luZG93LCAndG91Y2htb3ZlJywgdGhpcy5fb25Ub3VjaE1vdmUsIHRydWUpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIEF1dG9TY3JvbGwucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5fZXZlbnRzLmRpc3Bvc2UoKTtcclxuICAgICAgICB0aGlzLl9zdG9wU2Nyb2xsKCk7XHJcbiAgICB9O1xyXG4gICAgQXV0b1Njcm9sbC5wcm90b3R5cGUuX29uTW91c2VNb3ZlID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgdGhpcy5fY29tcHV0ZVNjcm9sbFZlbG9jaXR5KGV2LmNsaWVudFkpO1xyXG4gICAgfTtcclxuICAgIEF1dG9TY3JvbGwucHJvdG90eXBlLl9vblRvdWNoTW92ZSA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgIGlmIChldi50b3VjaGVzLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgdGhpcy5fY29tcHV0ZVNjcm9sbFZlbG9jaXR5KGV2LnRvdWNoZXNbMF0uY2xpZW50WSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEF1dG9TY3JvbGwucHJvdG90eXBlLl9jb21wdXRlU2Nyb2xsVmVsb2NpdHkgPSBmdW5jdGlvbiAoY2xpZW50WSkge1xyXG4gICAgICAgIGlmICghdGhpcy5fc2Nyb2xsUmVjdCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBzY3JvbGxSZWN0VG9wID0gdGhpcy5fc2Nyb2xsUmVjdC50b3A7XHJcbiAgICAgICAgdmFyIHNjcm9sbENsaWVudEJvdHRvbSA9IHNjcm9sbFJlY3RUb3AgKyB0aGlzLl9zY3JvbGxSZWN0LmhlaWdodCAtIFNDUk9MTF9HVVRURVJfSEVJR0hUO1xyXG4gICAgICAgIGlmIChjbGllbnRZIDwgKHNjcm9sbFJlY3RUb3AgKyBTQ1JPTExfR1VUVEVSX0hFSUdIVCkpIHtcclxuICAgICAgICAgICAgdGhpcy5fc2Nyb2xsVmVsb2NpdHkgPSBNYXRoLm1heCgtTUFYX1NDUk9MTF9WRUxPQ0lUWSwgLU1BWF9TQ1JPTExfVkVMT0NJVFkgKiAoKFNDUk9MTF9HVVRURVJfSEVJR0hUIC0gKGNsaWVudFkgLSBzY3JvbGxSZWN0VG9wKSkgLyBTQ1JPTExfR1VUVEVSX0hFSUdIVCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmIChjbGllbnRZID4gc2Nyb2xsQ2xpZW50Qm90dG9tKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3Njcm9sbFZlbG9jaXR5ID0gTWF0aC5taW4oTUFYX1NDUk9MTF9WRUxPQ0lUWSwgTUFYX1NDUk9MTF9WRUxPQ0lUWSAqICgoY2xpZW50WSAtIHNjcm9sbENsaWVudEJvdHRvbSkgLyBTQ1JPTExfR1VUVEVSX0hFSUdIVCkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fc2Nyb2xsVmVsb2NpdHkgPSAwO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5fc2Nyb2xsVmVsb2NpdHkpIHtcclxuICAgICAgICAgICAgdGhpcy5fc3RhcnRTY3JvbGwoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3N0b3BTY3JvbGwoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQXV0b1Njcm9sbC5wcm90b3R5cGUuX3N0YXJ0U2Nyb2xsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5fdGltZW91dElkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2luY3JlbWVudFNjcm9sbCgpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBBdXRvU2Nyb2xsLnByb3RvdHlwZS5faW5jcmVtZW50U2Nyb2xsID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9zY3JvbGxhYmxlUGFyZW50KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3Njcm9sbGFibGVQYXJlbnQuc2Nyb2xsVG9wICs9IE1hdGgucm91bmQodGhpcy5fc2Nyb2xsVmVsb2NpdHkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICB0aGlzLl90aW1lb3V0SWQgPSBzZXRUaW1lb3V0KHRoaXMuX2luY3JlbWVudFNjcm9sbCwgU0NST0xMX0lURVJBVElPTl9ERUxBWSk7XHJcbiAgICB9O1xyXG4gICAgQXV0b1Njcm9sbC5wcm90b3R5cGUuX3N0b3BTY3JvbGwgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX3RpbWVvdXRJZCkge1xyXG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy5fdGltZW91dElkKTtcclxuICAgICAgICAgICAgZGVsZXRlIHRoaXMuX3RpbWVvdXRJZDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEF1dG9TY3JvbGw7XHJcbn0oKSk7XHJcbmV4cG9ydHMuQXV0b1Njcm9sbCA9IEF1dG9TY3JvbGw7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUF1dG9TY3JvbGwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XHJcbnZhciBSZWFjdCA9IHJlcXVpcmUoXCJyZWFjdFwiKTtcclxudmFyIEFzeW5jXzEgPSByZXF1aXJlKFwiLi9Bc3luY1wiKTtcclxudmFyIEV2ZW50R3JvdXBfMSA9IHJlcXVpcmUoXCIuL0V2ZW50R3JvdXBcIik7XHJcbnZhciB3YXJuXzEgPSByZXF1aXJlKFwiLi93YXJuXCIpO1xyXG4vKipcclxuICogQmFzZUNvbXBvbmVudCBjbGFzcywgd2hpY2ggcHJvdmlkZXMgYmFzaWMgaGVscGVycyBmb3IgYWxsIGNvbXBvbmVudHMuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbnZhciBCYXNlQ29tcG9uZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoQmFzZUNvbXBvbmVudCwgX3N1cGVyKTtcclxuICAgIC8vIHRzbGludDplbmFibGU6dmFyaWFibGUtbmFtZVxyXG4gICAgLyoqXHJcbiAgICAgKiBCYXNlQ29tcG9uZW50IGNvbnN0cnVjdG9yXHJcbiAgICAgKiBAcGFyYW0gcHJvcHMgLSBUaGUgcHJvcHMgZm9yIHRoZSBjb21wb25lbnQuXHJcbiAgICAgKiBAcGFyYW0gY29udGV4dCAtIFRoZSBjb250ZXh0IGZvciB0aGUgY29tcG9uZW50LlxyXG4gICAgICovXHJcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYW55XHJcbiAgICBmdW5jdGlvbiBCYXNlQ29tcG9uZW50KHByb3BzLCBjb250ZXh0KSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgcHJvcHMsIGNvbnRleHQpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuX3Nob3VsZFVwZGF0ZUNvbXBvbmVudFJlZiA9IHRydWU7XHJcbiAgICAgICAgX21ha2VBbGxTYWZlKF90aGlzLCBCYXNlQ29tcG9uZW50LnByb3RvdHlwZSwgW1xyXG4gICAgICAgICAgICAnY29tcG9uZW50V2lsbE1vdW50JyxcclxuICAgICAgICAgICAgJ2NvbXBvbmVudERpZE1vdW50JyxcclxuICAgICAgICAgICAgJ3Nob3VsZENvbXBvbmVudFVwZGF0ZScsXHJcbiAgICAgICAgICAgICdjb21wb25lbnRXaWxsVXBkYXRlJyxcclxuICAgICAgICAgICAgJ2NvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMnLFxyXG4gICAgICAgICAgICAncmVuZGVyJyxcclxuICAgICAgICAgICAgJ2NvbXBvbmVudERpZFVwZGF0ZScsXHJcbiAgICAgICAgICAgICdjb21wb25lbnRXaWxsVW5tb3VudCdcclxuICAgICAgICBdKTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFdoZW4gdGhlIGNvbXBvbmVudCB3aWxsIHJlY2VpdmUgcHJvcHMsIG1ha2Ugc3VyZSB0aGUgY29tcG9uZW50UmVmIGlzIHVwZGF0ZWQuXHJcbiAgICAgKi9cclxuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1hbnlcclxuICAgIEJhc2VDb21wb25lbnQucHJvdG90eXBlLmNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgPSBmdW5jdGlvbiAobmV3UHJvcHMsIG5ld0NvbnRleHQpIHtcclxuICAgICAgICB0aGlzLl91cGRhdGVDb21wb25lbnRSZWYodGhpcy5wcm9wcywgbmV3UHJvcHMpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogV2hlbiB0aGUgY29tcG9uZW50IGhhcyBtb3VudGVkLCB1cGRhdGUgdGhlIGNvbXBvbmVudFJlZi5cclxuICAgICAqL1xyXG4gICAgQmFzZUNvbXBvbmVudC5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5fdXBkYXRlQ29tcG9uZW50UmVmKHVuZGVmaW5lZCwgdGhpcy5wcm9wcyk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBJZiB3ZSBoYXZlIGRpc3Bvc2FibGVzLCBkaXNwb3NlIHRoZW0gYXV0b21hdGljYWxseSBvbiB1bm1vdW50LlxyXG4gICAgICovXHJcbiAgICBCYXNlQ29tcG9uZW50LnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5fX2Rpc3Bvc2FibGVzKSB7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSB0aGlzLl9kaXNwb3NhYmxlcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGRpc3Bvc2FibGUgPSB0aGlzLl9fZGlzcG9zYWJsZXNbaV07XHJcbiAgICAgICAgICAgICAgICBpZiAoZGlzcG9zYWJsZS5kaXNwb3NlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlzcG9zYWJsZS5kaXNwb3NlKCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fX2Rpc3Bvc2FibGVzID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJhc2VDb21wb25lbnQucHJvdG90eXBlLCBcImNsYXNzTmFtZVwiLCB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogR2V0cyB0aGUgb2JqZWN0J3MgY2xhc3MgbmFtZS5cclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKCF0aGlzLl9fY2xhc3NOYW1lKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZnVuY05hbWVSZWdleCA9IC9mdW5jdGlvbiAoLnsxLH0pXFwoLztcclxuICAgICAgICAgICAgICAgIHZhciByZXN1bHRzID0gKGZ1bmNOYW1lUmVnZXgpLmV4ZWMoKHRoaXMpLmNvbnN0cnVjdG9yLnRvU3RyaW5nKCkpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX2NsYXNzTmFtZSA9IChyZXN1bHRzICYmIHJlc3VsdHMubGVuZ3RoID4gMSkgPyByZXN1bHRzWzFdIDogJyc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX19jbGFzc05hbWU7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoQmFzZUNvbXBvbmVudC5wcm90b3R5cGUsIFwiX2Rpc3Bvc2FibGVzXCIsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBBbGxvd3Mgc3ViY2xhc3NlcyB0byBwdXNoIHRoaW5ncyB0byB0aGlzLl9kaXNwb3NhYmxlcyB0byBiZSBhdXRvIGRpc3Bvc2VkLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX19kaXNwb3NhYmxlcykge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fX2Rpc3Bvc2FibGVzID0gW107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuX19kaXNwb3NhYmxlcztcclxuICAgICAgICB9LFxyXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlXHJcbiAgICB9KTtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShCYXNlQ29tcG9uZW50LnByb3RvdHlwZSwgXCJfYXN5bmNcIiwge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgdGhlIGFzeW5jIGluc3RhbmNlIGFzc29jaWF0ZWQgd2l0aCB0aGUgY29tcG9uZW50LCBjcmVhdGVkIG9uIGRlbWFuZC4gVGhlIGFzeW5jIGluc3RhbmNlIGdpdmVzXHJcbiAgICAgICAgICogc3ViY2xhc3NlcyBhIHdheSB0byBleGVjdXRlIHNldFRpbWVvdXQvc2V0SW50ZXJ2YWwgYXN5bmMgY2FsbHMgc2FmZWx5LCB3aGVyZSB0aGUgY2FsbGJhY2tzXHJcbiAgICAgICAgICogd2lsbCBiZSBjbGVhcmVkL2lnbm9yZWQgYXV0b21hdGljYWxseSBhZnRlciB1bm1vdW50aW5nLiBUaGUgaGVscGVycyB3aXRoaW4gdGhlIGFzeW5jIG9iamVjdCBhbHNvXHJcbiAgICAgICAgICogcHJlc2VydmUgdGhlIHRoaXMgcG9pbnRlciBzbyB0aGF0IHlvdSBkb24ndCBuZWVkIHRvIFwiYmluZFwiIHRoZSBjYWxsYmFja3MuXHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fX2FzeW5jKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9fYXN5bmMgPSBuZXcgQXN5bmNfMS5Bc3luYyh0aGlzKTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2Rpc3Bvc2FibGVzLnB1c2godGhpcy5fX2FzeW5jKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fX2FzeW5jO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJhc2VDb21wb25lbnQucHJvdG90eXBlLCBcIl9ldmVudHNcIiwge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEdldHMgdGhlIGV2ZW50IGdyb3VwIGluc3RhbmNlIGFzc29jYWl0ZWQgd2l0aCB0aGUgY29tcG9uZW50LCBjcmVhdGVkIG9uIGRlbWFuZC4gVGhlIGV2ZW50IGluc3RhbmNlXHJcbiAgICAgICAgICogcHJvdmlkZXMgb24vb2ZmIG1ldGhvZHMgZm9yIGxpc3RlbmluZyB0byBET00gKG9yIHJlZ3VsYXIgamF2YXNjcmlwdCBvYmplY3QpIGV2ZW50cy4gVGhlIGV2ZW50IGNhbGxiYWNrc1xyXG4gICAgICAgICAqIHdpbGwgYmUgYXV0b21hdGljYWxseSBkaXNjb25uZWN0ZWQgYWZ0ZXIgdW5tb3VudGluZy4gVGhlIGhlbHBlcnMgd2l0aGluIHRoZSBldmVudHMgb2JqZWN0IGFsc29cclxuICAgICAgICAgKiBwcmVzZXJ2ZSB0aGUgdGhpcyByZWZlcmVuY2Ugc28gdGhhdCB5b3UgZG9uJ3QgbmVlZCB0byBcImJpbmRcIiB0aGUgY2FsbGJhY2tzLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX19ldmVudHMpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX19ldmVudHMgPSBuZXcgRXZlbnRHcm91cF8xLkV2ZW50R3JvdXAodGhpcyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9kaXNwb3NhYmxlcy5wdXNoKHRoaXMuX19ldmVudHMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9fZXZlbnRzO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgLyoqXHJcbiAgICAgKiBIZWxwZXIgdG8gcmV0dXJuIGEgbWVtb2l6ZWQgcmVmIHJlc29sdmVyIGZ1bmN0aW9uLlxyXG4gICAgICogQHBhcmFtIHJlZk5hbWUgLSBOYW1lIG9mIHRoZSBtZW1iZXIgdG8gYXNzaWduIHRoZSByZWYgdG8uXHJcbiAgICAgKiBAcmV0dXJucyBBIGZ1bmN0aW9uIGluc3RhbmNlIGtleWVkIGZyb20gdGhlIGdpdmVuIHJlZm5hbWUuXHJcbiAgICAgKi9cclxuICAgIEJhc2VDb21wb25lbnQucHJvdG90eXBlLl9yZXNvbHZlUmVmID0gZnVuY3Rpb24gKHJlZk5hbWUpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGlmICghdGhpcy5fX3Jlc29sdmVzKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX19yZXNvbHZlcyA9IHt9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIXRoaXMuX19yZXNvbHZlc1tyZWZOYW1lXSkge1xyXG4gICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYW55XHJcbiAgICAgICAgICAgIHRoaXMuX19yZXNvbHZlc1tyZWZOYW1lXSA9IGZ1bmN0aW9uIChyZWYpIHtcclxuICAgICAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1hbnlcclxuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpc1tyZWZOYW1lXSA9IHJlZjtcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX19yZXNvbHZlc1tyZWZOYW1lXTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZXMgdGhlIGNvbXBvbmVudFJlZiAoYnkgY2FsbGluZyBpdCB3aXRoIFwidGhpc1wiIHdoZW4gbmVjZXNzYXJ5LilcclxuICAgICAqL1xyXG4gICAgQmFzZUNvbXBvbmVudC5wcm90b3R5cGUuX3VwZGF0ZUNvbXBvbmVudFJlZiA9IGZ1bmN0aW9uIChjdXJyZW50UHJvcHMsIG5ld1Byb3BzKSB7XHJcbiAgICAgICAgaWYgKG5ld1Byb3BzID09PSB2b2lkIDApIHsgbmV3UHJvcHMgPSB7fTsgfVxyXG4gICAgICAgIGlmICh0aGlzLl9zaG91bGRVcGRhdGVDb21wb25lbnRSZWYgJiZcclxuICAgICAgICAgICAgKCghY3VycmVudFByb3BzICYmIG5ld1Byb3BzLmNvbXBvbmVudFJlZikgfHxcclxuICAgICAgICAgICAgICAgIChjdXJyZW50UHJvcHMgJiYgY3VycmVudFByb3BzLmNvbXBvbmVudFJlZiAhPT0gbmV3UHJvcHMuY29tcG9uZW50UmVmKSkpIHtcclxuICAgICAgICAgICAgaWYgKGN1cnJlbnRQcm9wcyAmJiBjdXJyZW50UHJvcHMuY29tcG9uZW50UmVmKSB7XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50UHJvcHMuY29tcG9uZW50UmVmKG51bGwpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChuZXdQcm9wcy5jb21wb25lbnRSZWYpIHtcclxuICAgICAgICAgICAgICAgIG5ld1Byb3BzLmNvbXBvbmVudFJlZih0aGlzKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFdhcm5zIHdoZW4gYSBkZXByZWNhdGVkIHByb3BzIGFyZSBiZWluZyB1c2VkLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBkZXByZWNhdGlvbk1hcCAtIFRoZSBtYXAgb2YgZGVwcmVjYXRpb25zLCB3aGVyZSBrZXkgaXMgdGhlIHByb3AgbmFtZSBhbmQgdGhlIHZhbHVlIGlzXHJcbiAgICAgKiBlaXRoZXIgbnVsbCBvciBhIHJlcGxhY2VtZW50IHByb3AgbmFtZS5cclxuICAgICAqL1xyXG4gICAgQmFzZUNvbXBvbmVudC5wcm90b3R5cGUuX3dhcm5EZXByZWNhdGlvbnMgPSBmdW5jdGlvbiAoZGVwcmVjYXRpb25NYXApIHtcclxuICAgICAgICB3YXJuXzEud2FybkRlcHJlY2F0aW9ucyh0aGlzLmNsYXNzTmFtZSwgdGhpcy5wcm9wcywgZGVwcmVjYXRpb25NYXApO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogV2FybnMgd2hlbiBwcm9wcyB3aGljaCBhcmUgbXV0dWFsbHkgZXhjbHVzaXZlIHdpdGggZWFjaCBvdGhlciBhcmUgYm90aCB1c2VkLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBtdXR1YWxseUV4Y2x1c2l2ZU1hcCAtIFRoZSBtYXAgb2YgbXV0dWFsbHkgZXhjbHVzaXZlIHByb3BzLlxyXG4gICAgICovXHJcbiAgICBCYXNlQ29tcG9uZW50LnByb3RvdHlwZS5fd2Fybk11dHVhbGx5RXhjbHVzaXZlID0gZnVuY3Rpb24gKG11dHVhbGx5RXhjbHVzaXZlTWFwKSB7XHJcbiAgICAgICAgd2Fybl8xLndhcm5NdXR1YWxseUV4Y2x1c2l2ZSh0aGlzLmNsYXNzTmFtZSwgdGhpcy5wcm9wcywgbXV0dWFsbHlFeGNsdXNpdmVNYXApO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogV2FybnMgd2hlbiBwcm9wcyBhcmUgcmVxdWlyZWQgaWYgYSBjb25kaXRpb24gaXMgbWV0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSByZXF1aXJlZFByb3BzIC0gVGhlIG5hbWUgb2YgdGhlIHByb3BzIHRoYXQgYXJlIHJlcXVpcmVkIHdoZW4gdGhlIGNvbmRpdGlvbiBpcyBtZXQuXHJcbiAgICAgKiBAcGFyYW0gY29uZGl0aW9uYWxQcm9wTmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBwcm9wIHRoYXQgdGhlIGNvbmRpdGlvbiBpcyBiYXNlZCBvbi5cclxuICAgICAqIEBwYXJhbSBjb25kaXRpb24gLSBXaGV0aGVyIHRoZSBjb25kaXRpb24gaXMgbWV0LlxyXG4gICAgICovXHJcbiAgICBCYXNlQ29tcG9uZW50LnByb3RvdHlwZS5fd2FybkNvbmRpdGlvbmFsbHlSZXF1aXJlZFByb3BzID0gZnVuY3Rpb24gKHJlcXVpcmVkUHJvcHMsIGNvbmRpdGlvbmFsUHJvcE5hbWUsIGNvbmRpdGlvbikge1xyXG4gICAgICAgIHdhcm5fMS53YXJuQ29uZGl0aW9uYWxseVJlcXVpcmVkUHJvcHModGhpcy5jbGFzc05hbWUsIHRoaXMucHJvcHMsIHJlcXVpcmVkUHJvcHMsIGNvbmRpdGlvbmFsUHJvcE5hbWUsIGNvbmRpdGlvbik7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEJhc2VDb21wb25lbnQ7XHJcbn0oUmVhY3QuQ29tcG9uZW50KSk7XHJcbmV4cG9ydHMuQmFzZUNvbXBvbmVudCA9IEJhc2VDb21wb25lbnQ7XHJcbi8qKlxyXG4gKiBIZWxwZXIgdG8gb3ZlcnJpZGUgYSBnaXZlbiBtZXRob2Qgd2l0aCBhIHdyYXBwZXIgbWV0aG9kIHRoYXQgY2FuIHRyeS9jYXRjaCB0aGUgb3JpZ2luYWwsIGJ1dCBhbHNvXHJcbiAqIGVuc3VyZXMgdGhhdCB0aGUgQmFzZUNvbXBvbmVudCdzIG1ldGhvZHMgYXJlIGNhbGxlZCBiZWZvcmUgdGhlIHN1YmNsYXNzJ3MuIFRoaXMgZW5zdXJlcyB0aGF0XHJcbiAqIGNvbXBvbmVudFdpbGxVbm1vdW50IGluIHRoZSBiYXNlIGlzIGNhbGxlZCBhbmQgdGhhdCB0aGluZ3MgaW4gdGhlIF9kaXNwb3NhYmxlcyBhcnJheSBhcmUgZGlzcG9zZWQuXHJcbiAqL1xyXG5mdW5jdGlvbiBfbWFrZUFsbFNhZmUob2JqLCBwcm90b3R5cGUsIG1ldGhvZE5hbWVzKSB7XHJcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuID0gbWV0aG9kTmFtZXMubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcclxuICAgICAgICBfbWFrZVNhZmUob2JqLCBwcm90b3R5cGUsIG1ldGhvZE5hbWVzW2ldKTtcclxuICAgIH1cclxufVxyXG5mdW5jdGlvbiBfbWFrZVNhZmUob2JqLCBwcm90b3R5cGUsIG1ldGhvZE5hbWUpIHtcclxuICAgIC8vIHRzbGludDpkaXNhYmxlOm5vLWFueVxyXG4gICAgdmFyIGNsYXNzTWV0aG9kID0gb2JqW21ldGhvZE5hbWVdO1xyXG4gICAgdmFyIHByb3RvdHlwZU1ldGhvZCA9IHByb3RvdHlwZVttZXRob2ROYW1lXTtcclxuICAgIC8vIHRzbGludDplbmFibGU6bm8tYW55XHJcbiAgICBpZiAoY2xhc3NNZXRob2QgfHwgcHJvdG90eXBlTWV0aG9kKSB7XHJcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueVxyXG4gICAgICAgIG9ialttZXRob2ROYW1lXSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHJldFZhbDtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGlmIChwcm90b3R5cGVNZXRob2QpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXRWYWwgPSBwcm90b3R5cGVNZXRob2QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChjbGFzc01ldGhvZCAhPT0gcHJvdG90eXBlTWV0aG9kKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0VmFsID0gY2xhc3NNZXRob2QuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGVycm9yTWVzc2FnZSA9IFwiRXhjZXB0aW9uIGluIFwiICsgb2JqLmNsYXNzTmFtZSArIFwiLlwiICsgbWV0aG9kTmFtZSArIFwiKCk6IFwiICsgKHR5cGVvZiBlID09PSAnc3RyaW5nJyA/IGUgOiBlLnN0YWNrKTtcclxuICAgICAgICAgICAgICAgIGlmIChCYXNlQ29tcG9uZW50Lm9uRXJyb3IpIHtcclxuICAgICAgICAgICAgICAgICAgICBCYXNlQ29tcG9uZW50Lm9uRXJyb3IoZXJyb3JNZXNzYWdlLCBlKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gcmV0VmFsO1xyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbn1cclxuQmFzZUNvbXBvbmVudC5vbkVycm9yID0gZnVuY3Rpb24gKGVycm9yTWVzc2FnZSkge1xyXG4gICAgY29uc29sZS5lcnJvcihlcnJvck1lc3NhZ2UpO1xyXG4gICAgdGhyb3cgZXJyb3JNZXNzYWdlO1xyXG59O1xyXG4vKipcclxuICogU2ltcGxlIGNvbnN0YW50IGZ1bmN0aW9uIGZvciByZXR1cm5pbmcgbnVsbCwgdXNlZCB0byByZW5kZXIgZW1wdHkgdGVtcGxhdGVzIGluIEpTWC5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuZnVuY3Rpb24gbnVsbFJlbmRlcigpIHsgcmV0dXJuIG51bGw7IH1cclxuZXhwb3J0cy5udWxsUmVuZGVyID0gbnVsbFJlbmRlcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QmFzZUNvbXBvbmVudC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcclxudmFyIEdsb2JhbFNldHRpbmdzXzEgPSByZXF1aXJlKFwiLi9HbG9iYWxTZXR0aW5nc1wiKTtcclxudmFyIEV2ZW50R3JvdXBfMSA9IHJlcXVpcmUoXCIuL0V2ZW50R3JvdXBcIik7XHJcbnZhciBDdXN0b21pemF0aW9uc0dsb2JhbEtleSA9ICdjdXN0b21pemF0aW9ucyc7XHJcbnZhciBOT19DVVNUT01JWkFUSU9OUyA9IHsgc2V0dGluZ3M6IHt9LCBzY29wZWRTZXR0aW5nczoge30gfTtcclxudmFyIF9hbGxTZXR0aW5ncyA9IEdsb2JhbFNldHRpbmdzXzEuR2xvYmFsU2V0dGluZ3MuZ2V0VmFsdWUoQ3VzdG9taXphdGlvbnNHbG9iYWxLZXksIHtcclxuICAgIHNldHRpbmdzOiB7fSxcclxuICAgIHNjb3BlZFNldHRpbmdzOiB7fVxyXG59KTtcclxudmFyIF9ldmVudHMgPSBuZXcgRXZlbnRHcm91cF8xLkV2ZW50R3JvdXAoX2FsbFNldHRpbmdzKTtcclxudmFyIEN1c3RvbWl6YXRpb25zID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gQ3VzdG9taXphdGlvbnMoKSB7XHJcbiAgICB9XHJcbiAgICBDdXN0b21pemF0aW9ucy5yZXNldCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBfYWxsU2V0dGluZ3Muc2V0dGluZ3MgPSB7fTtcclxuICAgICAgICBfYWxsU2V0dGluZ3Muc2NvcGVkU2V0dGluZ3MgPSB7fTtcclxuICAgIH07XHJcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYW55XHJcbiAgICBDdXN0b21pemF0aW9ucy5hcHBseVNldHRpbmdzID0gZnVuY3Rpb24gKHNldHRpbmdzKSB7XHJcbiAgICAgICAgX2FsbFNldHRpbmdzLnNldHRpbmdzID0gdHNsaWJfMS5fX2Fzc2lnbih7fSwgX2FsbFNldHRpbmdzLnNldHRpbmdzLCBzZXR0aW5ncyk7XHJcbiAgICAgICAgQ3VzdG9taXphdGlvbnMuX3JhaXNlQ2hhbmdlKCk7XHJcbiAgICB9O1xyXG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueVxyXG4gICAgQ3VzdG9taXphdGlvbnMuYXBwbHlTY29wZWRTZXR0aW5ncyA9IGZ1bmN0aW9uIChzY29wZU5hbWUsIHNldHRpbmdzKSB7XHJcbiAgICAgICAgX2FsbFNldHRpbmdzLnNjb3BlZFNldHRpbmdzW3Njb3BlTmFtZV0gPSB0c2xpYl8xLl9fYXNzaWduKHt9LCBfYWxsU2V0dGluZ3Muc2NvcGVkU2V0dGluZ3Nbc2NvcGVOYW1lXSwgc2V0dGluZ3MpO1xyXG4gICAgICAgIEN1c3RvbWl6YXRpb25zLl9yYWlzZUNoYW5nZSgpO1xyXG4gICAgfTtcclxuICAgIEN1c3RvbWl6YXRpb25zLmdldFNldHRpbmdzID0gZnVuY3Rpb24gKHByb3BlcnRpZXMsIHNjb3BlTmFtZSwgbG9jYWxTZXR0aW5nc1xyXG4gICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1hbnlcclxuICAgICkge1xyXG4gICAgICAgIGlmIChsb2NhbFNldHRpbmdzID09PSB2b2lkIDApIHsgbG9jYWxTZXR0aW5ncyA9IE5PX0NVU1RPTUlaQVRJT05TOyB9XHJcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueVxyXG4gICAgICAgIHZhciBzZXR0aW5ncyA9IHt9O1xyXG4gICAgICAgIHZhciBsb2NhbFNjb3BlZFNldHRpbmdzID0gKHNjb3BlTmFtZSAmJiBsb2NhbFNldHRpbmdzLnNjb3BlZFNldHRpbmdzW3Njb3BlTmFtZV0pIHx8IHt9O1xyXG4gICAgICAgIHZhciBnbG9iYWxTY29wZWRTZXR0aW5ncyA9IChzY29wZU5hbWUgJiYgX2FsbFNldHRpbmdzLnNjb3BlZFNldHRpbmdzW3Njb3BlTmFtZV0pIHx8IHt9O1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMCwgcHJvcGVydGllc18xID0gcHJvcGVydGllczsgX2kgPCBwcm9wZXJ0aWVzXzEubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBwcm9wZXJ0eSA9IHByb3BlcnRpZXNfMVtfaV07XHJcbiAgICAgICAgICAgIHNldHRpbmdzW3Byb3BlcnR5XSA9IChsb2NhbFNjb3BlZFNldHRpbmdzW3Byb3BlcnR5XSB8fFxyXG4gICAgICAgICAgICAgICAgbG9jYWxTZXR0aW5ncy5zZXR0aW5nc1twcm9wZXJ0eV0gfHxcclxuICAgICAgICAgICAgICAgIGdsb2JhbFNjb3BlZFNldHRpbmdzW3Byb3BlcnR5XSB8fFxyXG4gICAgICAgICAgICAgICAgX2FsbFNldHRpbmdzLnNldHRpbmdzW3Byb3BlcnR5XSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzZXR0aW5ncztcclxuICAgIH07XHJcbiAgICBDdXN0b21pemF0aW9ucy5vYnNlcnZlID0gZnVuY3Rpb24gKG9uQ2hhbmdlKSB7XHJcbiAgICAgICAgX2V2ZW50cy5vbihfYWxsU2V0dGluZ3MsICdjaGFuZ2UnLCBvbkNoYW5nZSk7XHJcbiAgICB9O1xyXG4gICAgQ3VzdG9taXphdGlvbnMudW5vYnNlcnZlID0gZnVuY3Rpb24gKG9uQ2hhbmdlKSB7XHJcbiAgICAgICAgX2V2ZW50cy5vZmYoX2FsbFNldHRpbmdzLCAnY2hhbmdlJywgb25DaGFuZ2UpO1xyXG4gICAgfTtcclxuICAgIEN1c3RvbWl6YXRpb25zLl9yYWlzZUNoYW5nZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBfZXZlbnRzLnJhaXNlKCdjaGFuZ2UnKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gQ3VzdG9taXphdGlvbnM7XHJcbn0oKSk7XHJcbmV4cG9ydHMuQ3VzdG9taXphdGlvbnMgPSBDdXN0b21pemF0aW9ucztcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q3VzdG9taXphdGlvbnMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XHJcbnZhciBSZWFjdCA9IHJlcXVpcmUoXCJyZWFjdFwiKTtcclxudmFyIFByb3BUeXBlcyA9IHJlcXVpcmUoXCJwcm9wLXR5cGVzXCIpO1xyXG52YXIgQmFzZUNvbXBvbmVudF8xID0gcmVxdWlyZShcIi4vQmFzZUNvbXBvbmVudFwiKTtcclxuLyoqXHJcbiAqIFRoZSBDdXN0b21pemVyIGNvbXBvbmVudCBhbGxvd3MgZm9yIGRlZmF1bHQgcHJvcHMgdG8gYmUgbWl4ZWQgaW50byBjb21wb25lbnRzIHdoaWNoXHJcbiAqIGFyZSBkZWNvcmF0ZWQgd2l0aCB0aGUgY3VzdG9taXphYmxlKCkgZGVjb3JhdG9yLiBUaGlzIGVuYWJsZXMgaW5qZWN0aW9uIHNjZW5hcmlvcyBsaWtlOlxyXG4gKlxyXG4gKiAxLiByZW5kZXIgc3ZnIGljb25zIGluc3RlYWQgb2YgdGhlIGljb24gZm9udCB3aXRoaW4gYWxsIGJ1dHRvbnNcclxuICogMi4gaW5qZWN0IGEgY3VzdG9tIHRoZW1lIG9iamVjdCBpbnRvIGEgY29tcG9uZW50XHJcbiAqXHJcbiAqIFByb3BzIGFyZSBwcm92aWRlZCB2aWEgdGhlIHNldHRpbmdzIHByb3AsIHdoaWNoIHNob3VsZCBiZSBhIGpzb24gbWFwIHdoaWNoIGNvbnRhaW5zIDEgb3IgbW9yZVxyXG4gKiBuYW1lL3ZhbHVlIHBhaXJzIHJlcHJlc2VudGluZyBpbmplY3RhYmxlIHByb3BzLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG52YXIgQ3VzdG9taXplciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIHRzbGliXzEuX19leHRlbmRzKEN1c3RvbWl6ZXIsIF9zdXBlcik7XHJcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYW55XHJcbiAgICBmdW5jdGlvbiBDdXN0b21pemVyKHByb3BzLCBjb250ZXh0KSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgcHJvcHMpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuc3RhdGUgPSBfdGhpcy5fZ2V0Q3VzdG9taXphdGlvbnMocHJvcHMsIGNvbnRleHQpO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIEN1c3RvbWl6ZXIucHJvdG90eXBlLmdldENoaWxkQ29udGV4dCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5zdGF0ZTtcclxuICAgIH07XHJcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYW55XHJcbiAgICBDdXN0b21pemVyLnByb3RvdHlwZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID0gZnVuY3Rpb24gKG5ld1Byb3BzLCBuZXdDb250ZXh0KSB7XHJcbiAgICAgICAgdGhpcy5zZXRTdGF0ZSh0aGlzLl9nZXRDdXN0b21pemF0aW9ucyhuZXdQcm9wcywgbmV3Q29udGV4dCkpO1xyXG4gICAgfTtcclxuICAgIEN1c3RvbWl6ZXIucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gUmVhY3QuQ2hpbGRyZW4ub25seSh0aGlzLnByb3BzLmNoaWxkcmVuKTtcclxuICAgIH07XHJcbiAgICBDdXN0b21pemVyLnByb3RvdHlwZS5fZ2V0Q3VzdG9taXphdGlvbnMgPSBmdW5jdGlvbiAocHJvcHMsIGNvbnRleHQpIHtcclxuICAgICAgICB2YXIgX2EgPSBwcm9wcy5zZXR0aW5ncywgc2V0dGluZ3MgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYSwgX2IgPSBwcm9wcy5zY29wZWRTZXR0aW5ncywgc2NvcGVkU2V0dGluZ3MgPSBfYiA9PT0gdm9pZCAwID8ge30gOiBfYjtcclxuICAgICAgICB2YXIgX2MgPSBjb250ZXh0LmN1c3RvbWl6YXRpb25zLCBjdXN0b21pemF0aW9ucyA9IF9jID09PSB2b2lkIDAgPyB7IHNldHRpbmdzOiB7fSwgc2NvcGVkU2V0dGluZ3M6IHt9IH0gOiBfYztcclxuICAgICAgICB2YXIgbmV3U2NvcGVkU2V0dGluZ3MgPSB0c2xpYl8xLl9fYXNzaWduKHt9LCBzY29wZWRTZXR0aW5ncyk7XHJcbiAgICAgICAgZm9yICh2YXIgbmFtZV8xIGluIGN1c3RvbWl6YXRpb25zLnNjb3BlZFNldHRpbmdzKSB7XHJcbiAgICAgICAgICAgIGlmIChjdXN0b21pemF0aW9ucy5zY29wZWRTZXR0aW5ncy5oYXNPd25Qcm9wZXJ0eShuYW1lXzEpKSB7XHJcbiAgICAgICAgICAgICAgICBuZXdTY29wZWRTZXR0aW5nc1tuYW1lXzFdID0gdHNsaWJfMS5fX2Fzc2lnbih7fSwgc2NvcGVkU2V0dGluZ3NbbmFtZV8xXSwgY3VzdG9taXphdGlvbnMuc2NvcGVkU2V0dGluZ3NbbmFtZV8xXSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgY3VzdG9taXphdGlvbnM6IHtcclxuICAgICAgICAgICAgICAgIHNldHRpbmdzOiB0c2xpYl8xLl9fYXNzaWduKHt9LCBzZXR0aW5ncywgY3VzdG9taXphdGlvbnMuc2V0dGluZ3MpLFxyXG4gICAgICAgICAgICAgICAgc2NvcGVkU2V0dGluZ3M6IG5ld1Njb3BlZFNldHRpbmdzXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9O1xyXG4gICAgfTtcclxuICAgIEN1c3RvbWl6ZXIuY29udGV4dFR5cGVzID0ge1xyXG4gICAgICAgIGN1c3RvbWl6YXRpb25zOiBQcm9wVHlwZXMub2JqZWN0XHJcbiAgICB9O1xyXG4gICAgQ3VzdG9taXplci5jaGlsZENvbnRleHRUeXBlcyA9IEN1c3RvbWl6ZXIuY29udGV4dFR5cGVzO1xyXG4gICAgcmV0dXJuIEN1c3RvbWl6ZXI7XHJcbn0oQmFzZUNvbXBvbmVudF8xLkJhc2VDb21wb25lbnQpKTtcclxuZXhwb3J0cy5DdXN0b21pemVyID0gQ3VzdG9taXplcjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q3VzdG9taXplci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcclxudmFyIFJlYWN0ID0gcmVxdWlyZShcInJlYWN0XCIpO1xyXG4vKipcclxuICogVXRpbGl0eSBjb21wb25lbnQgZm9yIGRlbGF5aW5nIHRoZSByZW5kZXIgb2YgYSBjaGlsZCBjb21wb25lbnQgYWZ0ZXIgYSBnaXZlbiBkZWxheS4gVGhpcyBjb21wb25lbnRcclxuICogcmVxdWlyZXMgYSBzaW5nbGUgY2hpbGQgY29tcG9uZW50OyBkb24ndCBwYXNzIGluIG1hbnkgY29tcG9uZW50cy4gV3JhcCBtdWx0aXBsZSBjb21wb25lbnRzIGluIGEgRElWXHJcbiAqIGlmIG5lY2Vzc2FyeS5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxudmFyIERlbGF5ZWRSZW5kZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhEZWxheWVkUmVuZGVyLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gRGVsYXllZFJlbmRlcihwcm9wcykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHByb3BzKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLnN0YXRlID0ge1xyXG4gICAgICAgICAgICBpc1JlbmRlcmVkOiBmYWxzZVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgRGVsYXllZFJlbmRlci5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgZGVsYXkgPSB0aGlzLnByb3BzLmRlbGF5O1xyXG4gICAgICAgIHRoaXMuX3RpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBfdGhpcy5zZXRTdGF0ZSh7XHJcbiAgICAgICAgICAgICAgICBpc1JlbmRlcmVkOiB0cnVlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sIGRlbGF5KTtcclxuICAgIH07XHJcbiAgICBEZWxheWVkUmVuZGVyLnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5fdGltZW91dElkKSB7XHJcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lb3V0SWQpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBEZWxheWVkUmVuZGVyLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdGUuaXNSZW5kZXJlZCA/IFJlYWN0LkNoaWxkcmVuLm9ubHkodGhpcy5wcm9wcy5jaGlsZHJlbikgOiBudWxsO1xyXG4gICAgfTtcclxuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTp0eXBlZGVmXHJcbiAgICBEZWxheWVkUmVuZGVyLmRlZmF1bHRQcm9wcyA9IHtcclxuICAgICAgICBkZWxheTogMFxyXG4gICAgfTtcclxuICAgIHJldHVybiBEZWxheWVkUmVuZGVyO1xyXG59KFJlYWN0LkNvbXBvbmVudCkpO1xyXG5leHBvcnRzLkRlbGF5ZWRSZW5kZXIgPSBEZWxheWVkUmVuZGVyO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1EZWxheWVkUmVuZGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG4vKiB0c2xpbnQ6ZGlzYWJsZTpuby1zdHJpbmctbGl0ZXJhbCAqL1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbi8qKiBBbiBpbnN0YW5jZSBvZiBFdmVudEdyb3VwIGFsbG93cyBhbnl0aGluZyB3aXRoIGEgaGFuZGxlIHRvIGl0IHRvIHRyaWdnZXIgZXZlbnRzIG9uIGl0LlxyXG4gKiAgSWYgdGhlIHRhcmdldCBpcyBhbiBIVE1MRWxlbWVudCwgdGhlIGV2ZW50IHdpbGwgYmUgYXR0YWNoZWQgdG8gdGhlIGVsZW1lbnQgYW5kIGNhbiBiZVxyXG4gKiAgdHJpZ2dlcmVkIGFzIHVzdWFsIChsaWtlIGNsaWNraW5nIGZvciBvbmNsaWNrKS5cclxuICogIFRoZSBldmVudCBjYW4gYmUgdHJpZ2dlcmVkIGJ5IGNhbGxpbmcgRXZlbnRHcm91cC5yYWlzZSgpIGhlcmUuIElmIHRoZSB0YXJnZXQgaXMgYW5cclxuICogIEhUTUxFbGVtZW50LCB0aGUgZXZlbnQgZ2V0cyByYWlzZWQgYW5kIGlzIGhhbmRsZWQgYnkgdGhlIGJyb3dzZXIuIE90aGVyd2lzZSwgaXQgZ2V0c1xyXG4gKiAgaGFuZGxlZCBoZXJlIGluIEV2ZW50R3JvdXAsIGFuZCB0aGUgaGFuZGxlciBpcyBjYWxsZWQgaW4gdGhlIGNvbnRleHQgb2YgdGhlIHBhcmVudFxyXG4gKiAgKHdoaWNoIGlzIHBhc3NlZCBpbiBpbiB0aGUgY29uc3RydWN0b3IpLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG52YXIgRXZlbnRHcm91cCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIC8qKiBwYXJlbnQ6IHRoZSBjb250ZXh0IGluIHdoaWNoIGV2ZW50cyBhdHRhY2hlZCB0byBub24tSFRNTEVsZW1lbnRzIGFyZSBjYWxsZWQgKi9cclxuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1hbnlcclxuICAgIGZ1bmN0aW9uIEV2ZW50R3JvdXAocGFyZW50KSB7XHJcbiAgICAgICAgdGhpcy5faWQgPSBFdmVudEdyb3VwLl91bmlxdWVJZCsrO1xyXG4gICAgICAgIHRoaXMuX3BhcmVudCA9IHBhcmVudDtcclxuICAgICAgICB0aGlzLl9ldmVudFJlY29yZHMgPSBbXTtcclxuICAgIH1cclxuICAgIC8qKiBGb3IgSUU4LCBidWJibGVFdmVudCBpcyBpZ25vcmVkIGhlcmUgYW5kIG11c3QgYmUgZGVhbHQgd2l0aCBieSB0aGUgaGFuZGxlci5cclxuICAgICAqICBFdmVudHMgcmFpc2VkIGhlcmUgYnkgZGVmYXVsdCBoYXZlIGJ1YmJsaW5nIHNldCB0byBmYWxzZSBhbmQgY2FuY2VsYWJsZSBzZXQgdG8gdHJ1ZS5cclxuICAgICAqICBUaGlzIGFwcGxpZXMgYWxzbyB0byBidWlsdC1pbiBldmVudHMgYmVpbmcgcmFpc2VkIG1hbnVhbGx5IGhlcmUgb24gSFRNTEVsZW1lbnRzLFxyXG4gICAgICogIHdoaWNoIG1heSBsZWFkIHRvIHVuZXhwZWN0ZWQgYmVoYXZpb3IgaWYgaXQgZGlmZmVycyBmcm9tIHRoZSBkZWZhdWx0cy5cclxuICAgICAqXHJcbiAgICAgKi9cclxuICAgIEV2ZW50R3JvdXAucmFpc2UgPSBmdW5jdGlvbiAoXHJcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueVxyXG4gICAgICAgIHRhcmdldCwgZXZlbnROYW1lLCBcclxuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYW55XHJcbiAgICAgICAgZXZlbnRBcmdzLCBidWJibGVFdmVudCkge1xyXG4gICAgICAgIHZhciByZXRWYWw7XHJcbiAgICAgICAgaWYgKEV2ZW50R3JvdXAuX2lzRWxlbWVudCh0YXJnZXQpKSB7XHJcbiAgICAgICAgICAgIGlmIChkb2N1bWVudC5jcmVhdGVFdmVudCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGV2ID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0hUTUxFdmVudHMnKTtcclxuICAgICAgICAgICAgICAgIGV2LmluaXRFdmVudChldmVudE5hbWUsIGJ1YmJsZUV2ZW50IHx8IGZhbHNlLCB0cnVlKTtcclxuICAgICAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1hbnlcclxuICAgICAgICAgICAgICAgIGV2WydhcmdzJ10gPSBldmVudEFyZ3M7XHJcbiAgICAgICAgICAgICAgICByZXRWYWwgPSB0YXJnZXQuZGlzcGF0Y2hFdmVudChldik7XHJcbiAgICAgICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYW55XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoZG9jdW1lbnRbJ2NyZWF0ZUV2ZW50T2JqZWN0J10pIHtcclxuICAgICAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1hbnlcclxuICAgICAgICAgICAgICAgIHZhciBldk9iaiA9IGRvY3VtZW50WydjcmVhdGVFdmVudE9iamVjdCddKGV2ZW50QXJncyk7XHJcbiAgICAgICAgICAgICAgICAvLyBjYW5ub3Qgc2V0IGNhbmNlbEJ1YmJsZSBvbiBldk9iaiwgZmlyZUV2ZW50IHdpbGwgb3ZlcndyaXRlIGl0XHJcbiAgICAgICAgICAgICAgICB0YXJnZXQuZmlyZUV2ZW50KCdvbicgKyBldmVudE5hbWUsIGV2T2JqKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgd2hpbGUgKHRhcmdldCAmJiByZXRWYWwgIT09IGZhbHNlKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZXZlbnRzID0gdGFyZ2V0Ll9fZXZlbnRzX187XHJcbiAgICAgICAgICAgICAgICB2YXIgZXZlbnRSZWNvcmRzID0gZXZlbnRzID8gZXZlbnRzW2V2ZW50TmFtZV0gOiBudWxsO1xyXG4gICAgICAgICAgICAgICAgaWYgKGV2ZW50UmVjb3Jkcykge1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGlkIGluIGV2ZW50UmVjb3Jkcykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnRSZWNvcmRzLmhhc093blByb3BlcnR5KGlkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGV2ZW50UmVjb3JkTGlzdCA9IGV2ZW50UmVjb3Jkc1tpZF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBsaXN0SW5kZXggPSAwOyByZXRWYWwgIT09IGZhbHNlICYmIGxpc3RJbmRleCA8IGV2ZW50UmVjb3JkTGlzdC5sZW5ndGg7IGxpc3RJbmRleCsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlY29yZCA9IGV2ZW50UmVjb3JkTGlzdFtsaXN0SW5kZXhdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZWNvcmQub2JqZWN0Q2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0VmFsID0gcmVjb3JkLm9iamVjdENhbGxiYWNrLmNhbGwocmVjb3JkLnBhcmVudCwgZXZlbnRBcmdzKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAvLyBJZiB0aGUgdGFyZ2V0IGhhcyBhIHBhcmVudCwgYnViYmxlIHRoZSBldmVudCB1cC5cclxuICAgICAgICAgICAgICAgIHRhcmdldCA9IGJ1YmJsZUV2ZW50ID8gdGFyZ2V0LnBhcmVudCA6IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJldFZhbDtcclxuICAgIH07XHJcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYW55XHJcbiAgICBFdmVudEdyb3VwLmlzT2JzZXJ2ZWQgPSBmdW5jdGlvbiAodGFyZ2V0LCBldmVudE5hbWUpIHtcclxuICAgICAgICB2YXIgZXZlbnRzID0gdGFyZ2V0ICYmIHRhcmdldC5fX2V2ZW50c19fO1xyXG4gICAgICAgIHJldHVybiAhIWV2ZW50cyAmJiAhIWV2ZW50c1tldmVudE5hbWVdO1xyXG4gICAgfTtcclxuICAgIC8qKiBDaGVjayB0byBzZWUgaWYgdGhlIHRhcmdldCBoYXMgZGVjbGFyZWQgc3VwcG9ydCBvZiB0aGUgZ2l2ZW4gZXZlbnQuICovXHJcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYW55XHJcbiAgICBFdmVudEdyb3VwLmlzRGVjbGFyZWQgPSBmdW5jdGlvbiAodGFyZ2V0LCBldmVudE5hbWUpIHtcclxuICAgICAgICB2YXIgZGVjbGFyZWRFdmVudHMgPSB0YXJnZXQgJiYgdGFyZ2V0Ll9fZGVjbGFyZWRFdmVudHM7XHJcbiAgICAgICAgcmV0dXJuICEhZGVjbGFyZWRFdmVudHMgJiYgISFkZWNsYXJlZEV2ZW50c1tldmVudE5hbWVdO1xyXG4gICAgfTtcclxuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1hbnlcclxuICAgIEV2ZW50R3JvdXAuc3RvcFByb3BhZ2F0aW9uID0gZnVuY3Rpb24gKGV2ZW50KSB7XHJcbiAgICAgICAgaWYgKGV2ZW50LnN0b3BQcm9wYWdhdGlvbikge1xyXG4gICAgICAgICAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGV2ZW50LmNhbmNlbEJ1YmJsZSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEV2ZW50R3JvdXAuX2lzRWxlbWVudCA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcclxuICAgICAgICByZXR1cm4gKCEhdGFyZ2V0ICYmICghIXRhcmdldC5hZGRFdmVudExpc3RlbmVyIHx8XHJcbiAgICAgICAgICAgICh0eXBlb2YgSFRNTEVsZW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHRhcmdldCBpbnN0YW5jZW9mIEhUTUxFbGVtZW50KSkpO1xyXG4gICAgfTtcclxuICAgIEV2ZW50R3JvdXAucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9pc0Rpc3Bvc2VkKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2lzRGlzcG9zZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICB0aGlzLm9mZigpO1xyXG4gICAgICAgICAgICB0aGlzLl9wYXJlbnQgPSBudWxsO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKiogT24gdGhlIHRhcmdldCwgYXR0YWNoIGEgc2V0IG9mIGV2ZW50cywgd2hlcmUgdGhlIGV2ZW50cyBvYmplY3QgaXMgYSBuYW1lIHRvIGZ1bmN0aW9uIG1hcHBpbmcuICovXHJcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYW55XHJcbiAgICBFdmVudEdyb3VwLnByb3RvdHlwZS5vbkFsbCA9IGZ1bmN0aW9uICh0YXJnZXQsIGV2ZW50cywgdXNlQ2FwdHVyZSkge1xyXG4gICAgICAgIGZvciAodmFyIGV2ZW50TmFtZSBpbiBldmVudHMpIHtcclxuICAgICAgICAgICAgaWYgKGV2ZW50cy5oYXNPd25Qcm9wZXJ0eShldmVudE5hbWUpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9uKHRhcmdldCwgZXZlbnROYW1lLCBldmVudHNbZXZlbnROYW1lXSwgdXNlQ2FwdHVyZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqIE9uIHRoZSB0YXJnZXQsIGF0dGFjaCBhbiBldmVudCB3aG9zZSBoYW5kbGVyIHdpbGwgYmUgY2FsbGVkIGluIHRoZSBjb250ZXh0IG9mIHRoZSBwYXJlbnRcclxuICAgICAqIG9mIHRoaXMgaW5zdGFuY2Ugb2YgRXZlbnRHcm91cC5cclxuICAgICAqL1xyXG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueVxyXG4gICAgRXZlbnRHcm91cC5wcm90b3R5cGUub24gPSBmdW5jdGlvbiAodGFyZ2V0LCBldmVudE5hbWUsIGNhbGxiYWNrLCB1c2VDYXB0dXJlKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBpZiAoZXZlbnROYW1lLmluZGV4T2YoJywnKSA+IC0xKSB7XHJcbiAgICAgICAgICAgIHZhciBldmVudHMgPSBldmVudE5hbWUuc3BsaXQoL1sgLF0rLyk7XHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXZlbnRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLm9uKHRhcmdldCwgZXZlbnRzW2ldLCBjYWxsYmFjaywgdXNlQ2FwdHVyZSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHZhciBwYXJlbnRfMSA9IHRoaXMuX3BhcmVudDtcclxuICAgICAgICAgICAgdmFyIGV2ZW50UmVjb3JkID0ge1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0OiB0YXJnZXQsXHJcbiAgICAgICAgICAgICAgICBldmVudE5hbWU6IGV2ZW50TmFtZSxcclxuICAgICAgICAgICAgICAgIHBhcmVudDogcGFyZW50XzEsXHJcbiAgICAgICAgICAgICAgICBjYWxsYmFjazogY2FsbGJhY2ssXHJcbiAgICAgICAgICAgICAgICB1c2VDYXB0dXJlOiB1c2VDYXB0dXJlIHx8IGZhbHNlXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIC8vIEluaXRpYWxpemUgYW5kIHdpcmUgdXAgdGhlIHJlY29yZCBvbiB0aGUgdGFyZ2V0LCBzbyB0aGF0IGl0IGNhbiBjYWxsIHRoZSBjYWxsYmFjayBpZiB0aGUgZXZlbnQgZmlyZXMuXHJcbiAgICAgICAgICAgIHZhciBldmVudHMgPSAodGFyZ2V0Ll9fZXZlbnRzX18gPSB0YXJnZXQuX19ldmVudHNfXyB8fCB7fSk7XHJcbiAgICAgICAgICAgIGV2ZW50c1tldmVudE5hbWVdID0gZXZlbnRzW2V2ZW50TmFtZV0gfHwge1xyXG4gICAgICAgICAgICAgICAgY291bnQ6IDBcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgZXZlbnRzW2V2ZW50TmFtZV1bdGhpcy5faWRdID0gZXZlbnRzW2V2ZW50TmFtZV1bdGhpcy5faWRdIHx8IFtdO1xyXG4gICAgICAgICAgICBldmVudHNbZXZlbnROYW1lXVt0aGlzLl9pZF0ucHVzaChldmVudFJlY29yZCk7XHJcbiAgICAgICAgICAgIGV2ZW50c1tldmVudE5hbWVdLmNvdW50Kys7XHJcbiAgICAgICAgICAgIGlmIChFdmVudEdyb3VwLl9pc0VsZW1lbnQodGFyZ2V0KSkge1xyXG4gICAgICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueVxyXG4gICAgICAgICAgICAgICAgdmFyIHByb2Nlc3NFbGVtZW50RXZlbnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5faXNEaXNwb3NlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciByZXN1bHQ7XHJcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gY2FsbGJhY2suYXBwbHkocGFyZW50XzEsIGFyZ3MpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0ID09PSBmYWxzZSAmJiBhcmdzWzBdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgZSA9IGFyZ3NbMF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZS5wcmV2ZW50RGVmYXVsdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlLnN0b3BQcm9wYWdhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlLmNhbmNlbEJ1YmJsZSA9IHRydWU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGUpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgLyogRXJyb3JIZWxwZXIubG9nKGUpOyAqL1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIGV2ZW50UmVjb3JkLmVsZW1lbnRDYWxsYmFjayA9IHByb2Nlc3NFbGVtZW50RXZlbnQ7XHJcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAvKiB0c2xpbnQ6ZGlzYWJsZTpiYW4tbmF0aXZlLWZ1bmN0aW9ucyAqL1xyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldC5hZGRFdmVudExpc3RlbmVyKGV2ZW50TmFtZSwgcHJvY2Vzc0VsZW1lbnRFdmVudCwgdXNlQ2FwdHVyZSk7XHJcbiAgICAgICAgICAgICAgICAgICAgLyogdHNsaW50OmVuYWJsZTpiYW4tbmF0aXZlLWZ1bmN0aW9ucyAqL1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGFyZ2V0LmF0dGFjaEV2ZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0LmF0dGFjaEV2ZW50KCdvbicgKyBldmVudE5hbWUsIHByb2Nlc3NFbGVtZW50RXZlbnQpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueVxyXG4gICAgICAgICAgICAgICAgdmFyIHByb2Nlc3NPYmplY3RFdmVudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xyXG4gICAgICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKF90aGlzLl9pc0Rpc3Bvc2VkKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNhbGxiYWNrLmFwcGx5KHBhcmVudF8xLCBhcmdzKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBldmVudFJlY29yZC5vYmplY3RDYWxsYmFjayA9IHByb2Nlc3NPYmplY3RFdmVudDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBSZW1lbWJlciB0aGUgcmVjb3JkIGxvY2FsbHksIHNvIHRoYXQgaXQgY2FuIGJlIHJlbW92ZWQuXHJcbiAgICAgICAgICAgIHRoaXMuX2V2ZW50UmVjb3Jkcy5wdXNoKGV2ZW50UmVjb3JkKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueVxyXG4gICAgRXZlbnRHcm91cC5wcm90b3R5cGUub2ZmID0gZnVuY3Rpb24gKHRhcmdldCwgZXZlbnROYW1lLCBjYWxsYmFjaywgdXNlQ2FwdHVyZSkge1xyXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5fZXZlbnRSZWNvcmRzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBldmVudFJlY29yZCA9IHRoaXMuX2V2ZW50UmVjb3Jkc1tpXTtcclxuICAgICAgICAgICAgaWYgKCghdGFyZ2V0IHx8IHRhcmdldCA9PT0gZXZlbnRSZWNvcmQudGFyZ2V0KSAmJlxyXG4gICAgICAgICAgICAgICAgKCFldmVudE5hbWUgfHwgZXZlbnROYW1lID09PSBldmVudFJlY29yZC5ldmVudE5hbWUpICYmXHJcbiAgICAgICAgICAgICAgICAoIWNhbGxiYWNrIHx8IGNhbGxiYWNrID09PSBldmVudFJlY29yZC5jYWxsYmFjaykgJiZcclxuICAgICAgICAgICAgICAgICgodHlwZW9mIHVzZUNhcHR1cmUgIT09ICdib29sZWFuJykgfHwgdXNlQ2FwdHVyZSA9PT0gZXZlbnRSZWNvcmQudXNlQ2FwdHVyZSkpIHtcclxuICAgICAgICAgICAgICAgIHZhciBldmVudHMgPSBldmVudFJlY29yZC50YXJnZXQuX19ldmVudHNfXztcclxuICAgICAgICAgICAgICAgIHZhciB0YXJnZXRBcnJheUxvb2t1cCA9IGV2ZW50c1tldmVudFJlY29yZC5ldmVudE5hbWVdO1xyXG4gICAgICAgICAgICAgICAgdmFyIHRhcmdldEFycmF5ID0gdGFyZ2V0QXJyYXlMb29rdXAgPyB0YXJnZXRBcnJheUxvb2t1cFt0aGlzLl9pZF0gOiBudWxsO1xyXG4gICAgICAgICAgICAgICAgLy8gV2UgbWF5IGhhdmUgYWxyZWFkeSB0YXJnZXQncyBlbnRyaWVzLCBzbyBjaGVjayBmb3IgbnVsbC5cclxuICAgICAgICAgICAgICAgIGlmICh0YXJnZXRBcnJheSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0YXJnZXRBcnJheS5sZW5ndGggPT09IDEgfHwgIWNhbGxiYWNrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldEFycmF5TG9va3VwLmNvdW50IC09IHRhcmdldEFycmF5Lmxlbmd0aDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGV2ZW50c1tldmVudFJlY29yZC5ldmVudE5hbWVdW3RoaXMuX2lkXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldEFycmF5TG9va3VwLmNvdW50LS07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhcmdldEFycmF5LnNwbGljZSh0YXJnZXRBcnJheS5pbmRleE9mKGV2ZW50UmVjb3JkKSwgMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICghdGFyZ2V0QXJyYXlMb29rdXAuY291bnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIGV2ZW50c1tldmVudFJlY29yZC5ldmVudE5hbWVdO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChldmVudFJlY29yZC5lbGVtZW50Q2FsbGJhY2spIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZXZlbnRSZWNvcmQudGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRSZWNvcmQudGFyZ2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoZXZlbnRSZWNvcmQuZXZlbnROYW1lLCBldmVudFJlY29yZC5lbGVtZW50Q2FsbGJhY2ssIGV2ZW50UmVjb3JkLnVzZUNhcHR1cmUpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChldmVudFJlY29yZC50YXJnZXQuZGV0YWNoRXZlbnQpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgZXZlbnRSZWNvcmQudGFyZ2V0LmRldGFjaEV2ZW50KCdvbicgKyBldmVudFJlY29yZC5ldmVudE5hbWUsIGV2ZW50UmVjb3JkLmVsZW1lbnRDYWxsYmFjayk7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgdGhpcy5fZXZlbnRSZWNvcmRzLnNwbGljZShpLS0sIDEpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8qKiBUcmlnZ2VyIHRoZSBnaXZlbiBldmVudCBpbiB0aGUgY29udGV4dCBvZiB0aGlzIGluc3RhbmNlIG9mIEV2ZW50R3JvdXAuICovXHJcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYW55XHJcbiAgICBFdmVudEdyb3VwLnByb3RvdHlwZS5yYWlzZSA9IGZ1bmN0aW9uIChldmVudE5hbWUsIGV2ZW50QXJncywgYnViYmxlRXZlbnQpIHtcclxuICAgICAgICByZXR1cm4gRXZlbnRHcm91cC5yYWlzZSh0aGlzLl9wYXJlbnQsIGV2ZW50TmFtZSwgZXZlbnRBcmdzLCBidWJibGVFdmVudCk7XHJcbiAgICB9O1xyXG4gICAgLyoqIERlY2xhcmUgYW4gZXZlbnQgYXMgYmVpbmcgc3VwcG9ydGVkIGJ5IHRoaXMgaW5zdGFuY2Ugb2YgRXZlbnRHcm91cC4gKi9cclxuICAgIEV2ZW50R3JvdXAucHJvdG90eXBlLmRlY2xhcmUgPSBmdW5jdGlvbiAoZXZlbnQpIHtcclxuICAgICAgICB2YXIgZGVjbGFyZWRFdmVudHMgPSB0aGlzLl9wYXJlbnQuX19kZWNsYXJlZEV2ZW50cyA9IHRoaXMuX3BhcmVudC5fX2RlY2xhcmVkRXZlbnRzIHx8IHt9O1xyXG4gICAgICAgIGlmICh0eXBlb2YgZXZlbnQgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIGRlY2xhcmVkRXZlbnRzW2V2ZW50XSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGV2ZW50Lmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgICAgICBkZWNsYXJlZEV2ZW50c1tldmVudFtpXV0gPSB0cnVlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1pbmZlcnJhYmxlLXR5cGVzXHJcbiAgICBFdmVudEdyb3VwLl91bmlxdWVJZCA9IDA7XHJcbiAgICByZXR1cm4gRXZlbnRHcm91cDtcclxufSgpKTtcclxuZXhwb3J0cy5FdmVudEdyb3VwID0gRXZlbnRHcm91cDtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9RXZlbnRHcm91cC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgbm93ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gKHR5cGVvZiBwZXJmb3JtYW5jZSAhPT0gJ3VuZGVmaW5lZCcgJiYgISFwZXJmb3JtYW5jZS5ub3cpID8gcGVyZm9ybWFuY2Uubm93KCkgOiBEYXRlLm5vdygpOyB9O1xyXG52YXIgUkVTRVRfSU5URVJWQUwgPSAzICogNjAgKiAxMDAwOyAvLyBhdXRvIHJlc2V0IGV2ZXJ5IDMgbWludXRlc1xyXG4vKipcclxuICogUGVyZm9ybWFuY2UgaGVscGVyIGNsYXNzIGZvciBtZWFzdXJpbmcgdGhpbmdzLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG52YXIgRmFicmljUGVyZm9ybWFuY2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XHJcbiAgICBmdW5jdGlvbiBGYWJyaWNQZXJmb3JtYW5jZSgpIHtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogTWVhc3VyZXMgZXhlY3V0aW9uIHRpbWUgb2YgdGhlIGdpdmVuIHN5bmNyb25vdXMgZnVuY3Rpb24uIElmIHRoZSBzYW1lIGxvZ2ljIGlzIGV4ZWN1dGVkIG11bHRpcGxlIHRpbWVzLFxyXG4gICAgICogZWFjaCBpbmRpdmlkdWFsIG1lYXN1cmVtZW50IHdpbGwgYmUgY29sbGVjdGVkIGFzIHdlbGwgdGhlIG92ZXJhbGwgbnVtYmVycy5cclxuICAgICAqIEBwYXJhbSBuYW1lIC0gVGhlIG5hbWUgb2YgdGhpcyBtZWFzdXJlbWVudFxyXG4gICAgICogQHBhcmFtIGZ1bmMgLSBUaGUgbG9naWMgdG8gYmUgbWVhc3VyZWQgZm9yIGV4ZWN1dGlvbiB0aW1lXHJcbiAgICAgKi9cclxuICAgIEZhYnJpY1BlcmZvcm1hbmNlLm1lYXN1cmUgPSBmdW5jdGlvbiAobmFtZSwgZnVuYykge1xyXG4gICAgICAgIGlmIChOdW1iZXIuaXNJbnRlZ2VyKEZhYnJpY1BlcmZvcm1hbmNlLl90aW1lb3V0SWQpKSB7XHJcbiAgICAgICAgICAgIEZhYnJpY1BlcmZvcm1hbmNlLnNldFBlcmlvZGljUmVzZXQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHN0YXJ0ID0gbm93KCk7XHJcbiAgICAgICAgZnVuYygpO1xyXG4gICAgICAgIHZhciBlbmQgPSBub3coKTtcclxuICAgICAgICB2YXIgbWVhc3VyZW1lbnQgPSBGYWJyaWNQZXJmb3JtYW5jZS5zdW1tYXJ5W25hbWVdIHx8IHtcclxuICAgICAgICAgICAgdG90YWxEdXJhdGlvbjogMCxcclxuICAgICAgICAgICAgY291bnQ6IDAsXHJcbiAgICAgICAgICAgIGFsbDogW11cclxuICAgICAgICB9O1xyXG4gICAgICAgIHZhciBkdXJhdGlvbiA9IGVuZCAtIHN0YXJ0O1xyXG4gICAgICAgIG1lYXN1cmVtZW50LnRvdGFsRHVyYXRpb24gKz0gZHVyYXRpb247XHJcbiAgICAgICAgbWVhc3VyZW1lbnQuY291bnQrKztcclxuICAgICAgICBtZWFzdXJlbWVudC5hbGwucHVzaCh7XHJcbiAgICAgICAgICAgIGR1cmF0aW9uOiBkdXJhdGlvbixcclxuICAgICAgICAgICAgdGltZVN0YW1wOiBlbmRcclxuICAgICAgICB9KTtcclxuICAgICAgICBGYWJyaWNQZXJmb3JtYW5jZS5zdW1tYXJ5W25hbWVdID0gbWVhc3VyZW1lbnQ7XHJcbiAgICB9O1xyXG4gICAgRmFicmljUGVyZm9ybWFuY2UucmVzZXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgRmFicmljUGVyZm9ybWFuY2Uuc3VtbWFyeSA9IHt9O1xyXG4gICAgICAgIGNsZWFyVGltZW91dChGYWJyaWNQZXJmb3JtYW5jZS5fdGltZW91dElkKTtcclxuICAgICAgICBGYWJyaWNQZXJmb3JtYW5jZS5fdGltZW91dElkID0gTmFOO1xyXG4gICAgfTtcclxuICAgIEZhYnJpY1BlcmZvcm1hbmNlLnNldFBlcmlvZGljUmVzZXQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgRmFicmljUGVyZm9ybWFuY2UuX3RpbWVvdXRJZCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gRmFicmljUGVyZm9ybWFuY2UucmVzZXQoKTsgfSwgUkVTRVRfSU5URVJWQUwpO1xyXG4gICAgfTtcclxuICAgIEZhYnJpY1BlcmZvcm1hbmNlLnN1bW1hcnkgPSB7fTtcclxuICAgIHJldHVybiBGYWJyaWNQZXJmb3JtYW5jZTtcclxufSgpKTtcclxuZXhwb3J0cy5GYWJyaWNQZXJmb3JtYW5jZSA9IEZhYnJpY1BlcmZvcm1hbmNlO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1GYWJyaWNQZXJmb3JtYW5jZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuLyoqXHJcbiAqIFN0b3JpbmcgZ2xvYmFsIHN0YXRlIGluIGxvY2FsIG1vZHVsZSB2YXJpYWJsZXMgaGFzIGlzc3VlcyB3aGVuIG1vcmUgdGhhbiBvbmUgY29weVxyXG4gKiBpZiB0aGUgbW9kdWxlIGdldHMgbG9hZGVkIG9uIHRoZSBwYWdlIChkdWUgdG8gYSBidW5kbGluZyBlcnJvciBvciBzaW1wbHkgYnkgY29uc3VtaW5nXHJcbiAqIGEgcHJlYnVuZGxlZCBzY3JpcHQuKVxyXG4gKlxyXG4gKiBUaGlzIGZpbGUgY29udGFpbnMgaGVscGVycyB0byBkZWFsIHdpdGggdGhlIGdldHRpbmcgYW5kIHNldHRpbmcgbG9jYWwgc3RhdGUsIGFuZCBhbGxvd3NcclxuICogY2FsbGVycyB0byBnZXQgY2FsbGVkIGJhY2sgd2hlbiBpdCBtdXRhdGVzLlxyXG4gKi9cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgR0xPQkFMX1NFVFRJTkdTX1BST1BfTkFNRSA9ICdfX2dsb2JhbFNldHRpbmdzX18nO1xyXG52YXIgQ0FMTEJBQ0tfU1RBVEVfUFJPUF9OQU1FID0gJ19fY2FsbGJhY2tzX18nO1xyXG4vLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYW55XHJcbnZhciBfZ2xvYmFsU2V0dGluZ3MgPSB7fTtcclxudmFyIF9jb3VudGVyID0gMDtcclxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XHJcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYW55XHJcbiAgICB2YXIgd2luID0gd2luZG93O1xyXG4gICAgX2dsb2JhbFNldHRpbmdzID0gd2luW0dMT0JBTF9TRVRUSU5HU19QUk9QX05BTUVdID0gd2luW0dMT0JBTF9TRVRUSU5HU19QUk9QX05BTUVdIHx8IChfYSA9IHt9LFxyXG4gICAgICAgIF9hW0NBTExCQUNLX1NUQVRFX1BST1BfTkFNRV0gPSB7fSxcclxuICAgICAgICBfYSk7XHJcbn1cclxudmFyIF9jYWxsYmFja3MgPSBfZ2xvYmFsU2V0dGluZ3NbQ0FMTEJBQ0tfU1RBVEVfUFJPUF9OQU1FXTtcclxuLyoqXHJcbiAqIEdsb2JhbCBzZXR0aW5ncyBoZWxwZXIsIHdoaWNoIHN0b3JlcyBzZXR0aW5ncyBpbiB0aGUgZ2xvYmFsICh3aW5kb3cpIG5hbWVzcGFjZS5cclxuICogSWYgd2luZG93IGlzIG5vdCBwcm92aWRlZCwgaXQgd2lsbCBzdG9yZSBzZXR0aW5ncyBpbiBtb2R1bGUgc2NvcGUuIFByb3ZpZGVzIGFcclxuICogd2F5IHRvIG9ic2VydmUgY2hhbmdlcyBhcyB3ZWxsIHdoZW4gdGhlaXIgdmFsdWVzIGNoYW5nZS5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxudmFyIEdsb2JhbFNldHRpbmdzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gR2xvYmFsU2V0dGluZ3MoKSB7XHJcbiAgICB9XHJcbiAgICBHbG9iYWxTZXR0aW5ncy5nZXRWYWx1ZSA9IGZ1bmN0aW9uIChrZXksIGRlZmF1bHRWYWx1ZSkge1xyXG4gICAgICAgIGlmIChfZ2xvYmFsU2V0dGluZ3Nba2V5XSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIF9nbG9iYWxTZXR0aW5nc1trZXldID0gdHlwZW9mIGRlZmF1bHRWYWx1ZSA9PT0gJ2Z1bmN0aW9uJyA/IGRlZmF1bHRWYWx1ZSgpIDogZGVmYXVsdFZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gX2dsb2JhbFNldHRpbmdzW2tleV07XHJcbiAgICB9O1xyXG4gICAgR2xvYmFsU2V0dGluZ3Muc2V0VmFsdWUgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xyXG4gICAgICAgIHZhciBvbGRWYWx1ZSA9IF9nbG9iYWxTZXR0aW5nc1trZXldO1xyXG4gICAgICAgIGlmICh2YWx1ZSAhPT0gb2xkVmFsdWUpIHtcclxuICAgICAgICAgICAgX2dsb2JhbFNldHRpbmdzW2tleV0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgdmFyIGNoYW5nZURlc2NyaXB0aW9uID0ge1xyXG4gICAgICAgICAgICAgICAgb2xkVmFsdWU6IG9sZFZhbHVlLFxyXG4gICAgICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxyXG4gICAgICAgICAgICAgICAga2V5OiBrZXlcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgZm9yICh2YXIgaWQgaW4gX2NhbGxiYWNrcykge1xyXG4gICAgICAgICAgICAgICAgaWYgKF9jYWxsYmFja3MuaGFzT3duUHJvcGVydHkoaWQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX2NhbGxiYWNrc1tpZF0oY2hhbmdlRGVzY3JpcHRpb24pO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB2YWx1ZTtcclxuICAgIH07XHJcbiAgICBHbG9iYWxTZXR0aW5ncy5hZGRDaGFuZ2VMaXN0ZW5lciA9IGZ1bmN0aW9uIChjYikge1xyXG4gICAgICAgIC8vIE5vdGU6IHdlIHVzZSBnZW5lcmF0ZWQgaWRzIG9uIHRoZSBjYWxsYmFja3MgdG8gY3JlYXRlIGEgbWFwIG9mIHRoZSBjYWxsYmFja3MsIHdoaWNoIG9wdGltaXplcyByZW1vdmFsLlxyXG4gICAgICAgIC8vIChJdCdzIGZhc3RlciB0byBkZWxldGUgYSBrZXkgdGhhbiBpdCBpcyB0byBsb29rIHVwIHRoZSBpbmRleCBvZiBhbiBvYmplY3QgYW5kIHNwbGljZSBhbiBhcnJheS4pXHJcbiAgICAgICAgdmFyIGlkID0gY2IuX19pZF9fO1xyXG4gICAgICAgIGlmICghaWQpIHtcclxuICAgICAgICAgICAgaWQgPSBjYi5fX2lkX18gPSBTdHJpbmcoX2NvdW50ZXIrKyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIF9jYWxsYmFja3NbaWRdID0gY2I7XHJcbiAgICB9O1xyXG4gICAgR2xvYmFsU2V0dGluZ3MucmVtb3ZlQ2hhbmdlTGlzdGVuZXIgPSBmdW5jdGlvbiAoY2IpIHtcclxuICAgICAgICBkZWxldGUgX2NhbGxiYWNrc1tjYi5fX2lkX19dO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBHbG9iYWxTZXR0aW5ncztcclxufSgpKTtcclxuZXhwb3J0cy5HbG9iYWxTZXR0aW5ncyA9IEdsb2JhbFNldHRpbmdzO1xyXG52YXIgX2E7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUdsb2JhbFNldHRpbmdzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbi8qKlxyXG4gKiBDb25zdCBlbnVtIGZvciBrZXljb2Rlcy5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxudmFyIEtleUNvZGVzO1xyXG4oZnVuY3Rpb24gKEtleUNvZGVzKSB7XHJcbiAgICBLZXlDb2Rlc1tLZXlDb2Rlc1tcImFcIl0gPSA2NV0gPSBcImFcIjtcclxuICAgIEtleUNvZGVzW0tleUNvZGVzW1wiY1wiXSA9IDY3XSA9IFwiY1wiO1xyXG4gICAgS2V5Q29kZXNbS2V5Q29kZXNbXCJiYWNrc3BhY2VcIl0gPSA4XSA9IFwiYmFja3NwYWNlXCI7XHJcbiAgICBLZXlDb2Rlc1tLZXlDb2Rlc1tcImNvbW1hXCJdID0gMTg4XSA9IFwiY29tbWFcIjtcclxuICAgIEtleUNvZGVzW0tleUNvZGVzW1wiZGVsXCJdID0gNDZdID0gXCJkZWxcIjtcclxuICAgIEtleUNvZGVzW0tleUNvZGVzW1wiZG93blwiXSA9IDQwXSA9IFwiZG93blwiO1xyXG4gICAgS2V5Q29kZXNbS2V5Q29kZXNbXCJlbmRcIl0gPSAzNV0gPSBcImVuZFwiO1xyXG4gICAgS2V5Q29kZXNbS2V5Q29kZXNbXCJlbnRlclwiXSA9IDEzXSA9IFwiZW50ZXJcIjtcclxuICAgIEtleUNvZGVzW0tleUNvZGVzW1wiZXNjYXBlXCJdID0gMjddID0gXCJlc2NhcGVcIjtcclxuICAgIEtleUNvZGVzW0tleUNvZGVzW1wiaG9tZVwiXSA9IDM2XSA9IFwiaG9tZVwiO1xyXG4gICAgS2V5Q29kZXNbS2V5Q29kZXNbXCJsZWZ0XCJdID0gMzddID0gXCJsZWZ0XCI7XHJcbiAgICBLZXlDb2Rlc1tLZXlDb2Rlc1tcInBhZ2VEb3duXCJdID0gMzRdID0gXCJwYWdlRG93blwiO1xyXG4gICAgS2V5Q29kZXNbS2V5Q29kZXNbXCJwYWdlVXBcIl0gPSAzM10gPSBcInBhZ2VVcFwiO1xyXG4gICAgS2V5Q29kZXNbS2V5Q29kZXNbXCJyaWdodFwiXSA9IDM5XSA9IFwicmlnaHRcIjtcclxuICAgIEtleUNvZGVzW0tleUNvZGVzW1wic2VtaWNvbG9uXCJdID0gMTg2XSA9IFwic2VtaWNvbG9uXCI7XHJcbiAgICBLZXlDb2Rlc1tLZXlDb2Rlc1tcInNwYWNlXCJdID0gMzJdID0gXCJzcGFjZVwiO1xyXG4gICAgS2V5Q29kZXNbS2V5Q29kZXNbXCJ0YWJcIl0gPSA5XSA9IFwidGFiXCI7XHJcbiAgICBLZXlDb2Rlc1tLZXlDb2Rlc1tcInVwXCJdID0gMzhdID0gXCJ1cFwiO1xyXG59KShLZXlDb2RlcyA9IGV4cG9ydHMuS2V5Q29kZXMgfHwgKGV4cG9ydHMuS2V5Q29kZXMgPSB7fSkpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1LZXlDb2Rlcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4vKipcclxuICogUmVjdGFuZ2xlIGhlbHBlciBjbGFzcy5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxudmFyIFJlY3RhbmdsZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFJlY3RhbmdsZShsZWZ0LCByaWdodCwgdG9wLCBib3R0b20pIHtcclxuICAgICAgICBpZiAobGVmdCA9PT0gdm9pZCAwKSB7IGxlZnQgPSAwOyB9XHJcbiAgICAgICAgaWYgKHJpZ2h0ID09PSB2b2lkIDApIHsgcmlnaHQgPSAwOyB9XHJcbiAgICAgICAgaWYgKHRvcCA9PT0gdm9pZCAwKSB7IHRvcCA9IDA7IH1cclxuICAgICAgICBpZiAoYm90dG9tID09PSB2b2lkIDApIHsgYm90dG9tID0gMDsgfVxyXG4gICAgICAgIHRoaXMudG9wID0gdG9wO1xyXG4gICAgICAgIHRoaXMuYm90dG9tID0gYm90dG9tO1xyXG4gICAgICAgIHRoaXMubGVmdCA9IGxlZnQ7XHJcbiAgICAgICAgdGhpcy5yaWdodCA9IHJpZ2h0O1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlY3RhbmdsZS5wcm90b3R5cGUsIFwid2lkdGhcIiwge1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIENhbGN1bGF0ZWQgYXV0b21hdGljYWxseSBieSBzdWJ0cmFjdGluZyB0aGUgcmlnaHQgZnJvbSBsZWZ0XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgZ2V0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnJpZ2h0IC0gdGhpcy5sZWZ0O1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KFJlY3RhbmdsZS5wcm90b3R5cGUsIFwiaGVpZ2h0XCIsIHtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBDYWxjdWxhdGVkIGF1dG9tYXRpY2FsbHkgYnkgc3VidHJhY3RpbmcgdGhlIGJvdHRvbSBmcm9tIHRvcC5cclxuICAgICAgICAgKi9cclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYm90dG9tIC0gdGhpcy50b3A7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICAvKipcclxuICAgICAqIFRlc3RzIGlmIGFub3RoZXIgcmVjdCBpcyBhcHByb3hpbWF0ZWx5IGVxdWFsIHRvIHRoaXMgcmVjdCAod2l0aGluIDQgZGVjaW1hbCBwbGFjZXMuKVxyXG4gICAgICovXHJcbiAgICBSZWN0YW5nbGUucHJvdG90eXBlLmVxdWFscyA9IGZ1bmN0aW9uIChyZWN0KSB7XHJcbiAgICAgICAgLy8gSSdtIGZpeGluZyBpdCB0byA0IGRlY2ltYWwgcGxhY2VzIGJlY2F1c2UgaXQgYWxsb3dzIGVub3VnaCBwcmVjaXNpb24gYW5kIHdpbGwgaGFuZGxlIGNhc2VzIHdoZW4gc29tZXRoaW5nIHNob3VsZCBiZSByb3VuZGVkLFxyXG4gICAgICAgIC8vIGxpa2UgLjk5OTk5OSBzaG91bGQgcm91bmQgdG8gMS5cclxuICAgICAgICByZXR1cm4gKHBhcnNlRmxvYXQodGhpcy50b3AudG9GaXhlZCg0KSkgPT09IHBhcnNlRmxvYXQocmVjdC50b3AudG9GaXhlZCg0KSkgJiZcclxuICAgICAgICAgICAgcGFyc2VGbG9hdCh0aGlzLmJvdHRvbS50b0ZpeGVkKDQpKSA9PT0gcGFyc2VGbG9hdChyZWN0LmJvdHRvbS50b0ZpeGVkKDQpKSAmJlxyXG4gICAgICAgICAgICBwYXJzZUZsb2F0KHRoaXMubGVmdC50b0ZpeGVkKDQpKSA9PT0gcGFyc2VGbG9hdChyZWN0LmxlZnQudG9GaXhlZCg0KSkgJiZcclxuICAgICAgICAgICAgcGFyc2VGbG9hdCh0aGlzLnJpZ2h0LnRvRml4ZWQoNCkpID09PSBwYXJzZUZsb2F0KHJlY3QucmlnaHQudG9GaXhlZCg0KSkpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBSZWN0YW5nbGU7XHJcbn0oKSk7XHJcbmV4cG9ydHMuUmVjdGFuZ2xlID0gUmVjdGFuZ2xlO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1SZWN0YW5nbGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuLyoqXHJcbiAqIEhlbHBlciB0byBmaW5kIHRoZSBpbmRleCBvZiBhbiBpdGVtIHdpdGhpbiBhbiBhcnJheSwgdXNpbmcgYSBjYWxsYmFjayB0b1xyXG4gKiBkZXRlcm1pbmUgdGhlIG1hdGNoLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqIEBwYXJhbSBhcnJheSAtIEFycmF5IHRvIHNlYXJjaC5cclxuICogQHBhcmFtIGNiIC0gQ2FsbGJhY2sgd2hpY2ggcmV0dXJucyB0cnVlIG9uIG1hdGNoZXMuXHJcbiAqL1xyXG5mdW5jdGlvbiBmaW5kSW5kZXgoYXJyYXksIGNiKSB7XHJcbiAgICB2YXIgaW5kZXggPSAtMTtcclxuICAgIGZvciAodmFyIGkgPSAwOyBhcnJheSAmJiBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICBpZiAoY2IoYXJyYXlbaV0sIGkpKSB7XHJcbiAgICAgICAgICAgIGluZGV4ID0gaTtcclxuICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGluZGV4O1xyXG59XHJcbmV4cG9ydHMuZmluZEluZGV4ID0gZmluZEluZGV4O1xyXG4vKipcclxuICogSGVscGVyIHRvIGZpbmQgdGhlIGZpcnN0IGl0ZW0gd2l0aGluIGFuIGFycmF5IHRoYXQgc2F0aXNmaWVzIHRoZSBjYWxsYmFjay5cclxuICogQHBhcmFtIGFycmF5IC0gQXJyYXkgdG8gc2VhcmNoXHJcbiAqIEBwYXJhbSBjYiAtIENhbGxiYWNrIHdoaWNoIHJldHVybnMgdHJ1ZSBvbiBtYXRjaGVzXHJcbiAqL1xyXG5mdW5jdGlvbiBmaW5kKGFycmF5LCBjYikge1xyXG4gICAgdmFyIGluZGV4ID0gZmluZEluZGV4KGFycmF5LCBjYik7XHJcbiAgICBpZiAoaW5kZXggPCAwKSB7XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIHJldHVybiBhcnJheVtpbmRleF07XHJcbn1cclxuZXhwb3J0cy5maW5kID0gZmluZDtcclxuLyoqXHJcbiAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgYSBnaXZlbiBzaXplIGFuZCBoZWxwZXIgbWV0aG9kIHRvIHBvcHVsYXRlLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqIEBwYXJhbSBzaXplIC0gU2l6ZSBvZiBhcnJheS5cclxuICogQHBhcmFtIGdldEl0ZW0gLSBDYWxsYmFjayB0byBwb3B1bGF0ZSBnaXZlbiBjZWxsIGluZGV4LlxyXG4gKi9cclxuZnVuY3Rpb24gY3JlYXRlQXJyYXkoc2l6ZSwgZ2V0SXRlbSkge1xyXG4gICAgdmFyIGFycmF5ID0gW107XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKykge1xyXG4gICAgICAgIGFycmF5LnB1c2goZ2V0SXRlbShpKSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gYXJyYXk7XHJcbn1cclxuZXhwb3J0cy5jcmVhdGVBcnJheSA9IGNyZWF0ZUFycmF5O1xyXG4vKipcclxuICogQ29udmVydCB0aGUgZ2l2ZW4gYXJyYXkgdG8gYSBtYXRyaXggd2l0aCBjb2x1bW5Db3VudCBudW1iZXJcclxuICogb2YgY29sdW1ucy5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKiBAcGFyYW0gaXRlbXMgLSBUaGUgYXJyYXkgdG8gY29udmVydFxyXG4gKiBAcGFyYW0gY29sdW1uQ291bnQgLSBUaGUgbnVtYmVyIG9mIGNvbHVtbnMgZm9yIHRoZSByZXN1bHRpbmcgbWF0cml4XHJcbiAqIEByZXR1cm5zIHthbnlbXVtdfSAtIEEgbWF0cml4IG9mIGl0ZW1zXHJcbiAqL1xyXG5mdW5jdGlvbiB0b01hdHJpeChpdGVtcywgY29sdW1uQ291bnQpIHtcclxuICAgIHJldHVybiBpdGVtcy5yZWR1Y2UoZnVuY3Rpb24gKHJvd3MsIGN1cnJlbnRWYWx1ZSwgaW5kZXgpIHtcclxuICAgICAgICBpZiAoaW5kZXggJSBjb2x1bW5Db3VudCA9PT0gMCkge1xyXG4gICAgICAgICAgICByb3dzLnB1c2goW2N1cnJlbnRWYWx1ZV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcm93c1tyb3dzLmxlbmd0aCAtIDFdLnB1c2goY3VycmVudFZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHJvd3M7XHJcbiAgICB9LCBbXSk7XHJcbn1cclxuZXhwb3J0cy50b01hdHJpeCA9IHRvTWF0cml4O1xyXG4vKipcclxuICogR2l2ZW4gYW4gYXJyYXksIGl0IHJldHVybnMgYSBuZXcgYXJyYXkgdGhhdCBkb2VzIG5vdCBjb250YWluIHRoZSBpdGVtIGF0IHRoZSBnaXZlbiBpbmRleC5cclxuICogQHBhcmFtIGFycmF5IC0gVGhlIGFycmF5IHRvIG9wZXJhdGUgb25cclxuICogQHBhcmFtIGluZGV4IC0gVGhlIGluZGV4IG9mIHRoZSBlbGVtZW50IHRvIHJlbW92ZVxyXG4gKi9cclxuZnVuY3Rpb24gcmVtb3ZlSW5kZXgoYXJyYXksIGluZGV4KSB7XHJcbiAgICByZXR1cm4gYXJyYXkuZmlsdGVyKGZ1bmN0aW9uIChfLCBpKSB7IHJldHVybiBpbmRleCAhPT0gaTsgfSk7XHJcbn1cclxuZXhwb3J0cy5yZW1vdmVJbmRleCA9IHJlbW92ZUluZGV4O1xyXG4vKipcclxuICogR2l2ZW4gYW4gYXJyYXksIHRoaXMgZnVuY3Rpb24gcmV0dXJucyBhIG5ldyBhcnJheSB3aGVyZSB0aGUgZWxlbWVudCBhdCBhIGdpdmVuIGluZGV4IGhhcyBiZWVuIHJlcGxhY2VkLlxyXG4gKiBAcGFyYW0gYXJyYXkgLSBUaGUgYXJyYXkgdG8gb3BlcmF0ZSBvblxyXG4gKiBAcGFyYW0gbmV3RWxlbWVudCAtIFRoZSBlbGVtZW50IHRoYXQgd2lsbCBiZSBwbGFjZWQgaW4gdGhlIG5ldyBhcnJheVxyXG4gKiBAcGFyYW0gaW5kZXggLSBUaGUgaW5kZXggb2YgdGhlIGVsZW1lbnQgdGhhdCBzaG91bGQgYmUgcmVwbGFjZWRcclxuICovXHJcbmZ1bmN0aW9uIHJlcGxhY2VFbGVtZW50KGFycmF5LCBuZXdFbGVtZW50LCBpbmRleCkge1xyXG4gICAgdmFyIGNvcHkgPSBhcnJheS5zbGljZSgpO1xyXG4gICAgY29weVtpbmRleF0gPSBuZXdFbGVtZW50O1xyXG4gICAgcmV0dXJuIGNvcHk7XHJcbn1cclxuZXhwb3J0cy5yZXBsYWNlRWxlbWVudCA9IHJlcGxhY2VFbGVtZW50O1xyXG4vKipcclxuICogR2l2ZW4gYW4gYXJyYXksIHRoaXMgZnVuY3Rpb24gcmV0dXJucyBhIG5ldyBhcnJheSB3aGVyZSBhbiBlbGVtZW50IGhhcyBiZWVuIGluc2VydGVkIGF0IHRoZSBnaXZlbiBpbmRleC5cclxuICogQHBhcmFtIGFycmF5IC0gVGhlIGFycmF5IHRvIG9wZXJhdGUgb25cclxuICogQHBhcmFtIGluZGV4IC0gVGhlIGluZGV4IHdoZXJlIGFuIGVsZW1lbnQgc2hvdWxkIGJlIGluc2VydGVkXHJcbiAqIEBwYXJhbSBpdGVtVG9BZGQgLSBUaGUgZWxlbWVudCB0byBpbnNlcnRcclxuICovXHJcbmZ1bmN0aW9uIGFkZEVsZW1lbnRBdEluZGV4KGFycmF5LCBpbmRleCwgaXRlbVRvQWRkKSB7XHJcbiAgICB2YXIgY29weSA9IGFycmF5LnNsaWNlKCk7XHJcbiAgICBjb3B5LnNwbGljZShpbmRleCwgMCwgaXRlbVRvQWRkKTtcclxuICAgIHJldHVybiBjb3B5O1xyXG59XHJcbmV4cG9ydHMuYWRkRWxlbWVudEF0SW5kZXggPSBhZGRFbGVtZW50QXRJbmRleDtcclxuLyoqXHJcbiAqIEdpdmVuIGFuIGFycmF5IHdoZXJlIGVhY2ggZWxlbWVudCBpcyBvZiB0eXBlIFQgb3IgVFtdLCBmbGF0dGVuIGl0IGludG8gYW4gYXJyYXkgb2YgVFxyXG4gKiBAcGFyYW0gYXJyYXkgLSBUaGUgYXJyYXkgd2hlcmUgZWFjaCBlbGVtZW50IGNhbiBvcHRpb25hbGx5IGFsc28gYmUgYW4gYXJyYXlcclxuICovXHJcbmZ1bmN0aW9uIGZsYXR0ZW4oYXJyYXkpIHtcclxuICAgIHZhciByZXN1bHQgPSBbXTtcclxuICAgIGFycmF5LmZvckVhY2goZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuIChyZXN1bHQgPSByZXN1bHQuY29uY2F0KGl0ZW0pKTsgfSk7XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbmV4cG9ydHMuZmxhdHRlbiA9IGZsYXR0ZW47XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWFycmF5LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbi8qKlxyXG4gKiBBc3NlcnROZXZlciBpcyBhIHV0aWxpdHkgZnVuY3Rpb24gdGhhdCBjYW4gYmUgdXNlZCBmb3IgZXhoYXVzdGl2ZW5lc3MgY2hlY2tzIGluIHN3aXRjaCBzdGF0ZW1lbnRzLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5mdW5jdGlvbiBhc3NlcnROZXZlcih4KSB7XHJcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuZXhwZWN0ZWQgb2JqZWN0OiAnICsgeCk7XHJcbn1cclxuZXhwb3J0cy5hc3NlcnROZXZlciA9IGFzc2VydE5ldmVyO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hc3NlcnROZXZlci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4vKipcclxuICogQXV0b2JpbmQgaXMgYSB1dGlsaXR5IGZvciBiaW5kaW5nIG1ldGhvZHMgaW4gYSBjbGFzcy4gVGhpcyBzaW1wbGlmaWVzIHRhZ2dpbmcgbWV0aG9kcyBhcyBiZWluZyBcImJvdW5kXCIgdG8gdGhlIHRoaXMgcG9pbnRlclxyXG4gKiBzbyB0aGF0IHRoZXkgY2FuIGJlIHVzZWQgaW4gc2NlbmFyaW9zIHRoYXQgc2ltcGx5IHJlcXVpcmUgYSBmdW5jdGlvbiBjYWxsYmFjay5cclxuICovXHJcbi8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1hbnlcclxuZnVuY3Rpb24gYXV0b2JpbmQodGFyZ2V0LCBrZXksIGRlc2NyaXB0b3IpIHtcclxuICAgIHZhciBmbiA9IGRlc2NyaXB0b3IudmFsdWU7XHJcbiAgICB2YXIgZGVmaW5pbmcgPSBmYWxzZTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoZGVmaW5pbmcgfHwgKGZuICYmIHRoaXMgPT09IGZuLnByb3RvdHlwZSkgfHwgdGhpcy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZm47XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gQmluZCBtZXRob2Qgb25seSBvbmNlLCBhbmQgdXBkYXRlIHRoZSBwcm9wZXJ0eSB0byByZXR1cm4gdGhlIGJvdW5kIHZhbHVlIGZyb20gbm93IG9uXHJcbiAgICAgICAgICAgIHZhciBmbkJvdW5kID0gZm4gJiYgZm4uYmluZCh0aGlzKTtcclxuICAgICAgICAgICAgZGVmaW5pbmcgPSB0cnVlO1xyXG4gICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywga2V5LCB7XHJcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcclxuICAgICAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICB2YWx1ZTogZm5Cb3VuZFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgZGVmaW5pbmcgPSBmYWxzZTtcclxuICAgICAgICAgICAgcmV0dXJuIGZuQm91bmQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYW55XHJcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAobmV3VmFsdWUpIHtcclxuICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIGtleSwge1xyXG4gICAgICAgICAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgd3JpdGFibGU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgICAgICAgICAgdmFsdWU6IG5ld1ZhbHVlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cclxuZXhwb3J0cy5hdXRvYmluZCA9IGF1dG9iaW5kO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1hdXRvYmluZC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgaW5kZXhfMSA9IHJlcXVpcmUoXCJAdWlmYWJyaWMvbWVyZ2Utc3R5bGVzL2xpYi9pbmRleFwiKTtcclxuLyoqXHJcbiAqIENyZWF0ZXMgYSBnZXRDbGFzc05hbWVzIGZ1bmN0aW9uIHdoaWNoIGNhbGxzIGdldFN0eWxlcyBnaXZlbiB0aGUgcHJvcHMsIGFuZCBpbmplY3RzIHRoZW1cclxuICogaW50byBtZXJnZVN0eWxlU2V0cy5cclxuICovXHJcbmZ1bmN0aW9uIGNsYXNzTmFtZXNGdW5jdGlvbigpIHtcclxuICAgIC8vIFRPRE86IG1lbW9pemUuXHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKGdldFN0eWxlcywgc3R5bGVQcm9wcykgeyByZXR1cm4gaW5kZXhfMS5tZXJnZVN0eWxlU2V0cyhnZXRTdHlsZXMgJiYgZ2V0U3R5bGVzKHN0eWxlUHJvcHMpKTsgfTtcclxufVxyXG5leHBvcnRzLmNsYXNzTmFtZXNGdW5jdGlvbiA9IGNsYXNzTmFtZXNGdW5jdGlvbjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2xhc3NOYW1lc0Z1bmN0aW9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbi8qKlxyXG4gKiBDb25jYXRpbmF0aW9uIGhlbHBlciwgd2hpY2ggY2FuIG1lcmdlIGNsYXNzIG5hbWVzIHRvZ2V0aGVyLiBTa2lwcyBvdmVyIGZhbHNleSB2YWx1ZXMuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmZ1bmN0aW9uIGNzcygpIHtcclxuICAgIHZhciBhcmdzID0gW107XHJcbiAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgIH1cclxuICAgIHZhciBjbGFzc2VzID0gW107XHJcbiAgICBmb3IgKHZhciBfYSA9IDAsIGFyZ3NfMSA9IGFyZ3M7IF9hIDwgYXJnc18xLmxlbmd0aDsgX2ErKykge1xyXG4gICAgICAgIHZhciBhcmcgPSBhcmdzXzFbX2FdO1xyXG4gICAgICAgIGlmIChhcmcpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICBjbGFzc2VzLnB1c2goYXJnKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICgoYXJnLmhhc093blByb3BlcnR5KCd0b1N0cmluZycpICYmIHR5cGVvZiAoYXJnLnRvU3RyaW5nKSA9PT0gJ2Z1bmN0aW9uJykpIHtcclxuICAgICAgICAgICAgICAgIGNsYXNzZXMucHVzaChhcmcudG9TdHJpbmcoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYW55XHJcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBrZXkgaW4gYXJnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChhcmdba2V5XSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjbGFzc2VzLnB1c2goa2V5KTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gY2xhc3Nlcy5qb2luKCcgJyk7XHJcbn1cclxuZXhwb3J0cy5jc3MgPSBjc3M7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWNzcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcclxudmFyIFJlYWN0ID0gcmVxdWlyZShcInJlYWN0XCIpO1xyXG52YXIgUHJvcFR5cGVzID0gcmVxdWlyZShcInByb3AtdHlwZXNcIik7XHJcbnZhciBDdXN0b21pemF0aW9uc18xID0gcmVxdWlyZShcIi4vQ3VzdG9taXphdGlvbnNcIik7XHJcbmZ1bmN0aW9uIGN1c3RvbWl6YWJsZShzY29wZSwgZmllbGRzXHJcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYW55XHJcbikge1xyXG4gICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLXNoYWRvd2VkLXZhcmlhYmxlXHJcbiAgICByZXR1cm4gZnVuY3Rpb24gY3VzdG9taXphYmxlRmFjdG9yeShcclxuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYW55XHJcbiAgICAgICAgQ29tcG9zZWRDb21wb25lbnRcclxuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYW55XHJcbiAgICApIHtcclxuICAgICAgICByZXR1cm4gX2EgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICAgICAgICAgICAgICB0c2xpYl8xLl9fZXh0ZW5kcyhDb21wb25lbnRXaXRoSW5qZWN0ZWRQcm9wcywgX3N1cGVyKTtcclxuICAgICAgICAgICAgICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1hbnlcclxuICAgICAgICAgICAgICAgIGZ1bmN0aW9uIENvbXBvbmVudFdpdGhJbmplY3RlZFByb3BzKHByb3BzLCBjb250ZXh0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgcHJvcHMsIGNvbnRleHQpIHx8IHRoaXM7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX29uU2V0dGluZ0NoYW5nZWQgPSBfdGhpcy5fb25TZXR0aW5nQ2hhbmdlZC5iaW5kKF90aGlzKTtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBDb21wb25lbnRXaXRoSW5qZWN0ZWRQcm9wcy5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgQ3VzdG9taXphdGlvbnNfMS5DdXN0b21pemF0aW9ucy5vYnNlcnZlKHRoaXMuX29uU2V0dGluZ0NoYW5nZWQpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIENvbXBvbmVudFdpdGhJbmplY3RlZFByb3BzLnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICBDdXN0b21pemF0aW9uc18xLkN1c3RvbWl6YXRpb25zLnVub2JzZXJ2ZSh0aGlzLl9vblNldHRpbmdDaGFuZ2VkKTtcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgICAgICBDb21wb25lbnRXaXRoSW5qZWN0ZWRQcm9wcy5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciBkZWZhdWx0UHJvcHMgPSBDdXN0b21pemF0aW9uc18xLkN1c3RvbWl6YXRpb25zLmdldFNldHRpbmdzKGZpZWxkcywgc2NvcGUsIHRoaXMuY29udGV4dC5jdXN0b21pemF0aW9ucyk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIChcclxuICAgICAgICAgICAgICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYW55XHJcbiAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChDb21wb3NlZENvbXBvbmVudCwgdHNsaWJfMS5fX2Fzc2lnbih7fSwgZGVmYXVsdFByb3BzLCB0aGlzLnByb3BzKSkpO1xyXG4gICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgIENvbXBvbmVudFdpdGhJbmplY3RlZFByb3BzLnByb3RvdHlwZS5fb25TZXR0aW5nQ2hhbmdlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZvcmNlVXBkYXRlKCk7XHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIENvbXBvbmVudFdpdGhJbmplY3RlZFByb3BzO1xyXG4gICAgICAgICAgICB9KFJlYWN0LkNvbXBvbmVudCkpLFxyXG4gICAgICAgICAgICBfYS5kaXNwbGF5TmFtZSA9ICdDdXN0b21pemVkJyArIHNjb3BlLFxyXG4gICAgICAgICAgICBfYS5jb250ZXh0VHlwZXMgPSB7XHJcbiAgICAgICAgICAgICAgICBjdXN0b21pemF0aW9uczogUHJvcFR5cGVzLm9iamVjdFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBfYTtcclxuICAgICAgICB2YXIgX2E7XHJcbiAgICB9O1xyXG59XHJcbmV4cG9ydHMuY3VzdG9taXphYmxlID0gY3VzdG9taXphYmxlO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1jdXN0b21pemFibGUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuLyoqXHJcbiAqIFNldHMgdGhlIHZpcnR1YWwgcGFyZW50IG9mIGFuIGVsZW1lbnQuXHJcbiAqIFBhc3MgYHVuZGVmaW5lZGAgYXMgdGhlIGBwYXJlbnRgIHRvIGNsZWFyIHRoZSB2aXJ0dWFsIHBhcmVudC5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuZnVuY3Rpb24gc2V0VmlydHVhbFBhcmVudChjaGlsZCwgcGFyZW50KSB7XHJcbiAgICB2YXIgdmlydHVhbENoaWxkID0gY2hpbGQ7XHJcbiAgICB2YXIgdmlydHVhbFBhcmVudCA9IHBhcmVudDtcclxuICAgIGlmICghdmlydHVhbENoaWxkLl92aXJ0dWFsKSB7XHJcbiAgICAgICAgdmlydHVhbENoaWxkLl92aXJ0dWFsID0ge1xyXG4gICAgICAgICAgICBjaGlsZHJlbjogW11cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgdmFyIG9sZFBhcmVudCA9IHZpcnR1YWxDaGlsZC5fdmlydHVhbC5wYXJlbnQ7XHJcbiAgICBpZiAob2xkUGFyZW50ICYmIG9sZFBhcmVudCAhPT0gcGFyZW50KSB7XHJcbiAgICAgICAgLy8gUmVtb3ZlIHRoZSBjaGlsZCBmcm9tIGl0cyBvbGQgcGFyZW50LlxyXG4gICAgICAgIHZhciBpbmRleCA9IG9sZFBhcmVudC5fdmlydHVhbC5jaGlsZHJlbi5pbmRleE9mKHZpcnR1YWxDaGlsZCk7XHJcbiAgICAgICAgaWYgKGluZGV4ID4gLTEpIHtcclxuICAgICAgICAgICAgb2xkUGFyZW50Ll92aXJ0dWFsLmNoaWxkcmVuLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdmlydHVhbENoaWxkLl92aXJ0dWFsLnBhcmVudCA9IHZpcnR1YWxQYXJlbnQgfHwgdW5kZWZpbmVkO1xyXG4gICAgaWYgKHZpcnR1YWxQYXJlbnQpIHtcclxuICAgICAgICBpZiAoIXZpcnR1YWxQYXJlbnQuX3ZpcnR1YWwpIHtcclxuICAgICAgICAgICAgdmlydHVhbFBhcmVudC5fdmlydHVhbCA9IHtcclxuICAgICAgICAgICAgICAgIGNoaWxkcmVuOiBbXVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICB2aXJ0dWFsUGFyZW50Ll92aXJ0dWFsLmNoaWxkcmVuLnB1c2godmlydHVhbENoaWxkKTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLnNldFZpcnR1YWxQYXJlbnQgPSBzZXRWaXJ0dWFsUGFyZW50O1xyXG4vKipcclxuICogR2V0cyB0aGUgdmlydHVhbCBwYXJlbnQgZ2l2ZW4gdGhlIGNoaWxkIGVsZW1lbnQsIGlmIGl0IGV4aXN0cy5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuZnVuY3Rpb24gZ2V0VmlydHVhbFBhcmVudChjaGlsZCkge1xyXG4gICAgdmFyIHBhcmVudDtcclxuICAgIGlmIChjaGlsZCAmJiBpc1ZpcnR1YWxFbGVtZW50KGNoaWxkKSkge1xyXG4gICAgICAgIHBhcmVudCA9IGNoaWxkLl92aXJ0dWFsLnBhcmVudDtcclxuICAgIH1cclxuICAgIHJldHVybiBwYXJlbnQ7XHJcbn1cclxuZXhwb3J0cy5nZXRWaXJ0dWFsUGFyZW50ID0gZ2V0VmlydHVhbFBhcmVudDtcclxuLyoqXHJcbiAqIEdldHMgdGhlIGVsZW1lbnQgd2hpY2ggaXMgdGhlIHBhcmVudCBvZiBhIGdpdmVuIGVsZW1lbnQuXHJcbiAqIElmIGBhbGxvd1ZpcnR1YVBhcmVudHNgIGlzIGB0cnVlYCwgdGhpcyBtZXRob2QgcHJlZmVycyB0aGUgdmlydHVhbCBwYXJlbnQgb3ZlclxyXG4gKiByZWFsIERPTSBwYXJlbnQgd2hlbiBwcmVzZW50LlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRQYXJlbnQoY2hpbGQsIGFsbG93VmlydHVhbFBhcmVudHMpIHtcclxuICAgIGlmIChhbGxvd1ZpcnR1YWxQYXJlbnRzID09PSB2b2lkIDApIHsgYWxsb3dWaXJ0dWFsUGFyZW50cyA9IHRydWU7IH1cclxuICAgIHJldHVybiBjaGlsZCAmJiAoYWxsb3dWaXJ0dWFsUGFyZW50cyAmJiBnZXRWaXJ0dWFsUGFyZW50KGNoaWxkKSB8fFxyXG4gICAgICAgIGNoaWxkLnBhcmVudE5vZGUgJiYgY2hpbGQucGFyZW50Tm9kZSk7XHJcbn1cclxuZXhwb3J0cy5nZXRQYXJlbnQgPSBnZXRQYXJlbnQ7XHJcbi8qKlxyXG4gKiBHZXRzIHRoZSBlbGVtZW50cyB3aGljaCBhcmUgY2hpbGQgZWxlbWVudHMgb2YgdGhlIGdpdmVuIGVsZW1lbnQuXHJcbiAqIElmIGBhbGxvd1ZpcnR1YWxDaGlsZHJlbmAgaXMgYHRydWVgLCB0aGlzIG1ldGhvZCBlbnVtZXJhdGVzIHZpcnR1YWwgY2hpbGQgZWxlbWVudHNcclxuICogYWZ0ZXIgdGhlIG9yaWdpbmFsIGNoaWxkcmVuLlxyXG4gKiBAcGFyYW0gcGFyZW50XHJcbiAqIEBwYXJhbSBhbGxvd1ZpcnR1YWxDaGlsZHJlblxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0Q2hpbGRyZW4ocGFyZW50LCBhbGxvd1ZpcnR1YWxDaGlsZHJlbikge1xyXG4gICAgaWYgKGFsbG93VmlydHVhbENoaWxkcmVuID09PSB2b2lkIDApIHsgYWxsb3dWaXJ0dWFsQ2hpbGRyZW4gPSB0cnVlOyB9XHJcbiAgICB2YXIgY2hpbGRyZW4gPSBbXTtcclxuICAgIGlmIChwYXJlbnQpIHtcclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcmVudC5jaGlsZHJlbi5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgICAgICBjaGlsZHJlbi5wdXNoKHBhcmVudC5jaGlsZHJlbi5pdGVtKGkpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGFsbG93VmlydHVhbENoaWxkcmVuICYmIGlzVmlydHVhbEVsZW1lbnQocGFyZW50KSkge1xyXG4gICAgICAgICAgICBjaGlsZHJlbi5wdXNoLmFwcGx5KGNoaWxkcmVuLCBwYXJlbnQuX3ZpcnR1YWwuY2hpbGRyZW4pO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBjaGlsZHJlbjtcclxufVxyXG5leHBvcnRzLmdldENoaWxkcmVuID0gZ2V0Q2hpbGRyZW47XHJcbi8qKlxyXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgb3Igbm90IGEgcGFyZW50IGVsZW1lbnQgY29udGFpbnMgYSBnaXZlbiBjaGlsZCBlbGVtZW50LlxyXG4gKiBJZiBgYWxsb3dWaXJ0dWFsUGFyZW50c2AgaXMgdHJ1ZSwgdGhpcyBtZXRob2QgbWF5IHJldHVybiBgdHJ1ZWAgaWYgdGhlIGNoaWxkXHJcbiAqIGhhcyB0aGUgcGFyZW50IGluIGl0cyB2aXJ0dWFsIGVsZW1lbnQgaGllcmFyY2h5LlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5mdW5jdGlvbiBlbGVtZW50Q29udGFpbnMocGFyZW50LCBjaGlsZCwgYWxsb3dWaXJ0dWFsUGFyZW50cykge1xyXG4gICAgaWYgKGFsbG93VmlydHVhbFBhcmVudHMgPT09IHZvaWQgMCkgeyBhbGxvd1ZpcnR1YWxQYXJlbnRzID0gdHJ1ZTsgfVxyXG4gICAgdmFyIGlzQ29udGFpbmVkID0gZmFsc2U7XHJcbiAgICBpZiAocGFyZW50ICYmIGNoaWxkKSB7XHJcbiAgICAgICAgaWYgKGFsbG93VmlydHVhbFBhcmVudHMpIHtcclxuICAgICAgICAgICAgaXNDb250YWluZWQgPSBmYWxzZTtcclxuICAgICAgICAgICAgd2hpbGUgKGNoaWxkKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbmV4dFBhcmVudCA9IGdldFBhcmVudChjaGlsZCk7XHJcbiAgICAgICAgICAgICAgICBpZiAobmV4dFBhcmVudCA9PT0gcGFyZW50KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgaXNDb250YWluZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgY2hpbGQgPSBuZXh0UGFyZW50O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHBhcmVudC5jb250YWlucykge1xyXG4gICAgICAgICAgICBpc0NvbnRhaW5lZCA9IHBhcmVudC5jb250YWlucyhjaGlsZCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIGlzQ29udGFpbmVkO1xyXG59XHJcbmV4cG9ydHMuZWxlbWVudENvbnRhaW5zID0gZWxlbWVudENvbnRhaW5zO1xyXG52YXIgX2lzU1NSID0gZmFsc2U7XHJcbi8qKlxyXG4gKiBIZWxwZXIgdG8gc2V0IHNzciBtb2RlIHRvIHNpbXVsYXRlIG5vIHdpbmRvdyBvYmplY3QgcmV0dXJuZWQgZnJvbSBnZXRXaW5kb3cgaGVscGVyLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5mdW5jdGlvbiBzZXRTU1IoaXNFbmFibGVkKSB7XHJcbiAgICBfaXNTU1IgPSBpc0VuYWJsZWQ7XHJcbn1cclxuZXhwb3J0cy5zZXRTU1IgPSBzZXRTU1I7XHJcbi8qKlxyXG4gKiBIZWxwZXIgdG8gZ2V0IHRoZSB3aW5kb3cgb2JqZWN0LlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRXaW5kb3cocm9vdEVsZW1lbnQpIHtcclxuICAgIGlmIChfaXNTU1IgfHwgdHlwZW9mIHdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcpIHtcclxuICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgfVxyXG4gICAgZWxzZSB7XHJcbiAgICAgICAgcmV0dXJuIChyb290RWxlbWVudCAmJlxyXG4gICAgICAgICAgICByb290RWxlbWVudC5vd25lckRvY3VtZW50ICYmXHJcbiAgICAgICAgICAgIHJvb3RFbGVtZW50Lm93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcgP1xyXG4gICAgICAgICAgICByb290RWxlbWVudC5vd25lckRvY3VtZW50LmRlZmF1bHRWaWV3IDpcclxuICAgICAgICAgICAgd2luZG93KTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLmdldFdpbmRvdyA9IGdldFdpbmRvdztcclxuLyoqXHJcbiAqIEhlbHBlciB0byBnZXQgdGhlIGRvY3VtZW50IG9iamVjdC5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuZnVuY3Rpb24gZ2V0RG9jdW1lbnQocm9vdEVsZW1lbnQpIHtcclxuICAgIGlmIChfaXNTU1IgfHwgdHlwZW9mIGRvY3VtZW50ID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICByZXR1cm4gcm9vdEVsZW1lbnQgJiYgcm9vdEVsZW1lbnQub3duZXJEb2N1bWVudCA/IHJvb3RFbGVtZW50Lm93bmVyRG9jdW1lbnQgOiBkb2N1bWVudDtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLmdldERvY3VtZW50ID0gZ2V0RG9jdW1lbnQ7XHJcbi8qKlxyXG4gKiBIZWxwZXIgdG8gZ2V0IGJvdW5kaW5nIGNsaWVudCByZWN0LCB3b3JrcyB3aXRoIHdpbmRvdy5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuZnVuY3Rpb24gZ2V0UmVjdChlbGVtZW50KSB7XHJcbiAgICB2YXIgcmVjdDtcclxuICAgIGlmIChlbGVtZW50KSB7XHJcbiAgICAgICAgaWYgKGVsZW1lbnQgPT09IHdpbmRvdykge1xyXG4gICAgICAgICAgICByZWN0ID0ge1xyXG4gICAgICAgICAgICAgICAgbGVmdDogMCxcclxuICAgICAgICAgICAgICAgIHRvcDogMCxcclxuICAgICAgICAgICAgICAgIHdpZHRoOiB3aW5kb3cuaW5uZXJXaWR0aCxcclxuICAgICAgICAgICAgICAgIGhlaWdodDogd2luZG93LmlubmVySGVpZ2h0LFxyXG4gICAgICAgICAgICAgICAgcmlnaHQ6IHdpbmRvdy5pbm5lcldpZHRoLFxyXG4gICAgICAgICAgICAgICAgYm90dG9tOiB3aW5kb3cuaW5uZXJIZWlnaHRcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QpIHtcclxuICAgICAgICAgICAgcmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHJlY3Q7XHJcbn1cclxuZXhwb3J0cy5nZXRSZWN0ID0gZ2V0UmVjdDtcclxuLyoqXHJcbiAqIERldGVybWluZXMgd2hldGhlciBvciBub3QgYW4gZWxlbWVudCBoYXMgdGhlIHZpcnR1YWwgaGllcmFyY2h5IGV4dGVuc2lvbi5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuZnVuY3Rpb24gaXNWaXJ0dWFsRWxlbWVudChlbGVtZW50KSB7XHJcbiAgICByZXR1cm4gZWxlbWVudCAmJiAhIWVsZW1lbnQuX3ZpcnR1YWw7XHJcbn1cclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZG9tLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG4vKiB0c2xpbnQ6ZGlzYWJsZTpuby1zdHJpbmctbGl0ZXJhbCAqL1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBkb21fMSA9IHJlcXVpcmUoXCIuL2RvbVwiKTtcclxudmFyIElTX0ZPQ1VTQUJMRV9BVFRSSUJVVEUgPSAnZGF0YS1pcy1mb2N1c2FibGUnO1xyXG52YXIgSVNfVklTSUJMRV9BVFRSSUJVVEUgPSAnZGF0YS1pcy12aXNpYmxlJztcclxudmFyIEZPQ1VTWk9ORV9JRF9BVFRSSUJVVEUgPSAnZGF0YS1mb2N1c3pvbmUtaWQnO1xyXG52YXIgRk9DVVNaT05FX1NVQl9BVFRSSUJVVEUgPSAnZGF0YS1pcy1zdWItZm9jdXN6b25lJztcclxuLyoqXHJcbiAqIEdldHMgdGhlIGZpcnN0IGZvY3VzYWJsZSBlbGVtZW50LlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRGaXJzdEZvY3VzYWJsZShyb290RWxlbWVudCwgY3VycmVudEVsZW1lbnQsIGluY2x1ZGVFbGVtZW50c0luRm9jdXNab25lcykge1xyXG4gICAgcmV0dXJuIGdldE5leHRFbGVtZW50KHJvb3RFbGVtZW50LCBjdXJyZW50RWxlbWVudCwgdHJ1ZSwgZmFsc2UsIGZhbHNlLCBpbmNsdWRlRWxlbWVudHNJbkZvY3VzWm9uZXMpO1xyXG59XHJcbmV4cG9ydHMuZ2V0Rmlyc3RGb2N1c2FibGUgPSBnZXRGaXJzdEZvY3VzYWJsZTtcclxuLyoqXHJcbiAqIEdldHMgdGhlIGxhc3QgZm9jdXNhYmxlIGVsZW1lbnQuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmZ1bmN0aW9uIGdldExhc3RGb2N1c2FibGUocm9vdEVsZW1lbnQsIGN1cnJlbnRFbGVtZW50LCBpbmNsdWRlRWxlbWVudHNJbkZvY3VzWm9uZXMpIHtcclxuICAgIHJldHVybiBnZXRQcmV2aW91c0VsZW1lbnQocm9vdEVsZW1lbnQsIGN1cnJlbnRFbGVtZW50LCB0cnVlLCBmYWxzZSwgdHJ1ZSwgaW5jbHVkZUVsZW1lbnRzSW5Gb2N1c1pvbmVzKTtcclxufVxyXG5leHBvcnRzLmdldExhc3RGb2N1c2FibGUgPSBnZXRMYXN0Rm9jdXNhYmxlO1xyXG4vKipcclxuICogR2V0cyB0aGUgbGFzdCB0YWJiYWJsZSBlbGVtZW50LlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRMYXN0VGFiYmFibGUocm9vdEVsZW1lbnQsIGN1cnJlbnRFbGVtZW50LCBpbmNsdWRlRWxlbWVudHNJbkZvY3VzWm9uZXMpIHtcclxuICAgIHJldHVybiBnZXRQcmV2aW91c0VsZW1lbnQocm9vdEVsZW1lbnQsIGN1cnJlbnRFbGVtZW50LCB0cnVlLCBmYWxzZSwgdHJ1ZSwgaW5jbHVkZUVsZW1lbnRzSW5Gb2N1c1pvbmVzLCBmYWxzZSwgdHJ1ZSk7XHJcbn1cclxuZXhwb3J0cy5nZXRMYXN0VGFiYmFibGUgPSBnZXRMYXN0VGFiYmFibGU7XHJcbi8qKlxyXG4gKiBBdHRlbXB0cyB0byBmb2N1cyB0aGUgZmlyc3QgZm9jdXNhYmxlIGVsZW1lbnQgdGhhdCBpcyBhIGNoaWxkIG9yIGNoaWxkJ3MgY2hpbGQgb2YgdGhlIHJvb3RFbGVtZW50LlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqIEBwYXJhbSByb290RWxlbWVudCAtIEVsZW1lbnQgdG8gc3RhcnQgdGhlIHNlYXJjaCBmb3IgYSBmb2N1c2FibGUgY2hpbGQuXHJcbiAqIEByZXR1cm5zIFRydWUgaWYgZm9jdXMgd2FzIHNldCwgZmFsc2UgaWYgaXQgd2FzIG5vdC5cclxuICovXHJcbmZ1bmN0aW9uIGZvY3VzRmlyc3RDaGlsZChyb290RWxlbWVudCkge1xyXG4gICAgdmFyIGVsZW1lbnQgPSBnZXROZXh0RWxlbWVudChyb290RWxlbWVudCwgcm9vdEVsZW1lbnQsIHRydWUsIGZhbHNlLCBmYWxzZSwgdHJ1ZSk7XHJcbiAgICBpZiAoZWxlbWVudCkge1xyXG4gICAgICAgIGVsZW1lbnQuZm9jdXMoKTtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG5leHBvcnRzLmZvY3VzRmlyc3RDaGlsZCA9IGZvY3VzRmlyc3RDaGlsZDtcclxuLyoqXHJcbiAqIFRyYXZlcnNlIHRvIGZpbmQgdGhlIHByZXZpb3VzIGVsZW1lbnQuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmZ1bmN0aW9uIGdldFByZXZpb3VzRWxlbWVudChyb290RWxlbWVudCwgY3VycmVudEVsZW1lbnQsIGNoZWNrTm9kZSwgc3VwcHJlc3NQYXJlbnRUcmF2ZXJzYWwsIHRyYXZlcnNlQ2hpbGRyZW4sIGluY2x1ZGVFbGVtZW50c0luRm9jdXNab25lcywgYWxsb3dGb2N1c1Jvb3QsIHRhYmJhYmxlKSB7XHJcbiAgICBpZiAoIWN1cnJlbnRFbGVtZW50IHx8XHJcbiAgICAgICAgKCFhbGxvd0ZvY3VzUm9vdCAmJiBjdXJyZW50RWxlbWVudCA9PT0gcm9vdEVsZW1lbnQpKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICB2YXIgaXNDdXJyZW50RWxlbWVudFZpc2libGUgPSBpc0VsZW1lbnRWaXNpYmxlKGN1cnJlbnRFbGVtZW50KTtcclxuICAgIC8vIENoZWNrIGl0cyBjaGlsZHJlbi5cclxuICAgIGlmICh0cmF2ZXJzZUNoaWxkcmVuICYmIGlzQ3VycmVudEVsZW1lbnRWaXNpYmxlICYmXHJcbiAgICAgICAgKGluY2x1ZGVFbGVtZW50c0luRm9jdXNab25lcyB8fCAhKGlzRWxlbWVudEZvY3VzWm9uZShjdXJyZW50RWxlbWVudCkgfHwgaXNFbGVtZW50Rm9jdXNTdWJab25lKGN1cnJlbnRFbGVtZW50KSkpKSB7XHJcbiAgICAgICAgdmFyIGNoaWxkTWF0Y2ggPSBnZXRQcmV2aW91c0VsZW1lbnQocm9vdEVsZW1lbnQsIGN1cnJlbnRFbGVtZW50Lmxhc3RFbGVtZW50Q2hpbGQsIHRydWUsIHRydWUsIHRydWUsIGluY2x1ZGVFbGVtZW50c0luRm9jdXNab25lcywgYWxsb3dGb2N1c1Jvb3QsIHRhYmJhYmxlKTtcclxuICAgICAgICBpZiAoY2hpbGRNYXRjaCAmJiAoKHRhYmJhYmxlICYmIChpc0VsZW1lbnRUYWJiYWJsZShjaGlsZE1hdGNoLCB0cnVlKSkpIHx8ICF0YWJiYWJsZSkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNoaWxkTWF0Y2g7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgLy8gQ2hlY2sgdGhlIGN1cnJlbnQgbm9kZSwgaWYgaXQncyBub3QgdGhlIGZpcnN0IHRyYXZlcnNhbC5cclxuICAgIGlmIChjaGVja05vZGUgJiYgaXNDdXJyZW50RWxlbWVudFZpc2libGUgJiYgaXNFbGVtZW50VGFiYmFibGUoY3VycmVudEVsZW1lbnQpKSB7XHJcbiAgICAgICAgcmV0dXJuIGN1cnJlbnRFbGVtZW50O1xyXG4gICAgfVxyXG4gICAgLy8gQ2hlY2sgaXRzIHByZXZpb3VzIHNpYmxpbmcuXHJcbiAgICB2YXIgc2libGluZ01hdGNoID0gZ2V0UHJldmlvdXNFbGVtZW50KHJvb3RFbGVtZW50LCBjdXJyZW50RWxlbWVudC5wcmV2aW91c0VsZW1lbnRTaWJsaW5nLCB0cnVlLCB0cnVlLCB0cnVlLCBpbmNsdWRlRWxlbWVudHNJbkZvY3VzWm9uZXMsIGFsbG93Rm9jdXNSb290LCB0YWJiYWJsZSk7XHJcbiAgICBpZiAoc2libGluZ01hdGNoKSB7XHJcbiAgICAgICAgcmV0dXJuIHNpYmxpbmdNYXRjaDtcclxuICAgIH1cclxuICAgIC8vIENoZWNrIGl0cyBwYXJlbnQuXHJcbiAgICBpZiAoIXN1cHByZXNzUGFyZW50VHJhdmVyc2FsKSB7XHJcbiAgICAgICAgcmV0dXJuIGdldFByZXZpb3VzRWxlbWVudChyb290RWxlbWVudCwgY3VycmVudEVsZW1lbnQucGFyZW50RWxlbWVudCwgdHJ1ZSwgZmFsc2UsIGZhbHNlLCBpbmNsdWRlRWxlbWVudHNJbkZvY3VzWm9uZXMsIGFsbG93Rm9jdXNSb290LCB0YWJiYWJsZSk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gbnVsbDtcclxufVxyXG5leHBvcnRzLmdldFByZXZpb3VzRWxlbWVudCA9IGdldFByZXZpb3VzRWxlbWVudDtcclxuLyoqXHJcbiAqIFRyYXZlcnNlIHRvIGZpbmQgdGhlIG5leHQgZm9jdXNhYmxlIGVsZW1lbnQuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmZ1bmN0aW9uIGdldE5leHRFbGVtZW50KHJvb3RFbGVtZW50LCBjdXJyZW50RWxlbWVudCwgY2hlY2tOb2RlLCBzdXBwcmVzc1BhcmVudFRyYXZlcnNhbCwgc3VwcHJlc3NDaGlsZFRyYXZlcnNhbCwgaW5jbHVkZUVsZW1lbnRzSW5Gb2N1c1pvbmVzLCBhbGxvd0ZvY3VzUm9vdCkge1xyXG4gICAgaWYgKCFjdXJyZW50RWxlbWVudCB8fFxyXG4gICAgICAgIChjdXJyZW50RWxlbWVudCA9PT0gcm9vdEVsZW1lbnQgJiYgc3VwcHJlc3NDaGlsZFRyYXZlcnNhbCAmJiAhYWxsb3dGb2N1c1Jvb3QpKSB7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9XHJcbiAgICB2YXIgaXNDdXJyZW50RWxlbWVudFZpc2libGUgPSBpc0VsZW1lbnRWaXNpYmxlKGN1cnJlbnRFbGVtZW50KTtcclxuICAgIC8vIENoZWNrIHRoZSBjdXJyZW50IG5vZGUsIGlmIGl0J3Mgbm90IHRoZSBmaXJzdCB0cmF2ZXJzYWwuXHJcbiAgICBpZiAoY2hlY2tOb2RlICYmIGlzQ3VycmVudEVsZW1lbnRWaXNpYmxlICYmIGlzRWxlbWVudFRhYmJhYmxlKGN1cnJlbnRFbGVtZW50KSkge1xyXG4gICAgICAgIHJldHVybiBjdXJyZW50RWxlbWVudDtcclxuICAgIH1cclxuICAgIC8vIENoZWNrIGl0cyBjaGlsZHJlbi5cclxuICAgIGlmICghc3VwcHJlc3NDaGlsZFRyYXZlcnNhbCAmJiBpc0N1cnJlbnRFbGVtZW50VmlzaWJsZSAmJlxyXG4gICAgICAgIChpbmNsdWRlRWxlbWVudHNJbkZvY3VzWm9uZXMgfHwgIShpc0VsZW1lbnRGb2N1c1pvbmUoY3VycmVudEVsZW1lbnQpIHx8IGlzRWxlbWVudEZvY3VzU3ViWm9uZShjdXJyZW50RWxlbWVudCkpKSkge1xyXG4gICAgICAgIHZhciBjaGlsZE1hdGNoID0gZ2V0TmV4dEVsZW1lbnQocm9vdEVsZW1lbnQsIGN1cnJlbnRFbGVtZW50LmZpcnN0RWxlbWVudENoaWxkLCB0cnVlLCB0cnVlLCBmYWxzZSwgaW5jbHVkZUVsZW1lbnRzSW5Gb2N1c1pvbmVzLCBhbGxvd0ZvY3VzUm9vdCk7XHJcbiAgICAgICAgaWYgKGNoaWxkTWF0Y2gpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGNoaWxkTWF0Y2g7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKGN1cnJlbnRFbGVtZW50ID09PSByb290RWxlbWVudCkge1xyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gICAgLy8gQ2hlY2sgaXRzIHNpYmxpbmcuXHJcbiAgICB2YXIgc2libGluZ01hdGNoID0gZ2V0TmV4dEVsZW1lbnQocm9vdEVsZW1lbnQsIGN1cnJlbnRFbGVtZW50Lm5leHRFbGVtZW50U2libGluZywgdHJ1ZSwgdHJ1ZSwgZmFsc2UsIGluY2x1ZGVFbGVtZW50c0luRm9jdXNab25lcywgYWxsb3dGb2N1c1Jvb3QpO1xyXG4gICAgaWYgKHNpYmxpbmdNYXRjaCkge1xyXG4gICAgICAgIHJldHVybiBzaWJsaW5nTWF0Y2g7XHJcbiAgICB9XHJcbiAgICBpZiAoIXN1cHByZXNzUGFyZW50VHJhdmVyc2FsKSB7XHJcbiAgICAgICAgcmV0dXJuIGdldE5leHRFbGVtZW50KHJvb3RFbGVtZW50LCBjdXJyZW50RWxlbWVudC5wYXJlbnRFbGVtZW50LCBmYWxzZSwgZmFsc2UsIHRydWUsIGluY2x1ZGVFbGVtZW50c0luRm9jdXNab25lcywgYWxsb3dGb2N1c1Jvb3QpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIG51bGw7XHJcbn1cclxuZXhwb3J0cy5nZXROZXh0RWxlbWVudCA9IGdldE5leHRFbGVtZW50O1xyXG4vKipcclxuICogRGV0ZXJtaW5lcyBpZiBhbiBlbGVtZW50IGlzIHZpc2libGUuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmZ1bmN0aW9uIGlzRWxlbWVudFZpc2libGUoZWxlbWVudCkge1xyXG4gICAgLy8gSWYgdGhlIGVsZW1lbnQgaXMgbm90IHZhbGlkLCByZXR1cm4gZmFsc2UuXHJcbiAgICBpZiAoIWVsZW1lbnQgfHwgIWVsZW1lbnQuZ2V0QXR0cmlidXRlKSB7XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG4gICAgdmFyIHZpc2liaWxpdHlBdHRyaWJ1dGUgPSBlbGVtZW50LmdldEF0dHJpYnV0ZShJU19WSVNJQkxFX0FUVFJJQlVURSk7XHJcbiAgICAvLyBJZiB0aGUgZWxlbWVudCBpcyBleHBsaWNpdGx5IG1hcmtlZCB3aXRoIHRoZSB2aXNpYmlsaXR5IGF0dHJpYnV0ZSwgcmV0dXJuIHRoYXQgdmFsdWUgYXMgYm9vbGVhbi5cclxuICAgIGlmICh2aXNpYmlsaXR5QXR0cmlidXRlICE9PSBudWxsICYmIHZpc2liaWxpdHlBdHRyaWJ1dGUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHJldHVybiB2aXNpYmlsaXR5QXR0cmlidXRlID09PSAndHJ1ZSc7XHJcbiAgICB9XHJcbiAgICAvLyBGYWxsYmFjayB0byBvdGhlciBtZXRob2RzIG9mIGRldGVybWluaW5nIGFjdHVhbCB2aXNpYmlsaXR5LlxyXG4gICAgcmV0dXJuIChlbGVtZW50Lm9mZnNldEhlaWdodCAhPT0gMCB8fFxyXG4gICAgICAgIGVsZW1lbnQub2Zmc2V0UGFyZW50ICE9PSBudWxsIHx8XHJcbiAgICAgICAgLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueVxyXG4gICAgICAgIGVsZW1lbnQuaXNWaXNpYmxlID09PSB0cnVlKTsgLy8gdXNlZCBhcyBhIHdvcmthcm91bmQgZm9yIHRlc3RpbmcuXHJcbn1cclxuZXhwb3J0cy5pc0VsZW1lbnRWaXNpYmxlID0gaXNFbGVtZW50VmlzaWJsZTtcclxuLyoqXHJcbiAqIERldGVybWluZXMgaWYgYW4gZWxlbWVudCBjYW4gcmVjZWl2ZSBmb2N1cy5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuZnVuY3Rpb24gaXNFbGVtZW50VGFiYmFibGUoZWxlbWVudCwgY2hlY2tUYWJJbmRleCkge1xyXG4gICAgLy8gSWYgdGhpcyBlbGVtZW50IGlzIG51bGwgb3IgaXMgZGlzYWJsZWQsIGl0IGlzIG5vdCBjb25zaWRlcmVkIHRhYmJhYmxlLlxyXG4gICAgaWYgKCFlbGVtZW50IHx8IGVsZW1lbnQuZGlzYWJsZWQpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcbiAgICB2YXIgdGFiSW5kZXggPSAwO1xyXG4gICAgdmFyIHRhYkluZGV4QXR0cmlidXRlVmFsdWUgPSBudWxsO1xyXG4gICAgaWYgKGVsZW1lbnQgJiYgZWxlbWVudC5nZXRBdHRyaWJ1dGUpIHtcclxuICAgICAgICB0YWJJbmRleEF0dHJpYnV0ZVZhbHVlID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUoJ3RhYkluZGV4Jyk7XHJcbiAgICAgICAgaWYgKHRhYkluZGV4QXR0cmlidXRlVmFsdWUpIHtcclxuICAgICAgICAgICAgdGFiSW5kZXggPSBwYXJzZUludCh0YWJJbmRleEF0dHJpYnV0ZVZhbHVlLCAxMCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgdmFyIGlzRm9jdXNhYmxlQXR0cmlidXRlID0gZWxlbWVudC5nZXRBdHRyaWJ1dGUgPyBlbGVtZW50LmdldEF0dHJpYnV0ZShJU19GT0NVU0FCTEVfQVRUUklCVVRFKSA6IG51bGw7XHJcbiAgICB2YXIgaXNUYWJJbmRleFNldCA9IHRhYkluZGV4QXR0cmlidXRlVmFsdWUgIT09IG51bGwgJiYgdGFiSW5kZXggPj0gMDtcclxuICAgIHZhciByZXN1bHQgPSAhIWVsZW1lbnQgJiZcclxuICAgICAgICBpc0ZvY3VzYWJsZUF0dHJpYnV0ZSAhPT0gJ2ZhbHNlJyAmJlxyXG4gICAgICAgIChlbGVtZW50LnRhZ05hbWUgPT09ICdBJyB8fFxyXG4gICAgICAgICAgICAoZWxlbWVudC50YWdOYW1lID09PSAnQlVUVE9OJykgfHxcclxuICAgICAgICAgICAgKGVsZW1lbnQudGFnTmFtZSA9PT0gJ0lOUFVUJykgfHxcclxuICAgICAgICAgICAgKGVsZW1lbnQudGFnTmFtZSA9PT0gJ1RFWFRBUkVBJykgfHxcclxuICAgICAgICAgICAgaXNGb2N1c2FibGVBdHRyaWJ1dGUgPT09ICd0cnVlJyB8fFxyXG4gICAgICAgICAgICBpc1RhYkluZGV4U2V0IHx8XHJcbiAgICAgICAgICAgIGVsZW1lbnQuZ2V0QXR0cmlidXRlICYmIGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdyb2xlJykgPT09ICdidXR0b24nKTtcclxuICAgIHJldHVybiBjaGVja1RhYkluZGV4ID8gKHRhYkluZGV4ICE9PSAtMSkgJiYgcmVzdWx0IDogcmVzdWx0O1xyXG59XHJcbmV4cG9ydHMuaXNFbGVtZW50VGFiYmFibGUgPSBpc0VsZW1lbnRUYWJiYWJsZTtcclxuLyoqXHJcbiAqIERldGVybWluZXMgaWYgYSBnaXZlbiBlbGVtZW50IGlzIGEgZm9jdXMgem9uZS5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuZnVuY3Rpb24gaXNFbGVtZW50Rm9jdXNab25lKGVsZW1lbnQpIHtcclxuICAgIHJldHVybiAhIShlbGVtZW50ICYmIGVsZW1lbnQuZ2V0QXR0cmlidXRlICYmICEhZWxlbWVudC5nZXRBdHRyaWJ1dGUoRk9DVVNaT05FX0lEX0FUVFJJQlVURSkpO1xyXG59XHJcbmV4cG9ydHMuaXNFbGVtZW50Rm9jdXNab25lID0gaXNFbGVtZW50Rm9jdXNab25lO1xyXG4vKipcclxuICogRGV0ZXJtaW5lcyBpZiBhIGdpdmVuIGVsZW1lbnQgaXMgYSBmb2N1cyBzdWIgem9uZS5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuZnVuY3Rpb24gaXNFbGVtZW50Rm9jdXNTdWJab25lKGVsZW1lbnQpIHtcclxuICAgIHJldHVybiAhIShlbGVtZW50ICYmIGVsZW1lbnQuZ2V0QXR0cmlidXRlICYmIGVsZW1lbnQuZ2V0QXR0cmlidXRlKEZPQ1VTWk9ORV9TVUJfQVRUUklCVVRFKSA9PT0gJ3RydWUnKTtcclxufVxyXG5leHBvcnRzLmlzRWxlbWVudEZvY3VzU3ViWm9uZSA9IGlzRWxlbWVudEZvY3VzU3ViWm9uZTtcclxuLyoqXHJcbiAqIERldGVybWluZXMgaWYgYW4gZWxlbWVudCwgb3IgYW55IG9mIGl0cyBjaGlsZHJlbiwgY29udGFpbiBmb2N1cy5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuZnVuY3Rpb24gZG9lc0VsZW1lbnRDb250YWluRm9jdXMoZWxlbWVudCkge1xyXG4gICAgdmFyIGRvY3VtZW50ID0gZG9tXzEuZ2V0RG9jdW1lbnQoZWxlbWVudCk7XHJcbiAgICB2YXIgY3VycmVudEFjdGl2ZUVsZW1lbnQgPSBkb2N1bWVudCAmJiBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xyXG4gICAgaWYgKGN1cnJlbnRBY3RpdmVFbGVtZW50ICYmIGRvbV8xLmVsZW1lbnRDb250YWlucyhlbGVtZW50LCBjdXJyZW50QWN0aXZlRWxlbWVudCkpIHtcclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiBmYWxzZTtcclxufVxyXG5leHBvcnRzLmRvZXNFbGVtZW50Q29udGFpbkZvY3VzID0gZG9lc0VsZW1lbnRDb250YWluRm9jdXM7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZvY3VzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBSRUFDVF9MSUZFQ1lDTEVfRVhDTFVTSU9OUyA9IFtcclxuICAgICdzZXRTdGF0ZScsXHJcbiAgICAncmVuZGVyJyxcclxuICAgICdjb21wb25lbnRXaWxsTW91bnQnLFxyXG4gICAgJ2NvbXBvbmVudERpZE1vdW50JyxcclxuICAgICdjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzJyxcclxuICAgICdzaG91bGRDb21wb25lbnRVcGRhdGUnLFxyXG4gICAgJ2NvbXBvbmVudFdpbGxVcGRhdGUnLFxyXG4gICAgJ2NvbXBvbmVudERpZFVwZGF0ZScsXHJcbiAgICAnY29tcG9uZW50V2lsbFVubW91bnQnXHJcbl07XHJcbi8qKlxyXG4gKiBBbGxvd3MgeW91IHRvIGhvaXN0IG1ldGhvZHMsIGV4Y2VwdCB0aG9zZSBpbiBhbiBleGNsdXNpb24gc2V0IGZyb20gYSBzb3VyY2Ugb2JqZWN0IGludG8gYSBkZXN0aW5hdGlvbiBvYmplY3QuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICogQHBhcmFtIGRlc3RpbmF0aW9uIC0gVGhlIGluc3RhbmNlIG9mIHRoZSBvYmplY3QgdG8gaG9pc3QgdGhlIG1ldGhvZHMgb250by5cclxuICogQHBhcmFtIHNvdXJjZSAtIFRoZSBpbnN0YW5jZSBvZiB0aGUgb2JqZWN0IHdoZXJlIHRoZSBtZXRob2RzIGFyZSBob2lzdGVkIGZyb20uXHJcbiAqIEBwYXJhbSBleGNsdXNpb25zIC0gKE9wdGlvbmFsKSBXaGF0IG1ldGhvZHMgdG8gZXhjbHVkZSBmcm9tIGJlaW5nIGhvaXN0ZWQuXHJcbiAqIEByZXR1cm5zIEFuIGFycmF5IG9mIG5hbWVzIG9mIG1ldGhvZHMgdGhhdCB3ZXJlIGhvaXN0ZWQuXHJcbiAqL1xyXG4vLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYW55XHJcbmZ1bmN0aW9uIGhvaXN0TWV0aG9kcyhkZXN0aW5hdGlvbiwgc291cmNlLCBleGNsdXNpb25zKSB7XHJcbiAgICBpZiAoZXhjbHVzaW9ucyA9PT0gdm9pZCAwKSB7IGV4Y2x1c2lvbnMgPSBSRUFDVF9MSUZFQ1lDTEVfRVhDTFVTSU9OUzsgfVxyXG4gICAgdmFyIGhvaXN0ZWQgPSBbXTtcclxuICAgIHZhciBfbG9vcF8xID0gZnVuY3Rpb24gKG1ldGhvZE5hbWUpIHtcclxuICAgICAgICBpZiAodHlwZW9mIHNvdXJjZVttZXRob2ROYW1lXSA9PT0gJ2Z1bmN0aW9uJyAmJlxyXG4gICAgICAgICAgICBkZXN0aW5hdGlvblttZXRob2ROYW1lXSA9PT0gdW5kZWZpbmVkICYmXHJcbiAgICAgICAgICAgICghZXhjbHVzaW9ucyB8fCBleGNsdXNpb25zLmluZGV4T2YobWV0aG9kTmFtZSkgPT09IC0xKSkge1xyXG4gICAgICAgICAgICBob2lzdGVkLnB1c2gobWV0aG9kTmFtZSk7XHJcbiAgICAgICAgICAgIC8qIHRzbGludDpkaXNhYmxlOm5vLWZ1bmN0aW9uLWV4cHJlc3Npb24gKi9cclxuICAgICAgICAgICAgZGVzdGluYXRpb25bbWV0aG9kTmFtZV0gPSBmdW5jdGlvbiAoKSB7IHNvdXJjZVttZXRob2ROYW1lXS5hcHBseShzb3VyY2UsIGFyZ3VtZW50cyk7IH07XHJcbiAgICAgICAgICAgIC8qIHRzbGludDplbmFibGUgKi9cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgZm9yICh2YXIgbWV0aG9kTmFtZSBpbiBzb3VyY2UpIHtcclxuICAgICAgICBfbG9vcF8xKG1ldGhvZE5hbWUpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGhvaXN0ZWQ7XHJcbn1cclxuZXhwb3J0cy5ob2lzdE1ldGhvZHMgPSBob2lzdE1ldGhvZHM7XHJcbi8qKlxyXG4gKiBQcm92aWRlcyBhIG1ldGhvZCBmb3IgY29udmVuaWVuY2UgdG8gdW5ob2lzdCBob2lzdGVkIG1ldGhvZHMuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICogQHBhcmFtIHNvdXJjZSAtIFRoZSBzb3VyY2Ugb2JqZWN0IHVwb24gd2hpY2ggbWV0aG9kcyB3ZXJlIGhvaXN0ZWQuXHJcbiAqIEBwYXJhbSBtZXRob2ROYW1lcyAtIEFuIGFycmF5IG9mIG1ldGhvZCBuYW1lcyB0byB1bmhvaXN0LlxyXG4gKi9cclxuLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueVxyXG5mdW5jdGlvbiB1bmhvaXN0TWV0aG9kcyhzb3VyY2UsIG1ldGhvZE5hbWVzKSB7XHJcbiAgICBtZXRob2ROYW1lc1xyXG4gICAgICAgIC5mb3JFYWNoKGZ1bmN0aW9uIChtZXRob2ROYW1lKSB7IHJldHVybiBkZWxldGUgc291cmNlW21ldGhvZE5hbWVdOyB9KTtcclxufVxyXG5leHBvcnRzLnVuaG9pc3RNZXRob2RzID0gdW5ob2lzdE1ldGhvZHM7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWhvaXN0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xyXG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9Bc3luY1wiKSwgZXhwb3J0cyk7XHJcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL0F1dG9TY3JvbGxcIiksIGV4cG9ydHMpO1xyXG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9CYXNlQ29tcG9uZW50XCIpLCBleHBvcnRzKTtcclxudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vQ3VzdG9taXphdGlvbnNcIiksIGV4cG9ydHMpO1xyXG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9DdXN0b21pemVyXCIpLCBleHBvcnRzKTtcclxudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vRGVsYXllZFJlbmRlclwiKSwgZXhwb3J0cyk7XHJcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL0V2ZW50R3JvdXBcIiksIGV4cG9ydHMpO1xyXG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9GYWJyaWNQZXJmb3JtYW5jZVwiKSwgZXhwb3J0cyk7XHJcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL0dsb2JhbFNldHRpbmdzXCIpLCBleHBvcnRzKTtcclxudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vS2V5Q29kZXNcIiksIGV4cG9ydHMpO1xyXG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9SZWN0YW5nbGVcIiksIGV4cG9ydHMpO1xyXG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9hcnJheVwiKSwgZXhwb3J0cyk7XHJcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2Fzc2VydE5ldmVyXCIpLCBleHBvcnRzKTtcclxudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vYXV0b2JpbmRcIiksIGV4cG9ydHMpO1xyXG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9jbGFzc05hbWVzRnVuY3Rpb25cIiksIGV4cG9ydHMpO1xyXG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9jc3NcIiksIGV4cG9ydHMpO1xyXG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9jdXN0b21pemFibGVcIiksIGV4cG9ydHMpO1xyXG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9kb21cIiksIGV4cG9ydHMpO1xyXG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9mb2N1c1wiKSwgZXhwb3J0cyk7XHJcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2hvaXN0XCIpLCBleHBvcnRzKTtcclxudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vaW5pdGlhbHNcIiksIGV4cG9ydHMpO1xyXG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9sYW5ndWFnZVwiKSwgZXhwb3J0cyk7XHJcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL21hdGhcIiksIGV4cG9ydHMpO1xyXG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9tZW1vaXplXCIpLCBleHBvcnRzKTtcclxudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vb2JqZWN0XCIpLCBleHBvcnRzKTtcclxudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vb3ZlcmZsb3dcIiksIGV4cG9ydHMpO1xyXG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9wcm9wZXJ0aWVzXCIpLCBleHBvcnRzKTtcclxudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vcmVzb3VyY2VzXCIpLCBleHBvcnRzKTtcclxudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vcnRsXCIpLCBleHBvcnRzKTtcclxudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vc2Nyb2xsXCIpLCBleHBvcnRzKTtcclxudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vc3RyaW5nXCIpLCBleHBvcnRzKTtcclxudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vc3R5bGVkXCIpLCBleHBvcnRzKTtcclxudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vd2FyblwiKSwgZXhwb3J0cyk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbi8qKlxyXG4gKiBSZWd1bGFyIGV4cHJlc3Npb24gbWF0Y2hpbmcgY2hhcmFjdGVycyB0byBpZ25vcmUgd2hlbiBjYWxjdWxhdGluZyB0aGUgaW5pdGlhbHMuXHJcbiAqIFRoZSBmaXJzdCBwYXJ0IG1hdGNoZXMgY2hhcmFjdGVycyB3aXRoaW4gcGFyZW50aGVzaXMsIGluY2x1ZGluZyB0aGUgcGFyZW50aGVzaXMuXHJcbiAqIFRoZSBzZWNvbmQgcGFydCBtYXRjaGVzIHNwZWNpYWwgQVNDSUkgY2hhcmFjdGVycyBleGNlcHQgc3BhY2UsIHBsdXMgc29tZSB1bmljb2RlIHNwZWNpYWwgY2hhcmFjdGVycy5cclxuICovXHJcbnZhciBVTldBTlRFRF9DSEFSU19SRUdFWCA9IC9cXChbXildKlxcKXxbXFwwLVxcdTAwMUZcXCEtLzotQFxcWy1gXFx7LVxcdTAwQkZcXHUwMjUwLVxcdTAzNkZcXHVEODAwLVxcdUZGRkZdL2c7XHJcbi8qKiBSZWd1bGFyIGV4cHJlc3Npb24gbWF0Y2hpbmcgb25lIG9yIG1vcmUgc3BhY2VzLiAqL1xyXG52YXIgTVVMVElQTEVfV0hJVEVTUEFDRVNfUkVHRVggPSAvXFxzKy9nO1xyXG4vKipcclxuICogUmVndWxhciBleHByZXNzaW9uIG1hdGNoaW5nIGxhbmd1YWdlcyBmb3Igd2hpY2ggd2UgY3VycmVudGx5IGRvbid0IHN1cHBvcnQgaW5pdGlhbHMuXHJcbiAqIEFyYWJpYzogICBBcmFiaWMsIEFyYWJpYyBTdXBwbGVtZW50LCBBcmFiaWMgRXh0ZW5kZWQtQS5cclxuICogS29yZWFuOiAgIEhhbmd1bCBKYW1vLCBIYW5ndWwgQ29tcGF0aWJpbGl0eSBKYW1vLCBIYW5ndWwgSmFtbyBFeHRlbmRlZC1BLCBIYW5ndWwgU3lsbGFibGVzLCBIYW5ndWwgSmFtbyBFeHRlbmRlZC1CLlxyXG4gKiBKYXBhbmVzZTogSGlyYWdhbmEsIEthdGFrYW5hLlxyXG4gKiBDSks6ICAgICAgQ0pLIFVuaWZpZWQgSWRlb2dyYXBocyBFeHRlbnNpb24gQSwgQ0pLIFVuaWZpZWQgSWRlb2dyYXBocywgQ0pLIENvbXBhdGliaWxpdHkgSWRlb2dyYXBocywgQ0pLIFVuaWZpZWQgSWRlb2dyYXBocyBFeHRlbnNpb24gQlxyXG4gKi9cclxuLyogdHNsaW50OmRpc2FibGU6bWF4LWxpbmUtbGVuZ3RoICovXHJcbnZhciBVTlNVUFBPUlRFRF9URVhUX1JFR0VYID0gL1tcXHUwNjAwLVxcdTA2RkZcXHUwNzUwLVxcdTA3N0ZcXHUwOEEwLVxcdTA4RkZcXHUxMTAwLVxcdTExRkZcXHUzMTMwLVxcdTMxOEZcXHVBOTYwLVxcdUE5N0ZcXHVBQzAwLVxcdUQ3QUZcXHVEN0IwLVxcdUQ3RkZcXHUzMDQwLVxcdTMwOUZcXHUzMEEwLVxcdTMwRkZcXHUzNDAwLVxcdTREQkZcXHU0RTAwLVxcdTlGRkZcXHVGOTAwLVxcdUZBRkZdfFtcXHVEODQwLVxcdUQ4NjldW1xcdURDMDAtXFx1REVENl0vO1xyXG4vKiB0c2xpbnQ6ZW5hYmxlOm1heC1saW5lLWxlbmd0aCAqL1xyXG5mdW5jdGlvbiBnZXRJbml0aWFsc0xhdGluKGRpc3BsYXlOYW1lLCBpc1J0bCkge1xyXG4gICAgdmFyIGluaXRpYWxzID0gJyc7XHJcbiAgICB2YXIgc3BsaXRzID0gZGlzcGxheU5hbWUuc3BsaXQoJyAnKTtcclxuICAgIGlmIChzcGxpdHMubGVuZ3RoID09PSAyKSB7XHJcbiAgICAgICAgaW5pdGlhbHMgKz0gc3BsaXRzWzBdLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpO1xyXG4gICAgICAgIGluaXRpYWxzICs9IHNwbGl0c1sxXS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKHNwbGl0cy5sZW5ndGggPT09IDMpIHtcclxuICAgICAgICBpbml0aWFscyArPSBzcGxpdHNbMF0uY2hhckF0KDApLnRvVXBwZXJDYXNlKCk7XHJcbiAgICAgICAgaW5pdGlhbHMgKz0gc3BsaXRzWzJdLmNoYXJBdCgwKS50b1VwcGVyQ2FzZSgpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoc3BsaXRzLmxlbmd0aCAhPT0gMCkge1xyXG4gICAgICAgIGluaXRpYWxzICs9IHNwbGl0c1swXS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKTtcclxuICAgIH1cclxuICAgIGlmIChpc1J0bCAmJiBpbml0aWFscy5sZW5ndGggPiAxKSB7XHJcbiAgICAgICAgcmV0dXJuIGluaXRpYWxzLmNoYXJBdCgxKSArIGluaXRpYWxzLmNoYXJBdCgwKTtcclxuICAgIH1cclxuICAgIHJldHVybiBpbml0aWFscztcclxufVxyXG5mdW5jdGlvbiBjbGVhbnVwRGlzcGxheU5hbWUoZGlzcGxheU5hbWUpIHtcclxuICAgIGRpc3BsYXlOYW1lID0gZGlzcGxheU5hbWUucmVwbGFjZShVTldBTlRFRF9DSEFSU19SRUdFWCwgJycpO1xyXG4gICAgZGlzcGxheU5hbWUgPSBkaXNwbGF5TmFtZS5yZXBsYWNlKE1VTFRJUExFX1dISVRFU1BBQ0VTX1JFR0VYLCAnICcpO1xyXG4gICAgZGlzcGxheU5hbWUgPSBkaXNwbGF5TmFtZS50cmltKCk7XHJcbiAgICByZXR1cm4gZGlzcGxheU5hbWU7XHJcbn1cclxuLyoqXHJcbiAqIEdldCAodXAgdG8gMiBjaGFyYWN0ZXJzKSBpbml0aWFscyBiYXNlZCBvbiBkaXNwbGF5IG5hbWUgb2YgdGhlIHBlcnNvbmEuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmZ1bmN0aW9uIGdldEluaXRpYWxzKGRpc3BsYXlOYW1lLCBpc1J0bCkge1xyXG4gICAgaWYgKCFkaXNwbGF5TmFtZSkge1xyXG4gICAgICAgIHJldHVybiAnJztcclxuICAgIH1cclxuICAgIGRpc3BsYXlOYW1lID0gY2xlYW51cERpc3BsYXlOYW1lKGRpc3BsYXlOYW1lKTtcclxuICAgIGlmIChVTlNVUFBPUlRFRF9URVhUX1JFR0VYLnRlc3QoZGlzcGxheU5hbWUpKSB7XHJcbiAgICAgICAgcmV0dXJuICcnO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGdldEluaXRpYWxzTGF0aW4oZGlzcGxheU5hbWUsIGlzUnRsKTtcclxufVxyXG5leHBvcnRzLmdldEluaXRpYWxzID0gZ2V0SW5pdGlhbHM7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluaXRpYWxzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBkb21fMSA9IHJlcXVpcmUoXCIuL2RvbVwiKTtcclxudmFyIGxvY2FsU3RvcmFnZV8xID0gcmVxdWlyZShcIi4vbG9jYWxTdG9yYWdlXCIpO1xyXG4vLyBEZWZhdWx0IHRvIHVuZGVmaW5lZCBzbyB0aGF0IHdlIGluaXRpYWxpemUgb24gZmlyc3QgcmVhZC5cclxudmFyIF9sYW5ndWFnZTtcclxuLyoqXHJcbiAqIEdldHMgdGhlIHJ0bCBzdGF0ZSBvZiB0aGUgcGFnZSAocmV0dXJucyB0cnVlIGlmIGluIHJ0bC4pXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmZ1bmN0aW9uIGdldExhbmd1YWdlKCkge1xyXG4gICAgaWYgKF9sYW5ndWFnZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgdmFyIGRvYyA9IGRvbV8xLmdldERvY3VtZW50KCk7XHJcbiAgICAgICAgdmFyIHNhdmVkTGFuZ3VhZ2UgPSBsb2NhbFN0b3JhZ2VfMS5nZXRJdGVtKCdsYW5ndWFnZScpO1xyXG4gICAgICAgIGlmIChzYXZlZExhbmd1YWdlICE9PSBudWxsKSB7XHJcbiAgICAgICAgICAgIF9sYW5ndWFnZSA9IHNhdmVkTGFuZ3VhZ2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChfbGFuZ3VhZ2UgPT09IHVuZGVmaW5lZCAmJiBkb2MpIHtcclxuICAgICAgICAgICAgX2xhbmd1YWdlID0gZG9jLmRvY3VtZW50RWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2xhbmcnKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKF9sYW5ndWFnZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIF9sYW5ndWFnZSA9ICdlbic7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIF9sYW5ndWFnZTtcclxufVxyXG5leHBvcnRzLmdldExhbmd1YWdlID0gZ2V0TGFuZ3VhZ2U7XHJcbi8qKlxyXG4gKiBTZXRzIHRoZSBydGwgc3RhdGUgb2YgdGhlIHBhZ2UgKGJ5IGFkanVzdGluZyB0aGUgZGlyIGF0dHJpYnV0ZSBvZiB0aGUgaHRtbCBlbGVtZW50LilcclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuZnVuY3Rpb24gc2V0TGFuZ3VhZ2UobGFuZ3VhZ2UsIGF2b2lkUGVyc2lzdGluZykge1xyXG4gICAgaWYgKGF2b2lkUGVyc2lzdGluZyA9PT0gdm9pZCAwKSB7IGF2b2lkUGVyc2lzdGluZyA9IGZhbHNlOyB9XHJcbiAgICB2YXIgZG9jID0gZG9tXzEuZ2V0RG9jdW1lbnQoKTtcclxuICAgIGlmIChkb2MpIHtcclxuICAgICAgICBkb2MuZG9jdW1lbnRFbGVtZW50LnNldEF0dHJpYnV0ZSgnbGFuZycsIGxhbmd1YWdlKTtcclxuICAgIH1cclxuICAgIGlmICghYXZvaWRQZXJzaXN0aW5nKSB7XHJcbiAgICAgICAgbG9jYWxTdG9yYWdlXzEuc2V0SXRlbSgnbGFuZ3VhZ2UnLCBsYW5ndWFnZSk7XHJcbiAgICB9XHJcbiAgICBfbGFuZ3VhZ2UgPSBsYW5ndWFnZTtcclxufVxyXG5leHBvcnRzLnNldExhbmd1YWdlID0gc2V0TGFuZ3VhZ2U7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWxhbmd1YWdlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbi8qKlxyXG4gKiBGZXRjaGVzIGFuIGl0ZW0gZnJvbSBsb2NhbCBzdG9yYWdlIHdpdGhvdXQgdGhyb3dpbmcgYW4gZXhjZXB0aW9uXHJcbiAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgaXRlbSB0byBmZXRjaCBmcm9tIGxvY2FsIHN0b3JhZ2VcclxuICovXHJcbmZ1bmN0aW9uIGdldEl0ZW0oa2V5KSB7XHJcbiAgICB2YXIgcmVzdWx0ID0gbnVsbDtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgcmVzdWx0ID0gd2luZG93LmxvY2FsU3RvcmFnZS5nZXRJdGVtKGtleSk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgIC8qIEVhdCB0aGUgZXhjZXB0aW9uICovXHJcbiAgICB9XHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG59XHJcbmV4cG9ydHMuZ2V0SXRlbSA9IGdldEl0ZW07XHJcbi8qKlxyXG4gKiBJbnNlcnRzIGFuIGl0ZW0gaW50byBsb2NhbCBzdG9yYWdlIHdpdGhvdXQgdGhyb3dpbmcgYW4gZXhjZXB0aW9uXHJcbiAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgaXRlbSB0byBhZGQgdG8gbG9jYWwgc3RvcmFnZVxyXG4gKiBAcGFyYW0gZGF0YSBUaGUgZGF0YSB0byBwdXQgaW50byBsb2NhbCBzdG9yYWdlXHJcbiAqL1xyXG5mdW5jdGlvbiBzZXRJdGVtKGtleSwgZGF0YSkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICB3aW5kb3cubG9jYWxTdG9yYWdlLnNldEl0ZW0oa2V5LCBkYXRhKTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgLyogRWF0IHRoZSBleGNlcHRpb24gKi9cclxuICAgIH1cclxufVxyXG5leHBvcnRzLnNldEl0ZW0gPSBzZXRJdGVtO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1sb2NhbFN0b3JhZ2UuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuLyoqXHJcbiAqIERldGVybWluZXMgdGhlIGRpc3RhbmNlIGJldHdlZW4gdHdvIHBvaW50cy5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuZnVuY3Rpb24gZ2V0RGlzdGFuY2VCZXR3ZWVuUG9pbnRzKHBvaW50MSwgcG9pbnQyKSB7XHJcbiAgICB2YXIgZGlzdGFuY2UgPSBNYXRoLnNxcnQoTWF0aC5wb3cocG9pbnQxLnggLSBwb2ludDIueCwgMikgKyBNYXRoLnBvdyhwb2ludDEueSAtIHBvaW50Mi55LCAyKSk7XHJcbiAgICByZXR1cm4gZGlzdGFuY2U7XHJcbn1cclxuZXhwb3J0cy5nZXREaXN0YW5jZUJldHdlZW5Qb2ludHMgPSBnZXREaXN0YW5jZUJldHdlZW5Qb2ludHM7XHJcbi8qKlxyXG4gKiBQcm9kdWNlcyBhIHByb3BvcnRpb25hbGx5LXNjYWxlZCB2ZXJzaW9uIG9mIGFuIGlucHV0IGNvbnRlbnQgc2l6ZSB3aGVuIGZpdCB0byBhIGJvdW5kaW5nIHNpemUuXHJcbiAqIEdpdmVuIGEgYGNvbnRlbnRTaXplYCBhbmQgYSBgYm91bmRzU2l6ZWAsIHRoaXMgZnVuY3Rpb24gc2NhbGVzIGBjb250ZW50U2l6ZWAgcHJvcG9ydGlvbmFsbHlcclxuICogdXNpbmcgZWl0aGVyIGBjb250YWluYCBvciBgY292ZXJgIGZpdCBiZWhhdmlvcnMuXHJcbiAqIFVzZSB0aGlzIGZ1bmN0aW9uIHRvIHByZS1jYWxjdWxhdGUgdGhlIGxheW91dCBmb3IgdGhlIENTUyBgb2JqZWN0LWZpdGAgYW5kIGBiYWNrZ3JvdW5kLWZpdGAgYmVoYXZpb3JzLlxyXG4gKiBXaXRoIGBjb250YWluYCwgdGhlIG91dHB1dCBzaXplIG11c3QgYmUgdGhlIGxhcmdlc3QgaXQgY2FuIGJlIHdoaWxlIGNvbXBsZXRlbHkgd2l0aGluIHRoZSBgYm91bmRzU2l6ZWAuXHJcbiAqIFdpdGggYGNvdmVyYCwgdGhlIG91dHB1dCBzaXplIG11c3QgYmUgdGhlIHNtYWxsZXN0IGl0IGNhbiBiZSB3aGlsZSBjb21wbGV0ZWx5IGFyb3VuZCB0aGUgYGJvdW5kc1NpemVgLlxyXG4gKiBCeSBkZWZhdWx0LCB0aGVyZSBpcyBhIGBtYXhTY2FsZWAgdmFsdWUgb2YgMSwgd2hpY2ggcHJldmVudHMgdGhlIGBjb250ZW50U2l6ZWAgZnJvbSBiZWluZyBzY2FsZWQgbGFyZ2VyLlxyXG4gKlxyXG4gKiBAcGFyYW0gb3B0aW9ucyB0aGUgb3B0aW9ucyBmb3IgdGhlIGJvdW5kcyBmaXQgb3BlcmF0aW9uXHJcbiAqL1xyXG5mdW5jdGlvbiBmaXRDb250ZW50VG9Cb3VuZHMob3B0aW9ucykge1xyXG4gICAgdmFyIGNvbnRlbnRTaXplID0gb3B0aW9ucy5jb250ZW50U2l6ZSwgYm91bmRzU2l6ZSA9IG9wdGlvbnMuYm91bmRzU2l6ZSwgX2EgPSBvcHRpb25zLm1vZGUsIG1vZGUgPSBfYSA9PT0gdm9pZCAwID8gJ2NvbnRhaW4nIDogX2EsIF9iID0gb3B0aW9ucy5tYXhTY2FsZSwgbWF4U2NhbGUgPSBfYiA9PT0gdm9pZCAwID8gMSA6IF9iO1xyXG4gICAgdmFyIGNvbnRlbnRBc3BlY3RSYXRpbyA9IGNvbnRlbnRTaXplLndpZHRoIC8gY29udGVudFNpemUuaGVpZ2h0O1xyXG4gICAgdmFyIGJvdW5kc0FzcGVjdFJhdGlvID0gYm91bmRzU2l6ZS53aWR0aCAvIGJvdW5kc1NpemUuaGVpZ2h0O1xyXG4gICAgdmFyIHNjYWxlO1xyXG4gICAgaWYgKG1vZGUgPT09ICdjb250YWluJyA/IGNvbnRlbnRBc3BlY3RSYXRpbyA+IGJvdW5kc0FzcGVjdFJhdGlvIDogY29udGVudEFzcGVjdFJhdGlvIDwgYm91bmRzQXNwZWN0UmF0aW8pIHtcclxuICAgICAgICBzY2FsZSA9IGJvdW5kc1NpemUud2lkdGggLyBjb250ZW50U2l6ZS53aWR0aDtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHNjYWxlID0gYm91bmRzU2l6ZS5oZWlnaHQgLyBjb250ZW50U2l6ZS5oZWlnaHQ7XHJcbiAgICB9XHJcbiAgICB2YXIgZmluYWxTY2FsZSA9IE1hdGgubWluKG1heFNjYWxlLCBzY2FsZSk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHdpZHRoOiBjb250ZW50U2l6ZS53aWR0aCAqIGZpbmFsU2NhbGUsXHJcbiAgICAgICAgaGVpZ2h0OiBjb250ZW50U2l6ZS5oZWlnaHQgKiBmaW5hbFNjYWxlXHJcbiAgICB9O1xyXG59XHJcbmV4cG9ydHMuZml0Q29udGVudFRvQm91bmRzID0gZml0Q29udGVudFRvQm91bmRzO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1tYXRoLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBfZW1wdHlPYmplY3QgPSB7IGVtcHR5OiB0cnVlIH07XHJcbnZhciBfZGljdGlvbmFyeSA9IHt9O1xyXG52YXIgX3dlYWtNYXAgPSAodHlwZW9mIFdlYWtNYXAgPT09ICd1bmRlZmluZWQnKSA/IG51bGwgOiBXZWFrTWFwO1xyXG4vKipcclxuICogIFRlc3QgdXRpbGl0eSBmb3IgcHJvdmlkaW5nIGEgY3VzdG9tIHdlYWttYXAuXHJcbiAqXHJcbiAqIEBpbnRlcm5hbFxyXG4gKiAqL1xyXG5mdW5jdGlvbiBzZXRNZW1vaXplV2Vha01hcCh3ZWFrTWFwKSB7XHJcbiAgICBfd2Vha01hcCA9IHdlYWtNYXA7XHJcbn1cclxuZXhwb3J0cy5zZXRNZW1vaXplV2Vha01hcCA9IHNldE1lbW9pemVXZWFrTWFwO1xyXG4vKipcclxuICogTWVtb2l6ZSBkZWNvcmF0b3IgdG8gYmUgdXNlZCBvbiBjbGFzcyBtZXRob2RzLiBOb3RlIHRoYXQgdGhlIFwidGhpc1wiIHJlZmVyZW5jZVxyXG4gKiB3aWxsIGJlIGluYWNjZXNzaWJsZSB3aXRoaW4gYSBtZW1vaXplZCBtZXRob2QsIGdpdmVuIHRoYXQgYSBjYWNoZWQgbWV0aG9kJ3MgdGhpc1xyXG4gKiB3b3VsZCBub3QgYmUgaW5zdGFuY2Ugc3BlY2lmaWMuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmZ1bmN0aW9uIG1lbW9pemUodGFyZ2V0LCBrZXksIGRlc2NyaXB0b3IpIHtcclxuICAgIC8vIFdlIGJpbmQgdG8gXCJudWxsXCIgdG8gcHJldmVudCBwZW9wbGUgZnJvbSBpbmFkdmVydGVudGx5IHB1bGxpbmcgdmFsdWVzIGZyb20gXCJ0aGlzXCIsXHJcbiAgICAvLyByYXRoZXIgdGhhbiBwYXNzaW5nIHRoZW0gaW4gYXMgaW5wdXQgdmFsdWVzIHdoaWNoIGNhbiBiZSBtZW1vaXplZC5cclxuICAgIHZhciBmbiA9IG1lbW9pemVGdW5jdGlvbihkZXNjcmlwdG9yLnZhbHVlICYmIGRlc2NyaXB0b3IudmFsdWUuYmluZChudWxsKSk7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZuO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cclxuZXhwb3J0cy5tZW1vaXplID0gbWVtb2l6ZTtcclxuLyoqXHJcbiAqIE1lbW9pemVzIGEgZnVuY3Rpb247IHdoZW4geW91IHBhc3MgaW4gdGhlIHNhbWUgcGFyYW1ldGVycyBtdWx0aXBsZSB0aW1lcywgaXQgcmV0dXJucyBhIGNhY2hlZCByZXN1bHQuXHJcbiAqIEJlIGNhcmVmdWwgd2hlbiBwYXNzaW5nIGluIG9iamVjdHMsIHlvdSBuZWVkIHRvIHBhc3MgaW4gdGhlIHNhbWUgSU5TVEFOQ0UgZm9yIGNhY2hpbmcgdG8gd29yay4gT3RoZXJ3aXNlXHJcbiAqIGl0IHdpbGwgZ3JvdyB0aGUgY2FjaGUgdW5uZWNlc3NhcmlseS4gQWxzbyBhdm9pZCB1c2luZyBkZWZhdWx0IHZhbHVlcyB0aGF0IGV2YWx1YXRlIGZ1bmN0aW9uczsgcGFzc2luZyBpblxyXG4gKiB1bmRlZmluZWQgZm9yIGEgdmFsdWUgYW5kIHJlbHlpbmcgb24gYSBkZWZhdWx0IGZ1bmN0aW9uIHdpbGwgZXhlY3V0ZSBpdCB0aGUgZmlyc3QgdGltZSwgYnV0IHdpbGwgbm90XHJcbiAqIHJlLWV2YWx1YXRlIHN1YnNlcXVlbnQgdGltZXMgd2hpY2ggbWF5IGhhdmUgYmVlbiB1bmV4cGVjdGVkLlxyXG4gKlxyXG4gKiBCeSBkZWZhdWx0LCB0aGUgY2FjaGUgd2lsbCByZXNldCBhZnRlciAxMDAgcGVybXV0YXRpb25zLCB0byBhdm9pZCBhYnVzZSBjYXNlcyB3aGVyZSB0aGUgZnVuY3Rpb24gaXNcclxuICogdW5pbnRlbmRlZGx5IGNhbGxlZCB3aXRoIHVuaXF1ZSBvYmplY3RzLiBXaXRob3V0IGEgcmVzZXQsIHRoZSBjYWNoZSBjb3VsZCBncm93IGluZmluaXRlbHksIHNvIHdlIHNhZmVndWFyZFxyXG4gKiBieSByZXNldHRpbmcuIFRvIG92ZXJyaWRlIHRoaXMgYmVoYXZpb3IsIHBhc3MgYSB2YWx1ZSBvZiAwIHRvIHRoZSBtYXhDYWNoZVNpemUgcGFyYW1ldGVyLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqIEBwYXJhbSBjYiAtIFRoZSBmdW5jdGlvbiB0byBtZW1vaXplLlxyXG4gKiBAcGFyYW0gbWF4Q2FjaGVTaXplIC0gTWF4IHJlc3VsdHMgdG8gY2FjaGUuIElmIHRoZSBjYWNoZSBleGNlZWRzIHRoaXMgdmFsdWUsIGl0IHdpbGwgcmVzZXQgb24gdGhlIG5leHQgY2FsbC5cclxuICogQHJldHVybnMgQSBtZW1vaXplZCB2ZXJzaW9uIG9mIHRoZSBmdW5jdGlvbi5cclxuICovXHJcbmZ1bmN0aW9uIG1lbW9pemVGdW5jdGlvbihjYiwgbWF4Q2FjaGVTaXplKSB7XHJcbiAgICBpZiAobWF4Q2FjaGVTaXplID09PSB2b2lkIDApIHsgbWF4Q2FjaGVTaXplID0gMTAwOyB9XHJcbiAgICB2YXIgcm9vdE5vZGU7XHJcbiAgICB2YXIgY2FjaGVTaXplID0gMDtcclxuICAgIC8vIEF2b2lkIGJyZWFraW5nIHNjZW5hcmlvcyB3aGljaCBkb24ndCBoYXZlIHdlYWsgbWFwLlxyXG4gICAgaWYgKCFfd2Vha01hcCkge1xyXG4gICAgICAgIHJldHVybiBjYjtcclxuICAgIH1cclxuICAgIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1mdW5jdGlvbi1leHByZXNzaW9uXHJcbiAgICByZXR1cm4gZnVuY3Rpb24gbWVtb2l6ZWRGdW5jdGlvbigpIHtcclxuICAgICAgICB2YXIgYXJncyA9IFtdO1xyXG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGN1cnJlbnROb2RlID0gcm9vdE5vZGU7XHJcbiAgICAgICAgaWYgKHJvb3ROb2RlID09PSB1bmRlZmluZWQgfHwgKG1heENhY2hlU2l6ZSA+IDAgJiYgY2FjaGVTaXplID4gbWF4Q2FjaGVTaXplKSkge1xyXG4gICAgICAgICAgICByb290Tm9kZSA9IF9jcmVhdGVOb2RlKCk7XHJcbiAgICAgICAgICAgIGNhY2hlU2l6ZSA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGN1cnJlbnROb2RlID0gcm9vdE5vZGU7XHJcbiAgICAgICAgLy8gVHJhdmVyc2UgdGhlIHRyZWUgdW50aWwgd2UgZmluZCB0aGUgbWF0Y2guXHJcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIHZhciBhcmcgPSBfbm9ybWFsaXplQXJnKGFyZ3NbaV0pO1xyXG4gICAgICAgICAgICBpZiAoIWN1cnJlbnROb2RlLm1hcC5oYXMoYXJnKSkge1xyXG4gICAgICAgICAgICAgICAgY3VycmVudE5vZGUubWFwLnNldChhcmcsIF9jcmVhdGVOb2RlKCkpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGN1cnJlbnROb2RlID0gY3VycmVudE5vZGUubWFwLmdldChhcmcpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoIWN1cnJlbnROb2RlLmhhc093blByb3BlcnR5KCd2YWx1ZScpKSB7XHJcbiAgICAgICAgICAgIGN1cnJlbnROb2RlLnZhbHVlID0gY2IuYXBwbHkodm9pZCAwLCBhcmdzKTtcclxuICAgICAgICAgICAgY2FjaGVTaXplKys7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBjdXJyZW50Tm9kZS52YWx1ZTtcclxuICAgIH07XHJcbn1cclxuZXhwb3J0cy5tZW1vaXplRnVuY3Rpb24gPSBtZW1vaXplRnVuY3Rpb247XHJcbmZ1bmN0aW9uIF9ub3JtYWxpemVBcmcodmFsKSB7XHJcbiAgICBpZiAoIXZhbCkge1xyXG4gICAgICAgIHJldHVybiBfZW1wdHlPYmplY3Q7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlb2YgdmFsID09PSAnb2JqZWN0Jykge1xyXG4gICAgICAgIHJldHVybiB2YWw7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICghX2RpY3Rpb25hcnlbdmFsXSkge1xyXG4gICAgICAgIF9kaWN0aW9uYXJ5W3ZhbF0gPSB7IHZhbDogdmFsIH07XHJcbiAgICB9XHJcbiAgICByZXR1cm4gX2RpY3Rpb25hcnlbdmFsXTtcclxufVxyXG5mdW5jdGlvbiBfY3JlYXRlTm9kZSgpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgbWFwOiBfd2Vha01hcCA/IG5ldyBfd2Vha01hcCgpIDogbnVsbFxyXG4gICAgfTtcclxufVxyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1tZW1vaXplLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbi8vIEluaXRpYWxpemUgZ2xvYmFsIHdpbmRvdyBpZC5cclxudmFyIENVUlJFTlRfSURfUFJPUEVSVFkgPSAnX19jdXJyZW50SWRfXyc7XHJcbnZhciBERUZBVUxUX0lEX1NUUklORyA9ICdpZF9fJztcclxuLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueVxyXG52YXIgX2dsb2JhbCA9ICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cpIHx8IHByb2Nlc3M7XHJcbmlmIChfZ2xvYmFsW0NVUlJFTlRfSURfUFJPUEVSVFldID09PSB1bmRlZmluZWQpIHtcclxuICAgIF9nbG9iYWxbQ1VSUkVOVF9JRF9QUk9QRVJUWV0gPSAwO1xyXG59XHJcbi8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1hbnlcclxuZnVuY3Rpb24gY2hlY2tQcm9wZXJ0aWVzKGEsIGIpIHtcclxuICAgIGZvciAodmFyIHByb3BOYW1lIGluIGEpIHtcclxuICAgICAgICBpZiAoYS5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcclxuICAgICAgICAgICAgaWYgKCFiLmhhc093blByb3BlcnR5KHByb3BOYW1lKSB8fCAoYltwcm9wTmFtZV0gIT09IGFbcHJvcE5hbWVdKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcmV0dXJuIHRydWU7XHJcbn1cclxuLyoqXHJcbiAqIENvbXBhcmVzIGEgdG8gYiBhbmQgYiB0byBhLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5mdW5jdGlvbiBzaGFsbG93Q29tcGFyZShhLCBiKSB7XHJcbiAgICByZXR1cm4gY2hlY2tQcm9wZXJ0aWVzKGEsIGIpICYmIGNoZWNrUHJvcGVydGllcyhiLCBhKTtcclxufVxyXG5leHBvcnRzLnNoYWxsb3dDb21wYXJlID0gc2hhbGxvd0NvbXBhcmU7XHJcbi8qKlxyXG4gKiBNYWtlcyBhIHJlc3VsdGluZyBtZXJnZSBvZiBhIGJ1bmNoIG9mIG9iamVjdHMuIFBhc3MgaW4gdGhlIHRhcmdldCBvYmplY3QgZm9sbG93ZWQgYnkgMSBvciBtb3JlXHJcbiAqIG9iamVjdHMgYXMgYXJndW1lbnRzIGFuZCB0aGV5IHdpbGwgYmUgbWVyZ2VkIHNlcXVlbnRpYWxseSBpbnRvIHRoZSB0YXJnZXQuIE5vdGUgdGhhdCB0aGlzIHdpbGxcclxuICogc2hhbGxvdyBtZXJnZTsgaXQgd2lsbCBub3QgY3JlYXRlIG5ldyBjbG9uZWQgdmFsdWVzIGZvciB0YXJnZXQgbWVtYmVycy5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKiBAcGFyYW0gdGFyZ2V0IC0gVGFyZ2V0IG9iamVjdCB0byBtZXJnZSBmb2xsb3dpbmcgb2JqZWN0IGFyZ3VtZW50cyBpbnRvLlxyXG4gKiBAcGFyYW0gYXJncyAtIE9uZSBvciBtb3JlIG9iamVjdHMgdGhhdCB3aWxsIGJlIG1peGVkIGludG8gdGhlIHRhcmdldCBpbiB0aGUgb3JkZXIgdGhleSBhcmUgcHJvdmlkZWQuXHJcbiAqIEByZXR1cm5zIFJlc3VsdGluZyBtZXJnZWQgdGFyZ2V0LlxyXG4gKi9cclxuLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueVxyXG5mdW5jdGlvbiBhc3NpZ24odGFyZ2V0KSB7XHJcbiAgICB2YXIgYXJncyA9IFtdO1xyXG4gICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICBhcmdzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZpbHRlcmVkQXNzaWduLmFwcGx5KHRoaXMsIFtudWxsLCB0YXJnZXRdLmNvbmNhdChhcmdzKSk7XHJcbn1cclxuZXhwb3J0cy5hc3NpZ24gPSBhc3NpZ247XHJcbi8qKlxyXG4gKiBNYWtlcyBhIHJlc3VsdGluZyBtZXJnZSBvZiBhIGJ1bmNoIG9mIG9iamVjdHMsIGJ1dCBhbGxvd3MgYSBmaWx0ZXIgZnVuY3Rpb24gdG8gYmUgcGFzc2VkIGluIHRvIGZpbHRlclxyXG4gKiB0aGUgcmVzdWx0aW5nIG1lcmdlcy4gVGhpcyBhbGxvd3MgZm9yIHNjZW5hcmlvcyB3aGVyZSB5b3Ugd2FudCB0byBtZXJnZSBcImV2ZXJ5dGhpbmcgZXhjZXB0IHRoYXQgb25lIHRoaW5nXCJcclxuICogb3IgXCJwcm9wZXJ0aWVzIHRoYXQgc3RhcnQgd2l0aCBkYXRhLVwiLiBOb3RlIHRoYXQgdGhpcyB3aWxsIHNoYWxsb3cgbWVyZ2U7IGl0IHdpbGwgbm90IGNyZWF0ZSBuZXcgY2xvbmVkXHJcbiAqIHZhbHVlcyBmb3IgdGFyZ2V0IG1lbWJlcnMuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICogQHBhcmFtIGlzQWxsb3dlZCAtIENhbGxiYWNrIHRvIGRldGVybWluZSBpZiB0aGUgZ2l2ZW4gcHJvcE5hbWUgaXMgYWxsb3dlZCBpbiB0aGUgcmVzdWx0LlxyXG4gKiBAcGFyYW0gdGFyZ2V0IC0gVGFyZ2V0IG9iamVjdCB0byBtZXJnZSBmb2xsb3dpbmcgb2JqZWN0IGFyZ3VtZW50cyBpbnRvLlxyXG4gKiBAcGFyYW0gYXJncyAtIE9uZSBvciBtb3JlIG9iamVjdHMgdGhhdCB3aWxsIGJlIG1peGVkIGludG8gdGhlIHRhcmdldCBpbiB0aGUgb3JkZXIgdGhleSBhcmUgcHJvdmlkZWQuXHJcbiAqIEByZXR1cm5zIFJlc3VsdGluZyBtZXJnZWQgdGFyZ2V0LlxyXG4gKi9cclxuLy8gdHNsaW50OmRpc2FibGUtbmV4dC1saW5lOm5vLWFueVxyXG5mdW5jdGlvbiBmaWx0ZXJlZEFzc2lnbihpc0FsbG93ZWQsIHRhcmdldCkge1xyXG4gICAgdmFyIGFyZ3MgPSBbXTtcclxuICAgIGZvciAodmFyIF9pID0gMjsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgYXJnc1tfaSAtIDJdID0gYXJndW1lbnRzW19pXTtcclxuICAgIH1cclxuICAgIHRhcmdldCA9IHRhcmdldCB8fCB7fTtcclxuICAgIGZvciAodmFyIF9hID0gMCwgYXJnc18xID0gYXJnczsgX2EgPCBhcmdzXzEubGVuZ3RoOyBfYSsrKSB7XHJcbiAgICAgICAgdmFyIHNvdXJjZU9iamVjdCA9IGFyZ3NfMVtfYV07XHJcbiAgICAgICAgaWYgKHNvdXJjZU9iamVjdCkge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiBzb3VyY2VPYmplY3QpIHtcclxuICAgICAgICAgICAgICAgIGlmIChzb3VyY2VPYmplY3QuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpICYmXHJcbiAgICAgICAgICAgICAgICAgICAgKCFpc0FsbG93ZWQgfHwgaXNBbGxvd2VkKHByb3BOYW1lKSkpIHtcclxuICAgICAgICAgICAgICAgICAgICB0YXJnZXRbcHJvcE5hbWVdID0gc291cmNlT2JqZWN0W3Byb3BOYW1lXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0YXJnZXQ7XHJcbn1cclxuZXhwb3J0cy5maWx0ZXJlZEFzc2lnbiA9IGZpbHRlcmVkQXNzaWduO1xyXG4vKipcclxuICogR2VuZXJhdGVzIGEgdW5pcXVlIGlkIGluIHRoZSBnbG9iYWwgc2NvcGUgKHRoaXMgc3BhbnMgYWNyb3NzIGR1cGxpY2F0ZSBjb3BpZXMgb2YgdGhlIHNhbWUgbGlicmFyeS4pXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmZ1bmN0aW9uIGdldElkKHByZWZpeCkge1xyXG4gICAgdmFyIGluZGV4ID0gX2dsb2JhbFtDVVJSRU5UX0lEX1BST1BFUlRZXSsrO1xyXG4gICAgcmV0dXJuIChwcmVmaXggfHwgREVGQVVMVF9JRF9TVFJJTkcpICsgaW5kZXg7XHJcbn1cclxuZXhwb3J0cy5nZXRJZCA9IGdldElkO1xyXG4vKiBUYWtlcyBhbiBlbnVtIGFuZCBpdGVyYXRlcyBvdmVyIGVhY2ggdmFsdWUgb2YgdGhlIGVudW0gKGFzIGEgc3RyaW5nKSwgcnVubmluZyB0aGUgY2FsbGJhY2sgb24gZWFjaCwgcmV0dXJuaW5nIGEgbWFwcGVkIGFycmF5LlxyXG4gKiBUaGUgY2FsbGJhY2sgdGFrZXMgYXMgYSBmaXJzdCBwYXJhbWV0ZXIgdGhlIHN0cmluZyB0aGF0IHJlcHJlc2VudHMgdGhlIG5hbWUgb2YgdGhlIGVudHJ5LCBhbmQgdGhlIHNlY29uZCBwYXJhbWV0ZXIgaXMgdGhlXHJcbiAqIHZhbHVlIG9mIHRoYXQgZW50cnksIHdoaWNoIGlzIHRoZSB2YWx1ZSB5b3UnZCBub3JtYWxseSB1c2Ugd2hlbiB1c2luZyB0aGUgZW51bSAodXN1YWxseSBhIG51bWJlcikuXHJcbiAqICovXHJcbmZ1bmN0aW9uIG1hcEVudW1CeU5hbWUoXHJcbiAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYW55XHJcbiAgICB0aGVFbnVtLCBjYWxsYmFjaykge1xyXG4gICAgLy8gbWFwPGFueT4gdG8gc2F0aXNmeSBjb21waWxlciBzaW5jZSBpdCBkb2Vzbid0IHJlYWxpemUgd2Ugc3RyaXAgb3V0IHVuZGVmaW5lZHMgaW4gdGhlIC5maWx0ZXIoKSBjYWxsXHJcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhlRW51bSkubWFwKGZ1bmN0aW9uIChwKSB7XHJcbiAgICAgICAgaWYgKFN0cmluZyhOdW1iZXIocCkpICE9PSBwKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBjYWxsYmFjayhwLCB0aGVFbnVtW3BdKTtcclxuICAgICAgICB9XHJcbiAgICB9KS5maWx0ZXIoZnVuY3Rpb24gKHYpIHsgcmV0dXJuICEhdjsgfSk7IC8vIG9ubHkgcmV0dXJuIGVsZW1lbnRzIHdpdGggdmFsdWVzXHJcbn1cclxuZXhwb3J0cy5tYXBFbnVtQnlOYW1lID0gbWFwRW51bUJ5TmFtZTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9b2JqZWN0LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbi8qKlxyXG4gKiBEZXRlY3RzIHdoZXRoZXIgYW4gZWxlbWVudCdzIGNvbnRlbnQgaGFzIGhvcml6b250YWwgb3ZlcmZsb3dcclxuICpcclxuICogQHB1YmxpY1xyXG4gKiBAcGFyYW0gZWxlbWVudCAtIEVsZW1lbnQgdG8gY2hlY2sgZm9yIG92ZXJmbG93XHJcbiAqIEByZXR1cm5zIFRydWUgaWYgZWxlbWVudCdzIGNvbnRlbnQgb3ZlcmZsb3dzXHJcbiAqL1xyXG5mdW5jdGlvbiBoYXNIb3Jpem9udGFsT3ZlcmZsb3coZWxlbWVudCkge1xyXG4gICAgcmV0dXJuIGVsZW1lbnQuY2xpZW50V2lkdGggPCBlbGVtZW50LnNjcm9sbFdpZHRoO1xyXG59XHJcbmV4cG9ydHMuaGFzSG9yaXpvbnRhbE92ZXJmbG93ID0gaGFzSG9yaXpvbnRhbE92ZXJmbG93O1xyXG4vKipcclxuICogRGV0ZWN0cyB3aGV0aGVyIGFuIGVsZW1lbnQncyBjb250ZW50IGhhcyB2ZXJ0aWNhbCBvdmVyZmxvd1xyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqIEBwYXJhbSBlbGVtZW50IC0gRWxlbWVudCB0byBjaGVjayBmb3Igb3ZlcmZsb3dcclxuICogQHJldHVybnMgVHJ1ZSBpZiBlbGVtZW50J3MgY29udGVudCBvdmVyZmxvd3NcclxuICovXHJcbmZ1bmN0aW9uIGhhc1ZlcnRpY2FsT3ZlcmZsb3coZWxlbWVudCkge1xyXG4gICAgcmV0dXJuIGVsZW1lbnQuY2xpZW50SGVpZ2h0IDwgZWxlbWVudC5zY3JvbGxIZWlnaHQ7XHJcbn1cclxuZXhwb3J0cy5oYXNWZXJ0aWNhbE92ZXJmbG93ID0gaGFzVmVydGljYWxPdmVyZmxvdztcclxuLyoqXHJcbiAqIERldGVjdHMgd2hldGhlciBhbiBlbGVtZW50J3MgY29udGVudCBoYXMgb3ZlcmZsb3cgaW4gYW55IGRpcmVjdGlvblxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqIEBwYXJhbSBlbGVtZW50IC0gRWxlbWVudCB0byBjaGVjayBmb3Igb3ZlcmZsb3dcclxuICogQHJldHVybnMgVHJ1ZSBpZiBlbGVtZW50J3MgY29udGVudCBvdmVyZmxvd3NcclxuICovXHJcbmZ1bmN0aW9uIGhhc092ZXJmbG93KGVsZW1lbnQpIHtcclxuICAgIHJldHVybiBoYXNIb3Jpem9udGFsT3ZlcmZsb3coZWxlbWVudCkgfHwgaGFzVmVydGljYWxPdmVyZmxvdyhlbGVtZW50KTtcclxufVxyXG5leHBvcnRzLmhhc092ZXJmbG93ID0gaGFzT3ZlcmZsb3c7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPW92ZXJmbG93LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBvYmplY3RfMSA9IHJlcXVpcmUoXCIuL29iamVjdFwiKTtcclxuLyoqXHJcbiAqIEFuIGFycmF5IG9mIGV2ZW50cyB0aGF0IGFyZSBhbGxvd2VkIG9uIGV2ZXJ5IGh0bWwgZWxlbWVudCB0eXBlLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5leHBvcnRzLmJhc2VFbGVtZW50RXZlbnRzID0gW1xyXG4gICAgJ29uQ29weScsXHJcbiAgICAnb25DdXQnLFxyXG4gICAgJ29uUGFzdGUnLFxyXG4gICAgJ29uQ29tcG9zaXRpb25FbmQnLFxyXG4gICAgJ29uQ29tcG9zaXRpb25TdGFydCcsXHJcbiAgICAnb25Db21wb3NpdGlvblVwZGF0ZScsXHJcbiAgICAnb25Gb2N1cycsXHJcbiAgICAnb25Gb2N1c0NhcHR1cmUnLFxyXG4gICAgJ29uQmx1cicsXHJcbiAgICAnb25CbHVyQ2FwdHVyZScsXHJcbiAgICAnb25DaGFuZ2UnLFxyXG4gICAgJ29uSW5wdXQnLFxyXG4gICAgJ29uU3VibWl0JyxcclxuICAgICdvbkxvYWQnLFxyXG4gICAgJ29uRXJyb3InLFxyXG4gICAgJ29uS2V5RG93bicsXHJcbiAgICAnb25LZXlEb3duQ2FwdHVyZScsXHJcbiAgICAnb25LZXlQcmVzcycsXHJcbiAgICAnb25LZXlVcCcsXHJcbiAgICAnb25BYm9ydCcsXHJcbiAgICAnb25DYW5QbGF5JyxcclxuICAgICdvbkNhblBsYXlUaHJvdWdoJyxcclxuICAgICdvbkR1cmF0aW9uQ2hhbmdlJyxcclxuICAgICdvbkVtcHRpZWQnLFxyXG4gICAgJ29uRW5jcnlwdGVkJyxcclxuICAgICdvbkVuZGVkJyxcclxuICAgICdvbkxvYWRlZERhdGEnLFxyXG4gICAgJ29uTG9hZGVkTWV0YWRhdGEnLFxyXG4gICAgJ29uTG9hZFN0YXJ0JyxcclxuICAgICdvblBhdXNlJyxcclxuICAgICdvblBsYXknLFxyXG4gICAgJ29uUGxheWluZycsXHJcbiAgICAnb25Qcm9ncmVzcycsXHJcbiAgICAnb25SYXRlQ2hhbmdlJyxcclxuICAgICdvblNlZWtlZCcsXHJcbiAgICAnb25TZWVraW5nJyxcclxuICAgICdvblN0YWxsZWQnLFxyXG4gICAgJ29uU3VzcGVuZCcsXHJcbiAgICAnb25UaW1lVXBkYXRlJyxcclxuICAgICdvblZvbHVtZUNoYW5nZScsXHJcbiAgICAnb25XYWl0aW5nJyxcclxuICAgICdvbkNsaWNrJyxcclxuICAgICdvbkNsaWNrQ2FwdHVyZScsXHJcbiAgICAnb25Db250ZXh0TWVudScsXHJcbiAgICAnb25Eb3VibGVDbGljaycsXHJcbiAgICAnb25EcmFnJyxcclxuICAgICdvbkRyYWdFbmQnLFxyXG4gICAgJ29uRHJhZ0VudGVyJyxcclxuICAgICdvbkRyYWdFeGl0JyxcclxuICAgICdvbkRyYWdMZWF2ZScsXHJcbiAgICAnb25EcmFnT3ZlcicsXHJcbiAgICAnb25EcmFnU3RhcnQnLFxyXG4gICAgJ29uRHJvcCcsXHJcbiAgICAnb25Nb3VzZURvd24nLFxyXG4gICAgJ29uTW91c2VEb3duQ2FwdHVyZScsXHJcbiAgICAnb25Nb3VzZUVudGVyJyxcclxuICAgICdvbk1vdXNlTGVhdmUnLFxyXG4gICAgJ29uTW91c2VNb3ZlJyxcclxuICAgICdvbk1vdXNlT3V0JyxcclxuICAgICdvbk1vdXNlT3ZlcicsXHJcbiAgICAnb25Nb3VzZVVwJyxcclxuICAgICdvbk1vdXNlVXBDYXB0dXJlJyxcclxuICAgICdvblNlbGVjdCcsXHJcbiAgICAnb25Ub3VjaENhbmNlbCcsXHJcbiAgICAnb25Ub3VjaEVuZCcsXHJcbiAgICAnb25Ub3VjaE1vdmUnLFxyXG4gICAgJ29uVG91Y2hTdGFydCcsXHJcbiAgICAnb25TY3JvbGwnLFxyXG4gICAgJ29uV2hlZWwnXHJcbl07XHJcbi8qKlxyXG4gKiBBbiBhcnJheSBvZiBlbGVtZW50IGF0dHJpYnV0ZXMgd2hpY2ggYXJlIGFsbG93ZWQgb24gZXZlcnkgaHRtbCBlbGVtZW50IHR5cGUuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmV4cG9ydHMuYmFzZUVsZW1lbnRQcm9wZXJ0aWVzID0gW1xyXG4gICAgJ2RlZmF1bHRDaGVja2VkJyxcclxuICAgICdkZWZhdWx0VmFsdWUnLFxyXG4gICAgJ2FjY2VwdCcsXHJcbiAgICAnYWNjZXB0Q2hhcnNldCcsXHJcbiAgICAnYWNjZXNzS2V5JyxcclxuICAgICdhY3Rpb24nLFxyXG4gICAgJ2FsbG93RnVsbFNjcmVlbicsXHJcbiAgICAnYWxsb3dUcmFuc3BhcmVuY3knLFxyXG4gICAgJ2FsdCcsXHJcbiAgICAnYXN5bmMnLFxyXG4gICAgJ2F1dG9Db21wbGV0ZScsXHJcbiAgICAnYXV0b0ZvY3VzJyxcclxuICAgICdhdXRvUGxheScsXHJcbiAgICAnY2FwdHVyZScsXHJcbiAgICAnY2VsbFBhZGRpbmcnLFxyXG4gICAgJ2NlbGxTcGFjaW5nJyxcclxuICAgICdjaGFyU2V0JyxcclxuICAgICdjaGFsbGVuZ2UnLFxyXG4gICAgJ2NoZWNrZWQnLFxyXG4gICAgJ2NoaWxkcmVuJyxcclxuICAgICdjbGFzc0lEJyxcclxuICAgICdjbGFzc05hbWUnLFxyXG4gICAgJ2NvbHMnLFxyXG4gICAgJ2NvbFNwYW4nLFxyXG4gICAgJ2NvbnRlbnQnLFxyXG4gICAgJ2NvbnRlbnRFZGl0YWJsZScsXHJcbiAgICAnY29udGV4dE1lbnUnLFxyXG4gICAgJ2NvbnRyb2xzJyxcclxuICAgICdjb29yZHMnLFxyXG4gICAgJ2Nyb3NzT3JpZ2luJyxcclxuICAgICdkYXRhJyxcclxuICAgICdkYXRlVGltZScsXHJcbiAgICAnZGVmYXVsdCcsXHJcbiAgICAnZGVmZXInLFxyXG4gICAgJ2RpcicsXHJcbiAgICAnZG93bmxvYWQnLFxyXG4gICAgJ2RyYWdnYWJsZScsXHJcbiAgICAnZW5jVHlwZScsXHJcbiAgICAnZm9ybScsXHJcbiAgICAnZm9ybUFjdGlvbicsXHJcbiAgICAnZm9ybUVuY1R5cGUnLFxyXG4gICAgJ2Zvcm1NZXRob2QnLFxyXG4gICAgJ2Zvcm1Ob1ZhbGlkYXRlJyxcclxuICAgICdmb3JtVGFyZ2V0JyxcclxuICAgICdmcmFtZUJvcmRlcicsXHJcbiAgICAnaGVhZGVycycsXHJcbiAgICAnaGVpZ2h0JyxcclxuICAgICdoaWRkZW4nLFxyXG4gICAgJ2hpZ2gnLFxyXG4gICAgJ2hyZWZMYW5nJyxcclxuICAgICdodG1sRm9yJyxcclxuICAgICdodHRwRXF1aXYnLFxyXG4gICAgJ2ljb24nLFxyXG4gICAgJ2lkJyxcclxuICAgICdpbnB1dE1vZGUnLFxyXG4gICAgJ2ludGVncml0eScsXHJcbiAgICAnaXMnLFxyXG4gICAgJ2tleVBhcmFtcycsXHJcbiAgICAna2V5VHlwZScsXHJcbiAgICAna2luZCcsXHJcbiAgICAnbGFuZycsXHJcbiAgICAnbGlzdCcsXHJcbiAgICAnbG9vcCcsXHJcbiAgICAnbG93JyxcclxuICAgICdtYW5pZmVzdCcsXHJcbiAgICAnbWFyZ2luSGVpZ2h0JyxcclxuICAgICdtYXJnaW5XaWR0aCcsXHJcbiAgICAnbWF4JyxcclxuICAgICdtYXhMZW5ndGgnLFxyXG4gICAgJ21lZGlhJyxcclxuICAgICdtZWRpYUdyb3VwJyxcclxuICAgICdtZXRob2QnLFxyXG4gICAgJ21pbicsXHJcbiAgICAnbWluTGVuZ3RoJyxcclxuICAgICdtdWx0aXBsZScsXHJcbiAgICAnbXV0ZWQnLFxyXG4gICAgJ25hbWUnLFxyXG4gICAgJ25vVmFsaWRhdGUnLFxyXG4gICAgJ29wZW4nLFxyXG4gICAgJ29wdGltdW0nLFxyXG4gICAgJ3BhdHRlcm4nLFxyXG4gICAgJ3BsYWNlaG9sZGVyJyxcclxuICAgICdwb3N0ZXInLFxyXG4gICAgJ3ByZWxvYWQnLFxyXG4gICAgJ3JhZGlvR3JvdXAnLFxyXG4gICAgJ3JlYWRPbmx5JyxcclxuICAgICdyZWwnLFxyXG4gICAgJ3JlcXVpcmVkJyxcclxuICAgICdyb2xlJyxcclxuICAgICdyb3dzJyxcclxuICAgICdyb3dTcGFuJyxcclxuICAgICdzYW5kYm94JyxcclxuICAgICdzY29wZScsXHJcbiAgICAnc2NvcGVkJyxcclxuICAgICdzY3JvbGxpbmcnLFxyXG4gICAgJ3NlYW1sZXNzJyxcclxuICAgICdzZWxlY3RlZCcsXHJcbiAgICAnc2hhcGUnLFxyXG4gICAgJ3NpemUnLFxyXG4gICAgJ3NpemVzJyxcclxuICAgICdzcGFuJyxcclxuICAgICdzcGVsbENoZWNrJyxcclxuICAgICdzcmMnLFxyXG4gICAgJ3NyY0RvYycsXHJcbiAgICAnc3JjTGFuZycsXHJcbiAgICAnc3JjU2V0JyxcclxuICAgICdzdGFydCcsXHJcbiAgICAnc3RlcCcsXHJcbiAgICAnc3R5bGUnLFxyXG4gICAgJ3N1bW1hcnknLFxyXG4gICAgJ3RhYkluZGV4JyxcclxuICAgICd0aXRsZScsXHJcbiAgICAndHlwZScsXHJcbiAgICAndXNlTWFwJyxcclxuICAgICd2YWx1ZScsXHJcbiAgICAnd2lkdGgnLFxyXG4gICAgJ3dtb2RlJyxcclxuICAgICd3cmFwJ1xyXG5dO1xyXG4vKipcclxuICogQW4gYXJyYXkgb2YgSFRNTCBlbGVtZW50IHByb3BlcnRpZXMgYW5kIGV2ZW50cy5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuZXhwb3J0cy5odG1sRWxlbWVudFByb3BlcnRpZXMgPSBleHBvcnRzLmJhc2VFbGVtZW50UHJvcGVydGllcy5jb25jYXQoZXhwb3J0cy5iYXNlRWxlbWVudEV2ZW50cyk7XHJcbi8qKlxyXG4gKiBBbiBhcnJheSBvZiBBIHRhZyBwcm9wZXJ0aWVzIGFuZCBldmVudHMuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmV4cG9ydHMuYW5jaG9yUHJvcGVydGllcyA9IGV4cG9ydHMuaHRtbEVsZW1lbnRQcm9wZXJ0aWVzLmNvbmNhdChbXHJcbiAgICAnaHJlZicsXHJcbiAgICAndGFyZ2V0J1xyXG5dKTtcclxuLyoqXHJcbiAqIEFuIGFycmF5IG9mIEJVVFRPTiB0YWcgcHJvcGVydGllcyBhbmQgZXZlbnRzLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5leHBvcnRzLmJ1dHRvblByb3BlcnRpZXMgPSBleHBvcnRzLmh0bWxFbGVtZW50UHJvcGVydGllcy5jb25jYXQoW1xyXG4gICAgJ2Rpc2FibGVkJ1xyXG5dKTtcclxuLyoqXHJcbiAqIEFuIGFycmF5IG9mIERJViB0YWcgcHJvcGVydGllcyBhbmQgZXZlbnRzLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5leHBvcnRzLmRpdlByb3BlcnRpZXMgPSBleHBvcnRzLmh0bWxFbGVtZW50UHJvcGVydGllcy5jb25jYXQoWydhbGlnbicsICdub1dyYXAnXSk7XHJcbi8qKlxyXG4gKiBBbiBhcnJheSBvZiBJTlBVVCB0YWcgcHJvcGVydGllcyBhbmQgZXZlbnRzLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5leHBvcnRzLmlucHV0UHJvcGVydGllcyA9IGV4cG9ydHMuYnV0dG9uUHJvcGVydGllcztcclxuLyoqXHJcbiAqIEFuIGFycmF5IG9mIFRFWFRBUkVBIHRhZyBwcm9wZXJ0aWVzIGFuZCBldmVudHMuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmV4cG9ydHMudGV4dEFyZWFQcm9wZXJ0aWVzID0gZXhwb3J0cy5idXR0b25Qcm9wZXJ0aWVzO1xyXG4vKipcclxuICogQW4gYXJyYXkgb2YgSU1BR0UgdGFnIHByb3BlcnRpZXMgYW5kIGV2ZW50cy5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuZXhwb3J0cy5pbWFnZVByb3BlcnRpZXMgPSBleHBvcnRzLmRpdlByb3BlcnRpZXM7XHJcbi8qKlxyXG4gKiBHZXRzIG5hdGl2ZSBzdXBwb3J0ZWQgcHJvcHMgZm9yIGFuIGh0bWwgZWxlbWVudCBwcm92aWRlZCB0aGUgYWxsb3dhbmNlIHNldC4gVXNlIG9uZSBvZiB0aGUgcHJvcGVydHlcclxuICogc2V0cyBkZWZpbmVkIChkaXZQcm9wZXJ0aWVzLCBidXR0b25Qcm9wZXJ0ZXMsIGV0YykgdG8gZmlsdGVyIG91dCBzdXBwb3J0ZWQgcHJvcGVydGllcyBmcm9tIGEgZ2l2ZW5cclxuICogcHJvcHMgc2V0LiBOb3RlIHRoYXQgYWxsIGRhdGEtIGFuZCBhcmlhLSBwcmVmaXhlZCBhdHRyaWJ1dGVzIHdpbGwgYmUgYWxsb3dlZC5cclxuICogTk9URTogZ2V0TmF0aXZlUHJvcHMgc2hvdWxkIGFsd2F5cyBiZSBhcHBsaWVkIGZpcnN0IHdoZW4gYWRkaW5nIHByb3BzIHRvIGEgcmVhY3QgY29tcG9uZW50LiBUaGVcclxuICogbm9uLW5hdGl2ZSBwcm9wcyBzaG91bGQgYmUgYXBwbGllZCBzZWNvbmQuIFRoaXMgd2lsbCBwcmV2ZW50IGdldE5hdGl2ZVByb3BzIGZyb20gb3ZlcnJpZGluZyB5b3VyIGN1c3RvbSBwcm9wcy5cclxuICogRm9yIGV4YW1wbGUsIGlmIHByb3BzIHBhc3NlZCB0byBnZXROYXRpdmVQcm9wcyBoYXMgYW4gb25DbGljayBmdW5jdGlvbiBhbmQgZ2V0TmF0aXZlUHJvcHMgaXMgYWRkZWQgdG9cclxuICogdGhlIGNvbXBvbmVudCBhZnRlciBhbiBvbkNsaWNrIGZ1bmN0aW9uIGlzIGFkZGVkLCB0aGVuIHRoZSBnZXROYXRpdmVQcm9wcyBvbkNsaWNrIHdpbGwgb3ZlcnJpZGUgaXQuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICogQHBhcmFtIHByb3BzIC0gVGhlIHVuZmlsdGVyZWQgaW5wdXQgcHJvcHNcclxuICogQHBhcmFtIGFsbG93ZWRQcm9wc05hbWVzLSAgVGhlIGFycmF5IG9mIGFsbG93ZWQgcHJvcG5hbWVzLlxyXG4gKiBAcmV0dXJucyBUaGUgZmlsdGVyZWQgcHJvcHNcclxuICovXHJcbmZ1bmN0aW9uIGdldE5hdGl2ZVByb3BzKHByb3BzLCBhbGxvd2VkUHJvcE5hbWVzLCBleGNsdWRlZFByb3BOYW1lcykge1xyXG4gICAgcmV0dXJuIG9iamVjdF8xLmZpbHRlcmVkQXNzaWduKGZ1bmN0aW9uIChwcm9wTmFtZSkge1xyXG4gICAgICAgIHJldHVybiAoKCFleGNsdWRlZFByb3BOYW1lcyB8fCBleGNsdWRlZFByb3BOYW1lcy5pbmRleE9mKHByb3BOYW1lKSA8IDApICYmICgocHJvcE5hbWUuaW5kZXhPZignZGF0YS0nKSA9PT0gMCkgfHxcclxuICAgICAgICAgICAgKHByb3BOYW1lLmluZGV4T2YoJ2FyaWEtJykgPT09IDApIHx8XHJcbiAgICAgICAgICAgIChhbGxvd2VkUHJvcE5hbWVzLmluZGV4T2YocHJvcE5hbWUpID49IDApKSk7XHJcbiAgICB9LCB7fSwgcHJvcHMpO1xyXG59XHJcbmV4cG9ydHMuZ2V0TmF0aXZlUHJvcHMgPSBnZXROYXRpdmVQcm9wcztcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cHJvcGVydGllcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgX2Jhc2VVcmwgPSAnJztcclxuLyoqIFNldHMgdGhlIGN1cnJlbnQgYmFzZSB1cmwgdXNlZCBmb3IgZmV0Y2hpbmcgaW1hZ2VzLiAqL1xyXG5mdW5jdGlvbiBnZXRSZXNvdXJjZVVybCh1cmwpIHtcclxuICAgIHJldHVybiBfYmFzZVVybCArIHVybDtcclxufVxyXG5leHBvcnRzLmdldFJlc291cmNlVXJsID0gZ2V0UmVzb3VyY2VVcmw7XHJcbi8qKiBHZXRzIHRoZSBjdXJyZW50IGJhc2UgdXJsIHVzZWQgZm9yIGZldGNoaW5nIGltYWdlcy4gKi9cclxuZnVuY3Rpb24gc2V0QmFzZVVybChiYXNlVXJsKSB7XHJcbiAgICBfYmFzZVVybCA9IGJhc2VVcmw7XHJcbn1cclxuZXhwb3J0cy5zZXRCYXNlVXJsID0gc2V0QmFzZVVybDtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cmVzb3VyY2VzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBkb21fMSA9IHJlcXVpcmUoXCIuL2RvbVwiKTtcclxudmFyIHNlc3Npb25TdG9yYWdlXzEgPSByZXF1aXJlKFwiLi9zZXNzaW9uU3RvcmFnZVwiKTtcclxudmFyIFJUTF9MT0NBTF9TVE9SQUdFX0tFWSA9ICdpc1JUTCc7XHJcbi8vIERlZmF1bHQgdG8gdW5kZWZpbmVkIHNvIHRoYXQgd2UgaW5pdGlhbGl6ZSBvbiBmaXJzdCByZWFkLlxyXG52YXIgX2lzUlRMO1xyXG4vKipcclxuICogR2V0cyB0aGUgcnRsIHN0YXRlIG9mIHRoZSBwYWdlIChyZXR1cm5zIHRydWUgaWYgaW4gcnRsLilcclxuICovXHJcbmZ1bmN0aW9uIGdldFJUTCgpIHtcclxuICAgIGlmIChfaXNSVEwgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIC8vIEZhYnJpYyBzdXBwb3J0cyBwZXJzaXN0aW5nIHRoZSBSVEwgc2V0dGluZyBiZXR3ZWVuIHBhZ2UgcmVmcmVzaGVzIHZpYSBzZXNzaW9uIHN0b3JhZ2VcclxuICAgICAgICB2YXIgc2F2ZWRSVEwgPSBzZXNzaW9uU3RvcmFnZV8xLmdldEl0ZW0oUlRMX0xPQ0FMX1NUT1JBR0VfS0VZKTtcclxuICAgICAgICBpZiAoc2F2ZWRSVEwgIT09IG51bGwpIHtcclxuICAgICAgICAgICAgX2lzUlRMID0gc2F2ZWRSVEwgPT09ICcxJztcclxuICAgICAgICAgICAgc2V0UlRMKF9pc1JUTCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBkb2MgPSBkb21fMS5nZXREb2N1bWVudCgpO1xyXG4gICAgICAgIGlmIChfaXNSVEwgPT09IHVuZGVmaW5lZCAmJiBkb2MpIHtcclxuICAgICAgICAgICAgX2lzUlRMID0gZG9jLmRvY3VtZW50RWxlbWVudC5nZXRBdHRyaWJ1dGUoJ2RpcicpID09PSAncnRsJztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gISFfaXNSVEw7XHJcbn1cclxuZXhwb3J0cy5nZXRSVEwgPSBnZXRSVEw7XHJcbi8qKlxyXG4gKiBTZXRzIHRoZSBydGwgc3RhdGUgb2YgdGhlIHBhZ2UgKGJ5IGFkanVzdGluZyB0aGUgZGlyIGF0dHJpYnV0ZSBvZiB0aGUgaHRtbCBlbGVtZW50LilcclxuICovXHJcbmZ1bmN0aW9uIHNldFJUTChpc1JUTCwgcGVyc2lzdFNldHRpbmcpIHtcclxuICAgIGlmIChwZXJzaXN0U2V0dGluZyA9PT0gdm9pZCAwKSB7IHBlcnNpc3RTZXR0aW5nID0gZmFsc2U7IH1cclxuICAgIHZhciBkb2MgPSBkb21fMS5nZXREb2N1bWVudCgpO1xyXG4gICAgaWYgKGRvYykge1xyXG4gICAgICAgIGRvYy5kb2N1bWVudEVsZW1lbnQuc2V0QXR0cmlidXRlKCdkaXInLCBpc1JUTCA/ICdydGwnIDogJ2x0cicpO1xyXG4gICAgfVxyXG4gICAgaWYgKHBlcnNpc3RTZXR0aW5nKSB7XHJcbiAgICAgICAgc2Vzc2lvblN0b3JhZ2VfMS5zZXRJdGVtKFJUTF9MT0NBTF9TVE9SQUdFX0tFWSwgaXNSVEwgPyAnMScgOiAnMCcpO1xyXG4gICAgfVxyXG4gICAgX2lzUlRMID0gaXNSVEw7XHJcbn1cclxuZXhwb3J0cy5zZXRSVEwgPSBzZXRSVEw7XHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBnaXZlbiBrZXksIGJ1dCBmbGlwcyByaWdodC9sZWZ0IGFycm93cyBpZiBuZWNlc3NhcnkuXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRSVExTYWZlS2V5Q29kZShrZXkpIHtcclxuICAgIGlmIChnZXRSVEwoKSkge1xyXG4gICAgICAgIGlmIChrZXkgPT09IDM3IC8qIGxlZnQgKi8pIHtcclxuICAgICAgICAgICAga2V5ID0gMzkgLyogcmlnaHQgKi87XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGtleSA9PT0gMzkgLyogcmlnaHQgKi8pIHtcclxuICAgICAgICAgICAga2V5ID0gMzcgLyogbGVmdCAqLztcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4ga2V5O1xyXG59XHJcbmV4cG9ydHMuZ2V0UlRMU2FmZUtleUNvZGUgPSBnZXRSVExTYWZlS2V5Q29kZTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cnRsLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBkb21fMSA9IHJlcXVpcmUoXCIuL2RvbVwiKTtcclxudmFyIHN0eWxlcyA9IHJlcXVpcmUoXCIuL3Njcm9sbC5zY3NzXCIpO1xyXG52YXIgX3Njcm9sbGJhcldpZHRoO1xyXG52YXIgX2JvZHlTY3JvbGxEaXNhYmxlZENvdW50ID0gMDtcclxuLyoqXHJcbiAqIFBsYWNpbmcgdGhpcyBhdHRyaWJ1dGUgb24gc2Nyb2xsYWJsZSBkaXZzIG9wdGltaXplcyBkZXRlY3Rpb24gdG8ga25vd1xyXG4gKiBpZiB0aGUgZGl2IGlzIHNjcm9sbGFibGUgb3Igbm90IChnaXZlbiB3ZSBjYW4gYXZvaWQgZXhwZW5zaXZlIG9wZXJhdGlvbnNcclxuICogbGlrZSBnZXRDb21wdXRlZFN0eWxlLilcclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuZXhwb3J0cy5EQVRBX0lTX1NDUk9MTEFCTEVfQVRUUklCVVRFID0gJ2RhdGEtaXMtc2Nyb2xsYWJsZSc7XHJcbi8qKlxyXG4gKiBEaXNhYmxlcyB0aGUgYm9keSBzY3JvbGxpbmcuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmZ1bmN0aW9uIGRpc2FibGVCb2R5U2Nyb2xsKCkge1xyXG4gICAgdmFyIGRvYyA9IGRvbV8xLmdldERvY3VtZW50KCk7XHJcbiAgICBpZiAoZG9jICYmIGRvYy5ib2R5ICYmICFfYm9keVNjcm9sbERpc2FibGVkQ291bnQpIHtcclxuICAgICAgICBkb2MuYm9keS5jbGFzc0xpc3QuYWRkKHN0eWxlcy5zY3JvbGxEaXNhYmxlZCk7XHJcbiAgICB9XHJcbiAgICBfYm9keVNjcm9sbERpc2FibGVkQ291bnQrKztcclxufVxyXG5leHBvcnRzLmRpc2FibGVCb2R5U2Nyb2xsID0gZGlzYWJsZUJvZHlTY3JvbGw7XHJcbi8qKlxyXG4gKiBFbmFibGVzIHRoZSBib2R5IHNjcm9sbGluZy5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKi9cclxuZnVuY3Rpb24gZW5hYmxlQm9keVNjcm9sbCgpIHtcclxuICAgIGlmIChfYm9keVNjcm9sbERpc2FibGVkQ291bnQgPiAwKSB7XHJcbiAgICAgICAgdmFyIGRvYyA9IGRvbV8xLmdldERvY3VtZW50KCk7XHJcbiAgICAgICAgaWYgKGRvYyAmJiBkb2MuYm9keSAmJiBfYm9keVNjcm9sbERpc2FibGVkQ291bnQgPT09IDEpIHtcclxuICAgICAgICAgICAgZG9jLmJvZHkuY2xhc3NMaXN0LnJlbW92ZShzdHlsZXMuc2Nyb2xsRGlzYWJsZWQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBfYm9keVNjcm9sbERpc2FibGVkQ291bnQtLTtcclxuICAgIH1cclxufVxyXG5leHBvcnRzLmVuYWJsZUJvZHlTY3JvbGwgPSBlbmFibGVCb2R5U2Nyb2xsO1xyXG4vKipcclxuICogQ2FsY3VsYXRlcyB0aGUgd2lkdGggb2YgYSBzY3JvbGxiYXIgZm9yIHRoZSBicm93c2VyL29zLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRTY3JvbGxiYXJXaWR0aCgpIHtcclxuICAgIGlmIChfc2Nyb2xsYmFyV2lkdGggPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIHZhciBzY3JvbGxEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcclxuICAgICAgICBzY3JvbGxEaXYuc3R5bGUuc2V0UHJvcGVydHkoJ3dpZHRoJywgJzEwMHB4Jyk7XHJcbiAgICAgICAgc2Nyb2xsRGl2LnN0eWxlLnNldFByb3BlcnR5KCdoZWlnaHQnLCAnMTAwcHgnKTtcclxuICAgICAgICBzY3JvbGxEaXYuc3R5bGUuc2V0UHJvcGVydHkoJ292ZXJmbG93JywgJ3Njcm9sbCcpO1xyXG4gICAgICAgIHNjcm9sbERpdi5zdHlsZS5zZXRQcm9wZXJ0eSgncG9zaXRpb24nLCAnYWJzb2x1dGUnKTtcclxuICAgICAgICBzY3JvbGxEaXYuc3R5bGUuc2V0UHJvcGVydHkoJ3RvcCcsICctOTk5OXB4Jyk7XHJcbiAgICAgICAgZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzY3JvbGxEaXYpO1xyXG4gICAgICAgIC8vIEdldCB0aGUgc2Nyb2xsYmFyIHdpZHRoXHJcbiAgICAgICAgX3Njcm9sbGJhcldpZHRoID0gc2Nyb2xsRGl2Lm9mZnNldFdpZHRoIC0gc2Nyb2xsRGl2LmNsaWVudFdpZHRoO1xyXG4gICAgICAgIC8vIERlbGV0ZSB0aGUgRElWXHJcbiAgICAgICAgZG9jdW1lbnQuYm9keS5yZW1vdmVDaGlsZChzY3JvbGxEaXYpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIF9zY3JvbGxiYXJXaWR0aDtcclxufVxyXG5leHBvcnRzLmdldFNjcm9sbGJhcldpZHRoID0gZ2V0U2Nyb2xsYmFyV2lkdGg7XHJcbi8qKlxyXG4gKiBUcmF2ZXJzZXMgdXAgdGhlIERPTSBmb3IgdGhlIGVsZW1lbnQgd2l0aCB0aGUgZGF0YS1pcy1zY3JvbGxhYmxlPXRydWUgYXR0cmlidXRlLCBvciByZXR1cm5zXHJcbiAqIGRvY3VtZW50LmJvZHkuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbmZ1bmN0aW9uIGZpbmRTY3JvbGxhYmxlUGFyZW50KHN0YXJ0aW5nRWxlbWVudCkge1xyXG4gICAgdmFyIGVsID0gc3RhcnRpbmdFbGVtZW50O1xyXG4gICAgLy8gRmlyc3QgZG8gYSBxdWljayBzY2FuIGZvciB0aGUgc2Nyb2xsYWJsZSBhdHRyaWJ1dGUuXHJcbiAgICB3aGlsZSAoZWwgJiYgZWwgIT09IGRvY3VtZW50LmJvZHkpIHtcclxuICAgICAgICBpZiAoZWwuZ2V0QXR0cmlidXRlKGV4cG9ydHMuREFUQV9JU19TQ1JPTExBQkxFX0FUVFJJQlVURSkgPT09ICd0cnVlJykge1xyXG4gICAgICAgICAgICByZXR1cm4gZWw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsID0gZWwucGFyZW50RWxlbWVudDtcclxuICAgIH1cclxuICAgIC8vIElmIHdlIGhhdmVuJ3QgZm91bmQgaXQsIHRoZSB1c2UgdGhlIHNsb3dlciBtZXRob2Q6IGNvbXB1dGUgc3R5bGVzIHRvIGV2YWx1YXRlIGlmIG92ZXJmbG93IGlzIHNldC5cclxuICAgIGVsID0gc3RhcnRpbmdFbGVtZW50O1xyXG4gICAgd2hpbGUgKGVsICYmIGVsICE9PSBkb2N1bWVudC5ib2R5KSB7XHJcbiAgICAgICAgaWYgKGVsLmdldEF0dHJpYnV0ZShleHBvcnRzLkRBVEFfSVNfU0NST0xMQUJMRV9BVFRSSUJVVEUpICE9PSAnZmFsc2UnKSB7XHJcbiAgICAgICAgICAgIHZhciBjb21wdXRlZFN0eWxlcyA9IGdldENvbXB1dGVkU3R5bGUoZWwpO1xyXG4gICAgICAgICAgICB2YXIgb3ZlcmZsb3dZID0gY29tcHV0ZWRTdHlsZXMgPyBjb21wdXRlZFN0eWxlcy5nZXRQcm9wZXJ0eVZhbHVlKCdvdmVyZmxvdy15JykgOiAnJztcclxuICAgICAgICAgICAgaWYgKG92ZXJmbG93WSAmJiAob3ZlcmZsb3dZID09PSAnc2Nyb2xsJyB8fCBvdmVyZmxvd1kgPT09ICdhdXRvJykpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBlbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbCA9IGVsLnBhcmVudEVsZW1lbnQ7XHJcbiAgICB9XHJcbiAgICAvLyBGYWxsIGJhY2sgdG8gd2luZG93IHNjcm9sbC5cclxuICAgIGlmICghZWwgfHwgZWwgPT09IGRvY3VtZW50LmJvZHkpIHtcclxuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYW55XHJcbiAgICAgICAgZWwgPSB3aW5kb3c7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZWw7XHJcbn1cclxuZXhwb3J0cy5maW5kU2Nyb2xsYWJsZVBhcmVudCA9IGZpbmRTY3JvbGxhYmxlUGFyZW50O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zY3JvbGwuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuLyogdHNsaW50OmRpc2FibGUgKi9cclxudmFyIGxvYWRfdGhlbWVkX3N0eWxlc18xID0gcmVxdWlyZShcIkBtaWNyb3NvZnQvbG9hZC10aGVtZWQtc3R5bGVzXCIpO1xyXG5sb2FkX3RoZW1lZF9zdHlsZXNfMS5sb2FkU3R5bGVzKFt7IFwicmF3U3RyaW5nXCI6IFwiLnNjcm9sbERpc2FibGVkXzJkODAxNjZie292ZXJmbG93OmhpZGRlbiAhaW1wb3J0YW50fVxcblwiIH1dKTtcclxuZXhwb3J0cy5zY3JvbGxEaXNhYmxlZCA9IFwic2Nyb2xsRGlzYWJsZWRfMmQ4MDE2NmJcIjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2Nyb2xsLnNjc3MuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuLyoqXHJcbiAqIEZldGNoZXMgYW4gaXRlbSBmcm9tIHNlc3Npb24gc3RvcmFnZSB3aXRob3V0IHRocm93aW5nIGFuIGV4Y2VwdGlvblxyXG4gKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIGl0ZW0gdG8gZmV0Y2ggZnJvbSBzZXNzaW9uIHN0b3JhZ2VcclxuICovXHJcbmZ1bmN0aW9uIGdldEl0ZW0oa2V5KSB7XHJcbiAgICB2YXIgcmVzdWx0ID0gbnVsbDtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgcmVzdWx0ID0gd2luZG93LnNlc3Npb25TdG9yYWdlLmdldEl0ZW0oa2V5KTtcclxuICAgIH1cclxuICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgLyogRWF0IHRoZSBleGNlcHRpb24gKi9cclxuICAgIH1cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuZXhwb3J0cy5nZXRJdGVtID0gZ2V0SXRlbTtcclxuLyoqXHJcbiAqIEluc2VydHMgYW4gaXRlbSBpbnRvIHNlc3Npb24gc3RvcmFnZSB3aXRob3V0IHRocm93aW5nIGFuIGV4Y2VwdGlvblxyXG4gKiBAcGFyYW0ga2V5IFRoZSBrZXkgb2YgdGhlIGl0ZW0gdG8gYWRkIHRvIHNlc3Npb24gc3RvcmFnZVxyXG4gKiBAcGFyYW0gZGF0YSBUaGUgZGF0YSB0byBwdXQgaW50byBzZXNzaW9uIHN0b3JhZ2VcclxuICovXHJcbmZ1bmN0aW9uIHNldEl0ZW0oa2V5LCBkYXRhKSB7XHJcbiAgICB0cnkge1xyXG4gICAgICAgIHdpbmRvdy5zZXNzaW9uU3RvcmFnZS5zZXRJdGVtKGtleSwgZGF0YSk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgIC8qIEVhdCB0aGUgZXhjZXB0aW9uICovXHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy5zZXRJdGVtID0gc2V0SXRlbTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9c2Vzc2lvblN0b3JhZ2UuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuLy8gUmVnZXggdGhhdCBmaW5kcyB7IGFuZCB9IHNvIHRoZXkgY2FuIGJlIHJlbW92ZWQgb24gYSBsb29rdXAgZm9yIHN0cmluZyBmb3JtYXRcclxudmFyIEZPUk1BVF9BUkdTX1JFR0VYID0gL1tcXHtcXH1dL2c7XHJcbi8vIFJlZ2V4IHRoYXQgZmluZHMgeyN9IHNvIGl0IGNhbiBiZSByZXBsYWNlZCBieSB0aGUgYXJndW1lbnRzIGluIHN0cmluZyBmb3JtYXRcclxudmFyIEZPUk1BVF9SRUdFWCA9IC9cXHtcXGQrXFx9L2c7XHJcbi8qKlxyXG4gKiBTdHJpbmcgZm9ybWF0IG1ldGhvZCwgdXNlZCBmb3Igc2NlbmFyaW9zIHdoZXJlIGF0IHJ1bnRpbWUgeW91XHJcbiAqIG5lZWQgdG8gZXZhbHVhdGUgYSBmb3JtYXR0ZWQgc3RyaW5nIGdpdmVuIGEgdG9rZW5pemVkIHN0cmluZy4gVGhpc1xyXG4gKiB1c3VhbGx5IG9ubHkgaXMgbmVlZGVkIGluIGxvY2FsaXphdGlvbiBzY2VuYXJpb3MuXHJcblxyXG4gKiBFeGFtcGxlIFwiSSBsb3ZlIHswfSBldmVyeSB7MX1cIi5mb3JtYXQoXCJDWFBcIikgd2lsbCByZXN1bHQgaW4gYSBEZWJ1ZyBFeGNlcHRpb24uXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICovXHJcbi8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpuby1hbnlcclxuZnVuY3Rpb24gZm9ybWF0KHMpIHtcclxuICAgICd1c2Ugc3RyaWN0JztcclxuICAgIHZhciB2YWx1ZXMgPSBbXTtcclxuICAgIGZvciAodmFyIF9pID0gMTsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgdmFsdWVzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xyXG4gICAgfVxyXG4gICAgdmFyIGFyZ3MgPSB2YWx1ZXM7XHJcbiAgICAvLyBDYWxsYmFjayBtYXRjaCBmdW5jdGlvblxyXG4gICAgZnVuY3Rpb24gcmVwbGFjZV9mdW5jKG1hdGNoKSB7XHJcbiAgICAgICAgLy8gbG9va3MgdXAgaW4gdGhlIGFyZ3NcclxuICAgICAgICAvLyB0c2xpbnQ6ZGlzYWJsZS1uZXh0LWxpbmU6bm8tYW55XHJcbiAgICAgICAgdmFyIHJlcGxhY2VtZW50ID0gYXJnc1ttYXRjaC5yZXBsYWNlKEZPUk1BVF9BUkdTX1JFR0VYLCAnJyldO1xyXG4gICAgICAgIC8vIGNhdGNoZXMgdW5kZWZpbmVkIGluIG5vbmRlYnVnIGFuZCBudWxsIGluIGRlYnVnIGFuZCBub25kZWJ1Z1xyXG4gICAgICAgIGlmIChyZXBsYWNlbWVudCA9PT0gbnVsbCB8fCByZXBsYWNlbWVudCA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJlcGxhY2VtZW50ID0gJyc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZXBsYWNlbWVudDtcclxuICAgIH1cclxuICAgIHJldHVybiAocy5yZXBsYWNlKEZPUk1BVF9SRUdFWCwgcmVwbGFjZV9mdW5jKSk7XHJcbn1cclxuZXhwb3J0cy5mb3JtYXQgPSBmb3JtYXQ7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXN0cmluZy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcclxudmFyIFJlYWN0ID0gcmVxdWlyZShcInJlYWN0XCIpO1xyXG52YXIgaW5kZXhfMSA9IHJlcXVpcmUoXCJAdWlmYWJyaWMvbWVyZ2Utc3R5bGVzL2xpYi9pbmRleFwiKTtcclxuLyoqXHJcbiAqIFRoZSBzdHlsZWQgSE9DIHdyYXBwZXIgYWxsb3dzIHlvdSB0byBjcmVhdGUgYSBmdW5jdGlvbmFsIHdyYXBwZXIgYXJvdW5kIGEgZ2l2ZW4gY29tcG9uZW50IHdoaWNoIHdpbGwgcmVzb2x2ZVxyXG4gKiBnZXRTdHlsZXMgZnVuY3Rpb25hbCBwcm9wcywgYW5kIG1peCBjdXN0b21pemVkIHByb3BzIHBhc3NlZCBpbiB1c2luZyBjb25jYXRTdHlsZVNldHMuIEV4YW1wbGU6XHJcbiAqXHJcbiAqIGBgYHRzeFxyXG4gKiBleHBvcnQgY29uc3QgVG9nZ2xlID0gc3R5bGVkKFxyXG4gKiAgIFRvZ2dsZUJhc2UsXHJcbiAqICAge1xyXG4gKiAgICAgZ2V0U3R5bGVzOiBwcm9wcyA9PiAoeyByb290OiB7IGJhY2tncm91bmQ6ICdyZWQnIH19KVxyXG4gKiAgIH1cclxuICogKTtcclxuICogYGBgXHJcbiAqXHJcbiAqL1xyXG5mdW5jdGlvbiBzdHlsZWQoQ29tcG9uZW50LCBnZXRCYXNlU3R5bGVzLCBnZXRQcm9wcykge1xyXG4gICAgcmV0dXJuIGZ1bmN0aW9uIChjb21wb25lbnRQcm9wcykge1xyXG4gICAgICAgIHZhciBnZXRTdHlsZXMgPSBmdW5jdGlvbiAoc3R5bGVQcm9wcykgeyByZXR1cm4gaW5kZXhfMS5jb25jYXRTdHlsZVNldHMoZ2V0QmFzZVN0eWxlcyAmJiBnZXRCYXNlU3R5bGVzKHN0eWxlUHJvcHMpLCBjb21wb25lbnRQcm9wcyAmJiBjb21wb25lbnRQcm9wcy5nZXRTdHlsZXMgJiYgY29tcG9uZW50UHJvcHMuZ2V0U3R5bGVzKHN0eWxlUHJvcHMpKTsgfTtcclxuICAgICAgICB2YXIgYWRkaXRpb25hbFByb3BzID0gZ2V0UHJvcHMgPyBnZXRQcm9wcyhjb21wb25lbnRQcm9wcykgOiB7fTtcclxuICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29tcG9uZW50LCB0c2xpYl8xLl9fYXNzaWduKHt9LCBhZGRpdGlvbmFsUHJvcHMsIGNvbXBvbmVudFByb3BzLCB7IGdldFN0eWxlczogZ2V0U3R5bGVzIH0pKSk7XHJcbiAgICB9O1xyXG59XHJcbmV4cG9ydHMuc3R5bGVkID0gc3R5bGVkO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1zdHlsZWQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIF93YXJuaW5nQ2FsbGJhY2sgPSB1bmRlZmluZWQ7XHJcbi8qKlxyXG4gKiBXYXJucyB3aGVuIGEgZGVwcmVjYXRlZCBwcm9wcyBhcmUgYmVpbmcgdXNlZC5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKiBAcGFyYW0gY29tcG9uZW50TmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBjb21wb25lbnQgYmVpbmcgdXNlZC5cclxuICogQHBhcmFtIHByb3BzIC0gVGhlIHByb3BzIHBhc3NlZCBpbnRvIHRoZSBjb21wb25lbnQuXHJcbiAqIEBwYXJhbSBkZXByZWNhdGlvbk1hcCAtIFRoZSBtYXAgb2YgZGVwcmVjYXRpb25zLCB3aGVyZSBrZXkgaXMgdGhlIHByb3AgbmFtZSBhbmQgdGhlIHZhbHVlIGlzXHJcbiAqIGVpdGhlciBudWxsIG9yIGEgcmVwbGFjZW1lbnQgcHJvcCBuYW1lLlxyXG4gKi9cclxuZnVuY3Rpb24gd2FybkRlcHJlY2F0aW9ucyhjb21wb25lbnROYW1lLCBwcm9wcywgZGVwcmVjYXRpb25NYXApIHtcclxuICAgIGZvciAodmFyIHByb3BOYW1lIGluIGRlcHJlY2F0aW9uTWFwKSB7XHJcbiAgICAgICAgaWYgKHByb3BzICYmIHByb3BOYW1lIGluIHByb3BzKSB7XHJcbiAgICAgICAgICAgIHZhciBkZXByZWNhdGlvbk1lc3NhZ2UgPSBjb21wb25lbnROYW1lICsgXCIgcHJvcGVydHkgJ1wiICsgcHJvcE5hbWUgKyBcIicgd2FzIHVzZWQgYnV0IGhhcyBiZWVuIGRlcHJlY2F0ZWQuXCI7XHJcbiAgICAgICAgICAgIHZhciByZXBsYWNlbWVudFByb3BOYW1lID0gZGVwcmVjYXRpb25NYXBbcHJvcE5hbWVdO1xyXG4gICAgICAgICAgICBpZiAocmVwbGFjZW1lbnRQcm9wTmFtZSkge1xyXG4gICAgICAgICAgICAgICAgZGVwcmVjYXRpb25NZXNzYWdlICs9IFwiIFVzZSAnXCIgKyByZXBsYWNlbWVudFByb3BOYW1lICsgXCInIGluc3RlYWQuXCI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgd2FybihkZXByZWNhdGlvbk1lc3NhZ2UpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxufVxyXG5leHBvcnRzLndhcm5EZXByZWNhdGlvbnMgPSB3YXJuRGVwcmVjYXRpb25zO1xyXG4vKipcclxuICogV2FybnMgd2hlbiB0d28gcHJvcHMgd2hpY2ggYXJlIG11dHVhbGx5IGV4Y2x1c2l2ZSBhcmUgYm90aCBiZWluZyB1c2VkLlxyXG4gKlxyXG4gKiBAcHVibGljXHJcbiAqIEBwYXJhbSBjb21wb25lbnROYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGNvbXBvbmVudCBiZWluZyB1c2VkLlxyXG4gKiBAcGFyYW0gcHJvcHMgLSBUaGUgcHJvcHMgcGFzc2VkIGludG8gdGhlIGNvbXBvbmVudC5cclxuICogQHBhcmFtIGV4Y2x1c2l2ZU1hcCAtIEEgbWFwIHdoZXJlIHRoZSBrZXkgaXMgYSBwYXJhbWV0ZXIsIGFuZCB0aGUgdmFsdWUgaXMgdGhlIG90aGVyIHBhcmFtZXRlci5cclxuICovXHJcbmZ1bmN0aW9uIHdhcm5NdXR1YWxseUV4Y2x1c2l2ZShjb21wb25lbnROYW1lLCBwcm9wcywgZXhjbHVzaXZlTWFwKSB7XHJcbiAgICBmb3IgKHZhciBwcm9wTmFtZSBpbiBleGNsdXNpdmVNYXApIHtcclxuICAgICAgICBpZiAocHJvcHMgJiYgcHJvcE5hbWUgaW4gcHJvcHMpIHtcclxuICAgICAgICAgICAgdmFyIHByb3BJbkV4Y2x1c2l2ZU1hcFZhbHVlID0gZXhjbHVzaXZlTWFwW3Byb3BOYW1lXTtcclxuICAgICAgICAgICAgaWYgKHByb3BJbkV4Y2x1c2l2ZU1hcFZhbHVlICYmIHByb3BJbkV4Y2x1c2l2ZU1hcFZhbHVlIGluIHByb3BzKSB7XHJcbiAgICAgICAgICAgICAgICB3YXJuKGNvbXBvbmVudE5hbWUgKyBcIiBwcm9wZXJ0eSAnXCIgKyBwcm9wTmFtZSArIFwiJyBpcyBtdXR1YWxseSBleGNsdXNpdmUgd2l0aCAnXCIgKyBleGNsdXNpdmVNYXBbcHJvcE5hbWVdICsgXCInLiBVc2Ugb25lIG9yIHRoZSBvdGhlci5cIik7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy53YXJuTXV0dWFsbHlFeGNsdXNpdmUgPSB3YXJuTXV0dWFsbHlFeGNsdXNpdmU7XHJcbi8qKlxyXG4gKiBXYXJucyB3aGVuIHByb3BzIGFyZSByZXF1aXJlZCBpZiBhIGNvbmRpdGlvbiBpcyBtZXQuXHJcbiAqXHJcbiAqIEBwdWJsaWNcclxuICogQHBhcmFtIGNvbXBvbmVudE5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgY29tcG9uZW50IGJlaW5nIHVzZWQuXHJcbiAqIEBwYXJhbSBwcm9wcyAtIFRoZSBwcm9wcyBwYXNzZWQgaW50byB0aGUgY29tcG9uZW50LlxyXG4gKiBAcGFyYW0gcmVxdWlyZWRQcm9wcyAtIFRoZSBuYW1lIG9mIHRoZSBwcm9wcyB0aGF0IGFyZSByZXF1aXJlZCB3aGVuIHRoZSBjb25kaXRpb24gaXMgbWV0LlxyXG4gKiBAcGFyYW0gY29uZGl0aW9uYWxQcm9wTmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBwcm9wIHRoYXQgdGhlIGNvbmRpdGlvbiBpcyBiYXNlZCBvbi5cclxuICogQHBhcmFtIGNvbmRpdGlvbiAtIFdoZXRoZXIgdGhlIGNvbmRpdGlvbiBpcyBtZXQuXHJcbiovXHJcbmZ1bmN0aW9uIHdhcm5Db25kaXRpb25hbGx5UmVxdWlyZWRQcm9wcyhjb21wb25lbnROYW1lLCBwcm9wcywgcmVxdWlyZWRQcm9wcywgY29uZGl0aW9uYWxQcm9wTmFtZSwgY29uZGl0aW9uKSB7XHJcbiAgICBpZiAoY29uZGl0aW9uID09PSB0cnVlKSB7XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCByZXF1aXJlZFByb3BzXzEgPSByZXF1aXJlZFByb3BzOyBfaSA8IHJlcXVpcmVkUHJvcHNfMS5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgdmFyIHJlcXVpcmVkUHJvcE5hbWUgPSByZXF1aXJlZFByb3BzXzFbX2ldO1xyXG4gICAgICAgICAgICBpZiAoIShyZXF1aXJlZFByb3BOYW1lIGluIHByb3BzKSkge1xyXG4gICAgICAgICAgICAgICAgd2Fybihjb21wb25lbnROYW1lICsgXCIgcHJvcGVydHkgJ1wiICsgcmVxdWlyZWRQcm9wTmFtZSArIFwiJyBpcyByZXF1aXJlZCB3aGVuICdcIiArIGNvbmRpdGlvbmFsUHJvcE5hbWUgKyBcIicgaXMgdXNlZC4nXCIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG59XHJcbmV4cG9ydHMud2FybkNvbmRpdGlvbmFsbHlSZXF1aXJlZFByb3BzID0gd2FybkNvbmRpdGlvbmFsbHlSZXF1aXJlZFByb3BzO1xyXG4vKipcclxuICogU2VuZHMgYSB3YXJuaW5nIHRvIGNvbnNvbGUsIGlmIHRoZSBhcGkgaXMgcHJlc2VudC5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKiBAcGFyYW0gbWVzc2FnZSAtIFdhcm5pbmcgbWVzc2FnZS5cclxuICovXHJcbmZ1bmN0aW9uIHdhcm4obWVzc2FnZSkge1xyXG4gICAgaWYgKF93YXJuaW5nQ2FsbGJhY2spIHtcclxuICAgICAgICBfd2FybmluZ0NhbGxiYWNrKG1lc3NhZ2UpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAoY29uc29sZSAmJiBjb25zb2xlLndhcm4pIHtcclxuICAgICAgICBjb25zb2xlLndhcm4obWVzc2FnZSk7XHJcbiAgICB9XHJcbn1cclxuZXhwb3J0cy53YXJuID0gd2FybjtcclxuLyoqXHJcbiAqIENvbmZpZ3VyZXMgdGhlIHdhcm5pbmcgY2FsbGJhY2suIFBhc3NpbmcgaW4gdW5kZWZpbmVkIHdpbGwgcmVzZXQgaXQgdG8gdXNlIHRoZSBkZWZhdWx0XHJcbiAqIGNvbnNvbGUud2FybiBmdW5jdGlvbi5cclxuICpcclxuICogQHB1YmxpY1xyXG4gKiBAcGFyYW0gd2FybmluZ0NhbGxiYWNrIC0gQ2FsbGJhY2sgdG8gb3ZlcnJpZGUgdGhlIGdlbmVyYXRlZCB3YXJuaW5ncy5cclxuICovXHJcbmZ1bmN0aW9uIHNldFdhcm5pbmdDYWxsYmFjayh3YXJuaW5nQ2FsbGJhY2spIHtcclxuICAgIF93YXJuaW5nQ2FsbGJhY2sgPSB3YXJuaW5nQ2FsbGJhY2s7XHJcbn1cclxuZXhwb3J0cy5zZXRXYXJuaW5nQ2FsbGJhY2sgPSBzZXRXYXJuaW5nQ2FsbGJhY2s7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXdhcm4uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDEzLXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICogXG4gKi9cblxuZnVuY3Rpb24gbWFrZUVtcHR5RnVuY3Rpb24oYXJnKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGFyZztcbiAgfTtcbn1cblxuLyoqXG4gKiBUaGlzIGZ1bmN0aW9uIGFjY2VwdHMgYW5kIGRpc2NhcmRzIGlucHV0czsgaXQgaGFzIG5vIHNpZGUgZWZmZWN0cy4gVGhpcyBpc1xuICogcHJpbWFyaWx5IHVzZWZ1bCBpZGlvbWF0aWNhbGx5IGZvciBvdmVycmlkYWJsZSBmdW5jdGlvbiBlbmRwb2ludHMgd2hpY2hcbiAqIGFsd2F5cyBuZWVkIHRvIGJlIGNhbGxhYmxlLCBzaW5jZSBKUyBsYWNrcyBhIG51bGwtY2FsbCBpZGlvbSBhbGEgQ29jb2EuXG4gKi9cbnZhciBlbXB0eUZ1bmN0aW9uID0gZnVuY3Rpb24gZW1wdHlGdW5jdGlvbigpIHt9O1xuXG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zID0gbWFrZUVtcHR5RnVuY3Rpb247XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zRmFsc2UgPSBtYWtlRW1wdHlGdW5jdGlvbihmYWxzZSk7XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zVHJ1ZSA9IG1ha2VFbXB0eUZ1bmN0aW9uKHRydWUpO1xuZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGwgPSBtYWtlRW1wdHlGdW5jdGlvbihudWxsKTtcbmVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNUaGlzID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcztcbn07XG5lbXB0eUZ1bmN0aW9uLnRoYXRSZXR1cm5zQXJndW1lbnQgPSBmdW5jdGlvbiAoYXJnKSB7XG4gIHJldHVybiBhcmc7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IGVtcHR5RnVuY3Rpb247IiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqXG4gKi9cblxuJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFVzZSBpbnZhcmlhbnQoKSB0byBhc3NlcnQgc3RhdGUgd2hpY2ggeW91ciBwcm9ncmFtIGFzc3VtZXMgdG8gYmUgdHJ1ZS5cbiAqXG4gKiBQcm92aWRlIHNwcmludGYtc3R5bGUgZm9ybWF0IChvbmx5ICVzIGlzIHN1cHBvcnRlZCkgYW5kIGFyZ3VtZW50c1xuICogdG8gcHJvdmlkZSBpbmZvcm1hdGlvbiBhYm91dCB3aGF0IGJyb2tlIGFuZCB3aGF0IHlvdSB3ZXJlXG4gKiBleHBlY3RpbmcuXG4gKlxuICogVGhlIGludmFyaWFudCBtZXNzYWdlIHdpbGwgYmUgc3RyaXBwZWQgaW4gcHJvZHVjdGlvbiwgYnV0IHRoZSBpbnZhcmlhbnRcbiAqIHdpbGwgcmVtYWluIHRvIGVuc3VyZSBsb2dpYyBkb2VzIG5vdCBkaWZmZXIgaW4gcHJvZHVjdGlvbi5cbiAqL1xuXG52YXIgdmFsaWRhdGVGb3JtYXQgPSBmdW5jdGlvbiB2YWxpZGF0ZUZvcm1hdChmb3JtYXQpIHt9O1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YWxpZGF0ZUZvcm1hdCA9IGZ1bmN0aW9uIHZhbGlkYXRlRm9ybWF0KGZvcm1hdCkge1xuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdpbnZhcmlhbnQgcmVxdWlyZXMgYW4gZXJyb3IgbWVzc2FnZSBhcmd1bWVudCcpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gaW52YXJpYW50KGNvbmRpdGlvbiwgZm9ybWF0LCBhLCBiLCBjLCBkLCBlLCBmKSB7XG4gIHZhbGlkYXRlRm9ybWF0KGZvcm1hdCk7XG5cbiAgaWYgKCFjb25kaXRpb24pIHtcbiAgICB2YXIgZXJyb3I7XG4gICAgaWYgKGZvcm1hdCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcignTWluaWZpZWQgZXhjZXB0aW9uIG9jY3VycmVkOyB1c2UgdGhlIG5vbi1taW5pZmllZCBkZXYgZW52aXJvbm1lbnQgJyArICdmb3IgdGhlIGZ1bGwgZXJyb3IgbWVzc2FnZSBhbmQgYWRkaXRpb25hbCBoZWxwZnVsIHdhcm5pbmdzLicpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYXJncyA9IFthLCBiLCBjLCBkLCBlLCBmXTtcbiAgICAgIHZhciBhcmdJbmRleCA9IDA7XG4gICAgICBlcnJvciA9IG5ldyBFcnJvcihmb3JtYXQucmVwbGFjZSgvJXMvZywgZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gYXJnc1thcmdJbmRleCsrXTtcbiAgICAgIH0pKTtcbiAgICAgIGVycm9yLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgfVxuXG4gICAgZXJyb3IuZnJhbWVzVG9Qb3AgPSAxOyAvLyB3ZSBkb24ndCBjYXJlIGFib3V0IGludmFyaWFudCdzIG93biBmcmFtZVxuICAgIHRocm93IGVycm9yO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gaW52YXJpYW50OyIsIi8qKlxuICogQ29weXJpZ2h0IChjKSAyMDE0LXByZXNlbnQsIEZhY2Vib29rLCBJbmMuXG4gKlxuICogVGhpcyBzb3VyY2UgY29kZSBpcyBsaWNlbnNlZCB1bmRlciB0aGUgTUlUIGxpY2Vuc2UgZm91bmQgaW4gdGhlXG4gKiBMSUNFTlNFIGZpbGUgaW4gdGhlIHJvb3QgZGlyZWN0b3J5IG9mIHRoaXMgc291cmNlIHRyZWUuXG4gKlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCcuL2VtcHR5RnVuY3Rpb24nKTtcblxuLyoqXG4gKiBTaW1pbGFyIHRvIGludmFyaWFudCBidXQgb25seSBsb2dzIGEgd2FybmluZyBpZiB0aGUgY29uZGl0aW9uIGlzIG5vdCBtZXQuXG4gKiBUaGlzIGNhbiBiZSB1c2VkIHRvIGxvZyBpc3N1ZXMgaW4gZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzIGluIGNyaXRpY2FsXG4gKiBwYXRocy4gUmVtb3ZpbmcgdGhlIGxvZ2dpbmcgY29kZSBmb3IgcHJvZHVjdGlvbiBlbnZpcm9ubWVudHMgd2lsbCBrZWVwIHRoZVxuICogc2FtZSBsb2dpYyBhbmQgZm9sbG93IHRoZSBzYW1lIGNvZGUgcGF0aHMuXG4gKi9cblxudmFyIHdhcm5pbmcgPSBlbXB0eUZ1bmN0aW9uO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgcHJpbnRXYXJuaW5nID0gZnVuY3Rpb24gcHJpbnRXYXJuaW5nKGZvcm1hdCkge1xuICAgIGZvciAodmFyIF9sZW4gPSBhcmd1bWVudHMubGVuZ3RoLCBhcmdzID0gQXJyYXkoX2xlbiA+IDEgPyBfbGVuIC0gMSA6IDApLCBfa2V5ID0gMTsgX2tleSA8IF9sZW47IF9rZXkrKykge1xuICAgICAgYXJnc1tfa2V5IC0gMV0gPSBhcmd1bWVudHNbX2tleV07XG4gICAgfVxuXG4gICAgdmFyIGFyZ0luZGV4ID0gMDtcbiAgICB2YXIgbWVzc2FnZSA9ICdXYXJuaW5nOiAnICsgZm9ybWF0LnJlcGxhY2UoLyVzL2csIGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiBhcmdzW2FyZ0luZGV4KytdO1xuICAgIH0pO1xuICAgIGlmICh0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IobWVzc2FnZSk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAvLyAtLS0gV2VsY29tZSB0byBkZWJ1Z2dpbmcgUmVhY3QgLS0tXG4gICAgICAvLyBUaGlzIGVycm9yIHdhcyB0aHJvd24gYXMgYSBjb252ZW5pZW5jZSBzbyB0aGF0IHlvdSBjYW4gdXNlIHRoaXMgc3RhY2tcbiAgICAgIC8vIHRvIGZpbmQgdGhlIGNhbGxzaXRlIHRoYXQgY2F1c2VkIHRoaXMgd2FybmluZyB0byBmaXJlLlxuICAgICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICAgIH0gY2F0Y2ggKHgpIHt9XG4gIH07XG5cbiAgd2FybmluZyA9IGZ1bmN0aW9uIHdhcm5pbmcoY29uZGl0aW9uLCBmb3JtYXQpIHtcbiAgICBpZiAoZm9ybWF0ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignYHdhcm5pbmcoY29uZGl0aW9uLCBmb3JtYXQsIC4uLmFyZ3MpYCByZXF1aXJlcyBhIHdhcm5pbmcgJyArICdtZXNzYWdlIGFyZ3VtZW50Jyk7XG4gICAgfVxuXG4gICAgaWYgKGZvcm1hdC5pbmRleE9mKCdGYWlsZWQgQ29tcG9zaXRlIHByb3BUeXBlOiAnKSA9PT0gMCkge1xuICAgICAgcmV0dXJuOyAvLyBJZ25vcmUgQ29tcG9zaXRlQ29tcG9uZW50IHByb3B0eXBlIGNoZWNrLlxuICAgIH1cblxuICAgIGlmICghY29uZGl0aW9uKSB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBBcnJheShfbGVuMiA+IDIgPyBfbGVuMiAtIDIgOiAwKSwgX2tleTIgPSAyOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTIgLSAyXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIHByaW50V2FybmluZy5hcHBseSh1bmRlZmluZWQsIFtmb3JtYXRdLmNvbmNhdChhcmdzKSk7XG4gICAgfVxuICB9O1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IHdhcm5pbmc7IiwiLypcbm9iamVjdC1hc3NpZ25cbihjKSBTaW5kcmUgU29yaHVzXG5AbGljZW5zZSBNSVRcbiovXG5cbid1c2Ugc3RyaWN0Jztcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scztcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgcHJvcElzRW51bWVyYWJsZSA9IE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGU7XG5cbmZ1bmN0aW9uIHRvT2JqZWN0KHZhbCkge1xuXHRpZiAodmFsID09PSBudWxsIHx8IHZhbCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignT2JqZWN0LmFzc2lnbiBjYW5ub3QgYmUgY2FsbGVkIHdpdGggbnVsbCBvciB1bmRlZmluZWQnKTtcblx0fVxuXG5cdHJldHVybiBPYmplY3QodmFsKTtcbn1cblxuZnVuY3Rpb24gc2hvdWxkVXNlTmF0aXZlKCkge1xuXHR0cnkge1xuXHRcdGlmICghT2JqZWN0LmFzc2lnbikge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIERldGVjdCBidWdneSBwcm9wZXJ0eSBlbnVtZXJhdGlvbiBvcmRlciBpbiBvbGRlciBWOCB2ZXJzaW9ucy5cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTQxMThcblx0XHR2YXIgdGVzdDEgPSBuZXcgU3RyaW5nKCdhYmMnKTsgIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbmV3LXdyYXBwZXJzXG5cdFx0dGVzdDFbNV0gPSAnZGUnO1xuXHRcdGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyh0ZXN0MSlbMF0gPT09ICc1Jykge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTMwNTZcblx0XHR2YXIgdGVzdDIgPSB7fTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDEwOyBpKyspIHtcblx0XHRcdHRlc3QyWydfJyArIFN0cmluZy5mcm9tQ2hhckNvZGUoaSldID0gaTtcblx0XHR9XG5cdFx0dmFyIG9yZGVyMiA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHRlc3QyKS5tYXAoZnVuY3Rpb24gKG4pIHtcblx0XHRcdHJldHVybiB0ZXN0MltuXTtcblx0XHR9KTtcblx0XHRpZiAob3JkZXIyLmpvaW4oJycpICE9PSAnMDEyMzQ1Njc4OScpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHQvLyBodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvdjgvaXNzdWVzL2RldGFpbD9pZD0zMDU2XG5cdFx0dmFyIHRlc3QzID0ge307XG5cdFx0J2FiY2RlZmdoaWprbG1ub3BxcnN0Jy5zcGxpdCgnJykuZm9yRWFjaChmdW5jdGlvbiAobGV0dGVyKSB7XG5cdFx0XHR0ZXN0M1tsZXR0ZXJdID0gbGV0dGVyO1xuXHRcdH0pO1xuXHRcdGlmIChPYmplY3Qua2V5cyhPYmplY3QuYXNzaWduKHt9LCB0ZXN0MykpLmpvaW4oJycpICE9PVxuXHRcdFx0XHQnYWJjZGVmZ2hpamtsbW5vcHFyc3QnKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRydWU7XG5cdH0gY2F0Y2ggKGVycikge1xuXHRcdC8vIFdlIGRvbid0IGV4cGVjdCBhbnkgb2YgdGhlIGFib3ZlIHRvIHRocm93LCBidXQgYmV0dGVyIHRvIGJlIHNhZmUuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2hvdWxkVXNlTmF0aXZlKCkgPyBPYmplY3QuYXNzaWduIDogZnVuY3Rpb24gKHRhcmdldCwgc291cmNlKSB7XG5cdHZhciBmcm9tO1xuXHR2YXIgdG8gPSB0b09iamVjdCh0YXJnZXQpO1xuXHR2YXIgc3ltYm9scztcblxuXHRmb3IgKHZhciBzID0gMTsgcyA8IGFyZ3VtZW50cy5sZW5ndGg7IHMrKykge1xuXHRcdGZyb20gPSBPYmplY3QoYXJndW1lbnRzW3NdKTtcblxuXHRcdGZvciAodmFyIGtleSBpbiBmcm9tKSB7XG5cdFx0XHRpZiAoaGFzT3duUHJvcGVydHkuY2FsbChmcm9tLCBrZXkpKSB7XG5cdFx0XHRcdHRvW2tleV0gPSBmcm9tW2tleV07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKGdldE93blByb3BlcnR5U3ltYm9scykge1xuXHRcdFx0c3ltYm9scyA9IGdldE93blByb3BlcnR5U3ltYm9scyhmcm9tKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc3ltYm9scy5sZW5ndGg7IGkrKykge1xuXHRcdFx0XHRpZiAocHJvcElzRW51bWVyYWJsZS5jYWxsKGZyb20sIHN5bWJvbHNbaV0pKSB7XG5cdFx0XHRcdFx0dG9bc3ltYm9sc1tpXV0gPSBmcm9tW3N5bWJvbHNbaV1dO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHRvO1xufTtcbiIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xyXG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9jb21wb25lbnRzL0J1dHRvbi9pbmRleFwiKSwgZXhwb3J0cyk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJ1dHRvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcclxudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY29tcG9uZW50cy9DYWxsb3V0L2luZGV4XCIpLCBleHBvcnRzKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q2FsbG91dC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcclxudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY29tcG9uZW50cy9Db250ZXh0dWFsTWVudS9pbmRleFwiKSwgZXhwb3J0cyk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNvbnRleHR1YWxNZW51LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xyXG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9jb21wb25lbnRzL0RpdmlkZXIvaW5kZXhcIiksIGV4cG9ydHMpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1EaXZpZGVyLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xyXG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9jb21wb25lbnRzL0ZhYnJpYy9pbmRleFwiKSwgZXhwb3J0cyk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUZhYnJpYy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcclxudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY29tcG9uZW50cy9Gb2N1c1pvbmUvaW5kZXhcIiksIGV4cG9ydHMpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1Gb2N1c1pvbmUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XHJcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2NvbXBvbmVudHMvSWNvbi9pbmRleFwiKSwgZXhwb3J0cyk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUljb24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XHJcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL2NvbXBvbmVudHMvTGF5ZXIvaW5kZXhcIiksIGV4cG9ydHMpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1MYXllci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcclxudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vY29tcG9uZW50cy9Qb3B1cC9pbmRleFwiKSwgZXhwb3J0cyk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVBvcHVwLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xyXG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiQHVpZmFicmljL3N0eWxpbmcvbGliL2luZGV4XCIpLCBleHBvcnRzKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3R5bGluZy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcclxudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIkB1aWZhYnJpYy91dGlsaXRpZXMvbGliL2luZGV4XCIpLCBleHBvcnRzKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9VXRpbGl0aWVzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBEaXJlY3Rpb25hbEhpbnQ7XHJcbihmdW5jdGlvbiAoRGlyZWN0aW9uYWxIaW50KSB7XHJcbiAgICAvKipcclxuICAgICAqIEFwcGVhciBhYm92ZSB0aGUgdGFyZ2V0IGVsZW1lbnQsIHdpdGggdGhlIGxlZnQgZWRnZXMgb2YgdGhlIGNhbGxvdXQgYW5kIHRhcmdldCBhbGlnbmluZy5cclxuICAgICAqL1xyXG4gICAgRGlyZWN0aW9uYWxIaW50W0RpcmVjdGlvbmFsSGludFtcInRvcExlZnRFZGdlXCJdID0gMF0gPSBcInRvcExlZnRFZGdlXCI7XHJcbiAgICAvKipcclxuICAgICAqIEFwcGVhciBhYm92ZSB0aGUgdGFyZ2V0IGVsZW1lbnQsIHdpdGggdGhlIGNlbnRlcnMgb2YgdGhlIGNhbGxvdXQgYW5kIHRhcmdldCBhbGlnbmluZy5cclxuICAgICAqL1xyXG4gICAgRGlyZWN0aW9uYWxIaW50W0RpcmVjdGlvbmFsSGludFtcInRvcENlbnRlclwiXSA9IDFdID0gXCJ0b3BDZW50ZXJcIjtcclxuICAgIC8qKlxyXG4gICAgICogQXBwZWFyIGFib3ZlIHRoZSB0YXJnZXQgZWxlbWVudCwgd2l0aCB0aGUgcmlnaHQgZWRnZXMgb2YgdGhlIGNhbGxvdXQgYW5kIHRhcmdldCBhbGlnbmluZy5cclxuICAgICAqL1xyXG4gICAgRGlyZWN0aW9uYWxIaW50W0RpcmVjdGlvbmFsSGludFtcInRvcFJpZ2h0RWRnZVwiXSA9IDJdID0gXCJ0b3BSaWdodEVkZ2VcIjtcclxuICAgIC8qKlxyXG4gICAgICogQXBwZWFyIGFib3ZlIHRoZSB0YXJnZXQgZWxlbWVudCwgYWxpZ25pbmcgd2l0aCB0aGUgdGFyZ2V0IGVsZW1lbnQgc3VjaCB0aGF0IHRoZSBjYWxsb3V0IHRlbmRzIHRvd2FyZCB0aGUgY2VudGVyIG9mIHRoZSBzY3JlZW4uXHJcbiAgICAgKi9cclxuICAgIERpcmVjdGlvbmFsSGludFtEaXJlY3Rpb25hbEhpbnRbXCJ0b3BBdXRvRWRnZVwiXSA9IDNdID0gXCJ0b3BBdXRvRWRnZVwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBlYXIgYmVsb3cgdGhlIHRhcmdldCBlbGVtZW50LCB3aXRoIHRoZSBsZWZ0IGVkZ2VzIG9mIHRoZSBjYWxsb3V0IGFuZCB0YXJnZXQgYWxpZ25pbmcuXHJcbiAgICAgKi9cclxuICAgIERpcmVjdGlvbmFsSGludFtEaXJlY3Rpb25hbEhpbnRbXCJib3R0b21MZWZ0RWRnZVwiXSA9IDRdID0gXCJib3R0b21MZWZ0RWRnZVwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBlYXIgYmVsb3cgdGhlIHRhcmdldCBlbGVtZW50LCB3aXRoIHRoZSBjZW50ZXJzIG9mIHRoZSBjYWxsb3V0IGFuZCB0YXJnZXQgYWxpZ25pbmcuXHJcbiAgICAgKi9cclxuICAgIERpcmVjdGlvbmFsSGludFtEaXJlY3Rpb25hbEhpbnRbXCJib3R0b21DZW50ZXJcIl0gPSA1XSA9IFwiYm90dG9tQ2VudGVyXCI7XHJcbiAgICAvKipcclxuICAgICAqIEFwcGVhciBiZWxvdyB0aGUgdGFyZ2V0IGVsZW1lbnQsIHdpdGggdGhlIHJpZ2h0IGVkZ2VzIG9mIHRoZSBjYWxsb3V0IGFuZCB0YXJnZXQgYWxpZ25pbmcuXHJcbiAgICAgKi9cclxuICAgIERpcmVjdGlvbmFsSGludFtEaXJlY3Rpb25hbEhpbnRbXCJib3R0b21SaWdodEVkZ2VcIl0gPSA2XSA9IFwiYm90dG9tUmlnaHRFZGdlXCI7XHJcbiAgICAvKipcclxuICAgICAqIEFwcGVhciBiZWxvdyB0aGUgdGFyZ2V0IGVsZW1lbnQsIGFsaWduaW5nIHdpdGggdGhlIHRhcmdldCBlbGVtZW50IHN1Y2ggdGhhdCB0aGUgY2FsbG91dCB0ZW5kcyB0b3dhcmQgdGhlIGNlbnRlciBvZiB0aGUgc2NyZWVuLlxyXG4gICAgICovXHJcbiAgICBEaXJlY3Rpb25hbEhpbnRbRGlyZWN0aW9uYWxIaW50W1wiYm90dG9tQXV0b0VkZ2VcIl0gPSA3XSA9IFwiYm90dG9tQXV0b0VkZ2VcIjtcclxuICAgIC8qKlxyXG4gICAgICogQXBwZWFyIHRvIHRoZSBsZWZ0IG9mIHRoZSB0YXJnZXQgZWxlbWVudCwgd2l0aCB0aGUgdG9wIGVkZ2VzIG9mIHRoZSBjYWxsb3V0IGFuZCB0YXJnZXQgYWxpZ25pbmcuXHJcbiAgICAgKi9cclxuICAgIERpcmVjdGlvbmFsSGludFtEaXJlY3Rpb25hbEhpbnRbXCJsZWZ0VG9wRWRnZVwiXSA9IDhdID0gXCJsZWZ0VG9wRWRnZVwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBlYXIgdG8gdGhlIGxlZnQgb2YgdGhlIHRhcmdldCBlbGVtZW50LCB3aXRoIHRoZSBjZW50ZXJzIG9mIHRoZSBjYWxsb3V0IGFuZCB0YXJnZXQgYWxpZ25pbmcuXHJcbiAgICAgKi9cclxuICAgIERpcmVjdGlvbmFsSGludFtEaXJlY3Rpb25hbEhpbnRbXCJsZWZ0Q2VudGVyXCJdID0gOV0gPSBcImxlZnRDZW50ZXJcIjtcclxuICAgIC8qKlxyXG4gICAgICogQXBwZWFyIHRvIHRoZSBsZWZ0IG9mIHRoZSB0YXJnZXQgZWxlbWVudCwgd2l0aCB0aGUgYm90dG9tIGVkZ2VzIG9mIHRoZSBjYWxsb3V0IGFuZCB0YXJnZXQgYWxpZ25pbmcuXHJcbiAgICAgKi9cclxuICAgIERpcmVjdGlvbmFsSGludFtEaXJlY3Rpb25hbEhpbnRbXCJsZWZ0Qm90dG9tRWRnZVwiXSA9IDEwXSA9IFwibGVmdEJvdHRvbUVkZ2VcIjtcclxuICAgIC8qKlxyXG4gICAgICogQXBwZWFyIHRvIHRoZSByaWdodCBvZiB0aGUgdGFyZ2V0IGVsZW1lbnQsIHdpdGggdGhlIHRvcCBlZGdlcyBvZiB0aGUgY2FsbG91dCBhbmQgdGFyZ2V0IGFsaWduaW5nLlxyXG4gICAgICovXHJcbiAgICBEaXJlY3Rpb25hbEhpbnRbRGlyZWN0aW9uYWxIaW50W1wicmlnaHRUb3BFZGdlXCJdID0gMTFdID0gXCJyaWdodFRvcEVkZ2VcIjtcclxuICAgIC8qKlxyXG4gICAgICogQXBwZWFyIHRvIHRoZSByaWdodCBvZiB0aGUgdGFyZ2V0IGVsZW1lbnQsIHdpdGggdGhlIGNlbnRlcnMgb2YgdGhlIGNhbGxvdXQgYW5kIHRhcmdldCBhbGlnbmluZy5cclxuICAgICAqL1xyXG4gICAgRGlyZWN0aW9uYWxIaW50W0RpcmVjdGlvbmFsSGludFtcInJpZ2h0Q2VudGVyXCJdID0gMTJdID0gXCJyaWdodENlbnRlclwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBBcHBlYXIgdG8gdGhlIHJpZ2h0IG9mIHRoZSB0YXJnZXQgZWxlbWVudCwgd2l0aCB0aGUgYm90dG9tIGVkZ2VzIG9mIHRoZSBjYWxsb3V0IGFuZCB0YXJnZXQgYWxpZ25pbmcuXHJcbiAgICAgKi9cclxuICAgIERpcmVjdGlvbmFsSGludFtEaXJlY3Rpb25hbEhpbnRbXCJyaWdodEJvdHRvbUVkZ2VcIl0gPSAxM10gPSBcInJpZ2h0Qm90dG9tRWRnZVwiO1xyXG59KShEaXJlY3Rpb25hbEhpbnQgPSBleHBvcnRzLkRpcmVjdGlvbmFsSGludCB8fCAoZXhwb3J0cy5EaXJlY3Rpb25hbEhpbnQgPSB7fSkpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1EaXJlY3Rpb25hbEhpbnQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XHJcbnZhciBSZWFjdCA9IHJlcXVpcmUoXCJyZWFjdFwiKTtcclxudmFyIEJhc2VCdXR0b25fMSA9IHJlcXVpcmUoXCIuLi9CYXNlQnV0dG9uXCIpO1xyXG52YXIgVXRpbGl0aWVzXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vVXRpbGl0aWVzXCIpO1xyXG52YXIgQWN0aW9uQnV0dG9uX3N0eWxlc18xID0gcmVxdWlyZShcIi4vQWN0aW9uQnV0dG9uLnN0eWxlc1wiKTtcclxudmFyIEFjdGlvbkJ1dHRvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIHRzbGliXzEuX19leHRlbmRzKEFjdGlvbkJ1dHRvbiwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEFjdGlvbkJ1dHRvbigpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUZWxsIEJhc2VDb21wb25lbnQgdG8gYnlwYXNzIHJlc29sdXRpb24gb2YgY29tcG9uZW50UmVmLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLl9zaG91bGRVcGRhdGVDb21wb25lbnRSZWYgPSBmYWxzZTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBBY3Rpb25CdXR0b24ucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX2EgPSB0aGlzLnByb3BzLCBzdHlsZXMgPSBfYS5zdHlsZXMsIHRoZW1lID0gX2EudGhlbWU7XHJcbiAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KEJhc2VCdXR0b25fMS5CYXNlQnV0dG9uLCB0c2xpYl8xLl9fYXNzaWduKHt9LCB0aGlzLnByb3BzLCB7IHZhcmlhbnRDbGFzc05hbWU6ICdtcy1CdXR0b24tLWFjdGlvbiBtcy1CdXR0b24tLWNvbW1hbmQnLCBzdHlsZXM6IEFjdGlvbkJ1dHRvbl9zdHlsZXNfMS5nZXRTdHlsZXModGhlbWUsIHN0eWxlcyksIG9uUmVuZGVyRGVzY3JpcHRpb246IFV0aWxpdGllc18xLm51bGxSZW5kZXIgfSkpKTtcclxuICAgIH07XHJcbiAgICBBY3Rpb25CdXR0b24gPSB0c2xpYl8xLl9fZGVjb3JhdGUoW1xyXG4gICAgICAgIFV0aWxpdGllc18xLmN1c3RvbWl6YWJsZSgnQWN0aW9uQnV0dG9uJywgWyd0aGVtZSddKVxyXG4gICAgXSwgQWN0aW9uQnV0dG9uKTtcclxuICAgIHJldHVybiBBY3Rpb25CdXR0b247XHJcbn0oVXRpbGl0aWVzXzEuQmFzZUNvbXBvbmVudCkpO1xyXG5leHBvcnRzLkFjdGlvbkJ1dHRvbiA9IEFjdGlvbkJ1dHRvbjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QWN0aW9uQnV0dG9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBTdHlsaW5nXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vU3R5bGluZ1wiKTtcclxudmFyIFV0aWxpdGllc18xID0gcmVxdWlyZShcIi4uLy4uLy4uL1V0aWxpdGllc1wiKTtcclxudmFyIEJhc2VCdXR0b25fc3R5bGVzXzEgPSByZXF1aXJlKFwiLi4vQmFzZUJ1dHRvbi5zdHlsZXNcIik7XHJcbnZhciBERUZBVUxUX0JVVFRPTl9IRUlHSFQgPSAnNDBweCc7XHJcbnZhciBERUZBVUxUX1BBRERJTkcgPSAnMCA0cHgnO1xyXG5leHBvcnRzLmdldFN0eWxlcyA9IFV0aWxpdGllc18xLm1lbW9pemVGdW5jdGlvbihmdW5jdGlvbiAodGhlbWUsIGN1c3RvbVN0eWxlcykge1xyXG4gICAgdmFyIGJhc2VCdXR0b25TdHlsZXMgPSBCYXNlQnV0dG9uX3N0eWxlc18xLmdldFN0eWxlcyh0aGVtZSk7XHJcbiAgICB2YXIgYWN0aW9uQnV0dG9uU3R5bGVzID0ge1xyXG4gICAgICAgIHJvb3Q6IHtcclxuICAgICAgICAgICAgcGFkZGluZzogREVGQVVMVF9QQURESU5HLFxyXG4gICAgICAgICAgICBoZWlnaHQ6IERFRkFVTFRfQlVUVE9OX0hFSUdIVCxcclxuICAgICAgICAgICAgY29sb3I6IHRoZW1lLnBhbGV0dGUubmV1dHJhbFByaW1hcnksXHJcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ3RyYW5zcGFyZW50J1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcm9vdEhvdmVyZWQ6IHtcclxuICAgICAgICAgICAgY29sb3I6IHRoZW1lLnBhbGV0dGUudGhlbWVQcmltYXJ5LFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaWNvbkhvdmVyZWQ6IHtcclxuICAgICAgICAgICAgY29sb3I6IHRoZW1lLnBhbGV0dGUudGhlbWVQcmltYXJ5XHJcbiAgICAgICAgfSxcclxuICAgICAgICByb290UHJlc3NlZDoge1xyXG4gICAgICAgICAgICBjb2xvcjogdGhlbWUucGFsZXR0ZS5ibGFjayxcclxuICAgICAgICB9LFxyXG4gICAgICAgIHJvb3RFeHBhbmRlZDoge1xyXG4gICAgICAgICAgICBjb2xvcjogdGhlbWUucGFsZXR0ZS50aGVtZVByaW1hcnlcclxuICAgICAgICB9LFxyXG4gICAgICAgIGljb25QcmVzc2VkOiB7XHJcbiAgICAgICAgICAgIGNvbG9yOiB0aGVtZS5wYWxldHRlLnRoZW1lRGFya2VyXHJcbiAgICAgICAgfSxcclxuICAgICAgICByb290RGlzYWJsZWQ6IHtcclxuICAgICAgICAgICAgY29sb3I6IHRoZW1lLnBhbGV0dGUubmV1dHJhbFRlcnRpYXJ5LFxyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICd0cmFuc3BhcmVudCdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHJvb3RDaGVja2VkOiB7XHJcbiAgICAgICAgICAgIGNvbG9yOiB0aGVtZS5wYWxldHRlLmJsYWNrLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaWNvbkNoZWNrZWQ6IHtcclxuICAgICAgICAgICAgY29sb3I6IHRoZW1lLnBhbGV0dGUudGhlbWVEYXJrZXJcclxuICAgICAgICB9LFxyXG4gICAgICAgIGZsZXhDb250YWluZXI6IHtcclxuICAgICAgICAgICAganVzdGlmeUNvbnRlbnQ6ICdmbGV4LXN0YXJ0J1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaWNvbjoge1xyXG4gICAgICAgICAgICBjb2xvcjogdGhlbWUucGFsZXR0ZS50aGVtZURhcmtBbHRcclxuICAgICAgICB9LFxyXG4gICAgICAgIGljb25EaXNhYmxlZDoge1xyXG4gICAgICAgICAgICBjb2xvcjogJ2luaGVyaXQnXHJcbiAgICAgICAgfSxcclxuICAgICAgICBtZW51SWNvbjoge1xyXG4gICAgICAgICAgICBjb2xvcjogdGhlbWUucGFsZXR0ZS5uZXV0cmFsU2Vjb25kYXJ5XHJcbiAgICAgICAgfSxcclxuICAgICAgICB0ZXh0Q29udGFpbmVyOiB7XHJcbiAgICAgICAgICAgIGZsZXhHcm93OiAwXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiBTdHlsaW5nXzEuY29uY2F0U3R5bGVTZXRzKGJhc2VCdXR0b25TdHlsZXMsIGFjdGlvbkJ1dHRvblN0eWxlcywgY3VzdG9tU3R5bGVzKTtcclxufSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUFjdGlvbkJ1dHRvbi5zdHlsZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIFV0aWxpdGllc18xID0gcmVxdWlyZShcIi4uLy4uL1V0aWxpdGllc1wiKTtcclxudmFyIFN0eWxpbmdfMSA9IHJlcXVpcmUoXCIuLi8uLi9TdHlsaW5nXCIpO1xyXG5leHBvcnRzLmdldEJhc2VCdXR0b25DbGFzc05hbWVzID0gVXRpbGl0aWVzXzEubWVtb2l6ZUZ1bmN0aW9uKGZ1bmN0aW9uIChzdHlsZXMsIGNsYXNzTmFtZSwgdmFyaWFudENsYXNzTmFtZSwgaWNvbkNsYXNzTmFtZSwgbWVudUljb25DbGFzc05hbWUsIGRpc2FibGVkLCBjaGVja2VkLCBleHBhbmRlZCwgaXNTcGxpdCkge1xyXG4gICAgdmFyIGlzRXhwYW5kZWQgPSBleHBhbmRlZCAmJiAhaXNTcGxpdDtcclxuICAgIHJldHVybiBTdHlsaW5nXzEubWVyZ2VTdHlsZVNldHMoe1xyXG4gICAgICAgIHJvb3Q6IFtcclxuICAgICAgICAgICAgJ21zLUJ1dHRvbicsXHJcbiAgICAgICAgICAgIHN0eWxlcy5yb290LFxyXG4gICAgICAgICAgICB2YXJpYW50Q2xhc3NOYW1lLFxyXG4gICAgICAgICAgICBjbGFzc05hbWUsXHJcbiAgICAgICAgICAgIGNoZWNrZWQgJiYgW1xyXG4gICAgICAgICAgICAgICAgJ2lzLWNoZWNrZWQnLFxyXG4gICAgICAgICAgICAgICAgc3R5bGVzLnJvb3RDaGVja2VkXHJcbiAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgIGlzRXhwYW5kZWQgJiYgW1xyXG4gICAgICAgICAgICAgICAgJ2lzLWV4cGFuZGVkJyxcclxuICAgICAgICAgICAgICAgIHN0eWxlcy5yb290RXhwYW5kZWQsXHJcbiAgICAgICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3JzOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICc6aG92ZXIgLm1zLUJ1dHRvbi1pY29uJzogc3R5bGVzLmljb25FeHBhbmRlZEhvdmVyZWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICc6aG92ZXIgLm1zLUJ1dHRvbi1tZW51SWNvbic6IHN0eWxlcy5yb290RXhwYW5kZWRIb3ZlcmVkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAnOmhvdmVyJzogc3R5bGVzLnJvb3RFeHBhbmRlZEhvdmVyZWRcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgIGRpc2FibGVkICYmIFtcclxuICAgICAgICAgICAgICAgICdpcy1kaXNhYmxlZCcsXHJcbiAgICAgICAgICAgICAgICBzdHlsZXMucm9vdERpc2FibGVkXHJcbiAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgICFkaXNhYmxlZCAmJiAhaXNFeHBhbmRlZCAmJiAhY2hlY2tlZCAmJiB7XHJcbiAgICAgICAgICAgICAgICBzZWxlY3RvcnM6IHtcclxuICAgICAgICAgICAgICAgICAgICAnOmhvdmVyJzogc3R5bGVzLnJvb3RIb3ZlcmVkLFxyXG4gICAgICAgICAgICAgICAgICAgICc6aG92ZXIgLm1zLUJ1dHRvbi1pY29uJzogc3R5bGVzLmljb25Ib3ZlcmVkLFxyXG4gICAgICAgICAgICAgICAgICAgICc6aG92ZXIgLm1zLUJ1dHRvbi1kZXNjcmlwdGlvbic6IHN0eWxlcy5kZXNjcmlwdGlvbkhvdmVyZWQsXHJcbiAgICAgICAgICAgICAgICAgICAgJzpob3ZlciAubXMtQnV0dG9uLW1lbnVJY29uJzogc3R5bGVzLm1lbnVJY29uSG92ZXJlZCxcclxuICAgICAgICAgICAgICAgICAgICAnOmZvY3VzJzogc3R5bGVzLnJvb3RGb2N1c2VkLFxyXG4gICAgICAgICAgICAgICAgICAgICc6YWN0aXZlJzogc3R5bGVzLnJvb3RQcmVzc2VkLFxyXG4gICAgICAgICAgICAgICAgICAgICc6YWN0aXZlIC5tcy1CdXR0b24taWNvbic6IHN0eWxlcy5pY29uUHJlc3NlZCxcclxuICAgICAgICAgICAgICAgICAgICAnOmFjdGl2ZSAubXMtQnV0dG9uLWRlc2NyaXB0aW9uJzogc3R5bGVzLmRlc2NyaXB0aW9uUHJlc3NlZCxcclxuICAgICAgICAgICAgICAgICAgICAnOmFjdGl2ZSAubXMtQnV0dG9uLW1lbnVJY29uJzogc3R5bGVzLm1lbnVJY29uUHJlc3NlZFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBkaXNhYmxlZCAmJiBjaGVja2VkICYmIFtcclxuICAgICAgICAgICAgICAgIHN0eWxlcy5yb290Q2hlY2tlZERpc2FibGVkXHJcbiAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgICFkaXNhYmxlZCAmJiBjaGVja2VkICYmIHtcclxuICAgICAgICAgICAgICAgIHNlbGVjdG9yczoge1xyXG4gICAgICAgICAgICAgICAgICAgICc6aG92ZXInOiBzdHlsZXMucm9vdENoZWNrZWRIb3ZlcmVkLFxyXG4gICAgICAgICAgICAgICAgICAgICc6YWN0aXZlJzogc3R5bGVzLnJvb3RDaGVja2VkUHJlc3NlZFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgXSxcclxuICAgICAgICBmbGV4Q29udGFpbmVyOiBbXHJcbiAgICAgICAgICAgICdtcy1CdXR0b24tZmxleENvbnRhaW5lcicsXHJcbiAgICAgICAgICAgIHN0eWxlcy5mbGV4Q29udGFpbmVyXHJcbiAgICAgICAgXSxcclxuICAgICAgICB0ZXh0Q29udGFpbmVyOiBbXHJcbiAgICAgICAgICAgICdtcy1CdXR0b24tdGV4dENvbnRhaW5lcicsXHJcbiAgICAgICAgICAgIHN0eWxlcy50ZXh0Q29udGFpbmVyXHJcbiAgICAgICAgXSxcclxuICAgICAgICBpY29uOiBbXHJcbiAgICAgICAgICAgICdtcy1CdXR0b24taWNvbicsXHJcbiAgICAgICAgICAgIGljb25DbGFzc05hbWUsXHJcbiAgICAgICAgICAgIHN0eWxlcy5pY29uLFxyXG4gICAgICAgICAgICBpc0V4cGFuZGVkICYmIHN0eWxlcy5pY29uRXhwYW5kZWQsXHJcbiAgICAgICAgICAgIGNoZWNrZWQgJiYgc3R5bGVzLmljb25DaGVja2VkLFxyXG4gICAgICAgICAgICBkaXNhYmxlZCAmJiBzdHlsZXMuaWNvbkRpc2FibGVkLFxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgbGFiZWw6IFtcclxuICAgICAgICAgICAgJ21zLUJ1dHRvbi1sYWJlbCcsXHJcbiAgICAgICAgICAgIHN0eWxlcy5sYWJlbCxcclxuICAgICAgICAgICAgY2hlY2tlZCAmJiBzdHlsZXMubGFiZWxDaGVja2VkLFxyXG4gICAgICAgICAgICBkaXNhYmxlZCAmJiBzdHlsZXMubGFiZWxEaXNhYmxlZCxcclxuICAgICAgICBdLFxyXG4gICAgICAgIG1lbnVJY29uOiBbXHJcbiAgICAgICAgICAgICdtcy1CdXR0b24tbWVudUljb24nLFxyXG4gICAgICAgICAgICBtZW51SWNvbkNsYXNzTmFtZSxcclxuICAgICAgICAgICAgc3R5bGVzLm1lbnVJY29uLFxyXG4gICAgICAgICAgICBjaGVja2VkICYmIHN0eWxlcy5tZW51SWNvbkNoZWNrZWQsXHJcbiAgICAgICAgICAgIGRpc2FibGVkICYmIHN0eWxlcy5tZW51SWNvbkRpc2FibGVkLFxyXG4gICAgICAgICAgICAhZGlzYWJsZWQgJiZcclxuICAgICAgICAgICAgICAgICFpc0V4cGFuZGVkICYmXHJcbiAgICAgICAgICAgICAgICAhY2hlY2tlZCAmJiB7XHJcbiAgICAgICAgICAgICAgICBzZWxlY3RvcnM6IHtcclxuICAgICAgICAgICAgICAgICAgICAnOmhvdmVyJzogc3R5bGVzLm1lbnVJY29uSG92ZXJlZCxcclxuICAgICAgICAgICAgICAgICAgICAnOmFjdGl2ZSc6IHN0eWxlcy5tZW51SWNvblByZXNzZWQsXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBpc0V4cGFuZGVkICYmIFtcclxuICAgICAgICAgICAgICAgICdpcy1leHBhbmRlZCcsXHJcbiAgICAgICAgICAgICAgICBzdHlsZXMubWVudUljb25FeHBhbmRlZCxcclxuICAgICAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcnM6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJzpob3Zlcic6IHN0eWxlcy5tZW51SWNvbkV4cGFuZGVkSG92ZXJlZCxcclxuICAgICAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgXVxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgZGVzY3JpcHRpb246IFtcclxuICAgICAgICAgICAgJ21zLUJ1dHRvbi1kZXNjcmlwdGlvbicsXHJcbiAgICAgICAgICAgIHN0eWxlcy5kZXNjcmlwdGlvbixcclxuICAgICAgICAgICAgY2hlY2tlZCAmJiBzdHlsZXMuZGVzY3JpcHRpb25DaGVja2VkLFxyXG4gICAgICAgICAgICBkaXNhYmxlZCAmJiBzdHlsZXMuZGVzY3JpcHRpb25EaXNhYmxlZFxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgc2NyZWVuUmVhZGVyVGV4dDogW1xyXG4gICAgICAgICAgICAnbXMtQnV0dG9uLXNjcmVlblJlYWRlclRleHQnLFxyXG4gICAgICAgICAgICBzdHlsZXMuc2NyZWVuUmVhZGVyVGV4dFxyXG4gICAgICAgIF1cclxuICAgIH0pO1xyXG59KTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QmFzZUJ1dHRvbi5jbGFzc05hbWVzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xyXG52YXIgUmVhY3QgPSByZXF1aXJlKFwicmVhY3RcIik7XHJcbnZhciBVdGlsaXRpZXNfMSA9IHJlcXVpcmUoXCIuLi8uLi9VdGlsaXRpZXNcIik7XHJcbnZhciBJY29uXzEgPSByZXF1aXJlKFwiLi4vLi4vSWNvblwiKTtcclxudmFyIENvbnRleHR1YWxNZW51XzEgPSByZXF1aXJlKFwiLi4vLi4vQ29udGV4dHVhbE1lbnVcIik7XHJcbnZhciBCYXNlQnV0dG9uX2NsYXNzTmFtZXNfMSA9IHJlcXVpcmUoXCIuL0Jhc2VCdXR0b24uY2xhc3NOYW1lc1wiKTtcclxudmFyIFNwbGl0QnV0dG9uX2NsYXNzTmFtZXNfMSA9IHJlcXVpcmUoXCIuL1NwbGl0QnV0dG9uL1NwbGl0QnV0dG9uLmNsYXNzTmFtZXNcIik7XHJcbnZhciBCYXNlQnV0dG9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoQmFzZUJ1dHRvbiwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEJhc2VCdXR0b24ocHJvcHMsIHJvb3RDbGFzc05hbWUpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBwcm9wcykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5fd2FybkNvbmRpdGlvbmFsbHlSZXF1aXJlZFByb3BzKFsnbWVudVByb3BzJywgJ29uQ2xpY2snXSwgJ3NwbGl0JywgX3RoaXMucHJvcHMuc3BsaXQpO1xyXG4gICAgICAgIF90aGlzLl93YXJuRGVwcmVjYXRpb25zKHtcclxuICAgICAgICAgICAgcm9vdFByb3BzOiB1bmRlZmluZWRcclxuICAgICAgICB9KTtcclxuICAgICAgICBfdGhpcy5fbGFiZWxJZCA9IFV0aWxpdGllc18xLmdldElkKCk7XHJcbiAgICAgICAgX3RoaXMuX2Rlc2NyaXB0aW9uSWQgPSBVdGlsaXRpZXNfMS5nZXRJZCgpO1xyXG4gICAgICAgIF90aGlzLl9hcmlhRGVzY3JpcHRpb25JZCA9IFV0aWxpdGllc18xLmdldElkKCk7XHJcbiAgICAgICAgX3RoaXMuc3RhdGUgPSB7XHJcbiAgICAgICAgICAgIG1lbnVQcm9wczogbnVsbFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJhc2VCdXR0b24ucHJvdG90eXBlLCBcIl9pc1NwbGl0QnV0dG9uXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuICghIXRoaXMucHJvcHMubWVudVByb3BzICYmICEhdGhpcy5wcm9wcy5vbkNsaWNrKSAmJiB0aGlzLnByb3BzLnNwbGl0ID09PSB0cnVlO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcclxuICAgICAgICBjb25maWd1cmFibGU6IHRydWVcclxuICAgIH0pO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KEJhc2VCdXR0b24ucHJvdG90eXBlLCBcIl9pc0V4cGFuZGVkXCIsIHtcclxuICAgICAgICBnZXQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuICEhdGhpcy5zdGF0ZS5tZW51UHJvcHM7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxyXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxyXG4gICAgfSk7XHJcbiAgICBCYXNlQnV0dG9uLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF9hID0gdGhpcy5wcm9wcywgYXJpYURlc2NyaXB0aW9uID0gX2EuYXJpYURlc2NyaXB0aW9uLCBhcmlhTGFiZWwgPSBfYS5hcmlhTGFiZWwsIGFyaWFIaWRkZW4gPSBfYS5hcmlhSGlkZGVuLCBjbGFzc05hbWUgPSBfYS5jbGFzc05hbWUsIGRlc2NyaXB0aW9uID0gX2EuZGVzY3JpcHRpb24sIGRpc2FibGVkID0gX2EuZGlzYWJsZWQsIHByaW1hcnlEaXNhYmxlZCA9IF9hLnByaW1hcnlEaXNhYmxlZCwgaHJlZiA9IF9hLmhyZWYsIGljb25Qcm9wcyA9IF9hLmljb25Qcm9wcywgbWVudUljb25Qcm9wcyA9IF9hLm1lbnVJY29uUHJvcHMsIHN0eWxlcyA9IF9hLnN0eWxlcywgdGV4dCA9IF9hLnRleHQsIGNoZWNrZWQgPSBfYS5jaGVja2VkLCB2YXJpYW50Q2xhc3NOYW1lID0gX2EudmFyaWFudENsYXNzTmFtZSwgdGhlbWUgPSBfYS50aGVtZSwgZ2V0Q2xhc3NOYW1lcyA9IF9hLmdldENsYXNzTmFtZXM7XHJcbiAgICAgICAgdmFyIG1lbnVQcm9wcyA9IHRoaXMuc3RhdGUubWVudVByb3BzO1xyXG4gICAgICAgIC8vIEJ1dHRvbiBpcyBkaXNhYmxlZCBpZiB0aGUgd2hvbGUgYnV0dG9uIChpbiBjYXNlIG9mIHNwbGl0YnV0dG9uIGlzIGRpc2FibGVkKSBvciBpZiB0aGUgcHJpbWFyeSBhY3Rpb24gaXMgZGlzYWJsZWRcclxuICAgICAgICB2YXIgaXNQcmltYXJ5QnV0dG9uRGlzYWJsZWQgPSAoZGlzYWJsZWQgfHwgcHJpbWFyeURpc2FibGVkKTtcclxuICAgICAgICB0aGlzLl9jbGFzc05hbWVzID0gZ2V0Q2xhc3NOYW1lcyA/IGdldENsYXNzTmFtZXModGhlbWUsIGNsYXNzTmFtZSwgdmFyaWFudENsYXNzTmFtZSwgaWNvblByb3BzICYmIGljb25Qcm9wcy5jbGFzc05hbWUsIG1lbnVJY29uUHJvcHMgJiYgbWVudUljb25Qcm9wcy5jbGFzc05hbWUsIGlzUHJpbWFyeUJ1dHRvbkRpc2FibGVkLCBjaGVja2VkLCAhIXRoaXMuc3RhdGUubWVudVByb3BzLCB0aGlzLnByb3BzLnNwbGl0KSA6IEJhc2VCdXR0b25fY2xhc3NOYW1lc18xLmdldEJhc2VCdXR0b25DbGFzc05hbWVzKHN0eWxlcywgY2xhc3NOYW1lLCB2YXJpYW50Q2xhc3NOYW1lLCBpY29uUHJvcHMgJiYgaWNvblByb3BzLmNsYXNzTmFtZSwgbWVudUljb25Qcm9wcyAmJiBtZW51SWNvblByb3BzLmNsYXNzTmFtZSwgaXNQcmltYXJ5QnV0dG9uRGlzYWJsZWQsIGNoZWNrZWQsICEhdGhpcy5zdGF0ZS5tZW51UHJvcHMsIHRoaXMucHJvcHMuc3BsaXQpO1xyXG4gICAgICAgIHZhciBfYiA9IHRoaXMsIF9hcmlhRGVzY3JpcHRpb25JZCA9IF9iLl9hcmlhRGVzY3JpcHRpb25JZCwgX2xhYmVsSWQgPSBfYi5fbGFiZWxJZCwgX2Rlc2NyaXB0aW9uSWQgPSBfYi5fZGVzY3JpcHRpb25JZDtcclxuICAgICAgICAvLyBBbmNob3IgdGFnIGNhbm5vdCBiZSBkaXNhYmxlZCBoZW5jZSBpbiBkaXNhYmxlZCBzdGF0ZSByZW5kZXJpbmdcclxuICAgICAgICAvLyBhbmNob3IgYnV0dG9uIGFzIG5vcm1hbCBidXR0b25cclxuICAgICAgICB2YXIgcmVuZGVyQXNBbmNob3IgPSAhaXNQcmltYXJ5QnV0dG9uRGlzYWJsZWQgJiYgISFocmVmO1xyXG4gICAgICAgIHZhciB0YWcgPSByZW5kZXJBc0FuY2hvciA/ICdhJyA6ICdidXR0b24nO1xyXG4gICAgICAgIHZhciBuYXRpdmVQcm9wcyA9IFV0aWxpdGllc18xLmdldE5hdGl2ZVByb3BzKFV0aWxpdGllc18xLmFzc2lnbihyZW5kZXJBc0FuY2hvciA/IHt9IDogeyB0eXBlOiAnYnV0dG9uJyB9LCB0aGlzLnByb3BzLnJvb3RQcm9wcywgdGhpcy5wcm9wcyksIHJlbmRlckFzQW5jaG9yID8gVXRpbGl0aWVzXzEuYW5jaG9yUHJvcGVydGllcyA6IFV0aWxpdGllc18xLmJ1dHRvblByb3BlcnRpZXMsIFtcclxuICAgICAgICAgICAgJ2Rpc2FibGVkJyAvLyBMZXQgZGlzYWJsZWQgYnV0dG9ucyBiZSBmb2N1c2VkIGFuZCBzdHlsZWQgYXMgZGlzYWJsZWQuXHJcbiAgICAgICAgXSk7XHJcbiAgICAgICAgLy8gQ2hlY2sgZm9yIGFyaWFEZXNjcmlwdGlvbiwgZGVzY3JpcHRpb24gb3IgYXJpYS1kZXNjcmliZWRieSBpbiB0aGUgbmF0aXZlIHByb3BzIHRvIGRldGVybWluZSBzb3VyY2Ugb2YgYXJpYS1kZXNjcmliZWRieVxyXG4gICAgICAgIC8vIG90aGVyd2lzZSBkZWZhdWx0IHRvIG51bGwuXHJcbiAgICAgICAgdmFyIGFyaWFEZXNjcmliZWRCeTtcclxuICAgICAgICBpZiAoYXJpYURlc2NyaXB0aW9uKSB7XHJcbiAgICAgICAgICAgIGFyaWFEZXNjcmliZWRCeSA9IF9hcmlhRGVzY3JpcHRpb25JZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoZGVzY3JpcHRpb24pIHtcclxuICAgICAgICAgICAgYXJpYURlc2NyaWJlZEJ5ID0gX2Rlc2NyaXB0aW9uSWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKG5hdGl2ZVByb3BzWydhcmlhLWRlc2NyaWJlZGJ5J10pIHtcclxuICAgICAgICAgICAgYXJpYURlc2NyaWJlZEJ5ID0gbmF0aXZlUHJvcHNbJ2FyaWEtZGVzY3JpYmVkYnknXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGFyaWFEZXNjcmliZWRCeSA9IG51bGw7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIElmIGFuIGV4cGxpY2l0IGFyaWFMYWJlbCBpcyBnaXZlbiwgdXNlIHRoYXQgYXMgdGhlIGxhYmVsIGFuZCB3ZSdyZSBkb25lLlxyXG4gICAgICAgIC8vIElmIGFuIGV4cGxpY2l0IGFyaWEtbGFiZWxsZWRieSBpcyBnaXZlbiwgdXNlIHRoYXQgYW5kIHdlJ3JlIGRvbmUuXHJcbiAgICAgICAgLy8gSWYgYW55IGtpbmQgb2YgZGVzY3JpcHRpb24gaXMgZ2l2ZW4gKHdoaWNoIHdpbGwgZW5kIHVwIGFzIGFuIGFyaWEtZGVzY3JpYmVkYnkgYXR0cmlidXRlKSxcclxuICAgICAgICAvLyBzZXQgdGhlIGxhYmVsbGVkYnkgZWxlbWVudC4gT3RoZXJ3aXNlLCB0aGUgYnV0dG9uIGlzIGxhYmVsZWQgaW1wbGljaXRseSBieSB0aGUgZGVzY2VuZGVudFxyXG4gICAgICAgIC8vIHRleHQgb24gdGhlIGJ1dHRvbiAoaWYgaXQgZXhpc3RzKS4gTmV2ZXIgc2V0IGJvdGggYXJpYS1sYWJlbCBhbmQgYXJpYS1sYWJlbGxlZGJ5LlxyXG4gICAgICAgIHZhciBhcmlhTGFiZWxsZWRCeSA9IG51bGw7XHJcbiAgICAgICAgaWYgKCFhcmlhTGFiZWwpIHtcclxuICAgICAgICAgICAgaWYgKG5hdGl2ZVByb3BzWydhcmlhLWxhYmVsbGVkYnknXSkge1xyXG4gICAgICAgICAgICAgICAgYXJpYUxhYmVsbGVkQnkgPSBuYXRpdmVQcm9wc1snYXJpYS1sYWJlbGxlZGJ5J107XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoYXJpYURlc2NyaWJlZEJ5KSB7XHJcbiAgICAgICAgICAgICAgICBhcmlhTGFiZWxsZWRCeSA9IHRleHQgPyBfbGFiZWxJZCA6IG51bGw7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGJ1dHRvblByb3BzID0gVXRpbGl0aWVzXzEuYXNzaWduKG5hdGl2ZVByb3BzLCB7XHJcbiAgICAgICAgICAgIGNsYXNzTmFtZTogdGhpcy5fY2xhc3NOYW1lcy5yb290LFxyXG4gICAgICAgICAgICByZWY6IHRoaXMuX3Jlc29sdmVSZWYoJ19idXR0b25FbGVtZW50JyksXHJcbiAgICAgICAgICAgICdkaXNhYmxlZCc6IGlzUHJpbWFyeUJ1dHRvbkRpc2FibGVkLFxyXG4gICAgICAgICAgICAnYXJpYS1sYWJlbCc6IGFyaWFMYWJlbCxcclxuICAgICAgICAgICAgJ2FyaWEtbGFiZWxsZWRieSc6IGFyaWFMYWJlbGxlZEJ5LFxyXG4gICAgICAgICAgICAnYXJpYS1kZXNjcmliZWRieSc6IGFyaWFEZXNjcmliZWRCeSxcclxuICAgICAgICAgICAgJ2RhdGEtaXMtZm9jdXNhYmxlJzogKHRoaXMucHJvcHNbJ2RhdGEtaXMtZm9jdXNhYmxlJ10gPT09IGZhbHNlIHx8IGRpc2FibGVkKSA/IGZhbHNlIDogdHJ1ZSxcclxuICAgICAgICAgICAgJ2FyaWEtcHJlc3NlZCc6IGNoZWNrZWRcclxuICAgICAgICB9KTtcclxuICAgICAgICBpZiAoYXJpYUhpZGRlbikge1xyXG4gICAgICAgICAgICBidXR0b25Qcm9wc1snYXJpYS1oaWRkZW4nXSA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0aGlzLl9pc1NwbGl0QnV0dG9uKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAodGhpcy5fb25SZW5kZXJTcGxpdEJ1dHRvbkNvbnRlbnQodGFnLCBidXR0b25Qcm9wcykpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIGlmICh0aGlzLnByb3BzLm1lbnVQcm9wcykge1xyXG4gICAgICAgICAgICBVdGlsaXRpZXNfMS5hc3NpZ24oYnV0dG9uUHJvcHMsIHtcclxuICAgICAgICAgICAgICAgICdvbktleURvd24nOiB0aGlzLl9vbk1lbnVLZXlEb3duLFxyXG4gICAgICAgICAgICAgICAgJ29uQ2xpY2snOiB0aGlzLl9vbk1lbnVDbGljayxcclxuICAgICAgICAgICAgICAgICdhcmlhLWV4cGFuZGVkJzogdGhpcy5faXNFeHBhbmRlZCxcclxuICAgICAgICAgICAgICAgICdhcmlhLW93bnMnOiB0aGlzLnN0YXRlLm1lbnVQcm9wcyA/IHRoaXMuX2xhYmVsSWQgKyAnLW1lbnUnIDogbnVsbCxcclxuICAgICAgICAgICAgICAgICdhcmlhLWhhc3BvcHVwJzogdHJ1ZVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX29uUmVuZGVyQ29udGVudCh0YWcsIGJ1dHRvblByb3BzKTtcclxuICAgIH07XHJcbiAgICBCYXNlQnV0dG9uLnByb3RvdHlwZS5jb21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbiAocHJldlByb3BzLCBwcmV2U3RhdGUpIHtcclxuICAgICAgICAvLyBJZiBCdXR0b24ncyBtZW51IHdhcyBjbG9zZWQsIHJ1biBvbkFmdGVyTWVudURpc21pc3NcclxuICAgICAgICBpZiAodGhpcy5wcm9wcy5vbkFmdGVyTWVudURpc21pc3MgJiYgcHJldlN0YXRlLm1lbnVQcm9wcyAmJiAhdGhpcy5zdGF0ZS5tZW51UHJvcHMpIHtcclxuICAgICAgICAgICAgdGhpcy5wcm9wcy5vbkFmdGVyTWVudURpc21pc3MoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQmFzZUJ1dHRvbi5wcm90b3R5cGUuZm9jdXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2J1dHRvbkVsZW1lbnQpIHtcclxuICAgICAgICAgICAgdGhpcy5fYnV0dG9uRWxlbWVudC5mb2N1cygpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBCYXNlQnV0dG9uLnByb3RvdHlwZS5kaXNtaXNzTWVudSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLnNldFN0YXRlKHsgbWVudVByb3BzOiBudWxsIH0pO1xyXG4gICAgfTtcclxuICAgIEJhc2VCdXR0b24ucHJvdG90eXBlLl9vblJlbmRlckNvbnRlbnQgPSBmdW5jdGlvbiAodGFnLCBidXR0b25Qcm9wcykge1xyXG4gICAgICAgIHZhciBwcm9wcyA9IHRoaXMucHJvcHM7XHJcbiAgICAgICAgdmFyIFRhZyA9IHRhZztcclxuICAgICAgICB2YXIgbWVudUljb25Qcm9wcyA9IHByb3BzLm1lbnVJY29uUHJvcHMsIG1lbnVQcm9wcyA9IHByb3BzLm1lbnVQcm9wcywgX2EgPSBwcm9wcy5vblJlbmRlckljb24sIG9uUmVuZGVySWNvbiA9IF9hID09PSB2b2lkIDAgPyB0aGlzLl9vblJlbmRlckljb24gOiBfYSwgX2IgPSBwcm9wcy5vblJlbmRlckFyaWFEZXNjcmlwdGlvbiwgb25SZW5kZXJBcmlhRGVzY3JpcHRpb24gPSBfYiA9PT0gdm9pZCAwID8gdGhpcy5fb25SZW5kZXJBcmlhRGVzY3JpcHRpb24gOiBfYiwgX2MgPSBwcm9wcy5vblJlbmRlckNoaWxkcmVuLCBvblJlbmRlckNoaWxkcmVuID0gX2MgPT09IHZvaWQgMCA/IHRoaXMuX29uUmVuZGVyQ2hpbGRyZW4gOiBfYywgX2QgPSBwcm9wcy5vblJlbmRlck1lbnUsIG9uUmVuZGVyTWVudSA9IF9kID09PSB2b2lkIDAgPyB0aGlzLl9vblJlbmRlck1lbnUgOiBfZCwgX2UgPSBwcm9wcy5vblJlbmRlck1lbnVJY29uLCBvblJlbmRlck1lbnVJY29uID0gX2UgPT09IHZvaWQgMCA/IHRoaXMuX29uUmVuZGVyTWVudUljb24gOiBfZTtcclxuICAgICAgICB2YXIgQ29udGVudCA9IChSZWFjdC5jcmVhdGVFbGVtZW50KFRhZywgdHNsaWJfMS5fX2Fzc2lnbih7fSwgYnV0dG9uUHJvcHMpLFxyXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiB0aGlzLl9jbGFzc05hbWVzLmZsZXhDb250YWluZXIgfSxcclxuICAgICAgICAgICAgICAgIG9uUmVuZGVySWNvbihwcm9wcywgdGhpcy5fb25SZW5kZXJJY29uKSxcclxuICAgICAgICAgICAgICAgIHRoaXMuX29uUmVuZGVyVGV4dENvbnRlbnRzKCksXHJcbiAgICAgICAgICAgICAgICBvblJlbmRlckFyaWFEZXNjcmlwdGlvbihwcm9wcywgdGhpcy5fb25SZW5kZXJBcmlhRGVzY3JpcHRpb24pLFxyXG4gICAgICAgICAgICAgICAgb25SZW5kZXJDaGlsZHJlbihwcm9wcywgdGhpcy5fb25SZW5kZXJDaGlsZHJlbiksXHJcbiAgICAgICAgICAgICAgICAhdGhpcy5faXNTcGxpdEJ1dHRvbiAmJiAobWVudVByb3BzIHx8IG1lbnVJY29uUHJvcHMgfHwgdGhpcy5wcm9wcy5vblJlbmRlck1lbnVJY29uKSAmJiBvblJlbmRlck1lbnVJY29uKHRoaXMucHJvcHMsIHRoaXMuX29uUmVuZGVyTWVudUljb24pLFxyXG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZS5tZW51UHJvcHMgJiYgIXRoaXMuc3RhdGUubWVudVByb3BzLmRvTm90TGF5ZXIgJiYgb25SZW5kZXJNZW51KG1lbnVQcm9wcywgdGhpcy5fb25SZW5kZXJNZW51KSkpKTtcclxuICAgICAgICBpZiAobWVudVByb3BzICYmIG1lbnVQcm9wcy5kb05vdExheWVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHN0eWxlOiB7IGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snIH0gfSxcclxuICAgICAgICAgICAgICAgIENvbnRlbnQsXHJcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLm1lbnVQcm9wcyAmJiBvblJlbmRlck1lbnUobWVudVByb3BzLCB0aGlzLl9vblJlbmRlck1lbnUpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBDb250ZW50O1xyXG4gICAgfTtcclxuICAgIEJhc2VCdXR0b24ucHJvdG90eXBlLl9vblJlbmRlckljb24gPSBmdW5jdGlvbiAoYnV0dG9uUHJvcHMsIGRlZmF1bHRSZW5kZXIpIHtcclxuICAgICAgICB2YXIgaWNvblByb3BzID0gdGhpcy5wcm9wcy5pY29uUHJvcHM7XHJcbiAgICAgICAgaWYgKGljb25Qcm9wcykge1xyXG4gICAgICAgICAgICByZXR1cm4gSWNvbl8xLkljb24odHNsaWJfMS5fX2Fzc2lnbih7fSwgaWNvblByb3BzLCB7IGNsYXNzTmFtZTogdGhpcy5fY2xhc3NOYW1lcy5pY29uIH0pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9O1xyXG4gICAgQmFzZUJ1dHRvbi5wcm90b3R5cGUuX29uUmVuZGVyVGV4dENvbnRlbnRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfYSA9IHRoaXMucHJvcHMsIHRleHQgPSBfYS50ZXh0LCBjaGlsZHJlbiA9IF9hLmNoaWxkcmVuLCBkZXNjcmlwdGlvbiA9IF9hLmRlc2NyaXB0aW9uLCBfYiA9IF9hLm9uUmVuZGVyVGV4dCwgb25SZW5kZXJUZXh0ID0gX2IgPT09IHZvaWQgMCA/IHRoaXMuX29uUmVuZGVyVGV4dCA6IF9iLCBfYyA9IF9hLm9uUmVuZGVyRGVzY3JpcHRpb24sIG9uUmVuZGVyRGVzY3JpcHRpb24gPSBfYyA9PT0gdm9pZCAwID8gdGhpcy5fb25SZW5kZXJEZXNjcmlwdGlvbiA6IF9jO1xyXG4gICAgICAgIGlmICh0ZXh0IHx8IHR5cGVvZiAoY2hpbGRyZW4pID09PSAnc3RyaW5nJyB8fCBkZXNjcmlwdGlvbikge1xyXG4gICAgICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IHRoaXMuX2NsYXNzTmFtZXMudGV4dENvbnRhaW5lciB9LFxyXG4gICAgICAgICAgICAgICAgb25SZW5kZXJUZXh0KHRoaXMucHJvcHMsIHRoaXMuX29uUmVuZGVyVGV4dCksXHJcbiAgICAgICAgICAgICAgICBvblJlbmRlckRlc2NyaXB0aW9uKHRoaXMucHJvcHMsIHRoaXMuX29uUmVuZGVyRGVzY3JpcHRpb24pKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiAoW1xyXG4gICAgICAgICAgICBvblJlbmRlclRleHQodGhpcy5wcm9wcywgdGhpcy5fb25SZW5kZXJUZXh0KSxcclxuICAgICAgICAgICAgb25SZW5kZXJEZXNjcmlwdGlvbih0aGlzLnByb3BzLCB0aGlzLl9vblJlbmRlckRlc2NyaXB0aW9uKVxyXG4gICAgICAgIF0pO1xyXG4gICAgfTtcclxuICAgIEJhc2VCdXR0b24ucHJvdG90eXBlLl9vblJlbmRlclRleHQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF9hID0gdGhpcy5wcm9wcywgY2hpbGRyZW4gPSBfYS5jaGlsZHJlbiwgdGV4dCA9IF9hLnRleHQ7XHJcbiAgICAgICAgLy8gRm9yIGJhY2t3YXJkcyBjb21wYXQsIHdlIHNob3VsZCBjb250aW51ZSB0byB0YWtlIGluIHRoZSB0ZXh0IGNvbnRlbnQgZnJvbSBjaGlsZHJlbi5cclxuICAgICAgICBpZiAodGV4dCA9PT0gdW5kZWZpbmVkICYmIHR5cGVvZiAoY2hpbGRyZW4pID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICB0ZXh0ID0gY2hpbGRyZW47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICh0ZXh0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGtleTogdGhpcy5fbGFiZWxJZCwgY2xhc3NOYW1lOiB0aGlzLl9jbGFzc05hbWVzLmxhYmVsLCBpZDogdGhpcy5fbGFiZWxJZCB9LCB0ZXh0KSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfTtcclxuICAgIEJhc2VCdXR0b24ucHJvdG90eXBlLl9vblJlbmRlckNoaWxkcmVuID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBjaGlsZHJlbiA9IHRoaXMucHJvcHMuY2hpbGRyZW47XHJcbiAgICAgICAgLy8gSWYgY2hpbGRyZW4gaXMganVzdCBhIHN0cmluZywgZWl0aGVyIGl0IG9yIHRoZSB0ZXh0IHdpbGwgYmUgcmVuZGVyZWQgdmlhIG9uUmVuZGVyTGFiZWxcclxuICAgICAgICAvLyBJZiBjaGlsZHJlbiBpcyBhbm90aGVyIGNvbXBvbmVudCwgaXQgd2lsbCBiZSByZW5kZXJlZCBhZnRlciB0ZXh0XHJcbiAgICAgICAgaWYgKHR5cGVvZiAoY2hpbGRyZW4pID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNoaWxkcmVuO1xyXG4gICAgfTtcclxuICAgIEJhc2VCdXR0b24ucHJvdG90eXBlLl9vblJlbmRlckRlc2NyaXB0aW9uID0gZnVuY3Rpb24gKHByb3BzKSB7XHJcbiAgICAgICAgdmFyIGRlc2NyaXB0aW9uID0gdGhpcy5wcm9wcy5kZXNjcmlwdGlvbjtcclxuICAgICAgICAvLyBtcy1CdXR0b24tZGVzY3JpcHRpb24gaXMgb25seSBzaG93biB3aGVuIHRoZSBidXR0b24gdHlwZSBpcyBjb21wb3VuZC5cclxuICAgICAgICAvLyBJbiBvdGhlciBjYXNlcyBpdCB3aWxsIG5vdCBiZSBkaXNwbGF5ZWQuXHJcbiAgICAgICAgcmV0dXJuIGRlc2NyaXB0aW9uID8gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBrZXk6IHRoaXMuX2Rlc2NyaXB0aW9uSWQsIGNsYXNzTmFtZTogdGhpcy5fY2xhc3NOYW1lcy5kZXNjcmlwdGlvbiwgaWQ6IHRoaXMuX2Rlc2NyaXB0aW9uSWQgfSwgZGVzY3JpcHRpb24pKSA6IChudWxsKTtcclxuICAgIH07XHJcbiAgICBCYXNlQnV0dG9uLnByb3RvdHlwZS5fb25SZW5kZXJBcmlhRGVzY3JpcHRpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGFyaWFEZXNjcmlwdGlvbiA9IHRoaXMucHJvcHMuYXJpYURlc2NyaXB0aW9uO1xyXG4gICAgICAgIC8vIElmIGFyaWFEZXNjcmlwdGlvbiBpcyBnaXZlbiwgZGVzY3JpcHRpb25JZCB3aWxsIGJlIGFzc2lnbmVkIHRvIGFyaWFEZXNjcmlwdGlvblNwYW4sXHJcbiAgICAgICAgLy8gb3RoZXJ3aXNlIGl0IHdpbGwgYmUgYXNzaWduZWQgdG8gZGVzY3JpcHRpb25TcGFuLlxyXG4gICAgICAgIHJldHVybiBhcmlhRGVzY3JpcHRpb24gPyAoUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgeyBjbGFzc05hbWU6IHRoaXMuX2NsYXNzTmFtZXMuc2NyZWVuUmVhZGVyVGV4dCwgaWQ6IHRoaXMuX2FyaWFEZXNjcmlwdGlvbklkIH0sIGFyaWFEZXNjcmlwdGlvbikpIDogKG51bGwpO1xyXG4gICAgfTtcclxuICAgIEJhc2VCdXR0b24ucHJvdG90eXBlLl9vblJlbmRlck1lbnVJY29uID0gZnVuY3Rpb24gKHByb3BzKSB7XHJcbiAgICAgICAgdmFyIG1lbnVJY29uUHJvcHMgPSB0aGlzLnByb3BzLm1lbnVJY29uUHJvcHM7XHJcbiAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KEljb25fMS5JY29uLCB0c2xpYl8xLl9fYXNzaWduKHsgaWNvbk5hbWU6ICdDaGV2cm9uRG93bicgfSwgbWVudUljb25Qcm9wcywgeyBjbGFzc05hbWU6IHRoaXMuX2NsYXNzTmFtZXMubWVudUljb24gfSkpKTtcclxuICAgIH07XHJcbiAgICBCYXNlQnV0dG9uLnByb3RvdHlwZS5fb25SZW5kZXJNZW51ID0gZnVuY3Rpb24gKG1lbnVQcm9wcykge1xyXG4gICAgICAgIHZhciBfYSA9IG1lbnVQcm9wcy5vbkRpc21pc3MsIG9uRGlzbWlzcyA9IF9hID09PSB2b2lkIDAgPyB0aGlzLl9kaXNtaXNzTWVudSA6IF9hO1xyXG4gICAgICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChDb250ZXh0dWFsTWVudV8xLkNvbnRleHR1YWxNZW51LCB0c2xpYl8xLl9fYXNzaWduKHsgaWQ6IHRoaXMuX2xhYmVsSWQgKyAnLW1lbnUnLCBkaXJlY3Rpb25hbEhpbnQ6IDQgLyogYm90dG9tTGVmdEVkZ2UgKi8gfSwgbWVudVByb3BzLCB7IGNsYXNzTmFtZTogJ21zLUJhc2VCdXR0b24tbWVudWhvc3QgJyArIG1lbnVQcm9wcy5jbGFzc05hbWUsIHRhcmdldDogdGhpcy5faXNTcGxpdEJ1dHRvbiA/IHRoaXMuX3NwbGl0QnV0dG9uQ29udGFpbmVyIDogdGhpcy5fYnV0dG9uRWxlbWVudCwgbGFiZWxFbGVtZW50SWQ6IHRoaXMuX2xhYmVsSWQsIG9uRGlzbWlzczogb25EaXNtaXNzIH0pKSk7XHJcbiAgICB9O1xyXG4gICAgQmFzZUJ1dHRvbi5wcm90b3R5cGUuX2Rpc21pc3NNZW51ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuc2V0U3RhdGUoeyBtZW51UHJvcHM6IG51bGwgfSk7XHJcbiAgICB9O1xyXG4gICAgQmFzZUJ1dHRvbi5wcm90b3R5cGUuX29uVG9nZ2xlTWVudSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgbWVudVByb3BzID0gdGhpcy5wcm9wcy5tZW51UHJvcHM7XHJcbiAgICAgICAgdmFyIGN1cnJlbnRNZW51UHJvcHMgPSB0aGlzLnN0YXRlLm1lbnVQcm9wcztcclxuICAgICAgICB0aGlzLnNldFN0YXRlKHsgbWVudVByb3BzOiBjdXJyZW50TWVudVByb3BzID8gbnVsbCA6IG1lbnVQcm9wcyB9KTtcclxuICAgIH07XHJcbiAgICBCYXNlQnV0dG9uLnByb3RvdHlwZS5fb25SZW5kZXJTcGxpdEJ1dHRvbkNvbnRlbnQgPSBmdW5jdGlvbiAodGFnLCBidXR0b25Qcm9wcykge1xyXG4gICAgICAgIHZhciBfYSA9IHRoaXMucHJvcHMsIF9iID0gX2Euc3R5bGVzLCBzdHlsZXMgPSBfYiA9PT0gdm9pZCAwID8ge30gOiBfYiwgZGlzYWJsZWQgPSBfYS5kaXNhYmxlZCwgY2hlY2tlZCA9IF9hLmNoZWNrZWQsIGdldFNwbGl0QnV0dG9uQ2xhc3NOYW1lcyA9IF9hLmdldFNwbGl0QnV0dG9uQ2xhc3NOYW1lcztcclxuICAgICAgICB2YXIgY2xhc3NOYW1lcyA9IGdldFNwbGl0QnV0dG9uQ2xhc3NOYW1lcyA/IGdldFNwbGl0QnV0dG9uQ2xhc3NOYW1lcyghIWRpc2FibGVkLCAhIXRoaXMuc3RhdGUubWVudVByb3BzLCAhIWNoZWNrZWQpIDogc3R5bGVzICYmIFNwbGl0QnV0dG9uX2NsYXNzTmFtZXNfMS5nZXRDbGFzc05hbWVzKHN0eWxlcywgISFkaXNhYmxlZCwgISF0aGlzLnN0YXRlLm1lbnVQcm9wcywgISFjaGVja2VkKTtcclxuICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBcImFyaWEtbGFiZWxsZWRieVwiOiBidXR0b25Qcm9wcy5hcmlhTGFiZWwsIFwiYXJpYS1kaXNhYmxlZFwiOiBkaXNhYmxlZCwgXCJhcmlhLWhhc3BvcHVwXCI6IHRydWUsIFwiYXJpYS1leHBhbmRlZFwiOiB0aGlzLl9pc0V4cGFuZGVkLCBcImFyaWEtcHJlc3NlZFwiOiB0aGlzLnByb3BzLmNoZWNrZWQsIFwiYXJpYS1kZXNjcmliZWRieVwiOiBidXR0b25Qcm9wcy5hcmlhRGVzY3JpcHRpb24sIGNsYXNzTmFtZTogY2xhc3NOYW1lcyAmJiBjbGFzc05hbWVzLnNwbGl0QnV0dG9uQ29udGFpbmVyLCBvbktleURvd246IHRoaXMuX29uTWVudUtleURvd24sIHJlZjogdGhpcy5fcmVzb2x2ZVJlZignX3NwbGl0QnV0dG9uQ29udGFpbmVyJykgfSxcclxuICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgeyBcImFyaWEtaGlkZGVuXCI6IHRydWUsIFxyXG4gICAgICAgICAgICAgICAgLy8gVE9ETzogVEhJUyBTSE9VTEQgQkUgUkVNT1ZFRCFcclxuICAgICAgICAgICAgICAgIHN0eWxlOiB7ICdkaXNwbGF5JzogJ2ZsZXgnIH0gfSxcclxuICAgICAgICAgICAgICAgIHRoaXMuX29uUmVuZGVyQ29udGVudCh0YWcsIGJ1dHRvblByb3BzKSxcclxuICAgICAgICAgICAgICAgIHRoaXMuX29uUmVuZGVyU3BsaXRCdXR0b25NZW51QnV0dG9uKGNsYXNzTmFtZXMpLFxyXG4gICAgICAgICAgICAgICAgdGhpcy5fb25SZW5kZXJTcGxpdEJ1dHRvbkRpdmlkZXIoY2xhc3NOYW1lcykpKSk7XHJcbiAgICB9O1xyXG4gICAgQmFzZUJ1dHRvbi5wcm90b3R5cGUuX29uUmVuZGVyU3BsaXRCdXR0b25EaXZpZGVyID0gZnVuY3Rpb24gKGNsYXNzTmFtZXMpIHtcclxuICAgICAgICBpZiAoY2xhc3NOYW1lcyAmJiBjbGFzc05hbWVzLmRpdmlkZXIpIHtcclxuICAgICAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHsgY2xhc3NOYW1lOiBjbGFzc05hbWVzLmRpdmlkZXIgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfTtcclxuICAgIEJhc2VCdXR0b24ucHJvdG90eXBlLl9vblJlbmRlclNwbGl0QnV0dG9uTWVudUJ1dHRvbiA9IGZ1bmN0aW9uIChjbGFzc05hbWVzKSB7XHJcbiAgICAgICAgdmFyIF9hID0gdGhpcy5wcm9wcywgbWVudUljb25Qcm9wcyA9IF9hLm1lbnVJY29uUHJvcHMsIHNwbGl0QnV0dG9uQXJpYUxhYmVsID0gX2Euc3BsaXRCdXR0b25BcmlhTGFiZWw7XHJcbiAgICAgICAgaWYgKG1lbnVJY29uUHJvcHMgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICBtZW51SWNvblByb3BzID0ge1xyXG4gICAgICAgICAgICAgICAgaWNvbk5hbWU6ICdDaGV2cm9uRG93bidcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHNwbGl0QnV0dG9uUHJvcHMgPSB7XHJcbiAgICAgICAgICAgICdzdHlsZXMnOiBjbGFzc05hbWVzLFxyXG4gICAgICAgICAgICAnY2hlY2tlZCc6IHRoaXMucHJvcHMuY2hlY2tlZCxcclxuICAgICAgICAgICAgJ2Rpc2FibGVkJzogdGhpcy5wcm9wcy5kaXNhYmxlZCxcclxuICAgICAgICAgICAgJ29uQ2xpY2snOiB0aGlzLl9vbk1lbnVDbGljayxcclxuICAgICAgICAgICAgJ21lbnVQcm9wcyc6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgJ2ljb25Qcm9wcyc6IG1lbnVJY29uUHJvcHMsXHJcbiAgICAgICAgICAgICdhcmlhTGFiZWwnOiBzcGxpdEJ1dHRvbkFyaWFMYWJlbFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQmFzZUJ1dHRvbiwgdHNsaWJfMS5fX2Fzc2lnbih7fSwgc3BsaXRCdXR0b25Qcm9wcykpO1xyXG4gICAgfTtcclxuICAgIEJhc2VCdXR0b24ucHJvdG90eXBlLl9vbk1lbnVLZXlEb3duID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgaWYgKGV2LndoaWNoID09PSA0MCAvKiBkb3duICovKSB7XHJcbiAgICAgICAgICAgIHZhciBvbk1lbnVDbGljayA9IHRoaXMucHJvcHMub25NZW51Q2xpY2s7XHJcbiAgICAgICAgICAgIG9uTWVudUNsaWNrICYmIG9uTWVudUNsaWNrKGV2LCB0aGlzKTtcclxuICAgICAgICAgICAgIWV2LmRlZmF1bHRQcmV2ZW50ZWQgJiYgdGhpcy5fb25Ub2dnbGVNZW51KCk7XHJcbiAgICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBCYXNlQnV0dG9uLnByb3RvdHlwZS5fb25NZW51Q2xpY2sgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICB2YXIgb25NZW51Q2xpY2sgPSB0aGlzLnByb3BzLm9uTWVudUNsaWNrO1xyXG4gICAgICAgIG9uTWVudUNsaWNrICYmIG9uTWVudUNsaWNrKGV2LCB0aGlzKTtcclxuICAgICAgICAhZXYuZGVmYXVsdFByZXZlbnRlZCAmJiB0aGlzLl9vblRvZ2dsZU1lbnUoKTtcclxuICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgfTtcclxuICAgIEJhc2VCdXR0b24uZGVmYXVsdFByb3BzID0ge1xyXG4gICAgICAgIGJhc2VDbGFzc05hbWU6ICdtcy1CdXR0b24nLFxyXG4gICAgICAgIGNsYXNzTmFtZXM6IHt9LFxyXG4gICAgICAgIHN0eWxlczoge30sXHJcbiAgICAgICAgc3BsaXQ6IGZhbHNlLFxyXG4gICAgfTtcclxuICAgIHRzbGliXzEuX19kZWNvcmF0ZShbXHJcbiAgICAgICAgVXRpbGl0aWVzXzEuYXV0b2JpbmRcclxuICAgIF0sIEJhc2VCdXR0b24ucHJvdG90eXBlLCBcIl9vblJlbmRlckljb25cIiwgbnVsbCk7XHJcbiAgICB0c2xpYl8xLl9fZGVjb3JhdGUoW1xyXG4gICAgICAgIFV0aWxpdGllc18xLmF1dG9iaW5kXHJcbiAgICBdLCBCYXNlQnV0dG9uLnByb3RvdHlwZSwgXCJfb25SZW5kZXJUZXh0Q29udGVudHNcIiwgbnVsbCk7XHJcbiAgICB0c2xpYl8xLl9fZGVjb3JhdGUoW1xyXG4gICAgICAgIFV0aWxpdGllc18xLmF1dG9iaW5kXHJcbiAgICBdLCBCYXNlQnV0dG9uLnByb3RvdHlwZSwgXCJfb25SZW5kZXJUZXh0XCIsIG51bGwpO1xyXG4gICAgdHNsaWJfMS5fX2RlY29yYXRlKFtcclxuICAgICAgICBVdGlsaXRpZXNfMS5hdXRvYmluZFxyXG4gICAgXSwgQmFzZUJ1dHRvbi5wcm90b3R5cGUsIFwiX29uUmVuZGVyQ2hpbGRyZW5cIiwgbnVsbCk7XHJcbiAgICB0c2xpYl8xLl9fZGVjb3JhdGUoW1xyXG4gICAgICAgIFV0aWxpdGllc18xLmF1dG9iaW5kXHJcbiAgICBdLCBCYXNlQnV0dG9uLnByb3RvdHlwZSwgXCJfb25SZW5kZXJEZXNjcmlwdGlvblwiLCBudWxsKTtcclxuICAgIHRzbGliXzEuX19kZWNvcmF0ZShbXHJcbiAgICAgICAgVXRpbGl0aWVzXzEuYXV0b2JpbmRcclxuICAgIF0sIEJhc2VCdXR0b24ucHJvdG90eXBlLCBcIl9vblJlbmRlckFyaWFEZXNjcmlwdGlvblwiLCBudWxsKTtcclxuICAgIHRzbGliXzEuX19kZWNvcmF0ZShbXHJcbiAgICAgICAgVXRpbGl0aWVzXzEuYXV0b2JpbmRcclxuICAgIF0sIEJhc2VCdXR0b24ucHJvdG90eXBlLCBcIl9vblJlbmRlck1lbnVJY29uXCIsIG51bGwpO1xyXG4gICAgdHNsaWJfMS5fX2RlY29yYXRlKFtcclxuICAgICAgICBVdGlsaXRpZXNfMS5hdXRvYmluZFxyXG4gICAgXSwgQmFzZUJ1dHRvbi5wcm90b3R5cGUsIFwiX29uUmVuZGVyTWVudVwiLCBudWxsKTtcclxuICAgIHRzbGliXzEuX19kZWNvcmF0ZShbXHJcbiAgICAgICAgVXRpbGl0aWVzXzEuYXV0b2JpbmRcclxuICAgIF0sIEJhc2VCdXR0b24ucHJvdG90eXBlLCBcIl9kaXNtaXNzTWVudVwiLCBudWxsKTtcclxuICAgIHRzbGliXzEuX19kZWNvcmF0ZShbXHJcbiAgICAgICAgVXRpbGl0aWVzXzEuYXV0b2JpbmRcclxuICAgIF0sIEJhc2VCdXR0b24ucHJvdG90eXBlLCBcIl9vblRvZ2dsZU1lbnVcIiwgbnVsbCk7XHJcbiAgICB0c2xpYl8xLl9fZGVjb3JhdGUoW1xyXG4gICAgICAgIFV0aWxpdGllc18xLmF1dG9iaW5kXHJcbiAgICBdLCBCYXNlQnV0dG9uLnByb3RvdHlwZSwgXCJfb25NZW51S2V5RG93blwiLCBudWxsKTtcclxuICAgIHRzbGliXzEuX19kZWNvcmF0ZShbXHJcbiAgICAgICAgVXRpbGl0aWVzXzEuYXV0b2JpbmRcclxuICAgIF0sIEJhc2VCdXR0b24ucHJvdG90eXBlLCBcIl9vbk1lbnVDbGlja1wiLCBudWxsKTtcclxuICAgIHJldHVybiBCYXNlQnV0dG9uO1xyXG59KFV0aWxpdGllc18xLkJhc2VDb21wb25lbnQpKTtcclxuZXhwb3J0cy5CYXNlQnV0dG9uID0gQmFzZUJ1dHRvbjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QmFzZUJ1dHRvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgVXRpbGl0aWVzXzEgPSByZXF1aXJlKFwiLi4vLi4vVXRpbGl0aWVzXCIpO1xyXG52YXIgU3R5bGluZ18xID0gcmVxdWlyZShcIi4uLy4uL1N0eWxpbmdcIik7XHJcbnZhciBub091dGxpbmUgPSB7XHJcbiAgICBvdXRsaW5lOiAwXHJcbn07XHJcbnZhciBpY29uU3R5bGUgPSB7XHJcbiAgICBmb250U2l6ZTogU3R5bGluZ18xLkZvbnRTaXplcy5pY29uLFxyXG4gICAgbWFyZ2luOiAnMCA0cHgnLFxyXG4gICAgaGVpZ2h0OiAnMTZweCcsXHJcbiAgICBsaW5lSGVpZ2h0OiAnMTZweCcsXHJcbiAgICB0ZXh0QWxpZ246ICdjZW50ZXInLFxyXG4gICAgdmVydGljYWxBbGlnbjogJ21pZGRsZScsXHJcbiAgICBmbGV4U2hyaW5rOiAwXHJcbn07XHJcbi8qKlxyXG4gKiBHZXRzIHRoZSBiYXNlIGJ1dHRvbiBzdHlsZXMuIE5vdGU6IGJlY2F1c2UgaXQgaXMgYSBiYXNlIGNsYXNzIHRvIGJlIHVzZWQgd2l0aCB0aGUgYG1lcmdlUnVsZXNgXHJcbiAqIGhlbHBlciwgaXQgc2hvdWxkIGhhdmUgdmFsdWVzIGZvciBhbGwgY2xhc3MgbmFtZXMgaW4gdGhlIGludGVyZmFjZS4gVGhpcyBsZXQgYG1lcmdlUnVsZXNgIG9wdGltaXplXHJcbiAqIG1peGluZyBjbGFzcyBuYW1lcyB0b2dldGhlci5cclxuICovXHJcbmV4cG9ydHMuZ2V0U3R5bGVzID0gVXRpbGl0aWVzXzEubWVtb2l6ZUZ1bmN0aW9uKGZ1bmN0aW9uICh0aGVtZSkge1xyXG4gICAgdmFyIHNlbWFudGljQ29sb3JzID0gdGhlbWUuc2VtYW50aWNDb2xvcnM7XHJcbiAgICB2YXIgYm9yZGVyID0gc2VtYW50aWNDb2xvcnMuYnV0dG9uQm9yZGVyO1xyXG4gICAgdmFyIGRpc2FibGVkQmFja2dyb3VuZCA9IHNlbWFudGljQ29sb3JzLmRpc2FibGVkQmFja2dyb3VuZDtcclxuICAgIHZhciBkaXNhYmxlZFRleHQgPSBzZW1hbnRpY0NvbG9ycy5kaXNhYmxlZFRleHQ7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHJvb3Q6IFtcclxuICAgICAgICAgICAgU3R5bGluZ18xLmdldEZvY3VzU3R5bGUodGhlbWUsIC0xKSxcclxuICAgICAgICAgICAgdGhlbWUuZm9udHMubWVkaXVtLFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBib3hTaXppbmc6ICdib3JkZXItYm94JyxcclxuICAgICAgICAgICAgICAgIGJvcmRlcjogJzFweCBzb2xpZCAnICsgYm9yZGVyLFxyXG4gICAgICAgICAgICAgICAgdXNlclNlbGVjdDogJ25vbmUnLFxyXG4gICAgICAgICAgICAgICAgZGlzcGxheTogJ2lubGluZS1ibG9jaycsXHJcbiAgICAgICAgICAgICAgICB0ZXh0RGVjb3JhdGlvbjogJ25vbmUnLFxyXG4gICAgICAgICAgICAgICAgdGV4dEFsaWduOiAnY2VudGVyJyxcclxuICAgICAgICAgICAgICAgIGN1cnNvcjogJ3BvaW50ZXInLFxyXG4gICAgICAgICAgICAgICAgdmVydGljYWxBbGlnbjogJ3RvcCcsXHJcbiAgICAgICAgICAgICAgICBwYWRkaW5nOiAnMCAxNnB4JyxcclxuICAgICAgICAgICAgICAgIGJvcmRlclJhZGl1czogMFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgXSxcclxuICAgICAgICByb290RGlzYWJsZWQ6IHtcclxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBkaXNhYmxlZEJhY2tncm91bmQsXHJcbiAgICAgICAgICAgIGNvbG9yOiBkaXNhYmxlZFRleHQsXHJcbiAgICAgICAgICAgIGN1cnNvcjogJ2RlZmF1bHQnLFxyXG4gICAgICAgICAgICBwb2ludGVyRXZlbnRzOiAnbm9uZScsXHJcbiAgICAgICAgICAgIHNlbGVjdG9yczoge1xyXG4gICAgICAgICAgICAgICAgJzpob3Zlcic6IG5vT3V0bGluZSxcclxuICAgICAgICAgICAgICAgICc6Zm9jdXMnOiBub091dGxpbmVcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaWNvbkRpc2FibGVkOiB7XHJcbiAgICAgICAgICAgIGNvbG9yOiBkaXNhYmxlZFRleHRcclxuICAgICAgICB9LFxyXG4gICAgICAgIG1lbnVJY29uRGlzYWJsZWQ6IHtcclxuICAgICAgICAgICAgY29sb3I6IGRpc2FibGVkVGV4dFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZmxleENvbnRhaW5lcjoge1xyXG4gICAgICAgICAgICBkaXNwbGF5OiAnZmxleCcsXHJcbiAgICAgICAgICAgIGhlaWdodDogJzEwMCUnLFxyXG4gICAgICAgICAgICBmbGV4V3JhcDogJ25vd3JhcCcsXHJcbiAgICAgICAgICAgIGp1c3RpZnlDb250ZW50OiAnY2VudGVyJyxcclxuICAgICAgICAgICAgYWxpZ25JdGVtczogJ2NlbnRlcidcclxuICAgICAgICB9LFxyXG4gICAgICAgIHRleHRDb250YWluZXI6IHtcclxuICAgICAgICAgICAgZmxleEdyb3c6IDFcclxuICAgICAgICB9LFxyXG4gICAgICAgIGljb246IGljb25TdHlsZSxcclxuICAgICAgICBtZW51SWNvbjogW1xyXG4gICAgICAgICAgICBpY29uU3R5bGUsXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGZvbnRTaXplOiBTdHlsaW5nXzEuRm9udFNpemVzLnNtYWxsXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICBdLFxyXG4gICAgICAgIGxhYmVsOiB7XHJcbiAgICAgICAgICAgIG1hcmdpbjogJzAgNHB4JyxcclxuICAgICAgICAgICAgbGluZUhlaWdodDogJzEwMCUnXHJcbiAgICAgICAgfSxcclxuICAgICAgICBzY3JlZW5SZWFkZXJUZXh0OiBTdHlsaW5nXzEuaGlkZGVuQ29udGVudFN0eWxlXHJcbiAgICB9O1xyXG59KTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QmFzZUJ1dHRvbi5zdHlsZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XHJcbi8qIHRzbGludDpkaXNhYmxlOm5vLXVudXNlZC12YXJpYWJsZSAqL1xyXG52YXIgUmVhY3QgPSByZXF1aXJlKFwicmVhY3RcIik7XHJcbi8qIHRzbGludDplbmFibGU6bm8tdW51c2VkLXZhcmlhYmxlICovXHJcbnZhciBVdGlsaXRpZXNfMSA9IHJlcXVpcmUoXCIuLi8uLi9VdGlsaXRpZXNcIik7XHJcbnZhciBCdXR0b25fdHlwZXNfMSA9IHJlcXVpcmUoXCIuL0J1dHRvbi50eXBlc1wiKTtcclxudmFyIERlZmF1bHRCdXR0b25fMSA9IHJlcXVpcmUoXCIuL0RlZmF1bHRCdXR0b24vRGVmYXVsdEJ1dHRvblwiKTtcclxudmFyIEFjdGlvbkJ1dHRvbl8xID0gcmVxdWlyZShcIi4vQWN0aW9uQnV0dG9uL0FjdGlvbkJ1dHRvblwiKTtcclxudmFyIENvbXBvdW5kQnV0dG9uXzEgPSByZXF1aXJlKFwiLi9Db21wb3VuZEJ1dHRvbi9Db21wb3VuZEJ1dHRvblwiKTtcclxudmFyIEljb25CdXR0b25fMSA9IHJlcXVpcmUoXCIuL0ljb25CdXR0b24vSWNvbkJ1dHRvblwiKTtcclxudmFyIFByaW1hcnlCdXR0b25fMSA9IHJlcXVpcmUoXCIuL1ByaW1hcnlCdXR0b24vUHJpbWFyeUJ1dHRvblwiKTtcclxuLyoqXHJcbiAqIFRoaXMgY2xhc3MgaXMgZGVwcmVjYXRlZC4gVXNlIHRoZSBpbmRpdmlkdWFsICpCdXR0b24gY29tcG9uZW50cyBpbnN0ZWFkLlxyXG4gKiBAZGVwcmVjYXRlZFxyXG4gKi9cclxudmFyIEJ1dHRvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIHRzbGliXzEuX19leHRlbmRzKEJ1dHRvbiwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEJ1dHRvbihwcm9wcykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHByb3BzKSB8fCB0aGlzO1xyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIFNldCB0aGlzIEJhc2VDb21wb25lbnQuX3Jlc29sdmVDb21wb25lbnRSZWYgdG8gZmFsc2UsIGJ5cGFzc2luZyByZXNvbHV0aW9uIG9mIGNvbXBvbmVudFJlZi5cclxuICAgICAgICAgKi9cclxuICAgICAgICBfdGhpcy5fc2hvdWxkVXBkYXRlQ29tcG9uZW50UmVmID0gZmFsc2U7XHJcbiAgICAgICAgVXRpbGl0aWVzXzEud2FybihcIlRoZSBCdXR0b24gY29tcG9uZW50IGhhcyBiZWVuIGRlcHJlY2F0ZWQuIFVzZSBzcGVjaWZpYyB2YXJpYW50cyBpbnN0ZWFkLiBcIiArXHJcbiAgICAgICAgICAgIFwiKFByaW1hcnlCdXR0b24sIERlZmF1bHRCdXR0b24sIEljb25CdXR0b24sIEFjdGlvbkJ1dHRvbiwgZXRjLilcIik7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgQnV0dG9uLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHByb3BzID0gdGhpcy5wcm9wcztcclxuICAgICAgICBzd2l0Y2ggKHByb3BzLmJ1dHRvblR5cGUpIHtcclxuICAgICAgICAgICAgY2FzZSBCdXR0b25fdHlwZXNfMS5CdXR0b25UeXBlLmNvbW1hbmQ6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChBY3Rpb25CdXR0b25fMS5BY3Rpb25CdXR0b24sIHRzbGliXzEuX19hc3NpZ24oe30sIHByb3BzKSk7XHJcbiAgICAgICAgICAgIGNhc2UgQnV0dG9uX3R5cGVzXzEuQnV0dG9uVHlwZS5jb21wb3VuZDpcclxuICAgICAgICAgICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KENvbXBvdW5kQnV0dG9uXzEuQ29tcG91bmRCdXR0b24sIHRzbGliXzEuX19hc3NpZ24oe30sIHByb3BzKSk7XHJcbiAgICAgICAgICAgIGNhc2UgQnV0dG9uX3R5cGVzXzEuQnV0dG9uVHlwZS5pY29uOlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoSWNvbkJ1dHRvbl8xLkljb25CdXR0b24sIHRzbGliXzEuX19hc3NpZ24oe30sIHByb3BzKSk7XHJcbiAgICAgICAgICAgIGNhc2UgQnV0dG9uX3R5cGVzXzEuQnV0dG9uVHlwZS5wcmltYXJ5OlxyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoUHJpbWFyeUJ1dHRvbl8xLlByaW1hcnlCdXR0b24sIHRzbGliXzEuX19hc3NpZ24oe30sIHByb3BzKSk7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChEZWZhdWx0QnV0dG9uXzEuRGVmYXVsdEJ1dHRvbiwgdHNsaWJfMS5fX2Fzc2lnbih7fSwgcHJvcHMpKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEJ1dHRvbjtcclxufShVdGlsaXRpZXNfMS5CYXNlQ29tcG9uZW50KSk7XHJcbmV4cG9ydHMuQnV0dG9uID0gQnV0dG9uO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1CdXR0b24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIEVsZW1lbnRUeXBlO1xyXG4oZnVuY3Rpb24gKEVsZW1lbnRUeXBlKSB7XHJcbiAgICAvKiogPGJ1dHRvbj4gZWxlbWVudC4gKi9cclxuICAgIEVsZW1lbnRUeXBlW0VsZW1lbnRUeXBlW1wiYnV0dG9uXCJdID0gMF0gPSBcImJ1dHRvblwiO1xyXG4gICAgLyoqIDxhPiBlbGVtZW50LiAqL1xyXG4gICAgRWxlbWVudFR5cGVbRWxlbWVudFR5cGVbXCJhbmNob3JcIl0gPSAxXSA9IFwiYW5jaG9yXCI7XHJcbn0pKEVsZW1lbnRUeXBlID0gZXhwb3J0cy5FbGVtZW50VHlwZSB8fCAoZXhwb3J0cy5FbGVtZW50VHlwZSA9IHt9KSk7XHJcbnZhciBCdXR0b25UeXBlO1xyXG4oZnVuY3Rpb24gKEJ1dHRvblR5cGUpIHtcclxuICAgIEJ1dHRvblR5cGVbQnV0dG9uVHlwZVtcIm5vcm1hbFwiXSA9IDBdID0gXCJub3JtYWxcIjtcclxuICAgIEJ1dHRvblR5cGVbQnV0dG9uVHlwZVtcInByaW1hcnlcIl0gPSAxXSA9IFwicHJpbWFyeVwiO1xyXG4gICAgQnV0dG9uVHlwZVtCdXR0b25UeXBlW1wiaGVyb1wiXSA9IDJdID0gXCJoZXJvXCI7XHJcbiAgICBCdXR0b25UeXBlW0J1dHRvblR5cGVbXCJjb21wb3VuZFwiXSA9IDNdID0gXCJjb21wb3VuZFwiO1xyXG4gICAgQnV0dG9uVHlwZVtCdXR0b25UeXBlW1wiY29tbWFuZFwiXSA9IDRdID0gXCJjb21tYW5kXCI7XHJcbiAgICBCdXR0b25UeXBlW0J1dHRvblR5cGVbXCJpY29uXCJdID0gNV0gPSBcImljb25cIjtcclxuICAgIEJ1dHRvblR5cGVbQnV0dG9uVHlwZVtcImRlZmF1bHRcIl0gPSA2XSA9IFwiZGVmYXVsdFwiO1xyXG59KShCdXR0b25UeXBlID0gZXhwb3J0cy5CdXR0b25UeXBlIHx8IChleHBvcnRzLkJ1dHRvblR5cGUgPSB7fSkpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1CdXR0b24udHlwZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIFN0eWxpbmdfMSA9IHJlcXVpcmUoXCIuLi8uLi9TdHlsaW5nXCIpO1xyXG5mdW5jdGlvbiBzdGFuZGFyZFN0eWxlcyh0aGVtZSkge1xyXG4gICAgdmFyIHMgPSB0aGVtZS5zZW1hbnRpY0NvbG9ycztcclxuICAgIHZhciBidXR0b25CYWNrZ3JvdW5kID0gcy5idXR0b25CYWNrZ3JvdW5kO1xyXG4gICAgdmFyIGJ1dHRvbkJhY2tncm91bmRDaGVja2VkID0gcy5idXR0b25CYWNrZ3JvdW5kQ2hlY2tlZDtcclxuICAgIHZhciBidXR0b25CYWNrZ3JvdW5kSG92ZXJlZCA9IHMuYnV0dG9uQmFja2dyb3VuZEhvdmVyZWQ7XHJcbiAgICB2YXIgYnV0dG9uQmFja2dyb3VuZENoZWNrZWRIb3ZlcmVkID0gcy5idXR0b25CYWNrZ3JvdW5kQ2hlY2tlZEhvdmVyZWQ7XHJcbiAgICB2YXIgYnV0dG9uVGV4dCA9IHMuYnV0dG9uVGV4dDtcclxuICAgIHZhciBidXR0b25UZXh0SG92ZXJlZCA9IHMuYnV0dG9uVGV4dEhvdmVyZWQ7XHJcbiAgICB2YXIgYnV0dG9uVGV4dENoZWNrZWQgPSBzLmJ1dHRvblRleHRDaGVja2VkO1xyXG4gICAgdmFyIGJ1dHRvblRleHRDaGVja2VkSG92ZXJlZCA9IHMuYnV0dG9uVGV4dENoZWNrZWRIb3ZlcmVkO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICByb290OiB7XHJcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogYnV0dG9uQmFja2dyb3VuZCxcclxuICAgICAgICAgICAgY29sb3I6IGJ1dHRvblRleHRcclxuICAgICAgICB9LFxyXG4gICAgICAgIHJvb3RIb3ZlcmVkOiB7XHJcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogYnV0dG9uQmFja2dyb3VuZEhvdmVyZWQsXHJcbiAgICAgICAgICAgIGNvbG9yOiBidXR0b25UZXh0SG92ZXJlZFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcm9vdFByZXNzZWQ6IHtcclxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBidXR0b25CYWNrZ3JvdW5kQ2hlY2tlZCxcclxuICAgICAgICAgICAgY29sb3I6IGJ1dHRvblRleHRDaGVja2VkXHJcbiAgICAgICAgfSxcclxuICAgICAgICByb290RXhwYW5kZWQ6IHtcclxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBidXR0b25CYWNrZ3JvdW5kQ2hlY2tlZCxcclxuICAgICAgICAgICAgY29sb3I6IGJ1dHRvblRleHRDaGVja2VkXHJcbiAgICAgICAgfSxcclxuICAgICAgICByb290Q2hlY2tlZDoge1xyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IGJ1dHRvbkJhY2tncm91bmRDaGVja2VkLFxyXG4gICAgICAgICAgICBjb2xvcjogYnV0dG9uVGV4dENoZWNrZWRcclxuICAgICAgICB9LFxyXG4gICAgICAgIHJvb3RDaGVja2VkSG92ZXJlZDoge1xyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHRoZW1lLnBhbGV0dGUubmV1dHJhbExpZ2h0LFxyXG4gICAgICAgICAgICBjb2xvcjogYnV0dG9uVGV4dENoZWNrZWRIb3ZlcmVkXHJcbiAgICAgICAgfSxcclxuICAgICAgICAvLyBTcGxpdCBidXR0b24gc3R5bGVzXHJcbiAgICAgICAgc3BsaXRCdXR0b25Db250YWluZXI6IHt9LFxyXG4gICAgICAgIHNwbGl0QnV0dG9uTWVudUJ1dHRvbjoge1xyXG4gICAgICAgICAgICBjb2xvcjogdGhlbWUucGFsZXR0ZS53aGl0ZSxcclxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiB0aGVtZS5wYWxldHRlLm5ldXRyYWxMaWdodGVyLFxyXG4gICAgICAgICAgICBzZWxlY3RvcnM6IHtcclxuICAgICAgICAgICAgICAgICc6aG92ZXInOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiB0aGVtZS5wYWxldHRlLm5ldXRyYWxMaWdodFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc3BsaXRCdXR0b25NZW51QnV0dG9uRGlzYWJsZWQ6IHtcclxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiB0aGVtZS5wYWxldHRlLm5ldXRyYWxMaWdodGVyLFxyXG4gICAgICAgICAgICBzZWxlY3RvcnM6IHtcclxuICAgICAgICAgICAgICAgICc6aG92ZXInOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiB0aGVtZS5wYWxldHRlLm5ldXRyYWxMaWdodGVyLFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBzcGxpdEJ1dHRvbkRpdmlkZXI6IHtcclxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiB0aGVtZS5wYWxldHRlLm5ldXRyYWxUZXJ0aWFyeUFsdFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc3BsaXRCdXR0b25NZW51QnV0dG9uQ2hlY2tlZDoge1xyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHRoZW1lLnBhbGV0dGUudGhlbWVQcmltYXJ5LFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc3BsaXRCdXR0b25NZW51QnV0dG9uRXhwYW5kZWQ6IHtcclxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiB0aGVtZS5wYWxldHRlLm5ldXRyYWxMaWdodCxcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNwbGl0QnV0dG9uTWVudUljb246IHtcclxuICAgICAgICAgICAgY29sb3I6IHRoZW1lLnBhbGV0dGUubmV1dHJhbFByaW1hcnlcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNwbGl0QnV0dG9uTWVudUljb25EaXNhYmxlZDoge1xyXG4gICAgICAgICAgICBjb2xvcjogdGhlbWUucGFsZXR0ZS5uZXV0cmFsVGVydGlhcnlcclxuICAgICAgICB9LFxyXG4gICAgfTtcclxufVxyXG5leHBvcnRzLnN0YW5kYXJkU3R5bGVzID0gc3RhbmRhcmRTdHlsZXM7XHJcbmZ1bmN0aW9uIHByaW1hcnlTdHlsZXModGhlbWUpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcm9vdDoge1xyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHRoZW1lLnBhbGV0dGUudGhlbWVQcmltYXJ5LFxyXG4gICAgICAgICAgICBjb2xvcjogdGhlbWUucGFsZXR0ZS53aGl0ZSxcclxuICAgICAgICAgICAgc2VsZWN0b3JzOiAoX2EgPSB7fSxcclxuICAgICAgICAgICAgICAgIF9hW1N0eWxpbmdfMS5IaWdoQ29udHJhc3RTZWxlY3Rvcl0gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6ICdXaW5kb3cnLFxyXG4gICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ1dpbmRvd1RleHQnLFxyXG4gICAgICAgICAgICAgICAgICAgIE1zSGlnaENvbnRyYXN0QWRqdXN0OiAnbm9uZSdcclxuICAgICAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgICAgICBfYSlcclxuICAgICAgICB9LFxyXG4gICAgICAgIHJvb3RIb3ZlcmVkOiB7XHJcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogdGhlbWUucGFsZXR0ZS50aGVtZURhcmtBbHQsXHJcbiAgICAgICAgICAgIGNvbG9yOiB0aGVtZS5wYWxldHRlLndoaXRlLFxyXG4gICAgICAgICAgICBzZWxlY3RvcnM6IChfYiA9IHt9LFxyXG4gICAgICAgICAgICAgICAgX2JbU3R5bGluZ18xLkhpZ2hDb250cmFzdFNlbGVjdG9yXSA9IHtcclxuICAgICAgICAgICAgICAgICAgICBjb2xvcjogJ1dpbmRvdycsXHJcbiAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAnV2luZG93VGV4dCcsXHJcbiAgICAgICAgICAgICAgICAgICAgTXNIaWdoQ29udHJhc3RBZGp1c3Q6ICdub25lJ1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIF9iKVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcm9vdFByZXNzZWQ6IHtcclxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiB0aGVtZS5wYWxldHRlLnRoZW1lRGFyayxcclxuICAgICAgICAgICAgY29sb3I6IHRoZW1lLnBhbGV0dGUud2hpdGUsXHJcbiAgICAgICAgICAgIHNlbGVjdG9yczogKF9jID0ge30sXHJcbiAgICAgICAgICAgICAgICBfY1tTdHlsaW5nXzEuSGlnaENvbnRyYXN0U2VsZWN0b3JdID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiAnV2luZG93JyxcclxuICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdXaW5kb3dUZXh0JyxcclxuICAgICAgICAgICAgICAgICAgICBNc0hpZ2hDb250cmFzdEFkanVzdDogJ25vbmUnXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgX2MpXHJcbiAgICAgICAgfSxcclxuICAgICAgICByb290RXhwYW5kZWQ6IHtcclxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiB0aGVtZS5wYWxldHRlLnRoZW1lRGFyayxcclxuICAgICAgICAgICAgY29sb3I6IHRoZW1lLnBhbGV0dGUud2hpdGVcclxuICAgICAgICB9LFxyXG4gICAgICAgIHJvb3RDaGVja2VkOiB7XHJcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogdGhlbWUucGFsZXR0ZS50aGVtZURhcmssXHJcbiAgICAgICAgICAgIGNvbG9yOiB0aGVtZS5wYWxldHRlLndoaXRlLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcm9vdENoZWNrZWRIb3ZlcmVkOiB7XHJcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogdGhlbWUucGFsZXR0ZS50aGVtZVByaW1hcnksXHJcbiAgICAgICAgICAgIGNvbG9yOiB0aGVtZS5wYWxldHRlLndoaXRlXHJcbiAgICAgICAgfSxcclxuICAgICAgICByb290RGlzYWJsZWQ6IHtcclxuICAgICAgICAgICAgc2VsZWN0b3JzOiAoX2QgPSB7fSxcclxuICAgICAgICAgICAgICAgIF9kW1N0eWxpbmdfMS5IaWdoQ29udHJhc3RTZWxlY3Rvcl0gPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY29sb3I6ICdHcmF5VGV4dCcsXHJcbiAgICAgICAgICAgICAgICAgICAgYm9yZGVyQ29sb3I6ICdHcmF5VGV4dCcsXHJcbiAgICAgICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAnV2luZG93J1xyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIF9kKSxcclxuICAgICAgICB9LFxyXG4gICAgICAgIC8vIFNwbGl0IGJ1dHRvbiBzdHlsZXNcclxuICAgICAgICBzcGxpdEJ1dHRvbkNvbnRhaW5lcjoge30sXHJcbiAgICAgICAgc3BsaXRCdXR0b25EaXZpZGVyOiB7XHJcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogdGhlbWUucGFsZXR0ZS50aGVtZUxpZ2h0ZXJcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNwbGl0QnV0dG9uTWVudUJ1dHRvbjoge1xyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHRoZW1lLnBhbGV0dGUudGhlbWVQcmltYXJ5LFxyXG4gICAgICAgICAgICBjb2xvcjogdGhlbWUucGFsZXR0ZS53aGl0ZSxcclxuICAgICAgICAgICAgc2VsZWN0b3JzOiB7XHJcbiAgICAgICAgICAgICAgICAnOmhvdmVyJzoge1xyXG4gICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogdGhlbWUucGFsZXR0ZS50aGVtZURhcmtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSxcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNwbGl0QnV0dG9uTWVudUJ1dHRvbkRpc2FibGVkOiB7XHJcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogdGhlbWUucGFsZXR0ZS5uZXV0cmFsTGlnaHRlcixcclxuICAgICAgICAgICAgc2VsZWN0b3JzOiB7XHJcbiAgICAgICAgICAgICAgICAnOmhvdmVyJzoge1xyXG4gICAgICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogdGhlbWUucGFsZXR0ZS5uZXV0cmFsTGlnaHRlcixcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc3BsaXRCdXR0b25NZW51QnV0dG9uQ2hlY2tlZDoge1xyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHRoZW1lLnBhbGV0dGUudGhlbWVEYXJrLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc3BsaXRCdXR0b25NZW51QnV0dG9uRXhwYW5kZWQ6IHtcclxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiB0aGVtZS5wYWxldHRlLnRoZW1lRGFyayxcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNwbGl0QnV0dG9uTWVudUljb246IHtcclxuICAgICAgICAgICAgY29sb3I6IHRoZW1lLnBhbGV0dGUud2hpdGVcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNwbGl0QnV0dG9uTWVudUljb25EaXNhYmxlZDoge1xyXG4gICAgICAgICAgICBjb2xvcjogdGhlbWUucGFsZXR0ZS5uZXV0cmFsVGVydGlhcnlcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xyXG59XHJcbmV4cG9ydHMucHJpbWFyeVN0eWxlcyA9IHByaW1hcnlTdHlsZXM7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUJ1dHRvblRoZW1lcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcclxudmFyIFJlYWN0ID0gcmVxdWlyZShcInJlYWN0XCIpO1xyXG52YXIgQmFzZUJ1dHRvbl8xID0gcmVxdWlyZShcIi4uL0Jhc2VCdXR0b25cIik7XHJcbnZhciBVdGlsaXRpZXNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9VdGlsaXRpZXNcIik7XHJcbnZhciBDb21tYW5kQmFyQnV0dG9uX3N0eWxlc18xID0gcmVxdWlyZShcIi4vQ29tbWFuZEJhckJ1dHRvbi5zdHlsZXNcIik7XHJcbnZhciBDb21tYW5kQmFyQnV0dG9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoQ29tbWFuZEJhckJ1dHRvbiwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIENvbW1hbmRCYXJCdXR0b24oKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGVsbCBCYXNlQ29tcG9uZW50IHRvIGJ5cGFzcyByZXNvbHV0aW9uIG9mIGNvbXBvbmVudFJlZi5cclxuICAgICAgICAgKi9cclxuICAgICAgICBfdGhpcy5fc2hvdWxkVXBkYXRlQ29tcG9uZW50UmVmID0gZmFsc2U7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgQ29tbWFuZEJhckJ1dHRvbi5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfYSA9IHRoaXMucHJvcHMsIHN0eWxlcyA9IF9hLnN0eWxlcywgdGhlbWUgPSBfYS50aGVtZTtcclxuICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoQmFzZUJ1dHRvbl8xLkJhc2VCdXR0b24sIHRzbGliXzEuX19hc3NpZ24oe30sIHRoaXMucHJvcHMsIHsgdmFyaWFudENsYXNzTmFtZTogJ21zLUJ1dHRvbi0tY29tbWFuZEJhcicsIHN0eWxlczogQ29tbWFuZEJhckJ1dHRvbl9zdHlsZXNfMS5nZXRTdHlsZXModGhlbWUsIHN0eWxlcyksIG9uUmVuZGVyRGVzY3JpcHRpb246IFV0aWxpdGllc18xLm51bGxSZW5kZXIgfSkpKTtcclxuICAgIH07XHJcbiAgICBDb21tYW5kQmFyQnV0dG9uID0gdHNsaWJfMS5fX2RlY29yYXRlKFtcclxuICAgICAgICBVdGlsaXRpZXNfMS5jdXN0b21pemFibGUoJ0NvbW1hbmRCYXJCdXR0b24nLCBbJ3RoZW1lJ10pXHJcbiAgICBdLCBDb21tYW5kQmFyQnV0dG9uKTtcclxuICAgIHJldHVybiBDb21tYW5kQmFyQnV0dG9uO1xyXG59KFV0aWxpdGllc18xLkJhc2VDb21wb25lbnQpKTtcclxuZXhwb3J0cy5Db21tYW5kQmFyQnV0dG9uID0gQ29tbWFuZEJhckJ1dHRvbjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q29tbWFuZEJhckJ1dHRvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgU3R5bGluZ18xID0gcmVxdWlyZShcIi4uLy4uLy4uL1N0eWxpbmdcIik7XHJcbnZhciBVdGlsaXRpZXNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9VdGlsaXRpZXNcIik7XHJcbnZhciBCYXNlQnV0dG9uX3N0eWxlc18xID0gcmVxdWlyZShcIi4uL0Jhc2VCdXR0b24uc3R5bGVzXCIpO1xyXG52YXIgU3BsaXRCdXR0b25fc3R5bGVzXzEgPSByZXF1aXJlKFwiLi4vU3BsaXRCdXR0b24vU3BsaXRCdXR0b24uc3R5bGVzXCIpO1xyXG5leHBvcnRzLmdldFN0eWxlcyA9IFV0aWxpdGllc18xLm1lbW9pemVGdW5jdGlvbihmdW5jdGlvbiAodGhlbWUsIGN1c3RvbVN0eWxlcywgZm9jdXNJbnNldCwgZm9jdXNDb2xvcikge1xyXG4gICAgdmFyIGJhc2VCdXR0b25TdHlsZXMgPSBCYXNlQnV0dG9uX3N0eWxlc18xLmdldFN0eWxlcyh0aGVtZSk7XHJcbiAgICB2YXIgYmFzZVNwbGl0QnV0dG9uU3R5bGVzID0gU3BsaXRCdXR0b25fc3R5bGVzXzEuZ2V0U3R5bGVzKHRoZW1lKTtcclxuICAgIHZhciBjb21tYW5kQnV0dG9uU3R5bGVzID0ge1xyXG4gICAgICAgIHJvb3Q6IHtcclxuICAgICAgICAgICAgbWluV2lkdGg6ICc0MHB4JyxcclxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiB0aGVtZS5wYWxldHRlLm5ldXRyYWxMaWdodGVyLFxyXG4gICAgICAgICAgICBjb2xvcjogdGhlbWUucGFsZXR0ZS5uZXV0cmFsUHJpbWFyeSxcclxuICAgICAgICAgICAgcGFkZGluZzogJzAgNHB4J1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcm9vdEhvdmVyZWQ6IHtcclxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiB0aGVtZS5wYWxldHRlLm5ldXRyYWxMaWdodCxcclxuICAgICAgICAgICAgY29sb3I6IHRoZW1lLnBhbGV0dGUubmV1dHJhbERhcmtcclxuICAgICAgICB9LFxyXG4gICAgICAgIHJvb3RQcmVzc2VkOiB7XHJcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogdGhlbWUucGFsZXR0ZS5uZXV0cmFsUXVhdGVybmFyeUFsdCxcclxuICAgICAgICAgICAgY29sb3I6IHRoZW1lLnBhbGV0dGUuYmxhY2tcclxuICAgICAgICB9LFxyXG4gICAgICAgIHJvb3RDaGVja2VkOiB7XHJcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogdGhlbWUucGFsZXR0ZS5uZXV0cmFsUXVhdGVybmFyeUFsdCxcclxuICAgICAgICAgICAgY29sb3I6IHRoZW1lLnBhbGV0dGUuYmxhY2tcclxuICAgICAgICB9LFxyXG4gICAgICAgIHJvb3RFeHBhbmRlZDoge1xyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHRoZW1lLnBhbGV0dGUubmV1dHJhbFF1YXRlcm5hcnlBbHQsXHJcbiAgICAgICAgICAgIGNvbG9yOiB0aGVtZS5wYWxldHRlLmJsYWNrXHJcbiAgICAgICAgfSxcclxuICAgICAgICByb290Q2hlY2tlZEhvdmVyZWQ6IHtcclxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiB0aGVtZS5wYWxldHRlLm5ldXRyYWxRdWF0ZXJuYXJ5LFxyXG4gICAgICAgICAgICBjb2xvcjogdGhlbWUucGFsZXR0ZS5ibGFjayxcclxuICAgICAgICB9LFxyXG4gICAgICAgIGxhYmVsOiB7XHJcbiAgICAgICAgICAgIGZvbnRXZWlnaHQ6ICdub3JtYWwnIC8vIHRoZW1lLmZvbnRXZWlnaHRzLnNlbWlib2xkLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaWNvbjoge1xyXG4gICAgICAgICAgICBjb2xvcjogdGhlbWUucGFsZXR0ZS50aGVtZURhcmtBbHRcclxuICAgICAgICB9LFxyXG4gICAgICAgIG1lbnVJY29uOiB7XHJcbiAgICAgICAgICAgIGNvbG9yOiB0aGVtZS5wYWxldHRlLm5ldXRyYWxTZWNvbmRhcnlcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFN0eWxpbmdfMS5jb25jYXRTdHlsZVNldHMoYmFzZUJ1dHRvblN0eWxlcywgY29tbWFuZEJ1dHRvblN0eWxlcywgYmFzZVNwbGl0QnV0dG9uU3R5bGVzLCBjdXN0b21TdHlsZXMpO1xyXG59KTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q29tbWFuZEJhckJ1dHRvbi5zdHlsZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIEFjdGlvbkJ1dHRvbl8xID0gcmVxdWlyZShcIi4uL0FjdGlvbkJ1dHRvbi9BY3Rpb25CdXR0b25cIik7XHJcbmV4cG9ydHMuQ29tbWFuZEJ1dHRvbiA9IEFjdGlvbkJ1dHRvbl8xLkFjdGlvbkJ1dHRvbjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q29tbWFuZEJ1dHRvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcclxudmFyIFJlYWN0ID0gcmVxdWlyZShcInJlYWN0XCIpO1xyXG52YXIgQmFzZUJ1dHRvbl8xID0gcmVxdWlyZShcIi4uL0Jhc2VCdXR0b25cIik7XHJcbnZhciBVdGlsaXRpZXNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9VdGlsaXRpZXNcIik7XHJcbnZhciBDb21wb3VuZEJ1dHRvbl9zdHlsZXNfMSA9IHJlcXVpcmUoXCIuL0NvbXBvdW5kQnV0dG9uLnN0eWxlc1wiKTtcclxudmFyIENvbXBvdW5kQnV0dG9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoQ29tcG91bmRCdXR0b24sIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBDb21wb3VuZEJ1dHRvbigpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBUZWxsIEJhc2VDb21wb25lbnQgdG8gYnlwYXNzIHJlc29sdXRpb24gb2YgY29tcG9uZW50UmVmLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLl9zaG91bGRVcGRhdGVDb21wb25lbnRSZWYgPSBmYWxzZTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBDb21wb3VuZEJ1dHRvbi5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfYSA9IHRoaXMucHJvcHMsIF9iID0gX2EucHJpbWFyeSwgcHJpbWFyeSA9IF9iID09PSB2b2lkIDAgPyBmYWxzZSA6IF9iLCBzdHlsZXMgPSBfYS5zdHlsZXMsIHRoZW1lID0gX2EudGhlbWU7XHJcbiAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KEJhc2VCdXR0b25fMS5CYXNlQnV0dG9uLCB0c2xpYl8xLl9fYXNzaWduKHt9LCB0aGlzLnByb3BzLCB7IHZhcmlhbnRDbGFzc05hbWU6IHByaW1hcnkgPyAnbXMtQnV0dG9uLS1jb21wb3VuZFByaW1hcnknIDogJ21zLUJ1dHRvbi0tY29tcG91bmQnLCBzdHlsZXM6IENvbXBvdW5kQnV0dG9uX3N0eWxlc18xLmdldFN0eWxlcyh0aGVtZSwgc3R5bGVzLCBwcmltYXJ5KSB9KSkpO1xyXG4gICAgfTtcclxuICAgIENvbXBvdW5kQnV0dG9uID0gdHNsaWJfMS5fX2RlY29yYXRlKFtcclxuICAgICAgICBVdGlsaXRpZXNfMS5jdXN0b21pemFibGUoJ0NvbXBvdW5kQnV0dG9uJywgWyd0aGVtZSddKVxyXG4gICAgXSwgQ29tcG91bmRCdXR0b24pO1xyXG4gICAgcmV0dXJuIENvbXBvdW5kQnV0dG9uO1xyXG59KFV0aWxpdGllc18xLkJhc2VDb21wb25lbnQpKTtcclxuZXhwb3J0cy5Db21wb3VuZEJ1dHRvbiA9IENvbXBvdW5kQnV0dG9uO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1Db21wb3VuZEJ1dHRvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgU3R5bGluZ18xID0gcmVxdWlyZShcIi4uLy4uLy4uL1N0eWxpbmdcIik7XHJcbnZhciBVdGlsaXRpZXNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9VdGlsaXRpZXNcIik7XHJcbnZhciBCYXNlQnV0dG9uX3N0eWxlc18xID0gcmVxdWlyZShcIi4uL0Jhc2VCdXR0b24uc3R5bGVzXCIpO1xyXG52YXIgU3BsaXRCdXR0b25fc3R5bGVzXzEgPSByZXF1aXJlKFwiLi4vU3BsaXRCdXR0b24vU3BsaXRCdXR0b24uc3R5bGVzXCIpO1xyXG52YXIgQnV0dG9uVGhlbWVzXzEgPSByZXF1aXJlKFwiLi4vQnV0dG9uVGhlbWVzXCIpO1xyXG5leHBvcnRzLmdldFN0eWxlcyA9IFV0aWxpdGllc18xLm1lbW9pemVGdW5jdGlvbihmdW5jdGlvbiAodGhlbWUsIGN1c3RvbVN0eWxlcywgcHJpbWFyeSkge1xyXG4gICAgdmFyIGJhc2VCdXR0b25TdHlsZXMgPSBCYXNlQnV0dG9uX3N0eWxlc18xLmdldFN0eWxlcyh0aGVtZSk7XHJcbiAgICB2YXIgc3BsaXRCdXR0b25TdHlsZXMgPSBTcGxpdEJ1dHRvbl9zdHlsZXNfMS5nZXRTdHlsZXModGhlbWUpO1xyXG4gICAgdmFyIGNvbXBvdW5kQnV0dG9uU3R5bGVzID0ge1xyXG4gICAgICAgIHJvb3Q6IHtcclxuICAgICAgICAgICAgbWF4V2lkdGg6ICcyODBweCcsXHJcbiAgICAgICAgICAgIG1pbkhlaWdodDogJzcycHgnLFxyXG4gICAgICAgICAgICBoZWlnaHQ6ICdhdXRvJyxcclxuICAgICAgICAgICAgcGFkZGluZzogJzIwcHgnXHJcbiAgICAgICAgfSxcclxuICAgICAgICBmbGV4Q29udGFpbmVyOiB7XHJcbiAgICAgICAgICAgIGZsZXhEaXJlY3Rpb246ICdyb3cnLFxyXG4gICAgICAgICAgICBhbGlnbkl0ZW1zOiAnZmxleC1zdGFydCcsXHJcbiAgICAgICAgICAgIG1pbldpZHRoOiAnMTAwJScsXHJcbiAgICAgICAgICAgIG1hcmdpbjogJydcclxuICAgICAgICB9LFxyXG4gICAgICAgIHRleHRDb250YWluZXI6IHtcclxuICAgICAgICAgICAgdGV4dEFsaWduOiAnbGVmdCdcclxuICAgICAgICB9LFxyXG4gICAgICAgIGljb246IHtcclxuICAgICAgICAgICAgZm9udFNpemU6ICcyZW0nLFxyXG4gICAgICAgICAgICBsaW5lSGVpZ2h0OiAnMWVtJyxcclxuICAgICAgICAgICAgaGVpZ2h0OiAnMWVtJyxcclxuICAgICAgICAgICAgbWFyZ2luOiAnMHB4IDhweCAwcHggMHB4JyxcclxuICAgICAgICAgICAgZmxleEJhc2lzOiAnMWVtJyxcclxuICAgICAgICAgICAgZmxleFNocmluazogJzAnXHJcbiAgICAgICAgfSxcclxuICAgICAgICBsYWJlbDoge1xyXG4gICAgICAgICAgICBtYXJnaW46ICcwIDAgNXB4JyxcclxuICAgICAgICAgICAgbGluZUhlaWdodDogJzEwMCUnLFxyXG4gICAgICAgICAgICBmb250V2VpZ2h0OiBTdHlsaW5nXzEuRm9udFdlaWdodHMuc2VtaWJvbGRcclxuICAgICAgICB9LFxyXG4gICAgICAgIGRlc2NyaXB0aW9uOiBbXHJcbiAgICAgICAgICAgIHRoZW1lLmZvbnRzLnNtYWxsLFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBsaW5lSGVpZ2h0OiAnMTAwJSdcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIF0sXHJcbiAgICB9O1xyXG4gICAgdmFyIHN0YW5kYXJkQ29tcG91bmRUaGVtZSA9IHtcclxuICAgICAgICBkZXNjcmlwdGlvbjoge1xyXG4gICAgICAgICAgICBjb2xvcjogdGhlbWUucGFsZXR0ZS5uZXV0cmFsU2Vjb25kYXJ5LFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZGVzY3JpcHRpb25Ib3ZlcmVkOiB7XHJcbiAgICAgICAgICAgIGNvbG9yOiB0aGVtZS5wYWxldHRlLm5ldXRyYWxEYXJrXHJcbiAgICAgICAgfSxcclxuICAgICAgICBkZXNjcmlwdGlvblByZXNzZWQ6IHtcclxuICAgICAgICAgICAgY29sb3I6ICdpbmhlcml0J1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZGVzY3JpcHRpb25DaGVja2VkOiB7XHJcbiAgICAgICAgICAgIGNvbG9yOiAnaW5oZXJpdCdcclxuICAgICAgICB9LFxyXG4gICAgICAgIGRlc2NyaXB0aW9uRGlzYWJsZWQ6IHtcclxuICAgICAgICAgICAgY29sb3I6ICdpbmhlcml0J1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICB2YXIgcHJpbWFyeUNvbXBvdW5kVGhlbWUgPSB7XHJcbiAgICAgICAgZGVzY3JpcHRpb246IHtcclxuICAgICAgICAgICAgY29sb3I6IHRoZW1lLnBhbGV0dGUud2hpdGUsXHJcbiAgICAgICAgICAgIHNlbGVjdG9yczogKF9hID0ge30sXHJcbiAgICAgICAgICAgICAgICBfYVtTdHlsaW5nXzEuSGlnaENvbnRyYXN0U2VsZWN0b3JdID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiAnV2luZG93JyxcclxuICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdXaW5kb3dUZXh0JyxcclxuICAgICAgICAgICAgICAgICAgICBNc0hpZ2hDb250cmFzdEFkanVzdDogJ25vbmUnXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgX2EpXHJcbiAgICAgICAgfSxcclxuICAgICAgICBkZXNjcmlwdGlvbkhvdmVyZWQ6IHtcclxuICAgICAgICAgICAgY29sb3I6IHRoZW1lLnBhbGV0dGUud2hpdGUsXHJcbiAgICAgICAgICAgIHNlbGVjdG9yczogKF9iID0ge30sXHJcbiAgICAgICAgICAgICAgICBfYltTdHlsaW5nXzEuSGlnaENvbnRyYXN0U2VsZWN0b3JdID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiAnV2luZG93JyxcclxuICAgICAgICAgICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICdXaW5kb3dUZXh0JyxcclxuICAgICAgICAgICAgICAgICAgICBNc0hpZ2hDb250cmFzdEFkanVzdDogJ25vbmUnXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgX2IpXHJcbiAgICAgICAgfSxcclxuICAgICAgICBkZXNjcmlwdGlvblByZXNzZWQ6IHtcclxuICAgICAgICAgICAgY29sb3I6ICdpbmhlcml0J1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZGVzY3JpcHRpb25DaGVja2VkOiB7XHJcbiAgICAgICAgICAgIGNvbG9yOiAnaW5oZXJpdCdcclxuICAgICAgICB9LFxyXG4gICAgICAgIGRlc2NyaXB0aW9uRGlzYWJsZWQ6IHtcclxuICAgICAgICAgICAgY29sb3I6ICdpbmhlcml0J1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICByZXR1cm4gU3R5bGluZ18xLmNvbmNhdFN0eWxlU2V0cyhiYXNlQnV0dG9uU3R5bGVzLCBjb21wb3VuZEJ1dHRvblN0eWxlcywgcHJpbWFyeSA/IEJ1dHRvblRoZW1lc18xLnByaW1hcnlTdHlsZXModGhlbWUpIDogQnV0dG9uVGhlbWVzXzEuc3RhbmRhcmRTdHlsZXModGhlbWUpLCBwcmltYXJ5ID8gcHJpbWFyeUNvbXBvdW5kVGhlbWUgOiBzdGFuZGFyZENvbXBvdW5kVGhlbWUsIHNwbGl0QnV0dG9uU3R5bGVzLCBjdXN0b21TdHlsZXMpO1xyXG4gICAgdmFyIF9hLCBfYjtcclxufSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNvbXBvdW5kQnV0dG9uLnN0eWxlcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcclxudmFyIFJlYWN0ID0gcmVxdWlyZShcInJlYWN0XCIpO1xyXG52YXIgQmFzZUJ1dHRvbl8xID0gcmVxdWlyZShcIi4uL0Jhc2VCdXR0b25cIik7XHJcbnZhciBVdGlsaXRpZXNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9VdGlsaXRpZXNcIik7XHJcbnZhciBEZWZhdWx0QnV0dG9uX3N0eWxlc18xID0gcmVxdWlyZShcIi4vRGVmYXVsdEJ1dHRvbi5zdHlsZXNcIik7XHJcbnZhciBEZWZhdWx0QnV0dG9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoRGVmYXVsdEJ1dHRvbiwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIERlZmF1bHRCdXR0b24oKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGVsbCBCYXNlQ29tcG9uZW50IHRvIGJ5cGFzcyByZXNvbHV0aW9uIG9mIGNvbXBvbmVudFJlZi5cclxuICAgICAgICAgKi9cclxuICAgICAgICBfdGhpcy5fc2hvdWxkVXBkYXRlQ29tcG9uZW50UmVmID0gZmFsc2U7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgRGVmYXVsdEJ1dHRvbi5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfYSA9IHRoaXMucHJvcHMsIF9iID0gX2EucHJpbWFyeSwgcHJpbWFyeSA9IF9iID09PSB2b2lkIDAgPyBmYWxzZSA6IF9iLCBzdHlsZXMgPSBfYS5zdHlsZXMsIHRoZW1lID0gX2EudGhlbWU7XHJcbiAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KEJhc2VCdXR0b25fMS5CYXNlQnV0dG9uLCB0c2xpYl8xLl9fYXNzaWduKHt9LCB0aGlzLnByb3BzLCB7IHZhcmlhbnRDbGFzc05hbWU6IHByaW1hcnkgPyAnbXMtQnV0dG9uLS1wcmltYXJ5JyA6ICdtcy1CdXR0b24tLWRlZmF1bHQnLCBzdHlsZXM6IERlZmF1bHRCdXR0b25fc3R5bGVzXzEuZ2V0U3R5bGVzKHRoZW1lLCBzdHlsZXMsIHByaW1hcnkpLCBvblJlbmRlckRlc2NyaXB0aW9uOiBVdGlsaXRpZXNfMS5udWxsUmVuZGVyIH0pKSk7XHJcbiAgICB9O1xyXG4gICAgRGVmYXVsdEJ1dHRvbiA9IHRzbGliXzEuX19kZWNvcmF0ZShbXHJcbiAgICAgICAgVXRpbGl0aWVzXzEuY3VzdG9taXphYmxlKCdEZWZhdWx0QnV0dG9uJywgWyd0aGVtZSddKVxyXG4gICAgXSwgRGVmYXVsdEJ1dHRvbik7XHJcbiAgICByZXR1cm4gRGVmYXVsdEJ1dHRvbjtcclxufShVdGlsaXRpZXNfMS5CYXNlQ29tcG9uZW50KSk7XHJcbmV4cG9ydHMuRGVmYXVsdEJ1dHRvbiA9IERlZmF1bHRCdXR0b247XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPURlZmF1bHRCdXR0b24uanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIFN0eWxpbmdfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9TdHlsaW5nXCIpO1xyXG52YXIgVXRpbGl0aWVzXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vVXRpbGl0aWVzXCIpO1xyXG52YXIgQmFzZUJ1dHRvbl9zdHlsZXNfMSA9IHJlcXVpcmUoXCIuLi9CYXNlQnV0dG9uLnN0eWxlc1wiKTtcclxudmFyIFNwbGl0QnV0dG9uX3N0eWxlc18xID0gcmVxdWlyZShcIi4uL1NwbGl0QnV0dG9uL1NwbGl0QnV0dG9uLnN0eWxlc1wiKTtcclxudmFyIEJ1dHRvblRoZW1lc18xID0gcmVxdWlyZShcIi4uL0J1dHRvblRoZW1lc1wiKTtcclxudmFyIERFRkFVTFRfQlVUVE9OX0hFSUdIVCA9ICczMnB4JztcclxudmFyIERFRkFVTFRfQlVUVE9OX01JTldJRFRIID0gJzgwcHgnO1xyXG5leHBvcnRzLmdldFN0eWxlcyA9IFV0aWxpdGllc18xLm1lbW9pemVGdW5jdGlvbihmdW5jdGlvbiAodGhlbWUsIGN1c3RvbVN0eWxlcywgcHJpbWFyeSkge1xyXG4gICAgdmFyIGJhc2VCdXR0b25TdHlsZXMgPSBCYXNlQnV0dG9uX3N0eWxlc18xLmdldFN0eWxlcyh0aGVtZSk7XHJcbiAgICB2YXIgc3BsaXRCdXR0b25TdHlsZXMgPSBTcGxpdEJ1dHRvbl9zdHlsZXNfMS5nZXRTdHlsZXModGhlbWUpO1xyXG4gICAgdmFyIGRlZmF1bHRCdXR0b25TdHlsZXMgPSB7XHJcbiAgICAgICAgcm9vdDoge1xyXG4gICAgICAgICAgICBtaW5XaWR0aDogREVGQVVMVF9CVVRUT05fTUlOV0lEVEgsXHJcbiAgICAgICAgICAgIGhlaWdodDogREVGQVVMVF9CVVRUT05fSEVJR0hULFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgbGFiZWw6IHtcclxuICAgICAgICAgICAgZm9udFdlaWdodDogU3R5bGluZ18xLkZvbnRXZWlnaHRzLnNlbWlib2xkXHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHJldHVybiBTdHlsaW5nXzEuY29uY2F0U3R5bGVTZXRzKGJhc2VCdXR0b25TdHlsZXMsIGRlZmF1bHRCdXR0b25TdHlsZXMsIHByaW1hcnkgPyBCdXR0b25UaGVtZXNfMS5wcmltYXJ5U3R5bGVzKHRoZW1lKSA6IEJ1dHRvblRoZW1lc18xLnN0YW5kYXJkU3R5bGVzKHRoZW1lKSwgc3BsaXRCdXR0b25TdHlsZXMsIGN1c3RvbVN0eWxlcyk7XHJcbn0pO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1EZWZhdWx0QnV0dG9uLnN0eWxlcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcclxudmFyIFJlYWN0ID0gcmVxdWlyZShcInJlYWN0XCIpO1xyXG52YXIgQmFzZUJ1dHRvbl8xID0gcmVxdWlyZShcIi4uL0Jhc2VCdXR0b25cIik7XHJcbnZhciBVdGlsaXRpZXNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9VdGlsaXRpZXNcIik7XHJcbnZhciBJY29uQnV0dG9uX3N0eWxlc18xID0gcmVxdWlyZShcIi4vSWNvbkJ1dHRvbi5zdHlsZXNcIik7XHJcbnZhciBJY29uQnV0dG9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoSWNvbkJ1dHRvbiwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEljb25CdXR0b24oKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogVGVsbCBCYXNlQ29tcG9uZW50IHRvIGJ5cGFzcyByZXNvbHV0aW9uIG9mIGNvbXBvbmVudFJlZi5cclxuICAgICAgICAgKi9cclxuICAgICAgICBfdGhpcy5fc2hvdWxkVXBkYXRlQ29tcG9uZW50UmVmID0gZmFsc2U7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgSWNvbkJ1dHRvbi5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfYSA9IHRoaXMucHJvcHMsIHN0eWxlcyA9IF9hLnN0eWxlcywgdGhlbWUgPSBfYS50aGVtZTtcclxuICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoQmFzZUJ1dHRvbl8xLkJhc2VCdXR0b24sIHRzbGliXzEuX19hc3NpZ24oe30sIHRoaXMucHJvcHMsIHsgdmFyaWFudENsYXNzTmFtZTogJ21zLUJ1dHRvbi0taWNvbicsIHN0eWxlczogSWNvbkJ1dHRvbl9zdHlsZXNfMS5nZXRTdHlsZXModGhlbWUsIHN0eWxlcyksIG9uUmVuZGVyVGV4dDogVXRpbGl0aWVzXzEubnVsbFJlbmRlciwgb25SZW5kZXJEZXNjcmlwdGlvbjogVXRpbGl0aWVzXzEubnVsbFJlbmRlciB9KSkpO1xyXG4gICAgfTtcclxuICAgIEljb25CdXR0b24gPSB0c2xpYl8xLl9fZGVjb3JhdGUoW1xyXG4gICAgICAgIFV0aWxpdGllc18xLmN1c3RvbWl6YWJsZSgnSWNvbkJ1dHRvbicsIFsndGhlbWUnXSlcclxuICAgIF0sIEljb25CdXR0b24pO1xyXG4gICAgcmV0dXJuIEljb25CdXR0b247XHJcbn0oVXRpbGl0aWVzXzEuQmFzZUNvbXBvbmVudCkpO1xyXG5leHBvcnRzLkljb25CdXR0b24gPSBJY29uQnV0dG9uO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1JY29uQnV0dG9uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBTdHlsaW5nXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vU3R5bGluZ1wiKTtcclxudmFyIFV0aWxpdGllc18xID0gcmVxdWlyZShcIi4uLy4uLy4uL1V0aWxpdGllc1wiKTtcclxudmFyIEJhc2VCdXR0b25fc3R5bGVzXzEgPSByZXF1aXJlKFwiLi4vQmFzZUJ1dHRvbi5zdHlsZXNcIik7XHJcbnZhciBTcGxpdEJ1dHRvbl9zdHlsZXNfMSA9IHJlcXVpcmUoXCIuLi9TcGxpdEJ1dHRvbi9TcGxpdEJ1dHRvbi5zdHlsZXNcIik7XHJcbmV4cG9ydHMuZ2V0U3R5bGVzID0gVXRpbGl0aWVzXzEubWVtb2l6ZUZ1bmN0aW9uKGZ1bmN0aW9uICh0aGVtZSwgY3VzdG9tU3R5bGVzKSB7XHJcbiAgICB2YXIgYmFzZUJ1dHRvblN0eWxlcyA9IEJhc2VCdXR0b25fc3R5bGVzXzEuZ2V0U3R5bGVzKHRoZW1lKTtcclxuICAgIHZhciBzcGxpdEJ1dHRvblN0eWxlcyA9IFNwbGl0QnV0dG9uX3N0eWxlc18xLmdldFN0eWxlcyh0aGVtZSk7XHJcbiAgICB2YXIgaWNvbkJ1dHRvblN0eWxlcyA9IHtcclxuICAgICAgICByb290OiB7XHJcbiAgICAgICAgICAgIHBhZGRpbmc6ICcwIDRweCcsXHJcbiAgICAgICAgICAgIHdpZHRoOiAnMzJweCcsXHJcbiAgICAgICAgICAgIGhlaWdodDogJzMycHgnLFxyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6ICd0cmFuc3BhcmVudCdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHJvb3RIb3ZlcmVkOiB7XHJcbiAgICAgICAgICAgIGNvbG9yOiB0aGVtZS5wYWxldHRlLnRoZW1lRGFya2VyXHJcbiAgICAgICAgfSxcclxuICAgICAgICByb290UHJlc3NlZDoge1xyXG4gICAgICAgICAgICBjb2xvcjogdGhlbWUucGFsZXR0ZS50aGVtZVByaW1hcnlcclxuICAgICAgICB9LFxyXG4gICAgICAgIHJvb3RFeHBhbmRlZDoge1xyXG4gICAgICAgICAgICBjb2xvcjogdGhlbWUucGFsZXR0ZS50aGVtZVByaW1hcnlcclxuICAgICAgICB9LFxyXG4gICAgICAgIHJvb3RDaGVja2VkOiB7XHJcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogdGhlbWUucGFsZXR0ZS5uZXV0cmFsVGVydGlhcnlBbHQsXHJcbiAgICAgICAgfSxcclxuICAgICAgICByb290Q2hlY2tlZEhvdmVyZWQ6IHtcclxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiB0aGVtZS5wYWxldHRlLm5ldXRyYWxMaWdodFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgcm9vdERpc2FibGVkOiB7XHJcbiAgICAgICAgICAgIGNvbG9yOiB0aGVtZS5wYWxldHRlLm5ldXRyYWxUZXJ0aWFyeVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICByZXR1cm4gU3R5bGluZ18xLmNvbmNhdFN0eWxlU2V0cyhiYXNlQnV0dG9uU3R5bGVzLCBpY29uQnV0dG9uU3R5bGVzLCBzcGxpdEJ1dHRvblN0eWxlcywgY3VzdG9tU3R5bGVzKTtcclxufSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUljb25CdXR0b24uc3R5bGVzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xyXG52YXIgUmVhY3QgPSByZXF1aXJlKFwicmVhY3RcIik7XHJcbnZhciBEZWZhdWx0QnV0dG9uXzEgPSByZXF1aXJlKFwiLi4vRGVmYXVsdEJ1dHRvbi9EZWZhdWx0QnV0dG9uXCIpO1xyXG52YXIgVXRpbGl0aWVzXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vVXRpbGl0aWVzXCIpO1xyXG52YXIgTWVzc2FnZUJhckJ1dHRvbl9zdHlsZXNfMSA9IHJlcXVpcmUoXCIuL01lc3NhZ2VCYXJCdXR0b24uc3R5bGVzXCIpO1xyXG52YXIgTWVzc2FnZUJhckJ1dHRvbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIHRzbGliXzEuX19leHRlbmRzKE1lc3NhZ2VCYXJCdXR0b24sIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBNZXNzYWdlQmFyQnV0dG9uKCkge1xyXG4gICAgICAgIHJldHVybiBfc3VwZXIgIT09IG51bGwgJiYgX3N1cGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgfHwgdGhpcztcclxuICAgIH1cclxuICAgIE1lc3NhZ2VCYXJCdXR0b24ucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX2EgPSB0aGlzLnByb3BzLCBzdHlsZXMgPSBfYS5zdHlsZXMsIHRoZW1lID0gX2EudGhlbWU7XHJcbiAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KERlZmF1bHRCdXR0b25fMS5EZWZhdWx0QnV0dG9uLCB0c2xpYl8xLl9fYXNzaWduKHt9LCB0aGlzLnByb3BzLCB7IHN0eWxlczogTWVzc2FnZUJhckJ1dHRvbl9zdHlsZXNfMS5nZXRTdHlsZXModGhlbWUsIHN0eWxlcyksIG9uUmVuZGVyRGVzY3JpcHRpb246IFV0aWxpdGllc18xLm51bGxSZW5kZXIgfSkpKTtcclxuICAgIH07XHJcbiAgICBNZXNzYWdlQmFyQnV0dG9uID0gdHNsaWJfMS5fX2RlY29yYXRlKFtcclxuICAgICAgICBVdGlsaXRpZXNfMS5jdXN0b21pemFibGUoJ01lc3NhZ2VCYXJCdXR0b24nLCBbJ3RoZW1lJ10pXHJcbiAgICBdLCBNZXNzYWdlQmFyQnV0dG9uKTtcclxuICAgIHJldHVybiBNZXNzYWdlQmFyQnV0dG9uO1xyXG59KFV0aWxpdGllc18xLkJhc2VDb21wb25lbnQpKTtcclxuZXhwb3J0cy5NZXNzYWdlQmFyQnV0dG9uID0gTWVzc2FnZUJhckJ1dHRvbjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TWVzc2FnZUJhckJ1dHRvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgU3R5bGluZ18xID0gcmVxdWlyZShcIi4uLy4uLy4uL1N0eWxpbmdcIik7XHJcbnZhciBVdGlsaXRpZXNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9VdGlsaXRpZXNcIik7XHJcbnZhciBCYXNlQnV0dG9uX3N0eWxlc18xID0gcmVxdWlyZShcIi4uL0Jhc2VCdXR0b24uc3R5bGVzXCIpO1xyXG5leHBvcnRzLmdldFN0eWxlcyA9IFV0aWxpdGllc18xLm1lbW9pemVGdW5jdGlvbihmdW5jdGlvbiAodGhlbWUsIGN1c3RvbVN0eWxlcywgZm9jdXNJbnNldCwgZm9jdXNDb2xvcikge1xyXG4gICAgdmFyIGJhc2VCdXR0b25TdHlsZXMgPSBCYXNlQnV0dG9uX3N0eWxlc18xLmdldFN0eWxlcyh0aGVtZSk7XHJcbiAgICB2YXIgbWVzc2FnZUJhckJ1dHRvblN0eWxlcyA9IHtcclxuICAgICAgICByb290OiB7XHJcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogdGhlbWUucGFsZXR0ZS5uZXV0cmFsUXVhdGVybmFyeUFsdCxcclxuICAgICAgICAgICAgY29sb3I6IHRoZW1lLnBhbGV0dGUubmV1dHJhbFByaW1hcnlcclxuICAgICAgICB9LFxyXG4gICAgICAgIHJvb3RIb3ZlcmVkOiB7XHJcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogdGhlbWUucGFsZXR0ZS5uZXV0cmFsVGVydGlhcnlBbHQsXHJcbiAgICAgICAgICAgIGNvbG9yOiB0aGVtZS5wYWxldHRlLm5ldXRyYWxEYXJrXHJcbiAgICAgICAgfSxcclxuICAgICAgICByb290UHJlc3NlZDoge1xyXG4gICAgICAgICAgICBiYWNrZ3JvdW5kQ29sb3I6IHRoZW1lLnBhbGV0dGUubmV1dHJhbFRlcnRpYXJ5LFxyXG4gICAgICAgICAgICBjb2xvcjogdGhlbWUucGFsZXR0ZS5uZXV0cmFsRGFya1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICByZXR1cm4gU3R5bGluZ18xLmNvbmNhdFN0eWxlU2V0cyhiYXNlQnV0dG9uU3R5bGVzLCBtZXNzYWdlQmFyQnV0dG9uU3R5bGVzLCBjdXN0b21TdHlsZXMpO1xyXG59KTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9TWVzc2FnZUJhckJ1dHRvbi5zdHlsZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XHJcbnZhciBSZWFjdCA9IHJlcXVpcmUoXCJyZWFjdFwiKTtcclxudmFyIFV0aWxpdGllc18xID0gcmVxdWlyZShcIi4uLy4uLy4uL1V0aWxpdGllc1wiKTtcclxudmFyIERlZmF1bHRCdXR0b25fMSA9IHJlcXVpcmUoXCIuLi9EZWZhdWx0QnV0dG9uL0RlZmF1bHRCdXR0b25cIik7XHJcbnZhciBQcmltYXJ5QnV0dG9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoUHJpbWFyeUJ1dHRvbiwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIFByaW1hcnlCdXR0b24oKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogU2V0IHRoaXMgQmFzZUNvbXBvbmVudC5fcmVzb2x2ZUNvbXBvbmVudFJlZiB0byBmYWxzZSwgYnlwYXNzaW5nIHJlc29sdXRpb24gb2YgY29tcG9uZW50UmVmLlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIF90aGlzLl9zaG91bGRVcGRhdGVDb21wb25lbnRSZWYgPSBmYWxzZTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBQcmltYXJ5QnV0dG9uLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KERlZmF1bHRCdXR0b25fMS5EZWZhdWx0QnV0dG9uLCB0c2xpYl8xLl9fYXNzaWduKHt9LCB0aGlzLnByb3BzLCB7IHByaW1hcnk6IHRydWUsIG9uUmVuZGVyRGVzY3JpcHRpb246IFV0aWxpdGllc18xLm51bGxSZW5kZXIgfSkpKTtcclxuICAgIH07XHJcbiAgICBQcmltYXJ5QnV0dG9uID0gdHNsaWJfMS5fX2RlY29yYXRlKFtcclxuICAgICAgICBVdGlsaXRpZXNfMS5jdXN0b21pemFibGUoJ1ByaW1hcnlCdXR0b24nLCBbJ3RoZW1lJ10pXHJcbiAgICBdLCBQcmltYXJ5QnV0dG9uKTtcclxuICAgIHJldHVybiBQcmltYXJ5QnV0dG9uO1xyXG59KFV0aWxpdGllc18xLkJhc2VDb21wb25lbnQpKTtcclxuZXhwb3J0cy5QcmltYXJ5QnV0dG9uID0gUHJpbWFyeUJ1dHRvbjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UHJpbWFyeUJ1dHRvbi5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgVXRpbGl0aWVzXzEgPSByZXF1aXJlKFwiLi4vLi4vLi4vVXRpbGl0aWVzXCIpO1xyXG52YXIgU3R5bGluZ18xID0gcmVxdWlyZShcIi4uLy4uLy4uL1N0eWxpbmdcIik7XHJcbmV4cG9ydHMuZ2V0Q2xhc3NOYW1lcyA9IFV0aWxpdGllc18xLm1lbW9pemVGdW5jdGlvbihmdW5jdGlvbiAoc3R5bGVzLCBkaXNhYmxlZCwgZXhwYW5kZWQsIGNoZWNrZWQpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgcm9vdDogU3R5bGluZ18xLm1lcmdlU3R5bGVzKHN0eWxlcy5zcGxpdEJ1dHRvbk1lbnVCdXR0b24sIGV4cGFuZGVkICYmIFtcclxuICAgICAgICAgICAgc3R5bGVzLnNwbGl0QnV0dG9uTWVudUJ1dHRvbkV4cGFuZGVkXHJcbiAgICAgICAgXSwgZGlzYWJsZWQgJiYgW1xyXG4gICAgICAgICAgICBzdHlsZXMuc3BsaXRCdXR0b25NZW51QnV0dG9uRGlzYWJsZWRcclxuICAgICAgICBdLCBjaGVja2VkICYmICFkaXNhYmxlZCAmJiBbXHJcbiAgICAgICAgICAgIHN0eWxlcy5zcGxpdEJ1dHRvbk1lbnVCdXR0b25DaGVja2VkXHJcbiAgICAgICAgXSksXHJcbiAgICAgICAgc3BsaXRCdXR0b25Db250YWluZXI6IFN0eWxpbmdfMS5tZXJnZVN0eWxlcyhzdHlsZXMuc3BsaXRCdXR0b25Db250YWluZXIsIGNoZWNrZWQgJiYgIWRpc2FibGVkICYmIFtcclxuICAgICAgICAgICAgc3R5bGVzLnNwbGl0QnV0dG9uQ29udGFpbmVyQ2hlY2tlZCxcclxuICAgICAgICAgICAge1xyXG4gICAgICAgICAgICAgICAgc2VsZWN0b3JzOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgJzpob3Zlcic6IHN0eWxlcy5zcGxpdEJ1dHRvbkNvbnRhaW5lckNoZWNrZWRIb3ZlcmVkXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICBdLCAhZGlzYWJsZWQgJiYgIWNoZWNrZWQgJiYgW3tcclxuICAgICAgICAgICAgICAgIHNlbGVjdG9yczoge1xyXG4gICAgICAgICAgICAgICAgICAgICc6aG92ZXInOiBzdHlsZXMuc3BsaXRCdXR0b25Db250YWluZXJIb3ZlcmVkLFxyXG4gICAgICAgICAgICAgICAgICAgICc6Zm9jdXMnOiBzdHlsZXMuc3BsaXRCdXR0b25Db250YWluZXJGb2N1c2VkXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1dLCBkaXNhYmxlZCAmJiBzdHlsZXMuc3BsaXRCdXR0b25Db250YWluZXJEaXNhYmxlZCksXHJcbiAgICAgICAgaWNvbjogU3R5bGluZ18xLm1lcmdlU3R5bGVzKHN0eWxlcy5zcGxpdEJ1dHRvbk1lbnVJY29uLCBkaXNhYmxlZCAmJiBzdHlsZXMuc3BsaXRCdXR0b25NZW51SWNvbkRpc2FibGVkKSxcclxuICAgICAgICBmbGV4Q29udGFpbmVyOiBTdHlsaW5nXzEubWVyZ2VTdHlsZXMoc3R5bGVzLnNwbGl0QnV0dG9uRmxleENvbnRhaW5lciksXHJcbiAgICAgICAgZGl2aWRlcjogU3R5bGluZ18xLm1lcmdlU3R5bGVzKHN0eWxlcy5zcGxpdEJ1dHRvbkRpdmlkZXIpXHJcbiAgICB9O1xyXG59KTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3BsaXRCdXR0b24uY2xhc3NOYW1lcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgU3R5bGluZ18xID0gcmVxdWlyZShcIi4uLy4uLy4uL1N0eWxpbmdcIik7XHJcbnZhciBVdGlsaXRpZXNfMSA9IHJlcXVpcmUoXCIuLi8uLi8uLi9VdGlsaXRpZXNcIik7XHJcbmV4cG9ydHMuZ2V0U3R5bGVzID0gVXRpbGl0aWVzXzEubWVtb2l6ZUZ1bmN0aW9uKGZ1bmN0aW9uICh0aGVtZSwgY3VzdG9tU3R5bGVzKSB7XHJcbiAgICB2YXIgc3BsaXRCdXR0b25TdHlsZXMgPSB7XHJcbiAgICAgICAgc3BsaXRCdXR0b25Db250YWluZXI6IHtcclxuICAgICAgICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZScsXHJcbiAgICAgICAgICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxyXG4gICAgICAgICAgICBib3JkZXI6ICcxcHggc29saWQgdHJhbnNwYXJlbnQnXHJcbiAgICAgICAgfSxcclxuICAgICAgICBzcGxpdEJ1dHRvbkNvbnRhaW5lckZvY3VzZWQ6IHtcclxuICAgICAgICAgICAgb3V0bGluZTogJ25vbmUhaW1wb3J0YW50JyxcclxuICAgICAgICAgICAgYm9yZGVyOiAnMXB4IHNvbGlkJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc3BsaXRCdXR0b25NZW51QnV0dG9uOiBbXHJcbiAgICAgICAgICAgIFN0eWxpbmdfMS5nZXRGb2N1c1N0eWxlKHRoZW1lLCAtMSksXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIHBhZGRpbmc6IDYsXHJcbiAgICAgICAgICAgICAgICBoZWlnaHQ6ICdhdXRvJyxcclxuICAgICAgICAgICAgICAgIGJveFNpemluZzogJ2JvcmRlci1ib3gnLFxyXG4gICAgICAgICAgICAgICAgYm9yZGVyOiAnMXB4IHNvbGlkIHRyYW5zcGFyZW50JyxcclxuICAgICAgICAgICAgICAgIGJvcmRlclJhZGl1czogMCxcclxuICAgICAgICAgICAgICAgIG91dGxpbmU6ICd0cmFuc3BhcmVudCcsXHJcbiAgICAgICAgICAgICAgICB1c2VyU2VsZWN0OiAnbm9uZScsXHJcbiAgICAgICAgICAgICAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyxcclxuICAgICAgICAgICAgICAgIHRleHREZWNvcmF0aW9uOiAnbm9uZScsXHJcbiAgICAgICAgICAgICAgICB0ZXh0QWxpZ246ICdjZW50ZXInLFxyXG4gICAgICAgICAgICAgICAgY3Vyc29yOiAncG9pbnRlcicsXHJcbiAgICAgICAgICAgICAgICB2ZXJ0aWNhbEFsaWduOiAndG9wJyxcclxuICAgICAgICAgICAgICAgIHdpZHRoOiAzMixcclxuICAgICAgICAgICAgICAgIG1hcmdpbkxlZnQ6IC0xXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICBdLFxyXG4gICAgICAgIHNwbGl0QnV0dG9uRGl2aWRlcjoge1xyXG4gICAgICAgICAgICBwb3NpdGlvbjogJ2Fic29sdXRlJyxcclxuICAgICAgICAgICAgd2lkdGg6IDEsXHJcbiAgICAgICAgICAgIHJpZ2h0OiAzMSxcclxuICAgICAgICAgICAgdG9wOiA4LFxyXG4gICAgICAgICAgICBib3R0b206IDhcclxuICAgICAgICB9LFxyXG4gICAgICAgIHNwbGl0QnV0dG9uTWVudUJ1dHRvbkRpc2FibGVkOiB7XHJcbiAgICAgICAgICAgIHBvaW50ZXJFdmVudHM6ICdub25lJyxcclxuICAgICAgICAgICAgc2VsZWN0b3JzOiB7XHJcbiAgICAgICAgICAgICAgICAnOmhvdmVyJzoge1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnNvcjogJ2RlZmF1bHQnXHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIHNwbGl0QnV0dG9uRmxleENvbnRhaW5lcjoge1xyXG4gICAgICAgICAgICBkaXNwbGF5OiAnZmxleCcsXHJcbiAgICAgICAgICAgIGhlaWdodDogJzEwMCUnLFxyXG4gICAgICAgICAgICBmbGV4V3JhcDogJ25vd3JhcCcsXHJcbiAgICAgICAgICAgIGp1c3RpZnlDb250ZW50OiAnY2VudGVyJyxcclxuICAgICAgICAgICAgYWxpZ25JdGVtczogJ2NlbnRlcidcclxuICAgICAgICB9LFxyXG4gICAgfTtcclxuICAgIHJldHVybiBTdHlsaW5nXzEuY29uY2F0U3R5bGVTZXRzKHNwbGl0QnV0dG9uU3R5bGVzLCBjdXN0b21TdHlsZXMpO1xyXG59KTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9U3BsaXRCdXR0b24uc3R5bGVzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xyXG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9CYXNlQnV0dG9uXCIpLCBleHBvcnRzKTtcclxudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vQnV0dG9uLnR5cGVzXCIpLCBleHBvcnRzKTtcclxudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vQnV0dG9uXCIpLCBleHBvcnRzKTtcclxudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vQWN0aW9uQnV0dG9uL0FjdGlvbkJ1dHRvblwiKSwgZXhwb3J0cyk7XHJcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL0NvbW1hbmRCYXJCdXR0b24vQ29tbWFuZEJhckJ1dHRvblwiKSwgZXhwb3J0cyk7XHJcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL0NvbW1hbmRCdXR0b24vQ29tbWFuZEJ1dHRvblwiKSwgZXhwb3J0cyk7XHJcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL0NvbXBvdW5kQnV0dG9uL0NvbXBvdW5kQnV0dG9uXCIpLCBleHBvcnRzKTtcclxudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vRGVmYXVsdEJ1dHRvbi9EZWZhdWx0QnV0dG9uXCIpLCBleHBvcnRzKTtcclxudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vQ29tbWFuZEJ1dHRvbi9Db21tYW5kQnV0dG9uXCIpLCBleHBvcnRzKTtcclxudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vTWVzc2FnZUJhckJ1dHRvbi9NZXNzYWdlQmFyQnV0dG9uXCIpLCBleHBvcnRzKTtcclxudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vUHJpbWFyeUJ1dHRvbi9QcmltYXJ5QnV0dG9uXCIpLCBleHBvcnRzKTtcclxudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vSWNvbkJ1dHRvbi9JY29uQnV0dG9uXCIpLCBleHBvcnRzKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XHJcbi8qIHRzbGludDpkaXNhYmxlOm5vLXVudXNlZC12YXJpYWJsZSAqL1xyXG52YXIgUmVhY3QgPSByZXF1aXJlKFwicmVhY3RcIik7XHJcbi8qIHRzbGludDplbmFibGU6bm8tdW51c2VkLXZhcmlhYmxlICovXHJcbnZhciBVdGlsaXRpZXNfMSA9IHJlcXVpcmUoXCIuLi8uLi9VdGlsaXRpZXNcIik7XHJcbnZhciBDYWxsb3V0Q29udGVudF8xID0gcmVxdWlyZShcIi4vQ2FsbG91dENvbnRlbnRcIik7XHJcbnZhciBMYXllcl8xID0gcmVxdWlyZShcIi4uLy4uL0xheWVyXCIpO1xyXG52YXIgQ2FsbG91dCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIHRzbGliXzEuX19leHRlbmRzKENhbGxvdXQsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBDYWxsb3V0KHByb3BzKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgcHJvcHMpIHx8IHRoaXM7XHJcbiAgICAgICAgX3RoaXMuX3dhcm5EZXByZWNhdGlvbnMoe1xyXG4gICAgICAgICAgICAndGFyZ2V0UG9pbnQnOiAndGFyZ2V0JyxcclxuICAgICAgICAgICAgJ3VzZVRhcmdldFBvaW50JzogJ3RhcmdldCcsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgQ2FsbG91dC5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBjb250ZW50ID0gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ2FsbG91dENvbnRlbnRfMS5DYWxsb3V0Q29udGVudCwgdHNsaWJfMS5fX2Fzc2lnbih7fSwgdGhpcy5wcm9wcykpKTtcclxuICAgICAgICByZXR1cm4gdGhpcy5wcm9wcy5kb05vdExheWVyID8gY29udGVudCA6IChSZWFjdC5jcmVhdGVFbGVtZW50KExheWVyXzEuTGF5ZXIsIG51bGwsIGNvbnRlbnQpKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gQ2FsbG91dDtcclxufShVdGlsaXRpZXNfMS5CYXNlQ29tcG9uZW50KSk7XHJcbmV4cG9ydHMuQ2FsbG91dCA9IENhbGxvdXQ7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNhbGxvdXQuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuLyogdHNsaW50OmRpc2FibGUgKi9cclxudmFyIGxvYWRfdGhlbWVkX3N0eWxlc18xID0gcmVxdWlyZShcIkBtaWNyb3NvZnQvbG9hZC10aGVtZWQtc3R5bGVzXCIpO1xyXG5sb2FkX3RoZW1lZF9zdHlsZXNfMS5sb2FkU3R5bGVzKFt7IFwicmF3U3RyaW5nXCI6IFwiLnJvb3RfMzZlMzliNDF7cG9zaXRpb246YWJzb2x1dGU7LXdlYmtpdC1ib3gtc2l6aW5nOmJvcmRlci1ib3g7Ym94LXNpemluZzpib3JkZXItYm94O2JvcmRlcjoxcHggc29saWQgXCIgfSwgeyBcInRoZW1lXCI6IFwibmV1dHJhbExpZ2h0XCIsIFwiZGVmYXVsdFZhbHVlXCI6IFwiI2VhZWFlYVwiIH0sIHsgXCJyYXdTdHJpbmdcIjogXCJ9W2Rpcj0nbHRyJ10gLnJvb3RfMzZlMzliNDF7LXdlYmtpdC1ib3gtc2hhZG93OjAgMCA1cHggMHB4IHJnYmEoMCwwLDAsMC40KTtib3gtc2hhZG93OjAgMCA1cHggMHB4IHJnYmEoMCwwLDAsMC40KX1bZGlyPSdydGwnXSAucm9vdF8zNmUzOWI0MXstd2Via2l0LWJveC1zaGFkb3c6MCAwIDVweCAwcHggcmdiYSgwLDAsMCwwLjQpO2JveC1zaGFkb3c6MCAwIDVweCAwcHggcmdiYSgwLDAsMCwwLjQpfS5yb290XzM2ZTM5YjQxOjotbW96LWZvY3VzLWlubmVye2JvcmRlcjowfS5yb290XzM2ZTM5YjQxe291dGxpbmU6dHJhbnNwYXJlbnR9QG1lZGlhIHNjcmVlbiBhbmQgKC1tcy1oaWdoLWNvbnRyYXN0OiBhY3RpdmUpey5yb290XzM2ZTM5YjQxe2JvcmRlcjoxcHggc29saWQgV2luZG93VGV4dH19LmNvbnRhaW5lcl8zNmUzOWI0MXtwb3NpdGlvbjpyZWxhdGl2ZX0ubWFpbl8zNmUzOWI0MXtiYWNrZ3JvdW5kLWNvbG9yOlwiIH0sIHsgXCJ0aGVtZVwiOiBcIndoaXRlXCIsIFwiZGVmYXVsdFZhbHVlXCI6IFwiI2ZmZmZmZlwiIH0sIHsgXCJyYXdTdHJpbmdcIjogXCI7b3ZlcmZsb3cteDpoaWRkZW47b3ZlcmZsb3cteTphdXRvO3Bvc2l0aW9uOnJlbGF0aXZlfS5vdmVyRmxvd1lIaWRkZW5fMzZlMzliNDF7b3ZlcmZsb3cteTpoaWRkZW59LmJlYWtfMzZlMzliNDF7cG9zaXRpb246YWJzb2x1dGU7YmFja2dyb3VuZC1jb2xvcjpcIiB9LCB7IFwidGhlbWVcIjogXCJ3aGl0ZVwiLCBcImRlZmF1bHRWYWx1ZVwiOiBcIiNmZmZmZmZcIiB9LCB7IFwicmF3U3RyaW5nXCI6IFwiOy13ZWJraXQtYm94LXNoYWRvdzppbmhlcml0O2JveC1zaGFkb3c6aW5oZXJpdDtib3JkZXI6aW5oZXJpdDstd2Via2l0LWJveC1zaXppbmc6Ym9yZGVyLWJveDtib3gtc2l6aW5nOmJvcmRlci1ib3g7LXdlYmtpdC10cmFuc2Zvcm06cm90YXRlKDQ1ZGVnKTt0cmFuc2Zvcm06cm90YXRlKDQ1ZGVnKX0uYmVha0N1cnRhaW5fMzZlMzliNDF7cG9zaXRpb246YWJzb2x1dGU7dG9wOjA7cmlnaHQ6MDtib3R0b206MDtsZWZ0OjA7YmFja2dyb3VuZC1jb2xvcjpcIiB9LCB7IFwidGhlbWVcIjogXCJ3aGl0ZVwiLCBcImRlZmF1bHRWYWx1ZVwiOiBcIiNmZmZmZmZcIiB9LCB7IFwicmF3U3RyaW5nXCI6IFwifVxcblwiIH1dKTtcclxuZXhwb3J0cy5yb290ID0gXCJyb290XzM2ZTM5YjQxXCI7XHJcbmV4cG9ydHMuY29udGFpbmVyID0gXCJjb250YWluZXJfMzZlMzliNDFcIjtcclxuZXhwb3J0cy5tYWluID0gXCJtYWluXzM2ZTM5YjQxXCI7XHJcbmV4cG9ydHMub3ZlckZsb3dZSGlkZGVuID0gXCJvdmVyRmxvd1lIaWRkZW5fMzZlMzliNDFcIjtcclxuZXhwb3J0cy5iZWFrID0gXCJiZWFrXzM2ZTM5YjQxXCI7XHJcbmV4cG9ydHMuYmVha0N1cnRhaW4gPSBcImJlYWtDdXJ0YWluXzM2ZTM5YjQxXCI7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNhbGxvdXQuc2Nzcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcclxuLyogdHNsaW50OmRpc2FibGU6bm8tdW51c2VkLXZhcmlhYmxlICovXHJcbnZhciBSZWFjdCA9IHJlcXVpcmUoXCJyZWFjdFwiKTtcclxudmFyIFV0aWxpdGllc18xID0gcmVxdWlyZShcIi4uLy4uL1V0aWxpdGllc1wiKTtcclxudmFyIHBvc2l0aW9uaW5nXzEgPSByZXF1aXJlKFwiLi4vLi4vdXRpbGl0aWVzL3Bvc2l0aW9uaW5nXCIpO1xyXG52YXIgUG9wdXBfMSA9IHJlcXVpcmUoXCIuLi8uLi9Qb3B1cFwiKTtcclxudmFyIHN0eWxlc0ltcG9ydCA9IHJlcXVpcmUoXCIuL0NhbGxvdXQuc2Nzc1wiKTtcclxudmFyIFN0eWxpbmdfMSA9IHJlcXVpcmUoXCIuLi8uLi9TdHlsaW5nXCIpO1xyXG52YXIgc3R5bGVzID0gc3R5bGVzSW1wb3J0O1xyXG52YXIgQkVBS19PUklHSU5fUE9TSVRJT04gPSB7IHRvcDogMCwgbGVmdDogMCB9O1xyXG4vLyBNaWNyb3NvZnQgRWRnZSB3aWxsIG92ZXJ3cml0ZSBpbmxpbmUgc3R5bGVzIGlmIHRoZXJlIGlzIGFuIGFuaW1hdGlvbiBwZXJ0YWluaW5nIHRvIHRoYXQgc3R5bGUuXHJcbi8vIFRvIGhlbHAgZW5zdXJlIHRoYXQgZWRnZSB3aWxsIHJlc3BlY3QgdGhlIG9mZnNjcmVlbiBzdHlsZSBvcGFjaXR5XHJcbi8vIGZpbHRlciBuZWVkcyB0byBiZSBhZGRlZCBhcyBhbiBhZGRpdGlvbmFsIHdheSB0byBzZXQgb3BhY2l0eS5cclxudmFyIE9GRl9TQ1JFRU5fU1RZTEUgPSB7IG9wYWNpdHk6IDAsIGZpbHRlcjogJ29wYWNpdHkoMCknIH07XHJcbnZhciBCT1JERVJfV0lEVEggPSAxO1xyXG52YXIgU0xJREVfQU5JTUFUSU9OUyA9IChfYSA9IHt9LFxyXG4gICAgX2FbcG9zaXRpb25pbmdfMS5SZWN0YW5nbGVFZGdlLnRvcF0gPSAnc2xpZGVVcEluMjAnLFxyXG4gICAgX2FbcG9zaXRpb25pbmdfMS5SZWN0YW5nbGVFZGdlLmJvdHRvbV0gPSAnc2xpZGVEb3duSW4yMCcsXHJcbiAgICBfYVtwb3NpdGlvbmluZ18xLlJlY3RhbmdsZUVkZ2UubGVmdF0gPSAnc2xpZGVMZWZ0SW4yMCcsXHJcbiAgICBfYVtwb3NpdGlvbmluZ18xLlJlY3RhbmdsZUVkZ2UucmlnaHRdID0gJ3NsaWRlUmlnaHRJbjIwJyxcclxuICAgIF9hKTtcclxudmFyIENhbGxvdXRDb250ZW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoQ2FsbG91dENvbnRlbnQsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBDYWxsb3V0Q29udGVudChwcm9wcykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHByb3BzKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLl93YXJuRGVwcmVjYXRpb25zKHsgJ2JlYWtTdHlsZSc6ICdiZWFrV2lkdGgnIH0pO1xyXG4gICAgICAgIF90aGlzLl9kaWRTZXRJbml0aWFsRm9jdXMgPSBmYWxzZTtcclxuICAgICAgICBfdGhpcy5zdGF0ZSA9IHtcclxuICAgICAgICAgICAgcG9zaXRpb25zOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIHNsaWRlRGlyZWN0aW9uYWxDbGFzc05hbWU6IHVuZGVmaW5lZCxcclxuICAgICAgICAgICAgLy8gQFRPRE8gaXQgbG9va3MgbGlrZSB0aGlzIGlzIG5vdCBldmVuIGJlaW5nIHVzZWQgYW55bW9yZS5cclxuICAgICAgICAgICAgY2FsbG91dEVsZW1lbnRSZWN0OiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIGhlaWdodE9mZnNldDogMFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgX3RoaXMuX3Bvc2l0aW9uQXR0ZW1wdHMgPSAwO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIENhbGxvdXRDb250ZW50LnByb3RvdHlwZS5jb21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5fc2V0SW5pdGlhbEZvY3VzKCk7XHJcbiAgICAgICAgdGhpcy5fdXBkYXRlQXN5bmNQb3NpdGlvbigpO1xyXG4gICAgfTtcclxuICAgIENhbGxvdXRDb250ZW50LnByb3RvdHlwZS5jb21wb25lbnRXaWxsTW91bnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5fc2V0VGFyZ2V0V2luZG93QW5kRWxlbWVudCh0aGlzLl9nZXRUYXJnZXQoKSk7XHJcbiAgICB9O1xyXG4gICAgQ2FsbG91dENvbnRlbnQucHJvdG90eXBlLmNvbXBvbmVudFdpbGxVcGRhdGUgPSBmdW5jdGlvbiAobmV3UHJvcHMpIHtcclxuICAgICAgICAvLyBJZiB0aGUgdGFyZ2V0IGVsZW1lbnQgY2hhbmdlZCwgZmluZCB0aGUgbmV3IG9uZS4gSWYgd2UgYXJlIHRyYWNraW5nIHRhcmdldCB3aXRoIGNsYXNzIG5hbWUsIGFsd2F5cyBmaW5kIGVsZW1lbnQgYmVjYXVzZSB3ZSBkbyBub3Qga25vdyBpZiBmYWJyaWMgaGFzIHJlbmRlcmVkIGEgbmV3IGVsZW1lbnQgYW5kIGRpc3Bvc2VkIHRoZSBvbGQgZWxlbWVudC5cclxuICAgICAgICB2YXIgbmV3VGFyZ2V0ID0gdGhpcy5fZ2V0VGFyZ2V0KG5ld1Byb3BzKTtcclxuICAgICAgICB2YXIgb2xkVGFyZ2V0ID0gdGhpcy5fZ2V0VGFyZ2V0KCk7XHJcbiAgICAgICAgaWYgKG5ld1RhcmdldCAhPT0gb2xkVGFyZ2V0IHx8IHR5cGVvZiAobmV3VGFyZ2V0KSA9PT0gJ3N0cmluZycgfHwgbmV3VGFyZ2V0IGluc3RhbmNlb2YgU3RyaW5nKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX21heEhlaWdodCA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgdGhpcy5fc2V0VGFyZ2V0V2luZG93QW5kRWxlbWVudChuZXdUYXJnZXQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAobmV3UHJvcHMuZ2FwU3BhY2UgIT09IHRoaXMucHJvcHMuZ2FwU3BhY2UgfHwgdGhpcy5wcm9wcy5iZWFrV2lkdGggIT09IG5ld1Byb3BzLmJlYWtXaWR0aCkge1xyXG4gICAgICAgICAgICB0aGlzLl9tYXhIZWlnaHQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChuZXdQcm9wcy5maW5hbEhlaWdodCAhPT0gdGhpcy5wcm9wcy5maW5hbEhlaWdodCkge1xyXG4gICAgICAgICAgICB0aGlzLl9zZXRIZWlnaHRPZmZzZXRFdmVyeUZyYW1lKCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIENhbGxvdXRDb250ZW50LnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLl9vbkNvbXBvbmVudERpZE1vdW50KCk7XHJcbiAgICB9O1xyXG4gICAgQ2FsbG91dENvbnRlbnQucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAvLyBJZiB0aGVyZSBpcyBubyB0YXJnZXQgd2luZG93IHRoZW4gd2UgYXJlIGxpa2VseSBpbiBzZXJ2ZXIgc2lkZSByZW5kZXJpbmcgYW5kIHdlIHNob3VsZCBub3QgcmVuZGVyIGFueXRoaW5nLlxyXG4gICAgICAgIGlmICghdGhpcy5fdGFyZ2V0V2luZG93KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgX2EgPSB0aGlzLnByb3BzLCByb2xlID0gX2Eucm9sZSwgYXJpYUxhYmVsID0gX2EuYXJpYUxhYmVsLCBhcmlhRGVzY3JpYmVkQnkgPSBfYS5hcmlhRGVzY3JpYmVkQnksIGFyaWFMYWJlbGxlZEJ5ID0gX2EuYXJpYUxhYmVsbGVkQnksIGNsYXNzTmFtZSA9IF9hLmNsYXNzTmFtZSwgdGFyZ2V0ID0gX2EudGFyZ2V0LCBpc0JlYWtWaXNpYmxlID0gX2EuaXNCZWFrVmlzaWJsZSwgYmVha1N0eWxlID0gX2EuYmVha1N0eWxlLCBjaGlsZHJlbiA9IF9hLmNoaWxkcmVuLCBiZWFrV2lkdGggPSBfYS5iZWFrV2lkdGgsIGNhbGxvdXRXaWR0aCA9IF9hLmNhbGxvdXRXaWR0aCwgZmluYWxIZWlnaHQgPSBfYS5maW5hbEhlaWdodCwgYmFja2dyb3VuZENvbG9yID0gX2EuYmFja2dyb3VuZENvbG9yLCBjYWxsb3V0TWF4SGVpZ2h0ID0gX2EuY2FsbG91dE1heEhlaWdodCwgb25TY3JvbGwgPSBfYS5vblNjcm9sbDtcclxuICAgICAgICB0YXJnZXQgPSB0aGlzLl9nZXRUYXJnZXQoKTtcclxuICAgICAgICB2YXIgcG9zaXRpb25zID0gdGhpcy5zdGF0ZS5wb3NpdGlvbnM7XHJcbiAgICAgICAgdmFyIGRpcmVjdGlvbmFsQ2xhc3NOYW1lID0gKHBvc2l0aW9ucyAmJiBwb3NpdGlvbnMudGFyZ2V0RWRnZSlcclxuICAgICAgICAgICAgPyBTdHlsaW5nXzEuQW5pbWF0aW9uQ2xhc3NOYW1lc1tTTElERV9BTklNQVRJT05TW3Bvc2l0aW9ucy50YXJnZXRFZGdlXV1cclxuICAgICAgICAgICAgOiAnJztcclxuICAgICAgICB2YXIgZ2V0Q29udGVudE1heEhlaWdodCA9IHRoaXMuX2dldE1heEhlaWdodCgpICsgdGhpcy5zdGF0ZS5oZWlnaHRPZmZzZXQ7XHJcbiAgICAgICAgdmFyIGNvbnRlbnRNYXhIZWlnaHQgPSBjYWxsb3V0TWF4SGVpZ2h0ICYmIChjYWxsb3V0TWF4SGVpZ2h0IDwgZ2V0Q29udGVudE1heEhlaWdodCkgPyBjYWxsb3V0TWF4SGVpZ2h0IDogZ2V0Q29udGVudE1heEhlaWdodDtcclxuICAgICAgICB2YXIgYmVha1JlYWN0U3R5bGUgPSB0aGlzLl9nZXRCZWFrUG9zaXRpb24ocG9zaXRpb25zLCBiZWFrV2lkdGgsIGJhY2tncm91bmRDb2xvciwgYmVha1N0eWxlKTtcclxuICAgICAgICB2YXIgYmVha1Zpc2libGUgPSBpc0JlYWtWaXNpYmxlICYmICghIXRhcmdldCk7XHJcbiAgICAgICAgdmFyIGNvbnRlbnQgPSAoUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IHJlZjogdGhpcy5fcmVzb2x2ZVJlZignX2hvc3RFbGVtZW50JyksIGNsYXNzTmFtZTogVXRpbGl0aWVzXzEuY3NzKCdtcy1DYWxsb3V0LWNvbnRhaW5lcicsIHN0eWxlcy5jb250YWluZXIpIH0sXHJcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFN0eWxpbmdfMS5tZXJnZVN0eWxlcygnbXMtQ2FsbG91dCcsIHN0eWxlcy5yb290LCBjbGFzc05hbWUsIGRpcmVjdGlvbmFsQ2xhc3NOYW1lLCAhIWNhbGxvdXRXaWR0aCAmJiB7IHdpZHRoOiBjYWxsb3V0V2lkdGggfSksIHN0eWxlOiBwb3NpdGlvbnMgPyBwb3NpdGlvbnMuZWxlbWVudFBvc2l0aW9uIDogT0ZGX1NDUkVFTl9TVFlMRSwgdGFiSW5kZXg6IC0xLCBcclxuICAgICAgICAgICAgICAgIC8vIFNlZSBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVE1ML0VsZW1lbnQvYnV0dG9uI0NsaWNraW5nX2FuZF9mb2N1c1xyXG4gICAgICAgICAgICAgICAgcmVmOiB0aGlzLl9yZXNvbHZlUmVmKCdfY2FsbG91dEVsZW1lbnQnKSB9LFxyXG4gICAgICAgICAgICAgICAgYmVha1Zpc2libGUgJiYgKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgeyBjbGFzc05hbWU6IFV0aWxpdGllc18xLmNzcygnbXMtQ2FsbG91dC1iZWFrJywgc3R5bGVzLmJlYWspLCBzdHlsZTogYmVha1JlYWN0U3R5bGUgfSkpLFxyXG4gICAgICAgICAgICAgICAgYmVha1Zpc2libGUgJiZcclxuICAgICAgICAgICAgICAgICAgICAoUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogVXRpbGl0aWVzXzEuY3NzKCdtcy1DYWxsb3V0LWJlYWtDdXJ0YWluJywgc3R5bGVzLmJlYWtDdXJ0YWluKSB9KSksXHJcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFBvcHVwXzEuUG9wdXAsIHsgcm9sZTogcm9sZSwgYXJpYUxhYmVsOiBhcmlhTGFiZWwsIGFyaWFEZXNjcmliZWRCeTogYXJpYURlc2NyaWJlZEJ5LCBhcmlhTGFiZWxsZWRCeTogYXJpYUxhYmVsbGVkQnksIGNsYXNzTmFtZTogVXRpbGl0aWVzXzEuY3NzKCdtcy1DYWxsb3V0LW1haW4nLCBzdHlsZXMubWFpbiwgKF9iID0ge30sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iW3N0eWxlcy5vdmVyRmxvd1lIaWRkZW5dID0gISFmaW5hbEhlaWdodCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2IpKSwgb25EaXNtaXNzOiB0aGlzLmRpc21pc3MsIG9uU2Nyb2xsOiBvblNjcm9sbCwgc2hvdWxkUmVzdG9yZUZvY3VzOiB0cnVlLCBzdHlsZTogeyBtYXhIZWlnaHQ6IGNvbnRlbnRNYXhIZWlnaHQsIGJhY2tncm91bmRDb2xvcjogYmFja2dyb3VuZENvbG9yIH0gfSwgY2hpbGRyZW4pKSkpO1xyXG4gICAgICAgIHJldHVybiBjb250ZW50O1xyXG4gICAgICAgIHZhciBfYjtcclxuICAgIH07XHJcbiAgICBDYWxsb3V0Q29udGVudC5wcm90b3R5cGUuZGlzbWlzcyA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgIHZhciBvbkRpc21pc3MgPSB0aGlzLnByb3BzLm9uRGlzbWlzcztcclxuICAgICAgICBpZiAob25EaXNtaXNzKSB7XHJcbiAgICAgICAgICAgIG9uRGlzbWlzcyhldik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIENhbGxvdXRDb250ZW50LnByb3RvdHlwZS5fZGlzbWlzc09uU2Nyb2xsID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgdmFyIHByZXZlbnREaXNtaXNzT25TY3JvbGwgPSB0aGlzLnByb3BzLnByZXZlbnREaXNtaXNzT25TY3JvbGw7XHJcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUucG9zaXRpb25zICYmICFwcmV2ZW50RGlzbWlzc09uU2Nyb2xsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX2Rpc21pc3NPbkxvc3RGb2N1cyhldik7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIENhbGxvdXRDb250ZW50LnByb3RvdHlwZS5fZGlzbWlzc09uTG9zdEZvY3VzID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgdmFyIHRhcmdldCA9IGV2LnRhcmdldDtcclxuICAgICAgICB2YXIgY2xpY2tlZE91dHNpZGVDYWxsb3V0ID0gdGhpcy5faG9zdEVsZW1lbnQgJiYgIVV0aWxpdGllc18xLmVsZW1lbnRDb250YWlucyh0aGlzLl9ob3N0RWxlbWVudCwgdGFyZ2V0KTtcclxuICAgICAgICBpZiAoKCF0aGlzLl90YXJnZXQgJiYgY2xpY2tlZE91dHNpZGVDYWxsb3V0KSB8fFxyXG4gICAgICAgICAgICBldi50YXJnZXQgIT09IHRoaXMuX3RhcmdldFdpbmRvdyAmJlxyXG4gICAgICAgICAgICAgICAgY2xpY2tlZE91dHNpZGVDYWxsb3V0ICYmXHJcbiAgICAgICAgICAgICAgICAodGhpcy5fdGFyZ2V0LnN0b3BQcm9wYWdhdGlvbiB8fFxyXG4gICAgICAgICAgICAgICAgICAgICghdGhpcy5fdGFyZ2V0IHx8ICh0YXJnZXQgIT09IHRoaXMuX3RhcmdldCAmJiAhVXRpbGl0aWVzXzEuZWxlbWVudENvbnRhaW5zKHRoaXMuX3RhcmdldCwgdGFyZ2V0KSkpKSkge1xyXG4gICAgICAgICAgICB0aGlzLmRpc21pc3MoZXYpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBDYWxsb3V0Q29udGVudC5wcm90b3R5cGUuX3NldEluaXRpYWxGb2N1cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5wcm9wcy5zZXRJbml0aWFsRm9jdXMgJiYgIXRoaXMuX2RpZFNldEluaXRpYWxGb2N1cyAmJiB0aGlzLnN0YXRlLnBvc2l0aW9ucykge1xyXG4gICAgICAgICAgICB0aGlzLl9kaWRTZXRJbml0aWFsRm9jdXMgPSB0cnVlO1xyXG4gICAgICAgICAgICBVdGlsaXRpZXNfMS5mb2N1c0ZpcnN0Q2hpbGQodGhpcy5fY2FsbG91dEVsZW1lbnQpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBDYWxsb3V0Q29udGVudC5wcm90b3R5cGUuX29uQ29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICAvLyBUaGlzIGlzIGFkZGVkIHNvIHRoZSBjYWxsb3V0IHdpbGwgZGlzbWlzcyB3aGVuIHRoZSB3aW5kb3cgaXMgc2Nyb2xsZWRcclxuICAgICAgICAvLyBidXQgbm90IHdoZW4gc29tZXRoaW5nIGluc2lkZSB0aGUgY2FsbG91dCBpcyBzY3JvbGxlZC4gVGhlIGRlbGF5IHNlZW1zXHJcbiAgICAgICAgLy8gdG8gYmUgcmVxdWlyZWQgdG8gYXZvaWQgUmVhY3QgZmlyaW5nIGFuIGFzeW5jIGZvY3VzIGV2ZW50IGluIElFIGZyb21cclxuICAgICAgICAvLyB0aGUgdGFyZ2V0IGNoYW5naW5nIGZvY3VzIHF1aWNrbHkgcHJpb3IgdG8gcmVuZGVyaW5nIHRoZSBjYWxsb3V0LlxyXG4gICAgICAgIHRoaXMuX2FzeW5jLnNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBfdGhpcy5fZXZlbnRzLm9uKF90aGlzLl90YXJnZXRXaW5kb3csICdzY3JvbGwnLCBfdGhpcy5fZGlzbWlzc09uU2Nyb2xsLCB0cnVlKTtcclxuICAgICAgICAgICAgX3RoaXMuX2V2ZW50cy5vbihfdGhpcy5fdGFyZ2V0V2luZG93LCAncmVzaXplJywgX3RoaXMuZGlzbWlzcywgdHJ1ZSk7XHJcbiAgICAgICAgICAgIF90aGlzLl9ldmVudHMub24oX3RoaXMuX3RhcmdldFdpbmRvdy5kb2N1bWVudC5ib2R5LCAnZm9jdXMnLCBfdGhpcy5fZGlzbWlzc09uTG9zdEZvY3VzLCB0cnVlKTtcclxuICAgICAgICAgICAgX3RoaXMuX2V2ZW50cy5vbihfdGhpcy5fdGFyZ2V0V2luZG93LmRvY3VtZW50LmJvZHksICdjbGljaycsIF90aGlzLl9kaXNtaXNzT25Mb3N0Rm9jdXMsIHRydWUpO1xyXG4gICAgICAgIH0sIDApO1xyXG4gICAgICAgIGlmICh0aGlzLnByb3BzLm9uTGF5ZXJNb3VudGVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvcHMub25MYXllck1vdW50ZWQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fdXBkYXRlQXN5bmNQb3NpdGlvbigpO1xyXG4gICAgICAgIHRoaXMuX3NldEhlaWdodE9mZnNldEV2ZXJ5RnJhbWUoKTtcclxuICAgIH07XHJcbiAgICBDYWxsb3V0Q29udGVudC5wcm90b3R5cGUuX3VwZGF0ZUFzeW5jUG9zaXRpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB0aGlzLl9hc3luYy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX3VwZGF0ZVBvc2l0aW9uKCk7IH0pO1xyXG4gICAgfTtcclxuICAgIENhbGxvdXRDb250ZW50LnByb3RvdHlwZS5fdXBkYXRlUG9zaXRpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHBvc2l0aW9ucyA9IHRoaXMuc3RhdGUucG9zaXRpb25zO1xyXG4gICAgICAgIHZhciBob3N0RWxlbWVudCA9IHRoaXMuX2hvc3RFbGVtZW50O1xyXG4gICAgICAgIHZhciBjYWxsb3V0RWxlbWVudCA9IHRoaXMuX2NhbGxvdXRFbGVtZW50O1xyXG4gICAgICAgIGlmIChob3N0RWxlbWVudCAmJiBjYWxsb3V0RWxlbWVudCkge1xyXG4gICAgICAgICAgICB2YXIgY3VycmVudFByb3BzID0gdm9pZCAwO1xyXG4gICAgICAgICAgICBjdXJyZW50UHJvcHMgPSBVdGlsaXRpZXNfMS5hc3NpZ24oY3VycmVudFByb3BzLCB0aGlzLnByb3BzKTtcclxuICAgICAgICAgICAgY3VycmVudFByb3BzLmJvdW5kcyA9IHRoaXMuX2dldEJvdW5kcygpO1xyXG4gICAgICAgICAgICBjdXJyZW50UHJvcHMudGFyZ2V0ID0gdGhpcy5fdGFyZ2V0O1xyXG4gICAgICAgICAgICB2YXIgbmV3UG9zaXRpb25zID0gcG9zaXRpb25pbmdfMS5wb3NpdGlvbkNhbGxvdXQoY3VycmVudFByb3BzLCBob3N0RWxlbWVudCwgY2FsbG91dEVsZW1lbnQpO1xyXG4gICAgICAgICAgICAvLyBTZXQgdGhlIG5ldyBwb3NpdGlvbiBvbmx5IHdoZW4gdGhlIHBvc2l0aW9ucyBhcmUgbm90IGV4aXN0cyBvciBvbmUgb2YgdGhlIG5ldyBjYWxsb3V0IHBvc2l0aW9ucyBhcmUgZGlmZmVyZW50LlxyXG4gICAgICAgICAgICAvLyBUaGUgcG9zaXRpb24gc2hvdWxkIG5vdCBjaGFuZ2UgaWYgdGhlIHBvc2l0aW9uIGlzIHdpdGhpbiAyIGRlY2ltYWwgcGxhY2VzLlxyXG4gICAgICAgICAgICBpZiAoKCFwb3NpdGlvbnMgJiYgbmV3UG9zaXRpb25zKSB8fFxyXG4gICAgICAgICAgICAgICAgKHBvc2l0aW9ucyAmJiBuZXdQb3NpdGlvbnMgJiYgIXRoaXMuX2FyZVBvc2l0aW9uc0VxdWFsKHBvc2l0aW9ucywgbmV3UG9zaXRpb25zKVxyXG4gICAgICAgICAgICAgICAgICAgICYmIHRoaXMuX3Bvc2l0aW9uQXR0ZW1wdHMgPCA1KSkge1xyXG4gICAgICAgICAgICAgICAgLy8gV2Ugc2hvdWxkIG5vdCByZXBvc2l0aW9uIHRoZSBjYWxsb3V0IG1vcmUgdGhhbiBhIGZldyB0aW1lcywgaWYgaXQgaXMgdGhlbiB0aGUgY29udGVudCBpcyBsaWtlbHkgcmVzaXppbmdcclxuICAgICAgICAgICAgICAgIC8vIGFuZCB3ZSBzaG91bGQgc3RvcCB0cnlpbmcgdG8gcmVwb3NpdGlvbiB0byBwcmV2ZW50IGEgc3RhY2sgb3ZlcmZsb3cuXHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wb3NpdGlvbkF0dGVtcHRzKys7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcclxuICAgICAgICAgICAgICAgICAgICBwb3NpdGlvbnM6IG5ld1Bvc2l0aW9uc1xyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9wb3NpdGlvbkF0dGVtcHRzID0gMDtcclxuICAgICAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLm9uUG9zaXRpb25lZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucHJvcHMub25Qb3NpdGlvbmVkKHRoaXMuc3RhdGUucG9zaXRpb25zKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBDYWxsb3V0Q29udGVudC5wcm90b3R5cGUuX2dldEJlYWtQb3NpdGlvbiA9IGZ1bmN0aW9uIChwb3NpdGlvbnMsIGJlYWtXaWR0aCwgYmFja2dyb3VuZENvbG9yLCBiZWFrU3R5bGUpIHtcclxuICAgICAgICB2YXIgYmVha1N0eWxlV2lkdGggPSBiZWFrV2lkdGg7XHJcbiAgICAgICAgLy8gVGhpcyBpcyBoZXJlIHRvIHN1cHBvcnQgdGhlIG9sZCB3YXkgb2Ygc2V0dGluZyB0aGUgYmVhayBzaXplIHVudGlsIHZlcnNpb24gMS4wLjAuXHJcbiAgICAgICAgLy8gYmVha1N0eWxlIGlzIG5vdyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIGJlIHJlbW92ZWQgYXQgdmVyc2lvbiAxLjAuMFxyXG4gICAgICAgIGlmIChiZWFrU3R5bGUgPT09ICdtcy1DYWxsb3V0LXNtYWxsYmVhaycpIHtcclxuICAgICAgICAgICAgYmVha1N0eWxlV2lkdGggPSAxNjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGJlYWtSZWFjdFN0eWxlID0gdHNsaWJfMS5fX2Fzc2lnbih7fSwgKHBvc2l0aW9ucyAmJiBwb3NpdGlvbnMuYmVha1Bvc2l0aW9uID8gcG9zaXRpb25zLmJlYWtQb3NpdGlvbi5lbGVtZW50UG9zaXRpb24gOiBudWxsKSk7XHJcbiAgICAgICAgYmVha1JlYWN0U3R5bGUuaGVpZ2h0ID0gYmVha1N0eWxlV2lkdGg7XHJcbiAgICAgICAgYmVha1JlYWN0U3R5bGUud2lkdGggPSBiZWFrU3R5bGVXaWR0aDtcclxuICAgICAgICBiZWFrUmVhY3RTdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBiYWNrZ3JvdW5kQ29sb3I7XHJcbiAgICAgICAgaWYgKCFiZWFrUmVhY3RTdHlsZS50b3AgJiYgIWJlYWtSZWFjdFN0eWxlLmJvdHRvbSAmJiAhYmVha1JlYWN0U3R5bGUubGVmdCAmJiAhYmVha1JlYWN0U3R5bGUucmlnaHQpIHtcclxuICAgICAgICAgICAgYmVha1JlYWN0U3R5bGUubGVmdCA9IEJFQUtfT1JJR0lOX1BPU0lUSU9OLmxlZnQ7XHJcbiAgICAgICAgICAgIGJlYWtSZWFjdFN0eWxlLnRvcCA9IEJFQUtfT1JJR0lOX1BPU0lUSU9OLnRvcDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGJlYWtSZWFjdFN0eWxlO1xyXG4gICAgfTtcclxuICAgIENhbGxvdXRDb250ZW50LnByb3RvdHlwZS5fZ2V0Qm91bmRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICghdGhpcy5fYm91bmRzKSB7XHJcbiAgICAgICAgICAgIHZhciBjdXJyZW50Qm91bmRzID0gdGhpcy5wcm9wcy5ib3VuZHM7XHJcbiAgICAgICAgICAgIGlmICghY3VycmVudEJvdW5kcykge1xyXG4gICAgICAgICAgICAgICAgY3VycmVudEJvdW5kcyA9IHtcclxuICAgICAgICAgICAgICAgICAgICB0b3A6IDAgKyB0aGlzLnByb3BzLm1pblBhZ2VQYWRkaW5nLFxyXG4gICAgICAgICAgICAgICAgICAgIGxlZnQ6IDAgKyB0aGlzLnByb3BzLm1pblBhZ2VQYWRkaW5nLFxyXG4gICAgICAgICAgICAgICAgICAgIHJpZ2h0OiB0aGlzLl90YXJnZXRXaW5kb3cuaW5uZXJXaWR0aCAtIHRoaXMucHJvcHMubWluUGFnZVBhZGRpbmcsXHJcbiAgICAgICAgICAgICAgICAgICAgYm90dG9tOiB0aGlzLl90YXJnZXRXaW5kb3cuaW5uZXJIZWlnaHQgLSB0aGlzLnByb3BzLm1pblBhZ2VQYWRkaW5nLFxyXG4gICAgICAgICAgICAgICAgICAgIHdpZHRoOiB0aGlzLl90YXJnZXRXaW5kb3cuaW5uZXJXaWR0aCAtIHRoaXMucHJvcHMubWluUGFnZVBhZGRpbmcgKiAyLFxyXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodDogdGhpcy5fdGFyZ2V0V2luZG93LmlubmVySGVpZ2h0IC0gdGhpcy5wcm9wcy5taW5QYWdlUGFkZGluZyAqIDJcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGhpcy5fYm91bmRzID0gY3VycmVudEJvdW5kcztcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2JvdW5kcztcclxuICAgIH07XHJcbiAgICBDYWxsb3V0Q29udGVudC5wcm90b3R5cGUuX2dldE1heEhlaWdodCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAoIXRoaXMuX21heEhlaWdodCkge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wcm9wcy5kaXJlY3Rpb25hbEhpbnRGaXhlZCAmJiB0aGlzLl90YXJnZXQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBiZWFrV2lkdGggPSB0aGlzLnByb3BzLmlzQmVha1Zpc2libGUgPyB0aGlzLnByb3BzLmJlYWtXaWR0aCA6IDA7XHJcbiAgICAgICAgICAgICAgICB2YXIgZ2FwU3BhY2UgPSB0aGlzLnByb3BzLmdhcFNwYWNlID8gdGhpcy5wcm9wcy5nYXBTcGFjZSA6IDA7XHJcbiAgICAgICAgICAgICAgICAvLyBTaW5jZSB0aGUgY2FsbG91dCBjYW5ub3QgbWVhc3VyZSBpdCdzIGJvcmRlciBzaXplIGl0IG11c3QgYmUgdGFrZW4gaW50byBhY2NvdW50IGhlcmUuIE90aGVyd2lzZSBpdCB3aWxsXHJcbiAgICAgICAgICAgICAgICAvLyBvdmVybGFwIHdpdGggdGhlIHRhcmdldC5cclxuICAgICAgICAgICAgICAgIHZhciB0b3RhbEdhcCA9IGdhcFNwYWNlICsgYmVha1dpZHRoICsgQk9SREVSX1dJRFRIICogMjtcclxuICAgICAgICAgICAgICAgIHRoaXMuX21heEhlaWdodCA9IHBvc2l0aW9uaW5nXzEuZ2V0TWF4SGVpZ2h0KHRoaXMuX3RhcmdldCwgdGhpcy5wcm9wcy5kaXJlY3Rpb25hbEhpbnQsIHRvdGFsR2FwLCB0aGlzLl9nZXRCb3VuZHMoKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9tYXhIZWlnaHQgPSB0aGlzLl9nZXRCb3VuZHMoKS5oZWlnaHQgLSBCT1JERVJfV0lEVEggKiAyO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0aGlzLl9tYXhIZWlnaHQ7XHJcbiAgICB9O1xyXG4gICAgQ2FsbG91dENvbnRlbnQucHJvdG90eXBlLl9hcmVQb3NpdGlvbnNFcXVhbCA9IGZ1bmN0aW9uIChwb3NpdGlvbnMsIG5ld1Bvc2l0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NvbXBhcmVQb3NpdGlvbnMocG9zaXRpb25zLmVsZW1lbnRQb3NpdGlvbiwgbmV3UG9zaXRpb24uZWxlbWVudFBvc2l0aW9uKSAmJlxyXG4gICAgICAgICAgICB0aGlzLl9jb21wYXJlUG9zaXRpb25zKHBvc2l0aW9ucy5iZWFrUG9zaXRpb24uZWxlbWVudFBvc2l0aW9uLCBuZXdQb3NpdGlvbi5iZWFrUG9zaXRpb24uZWxlbWVudFBvc2l0aW9uKTtcclxuICAgIH07XHJcbiAgICBDYWxsb3V0Q29udGVudC5wcm90b3R5cGUuX2NvbXBhcmVQb3NpdGlvbnMgPSBmdW5jdGlvbiAob2xkUG9zaXRpb25zLCBuZXdQb3NpdGlvbnMpIHtcclxuICAgICAgICBmb3IgKHZhciBrZXkgaW4gbmV3UG9zaXRpb25zKSB7XHJcbiAgICAgICAgICAgIC8vIFRoaXMgbmVlZHMgdG8gYmUgY2hlY2tlZCBoZXJlIGFuZCBiZWxvdyBiZWNhdXNlIHRoZXJlIGlzIGEgbGludGluZyBlcnJvciBpZiBmb3IgaW4gZG9lcyBub3QgaW1tZWRpYXRlbHkgaGF2ZSBhbiBpZiBzdGF0ZW1lbnRcclxuICAgICAgICAgICAgaWYgKG5ld1Bvc2l0aW9ucy5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgb2xkUG9zaXRpb25FZGdlID0gb2xkUG9zaXRpb25zW2tleV07XHJcbiAgICAgICAgICAgICAgICB2YXIgbmV3UG9zaXRpb25FZGdlID0gbmV3UG9zaXRpb25zW2tleV07XHJcbiAgICAgICAgICAgICAgICBpZiAob2xkUG9zaXRpb25FZGdlICE9PSB1bmRlZmluZWQgJiYgbmV3UG9zaXRpb25FZGdlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAob2xkUG9zaXRpb25FZGdlLnRvRml4ZWQoMikgIT09IG5ld1Bvc2l0aW9uRWRnZS50b0ZpeGVkKDIpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9O1xyXG4gICAgQ2FsbG91dENvbnRlbnQucHJvdG90eXBlLl9zZXRUYXJnZXRXaW5kb3dBbmRFbGVtZW50ID0gZnVuY3Rpb24gKHRhcmdldCkge1xyXG4gICAgICAgIGlmICh0YXJnZXQpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0YXJnZXQgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgY3VycmVudERvYyA9IFV0aWxpdGllc18xLmdldERvY3VtZW50KCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl90YXJnZXQgPSBjdXJyZW50RG9jID8gY3VycmVudERvYy5xdWVyeVNlbGVjdG9yKHRhcmdldCkgOiBudWxsO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdGFyZ2V0V2luZG93ID0gVXRpbGl0aWVzXzEuZ2V0V2luZG93KCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodGFyZ2V0LnN0b3BQcm9wYWdhdGlvbikge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdGFyZ2V0V2luZG93ID0gVXRpbGl0aWVzXzEuZ2V0V2luZG93KHRhcmdldC50b0VsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHRhcmdldC54ICE9PSB1bmRlZmluZWQgJiYgdGFyZ2V0LnkgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdGFyZ2V0V2luZG93ID0gVXRpbGl0aWVzXzEuZ2V0V2luZG93KCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl90YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgdGFyZ2V0RWxlbWVudCA9IHRhcmdldDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3RhcmdldFdpbmRvdyA9IFV0aWxpdGllc18xLmdldFdpbmRvdyh0YXJnZXRFbGVtZW50KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3RhcmdldCA9IHRhcmdldDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5fdGFyZ2V0V2luZG93ID0gVXRpbGl0aWVzXzEuZ2V0V2luZG93KCk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIENhbGxvdXRDb250ZW50LnByb3RvdHlwZS5fc2V0SGVpZ2h0T2Zmc2V0RXZlcnlGcmFtZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGlmICh0aGlzLl9jYWxsb3V0RWxlbWVudCAmJiB0aGlzLnByb3BzLmZpbmFsSGVpZ2h0KSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3NldEhlaWdodE9mZnNldFRpbWVyID0gdGhpcy5fYXN5bmMucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHZhciBjYWxsb3V0TWFpbkVsZW0gPSBfdGhpcy5fY2FsbG91dEVsZW1lbnQubGFzdENoaWxkO1xyXG4gICAgICAgICAgICAgICAgdmFyIGNhcmRTY3JvbGxIZWlnaHQgPSBjYWxsb3V0TWFpbkVsZW0uc2Nyb2xsSGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgdmFyIGNhcmRDdXJySGVpZ2h0ID0gY2FsbG91dE1haW5FbGVtLm9mZnNldEhlaWdodDtcclxuICAgICAgICAgICAgICAgIHZhciBzY3JvbGxEaWZmID0gY2FyZFNjcm9sbEhlaWdodCAtIGNhcmRDdXJySGVpZ2h0O1xyXG4gICAgICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoe1xyXG4gICAgICAgICAgICAgICAgICAgIGhlaWdodE9mZnNldDogX3RoaXMuc3RhdGUuaGVpZ2h0T2Zmc2V0ICsgc2Nyb2xsRGlmZlxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgICAgICBpZiAoY2FsbG91dE1haW5FbGVtLm9mZnNldEhlaWdodCA8IF90aGlzLnByb3BzLmZpbmFsSGVpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuX3NldEhlaWdodE9mZnNldEV2ZXJ5RnJhbWUoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9hc3luYy5jYW5jZWxBbmltYXRpb25GcmFtZShfdGhpcy5fc2V0SGVpZ2h0T2Zmc2V0VGltZXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQ2FsbG91dENvbnRlbnQucHJvdG90eXBlLl9nZXRUYXJnZXQgPSBmdW5jdGlvbiAocHJvcHMpIHtcclxuICAgICAgICBpZiAocHJvcHMgPT09IHZvaWQgMCkgeyBwcm9wcyA9IHRoaXMucHJvcHM7IH1cclxuICAgICAgICB2YXIgdXNlVGFyZ2V0UG9pbnQgPSBwcm9wcy51c2VUYXJnZXRQb2ludCwgdGFyZ2V0UG9pbnQgPSBwcm9wcy50YXJnZXRQb2ludCwgdGFyZ2V0ID0gcHJvcHMudGFyZ2V0O1xyXG4gICAgICAgIHJldHVybiB1c2VUYXJnZXRQb2ludCA/IHRhcmdldFBvaW50IDogdGFyZ2V0O1xyXG4gICAgfTtcclxuICAgIENhbGxvdXRDb250ZW50LmRlZmF1bHRQcm9wcyA9IHtcclxuICAgICAgICBwcmV2ZW50RGlzbWlzc09uU2Nyb2xsOiBmYWxzZSxcclxuICAgICAgICBpc0JlYWtWaXNpYmxlOiB0cnVlLFxyXG4gICAgICAgIGJlYWtXaWR0aDogMTYsXHJcbiAgICAgICAgZ2FwU3BhY2U6IDAsXHJcbiAgICAgICAgbWluUGFnZVBhZGRpbmc6IDgsXHJcbiAgICAgICAgZGlyZWN0aW9uYWxIaW50OiA3IC8qIGJvdHRvbUF1dG9FZGdlICovXHJcbiAgICB9O1xyXG4gICAgdHNsaWJfMS5fX2RlY29yYXRlKFtcclxuICAgICAgICBVdGlsaXRpZXNfMS5hdXRvYmluZFxyXG4gICAgXSwgQ2FsbG91dENvbnRlbnQucHJvdG90eXBlLCBcImRpc21pc3NcIiwgbnVsbCk7XHJcbiAgICB0c2xpYl8xLl9fZGVjb3JhdGUoW1xyXG4gICAgICAgIFV0aWxpdGllc18xLmF1dG9iaW5kXHJcbiAgICBdLCBDYWxsb3V0Q29udGVudC5wcm90b3R5cGUsIFwiX3NldEluaXRpYWxGb2N1c1wiLCBudWxsKTtcclxuICAgIHRzbGliXzEuX19kZWNvcmF0ZShbXHJcbiAgICAgICAgVXRpbGl0aWVzXzEuYXV0b2JpbmRcclxuICAgIF0sIENhbGxvdXRDb250ZW50LnByb3RvdHlwZSwgXCJfb25Db21wb25lbnREaWRNb3VudFwiLCBudWxsKTtcclxuICAgIHJldHVybiBDYWxsb3V0Q29udGVudDtcclxufShVdGlsaXRpZXNfMS5CYXNlQ29tcG9uZW50KSk7XHJcbmV4cG9ydHMuQ2FsbG91dENvbnRlbnQgPSBDYWxsb3V0Q29udGVudDtcclxudmFyIF9hO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1DYWxsb3V0Q29udGVudC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcclxudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vQ2FsbG91dFwiKSwgZXhwb3J0cyk7XHJcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuLi8uLi9jb21tb24vRGlyZWN0aW9uYWxIaW50XCIpLCBleHBvcnRzKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIFV0aWxpdGllc18xID0gcmVxdWlyZShcIi4uLy4uL1V0aWxpdGllc1wiKTtcclxudmFyIFN0eWxpbmdfMSA9IHJlcXVpcmUoXCIuLi8uLi9TdHlsaW5nXCIpO1xyXG52YXIgQ29udGV4dHVhbE1lbnVfc3R5bGVzXzEgPSByZXF1aXJlKFwiLi9Db250ZXh0dWFsTWVudS5zdHlsZXNcIik7XHJcbnZhciBWZXJ0aWNhbERpdmlkZXJfY2xhc3NOYW1lc18xID0gcmVxdWlyZShcIi4uL0RpdmlkZXIvVmVydGljYWxEaXZpZGVyLmNsYXNzTmFtZXNcIik7XHJcbmV4cG9ydHMuZ2V0U3BsaXRCdXR0b25WZXJ0aWNhbERpdmlkZXJDbGFzc05hbWVzID0gVXRpbGl0aWVzXzEubWVtb2l6ZUZ1bmN0aW9uKGZ1bmN0aW9uICh0aGVtZSkge1xyXG4gICAgdmFyIHNlbWFudGljQ29sb3JzID0gdGhlbWUuc2VtYW50aWNDb2xvcnM7XHJcbiAgICB2YXIgQ29udGV4dHVhbE1lbnVEaXZpZGVyQ29sb3IgPSBzZW1hbnRpY0NvbG9ycy5ib2R5RGl2aWRlcjtcclxuICAgIHJldHVybiBTdHlsaW5nXzEubWVyZ2VTdHlsZVNldHMoVmVydGljYWxEaXZpZGVyX2NsYXNzTmFtZXNfMS5nZXREaXZpZGVyQ2xhc3NOYW1lcyh0aGVtZSksIHtcclxuICAgICAgICBkaXZpZGVyOiB7XHJcbiAgICAgICAgICAgIGhlaWdodDogMTYsXHJcbiAgICAgICAgICAgIHdpZHRoOiAxLFxyXG4gICAgICAgIH1cclxuICAgIH0pO1xyXG59KTtcclxuZXhwb3J0cy5nZXRDb250ZXh0dWFsTWVudUNsYXNzTmFtZXMgPSBVdGlsaXRpZXNfMS5tZW1vaXplRnVuY3Rpb24oZnVuY3Rpb24gKHRoZW1lLCBjbGFzc05hbWUpIHtcclxuICAgIHZhciBzdHlsZXMgPSBDb250ZXh0dWFsTWVudV9zdHlsZXNfMS5nZXRTdHlsZXModGhlbWUpO1xyXG4gICAgcmV0dXJuIFN0eWxpbmdfMS5tZXJnZVN0eWxlU2V0cyh7XHJcbiAgICAgICAgY29udGFpbmVyOiBbXHJcbiAgICAgICAgICAgICdtcy1Db250ZXh0dWFsTWVudS1jb250YWluZXInLFxyXG4gICAgICAgICAgICBzdHlsZXMuY29udGFpbmVyLFxyXG4gICAgICAgICAgICBjbGFzc05hbWUsXHJcbiAgICAgICAgICAgIFt7XHJcbiAgICAgICAgICAgICAgICAgICAgc2VsZWN0b3JzOiB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICc6Zm9jdXMnOiB7IG91dGxpbmU6IDAgfVxyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1dXHJcbiAgICAgICAgXSxcclxuICAgICAgICByb290OiBbXHJcbiAgICAgICAgICAgICdtcy1Db250ZXh0dWFsTWVudSBpcy1vcGVuJyxcclxuICAgICAgICAgICAgc3R5bGVzLnJvb3RcclxuICAgICAgICBdLFxyXG4gICAgICAgIGxpc3Q6IFtcclxuICAgICAgICAgICAgJ21zLUNvbnRleHR1YWxNZW51LWxpc3QgaXMtb3BlbicsXHJcbiAgICAgICAgICAgIHN0eWxlcy5saXN0XHJcbiAgICAgICAgXSxcclxuICAgICAgICBoZWFkZXI6IFtcclxuICAgICAgICAgICAgJ21zLUNvbnRleHR1YWxNZW51LWhlYWRlcicsXHJcbiAgICAgICAgICAgIHN0eWxlcy5oZWFkZXJcclxuICAgICAgICBdLFxyXG4gICAgICAgIHRpdGxlOiBzdHlsZXMudGl0bGVcclxuICAgIH0pO1xyXG59KTtcclxuZXhwb3J0cy5nZXRJdGVtQ2xhc3NOYW1lcyA9IFV0aWxpdGllc18xLm1lbW9pemVGdW5jdGlvbihmdW5jdGlvbiAodGhlbWUsIGRpc2FibGVkLCBleHBhbmRlZCwgY2hlY2tlZCwgaXNBbmNob3JMaW5rLCBrbm93bkljb24sIGl0ZW1DbGFzc05hbWUsIGRpdmlkZXJDbGFzc05hbWUsIGljb25DbGFzc05hbWUsIHN1Yk1lbnVDbGFzc05hbWUpIHtcclxuICAgIHZhciBzZW1hbnRpY0NvbG9ycyA9IHRoZW1lLnNlbWFudGljQ29sb3JzO1xyXG4gICAgdmFyIENvbnRleHR1YWxNZW51SWNvbkNvbG9yID0gc2VtYW50aWNDb2xvcnMubWVudUljb247XHJcbiAgICB2YXIgc3R5bGVzID0gQ29udGV4dHVhbE1lbnVfc3R5bGVzXzEuZ2V0TWVudUl0ZW1TdHlsZXModGhlbWUpO1xyXG4gICAgcmV0dXJuIFN0eWxpbmdfMS5tZXJnZVN0eWxlU2V0cyh7XHJcbiAgICAgICAgaXRlbTogW1xyXG4gICAgICAgICAgICAnbXMtQ29udGV4dHVhbE1lbnUtaXRlbScsXHJcbiAgICAgICAgICAgIHN0eWxlcy5pdGVtLFxyXG4gICAgICAgICAgICBpdGVtQ2xhc3NOYW1lLFxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgZGl2aWRlcjogW1xyXG4gICAgICAgICAgICAnbXMtQ29udGV4dHVhbE1lbnUtZGl2aWRlcicsXHJcbiAgICAgICAgICAgIHN0eWxlcy5kaXZpZGVyLFxyXG4gICAgICAgICAgICBkaXZpZGVyQ2xhc3NOYW1lLFxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgcm9vdDogW1xyXG4gICAgICAgICAgICAnbXMtQ29udGV4dHVhbE1lbnUtbGluaycsXHJcbiAgICAgICAgICAgIHN0eWxlcy5yb290LFxyXG4gICAgICAgICAgICBjaGVja2VkICYmIFtcclxuICAgICAgICAgICAgICAgICdpcy1jaGVja2VkJyxcclxuICAgICAgICAgICAgICAgIHN0eWxlcy5yb290Q2hlY2tlZFxyXG4gICAgICAgICAgICBdLFxyXG4gICAgICAgICAgICBpc0FuY2hvckxpbmsgJiYgc3R5bGVzLmFuY2hvckxpbmssXHJcbiAgICAgICAgICAgIGV4cGFuZGVkICYmIFtcclxuICAgICAgICAgICAgICAgICdpcy1leHBhbmRlZCcsXHJcbiAgICAgICAgICAgICAgICBzdHlsZXMucm9vdEV4cGFuZGVkXHJcbiAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgIGRpc2FibGVkICYmIFtcclxuICAgICAgICAgICAgICAgICdpcy1kaXNhYmxlZCcsXHJcbiAgICAgICAgICAgICAgICBzdHlsZXMucm9vdERpc2FibGVkXHJcbiAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgICFkaXNhYmxlZCAmJiAhZXhwYW5kZWQgJiYgW3tcclxuICAgICAgICAgICAgICAgICAgICBzZWxlY3RvcnM6IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgJzpob3Zlcic6IHN0eWxlcy5yb290SG92ZXJlZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgJzphY3RpdmUnOiBzdHlsZXMucm9vdFByZXNzZWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICcubXMtRmFicmljLmlzLWZvY3VzVmlzaWJsZSAmOmZvY3VzLCAubXMtRmFicmljLmlzLWZvY3VzVmlzaWJsZSAmOmZvY3VzOmhvdmVyJzogc3R5bGVzLnJvb3RGb2N1c2VkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAnLm1zLUZhYnJpYy5pcy1mb2N1c1Zpc2libGUgJjpob3Zlcic6IHsgYmFja2dyb3VuZDogJ2luaGVyaXQ7JyB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfV0sXHJcbiAgICAgICAgXSxcclxuICAgICAgICBzcGxpdFByaW1hcnk6IFtcclxuICAgICAgICAgICAgc3R5bGVzLnJvb3QsXHJcbiAgICAgICAgICAgIGNoZWNrZWQgJiYgW1xyXG4gICAgICAgICAgICAgICAgJ2lzLWNoZWNrZWQnLFxyXG4gICAgICAgICAgICAgICAgc3R5bGVzLnJvb3RDaGVja2VkXHJcbiAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgIGRpc2FibGVkICYmIFtcclxuICAgICAgICAgICAgICAgICdpcy1kaXNhYmxlZCcsXHJcbiAgICAgICAgICAgICAgICBzdHlsZXMucm9vdERpc2FibGVkXHJcbiAgICAgICAgICAgIF0sXHJcbiAgICAgICAgICAgICFkaXNhYmxlZCAmJiAhY2hlY2tlZCAmJiBbe1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yczoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnOmhvdmVyJzogc3R5bGVzLnJvb3RIb3ZlcmVkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAnOmFjdGl2ZSc6IHN0eWxlcy5yb290UHJlc3NlZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgJy5tcy1GYWJyaWMuaXMtZm9jdXNWaXNpYmxlICY6Zm9jdXMsIC5tcy1GYWJyaWMuaXMtZm9jdXNWaXNpYmxlICY6Zm9jdXM6aG92ZXInOiBzdHlsZXMucm9vdEZvY3VzZWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICcubXMtRmFicmljLmlzLWZvY3VzVmlzaWJsZSAmOmhvdmVyJzogeyBiYWNrZ3JvdW5kOiAnaW5oZXJpdDsnIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XVxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgc3BsaXRNZW51OiBbXHJcbiAgICAgICAgICAgIHN0eWxlcy5yb290LFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICB3aWR0aDogMzJcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgZXhwYW5kZWQgJiYgW1xyXG4gICAgICAgICAgICAgICAgJ2lzLWV4cGFuZGVkJyxcclxuICAgICAgICAgICAgICAgIHN0eWxlcy5yb290RXhwYW5kZWRcclxuICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgZGlzYWJsZWQgJiYgW1xyXG4gICAgICAgICAgICAgICAgJ2lzLWRpc2FibGVkJyxcclxuICAgICAgICAgICAgICAgIHN0eWxlcy5yb290RGlzYWJsZWRcclxuICAgICAgICAgICAgXSxcclxuICAgICAgICAgICAgIWRpc2FibGVkICYmICFleHBhbmRlZCAmJiBbe1xyXG4gICAgICAgICAgICAgICAgICAgIHNlbGVjdG9yczoge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAnOmhvdmVyJzogc3R5bGVzLnJvb3RIb3ZlcmVkLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAnOmFjdGl2ZSc6IHN0eWxlcy5yb290UHJlc3NlZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgJy5tcy1GYWJyaWMuaXMtZm9jdXNWaXNpYmxlICY6Zm9jdXMsIC5tcy1GYWJyaWMuaXMtZm9jdXNWaXNpYmxlICY6Zm9jdXM6aG92ZXInOiBzdHlsZXMucm9vdEZvY3VzZWQsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICcubXMtRmFicmljLmlzLWZvY3VzVmlzaWJsZSAmOmhvdmVyJzogeyBiYWNrZ3JvdW5kOiAnaW5oZXJpdDsnIH1cclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XVxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgbGlua0NvbnRlbnQ6IFtcclxuICAgICAgICAgICAgJ21zLUNvbnRleHR1YWxNZW51LWxpbmtDb250ZW50JyxcclxuICAgICAgICAgICAgc3R5bGVzLmxpbmtDb250ZW50XHJcbiAgICAgICAgXSxcclxuICAgICAgICBsaW5rQ29udGVudE1lbnU6IFtcclxuICAgICAgICAgICAgJ21zLUNvbnRleHR1YWxNZW51LWxpbmtDb250ZW50JyxcclxuICAgICAgICAgICAgc3R5bGVzLmxpbmtDb250ZW50LFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBqdXN0aWZ5Q29udGVudDogJ2NlbnRlcicsXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICBdLFxyXG4gICAgICAgIGljb246IFtcclxuICAgICAgICAgICAgJ21zLUNvbnRleHR1YWxNZW51LWljb24nLFxyXG4gICAgICAgICAgICBrbm93bkljb24gJiYgJ21zLUNvbnRleHR1YWxNZW51LWljb25Db2xvciAnICYmIHN0eWxlcy5pY29uQ29sb3IsXHJcbiAgICAgICAgICAgIHN0eWxlcy5pY29uLFxyXG4gICAgICAgICAgICBpY29uQ2xhc3NOYW1lLFxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgY2hlY2ttYXJrSWNvbjogW1xyXG4gICAgICAgICAgICAnbXMtQ29udGV4dHVhbE1lbnUtY2hlY2ttYXJrSWNvbicsXHJcbiAgICAgICAgICAgIGtub3duSWNvbiAmJiAnbXMtQ29udGV4dHVhbE1lbnUtY2hlY2ttYXJrSWNvbiAnICYmIHN0eWxlcy5jaGVja21hcmtJY29uLFxyXG4gICAgICAgICAgICBzdHlsZXMuaWNvbixcclxuICAgICAgICAgICAgaWNvbkNsYXNzTmFtZSxcclxuICAgICAgICBdLFxyXG4gICAgICAgIHN1Yk1lbnVJY29uOiBbXHJcbiAgICAgICAgICAgICdtcy1Db250ZXh0dWFsTWVudS1zdWJtZW51SWNvbicsXHJcbiAgICAgICAgICAgIHN0eWxlcy5zdWJNZW51SWNvbixcclxuICAgICAgICAgICAgc3ViTWVudUNsYXNzTmFtZSxcclxuICAgICAgICBdLFxyXG4gICAgICAgIGxhYmVsOiBbXHJcbiAgICAgICAgICAgICdtcy1Db250ZXh0dWFsTWVudS1pdGVtVGV4dCcsXHJcbiAgICAgICAgICAgIHN0eWxlcy5sYWJlbFxyXG4gICAgICAgIF0sXHJcbiAgICAgICAgc3BsaXRDb250YWluZXI6IHN0eWxlcy5zcGxpdEJ1dHRvbkZsZXhDb250YWluZXIsXHJcbiAgICB9KTtcclxufSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNvbnRleHR1YWxNZW51LmNsYXNzTmFtZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XHJcbnZhciBSZWFjdCA9IHJlcXVpcmUoXCJyZWFjdFwiKTtcclxudmFyIENvbnRleHR1YWxNZW51X3R5cGVzXzEgPSByZXF1aXJlKFwiLi9Db250ZXh0dWFsTWVudS50eXBlc1wiKTtcclxudmFyIEZvY3VzWm9uZV8xID0gcmVxdWlyZShcIi4uLy4uL0ZvY3VzWm9uZVwiKTtcclxudmFyIENvbnRleHR1YWxNZW51X2NsYXNzTmFtZXNfMSA9IHJlcXVpcmUoXCIuL0NvbnRleHR1YWxNZW51LmNsYXNzTmFtZXNcIik7XHJcbnZhciBVdGlsaXRpZXNfMSA9IHJlcXVpcmUoXCIuLi8uLi9VdGlsaXRpZXNcIik7XHJcbnZhciB3aXRoUmVzcG9uc2l2ZU1vZGVfMSA9IHJlcXVpcmUoXCIuLi8uLi91dGlsaXRpZXMvZGVjb3JhdG9ycy93aXRoUmVzcG9uc2l2ZU1vZGVcIik7XHJcbnZhciBDYWxsb3V0XzEgPSByZXF1aXJlKFwiLi4vLi4vQ2FsbG91dFwiKTtcclxudmFyIEljb25fMSA9IHJlcXVpcmUoXCIuLi8uLi9JY29uXCIpO1xyXG52YXIgRGl2aWRlcl8xID0gcmVxdWlyZShcIi4uLy4uL0RpdmlkZXJcIik7XHJcbmZ1bmN0aW9uIGhhc1N1Ym1lbnVJdGVtcyhpdGVtKSB7XHJcbiAgICB2YXIgc3VibWVudUl0ZW1zID0gZ2V0U3VibWVudUl0ZW1zKGl0ZW0pO1xyXG4gICAgcmV0dXJuICEhKHN1Ym1lbnVJdGVtcyAmJiBzdWJtZW51SXRlbXMubGVuZ3RoKTtcclxufVxyXG5leHBvcnRzLmhhc1N1Ym1lbnVJdGVtcyA9IGhhc1N1Ym1lbnVJdGVtcztcclxuZnVuY3Rpb24gZ2V0U3VibWVudUl0ZW1zKGl0ZW0pIHtcclxuICAgIHJldHVybiBpdGVtLnN1Yk1lbnVQcm9wcyA/IGl0ZW0uc3ViTWVudVByb3BzLml0ZW1zIDogaXRlbS5pdGVtcztcclxufVxyXG5leHBvcnRzLmdldFN1Ym1lbnVJdGVtcyA9IGdldFN1Ym1lbnVJdGVtcztcclxuLyoqXHJcbiAqIERldGVybWluZXMgdGhlIGVmZmVjdGl2ZSBjaGVja2VkIHN0YXRlIG9mIGEgbWVudSBpdGVtLlxyXG4gKlxyXG4gKiBAcGFyYW0gaXRlbSB7SUNvbnRleHR1YWxNZW51SXRlbX0gdG8gZ2V0IHRoZSBjaGVjayBzdGF0ZSBvZi5cclxuICogQHJldHVybnMge3RydWV9IGlmIHRoZSBpdGVtIGlzIGNoZWNrZWQuXHJcbiAqIEByZXR1cm5zIHtmYWxzZX0gaWYgdGhlIGl0ZW0gaXMgdW5jaGVja2VkLlxyXG4gKiBAcmV0dXJucyB7bnVsbH0gaWYgdGhlIGl0ZW0gaXMgbm90IGNoZWNrYWJsZS5cclxuICovXHJcbmZ1bmN0aW9uIGdldElzQ2hlY2tlZChpdGVtKSB7XHJcbiAgICBpZiAoaXRlbS5jYW5DaGVjaykge1xyXG4gICAgICAgIHJldHVybiAhIShpdGVtLmlzQ2hlY2tlZCB8fCBpdGVtLmNoZWNrZWQpO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiBpdGVtLmlzQ2hlY2tlZCA9PT0gJ2Jvb2xlYW4nKSB7XHJcbiAgICAgICAgcmV0dXJuIGl0ZW0uaXNDaGVja2VkO1xyXG4gICAgfVxyXG4gICAgaWYgKHR5cGVvZiBpdGVtLmNoZWNrZWQgPT09ICdib29sZWFuJykge1xyXG4gICAgICAgIHJldHVybiBpdGVtLmNoZWNrZWQ7XHJcbiAgICB9XHJcbiAgICAvLyBJdGVtIGlzIG5vdCBjaGVja2FibGUuXHJcbiAgICByZXR1cm4gbnVsbDtcclxufVxyXG4vKipcclxuICogUmV0dXJucyB0cnVlIGlmIGEgbGlzdCBvZiBtZW51IGl0ZW1zIGNhbiBjb250YWluIGEgY2hlY2tib3hcclxuICovXHJcbmZ1bmN0aW9uIGNhbkFueU1lbnVJdGVtc0NoZWNrKGl0ZW1zKSB7XHJcbiAgICByZXR1cm4gaXRlbXMuc29tZShmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgIGlmIChpdGVtLmNhbkNoZWNrKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBJZiB0aGUgaXRlbSBpcyBhIHNlY3Rpb24sIGNoZWNrIGlmIGFueSBvZiB0aGUgaXRlbXMgaW4gdGhlIHNlY3Rpb24gY2FuIGNoZWNrLlxyXG4gICAgICAgIGlmIChpdGVtLnNlY3Rpb25Qcm9wcyAmJiBpdGVtLnNlY3Rpb25Qcm9wcy5pdGVtcy5zb21lKGZ1bmN0aW9uIChzdWJtZW51SXRlbSkgeyByZXR1cm4gc3VibWVudUl0ZW0uY2FuQ2hlY2sgPT09IHRydWU7IH0pKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9KTtcclxufVxyXG5leHBvcnRzLmNhbkFueU1lbnVJdGVtc0NoZWNrID0gY2FuQW55TWVudUl0ZW1zQ2hlY2s7XHJcbnZhciBDb250ZXh0dWFsTWVudSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIHRzbGliXzEuX19leHRlbmRzKENvbnRleHR1YWxNZW51LCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gQ29udGV4dHVhbE1lbnUocHJvcHMpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBwcm9wcykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5fc2Nyb2xsSWRsZURlbGF5ID0gMjUwIC8qIG1zICovO1xyXG4gICAgICAgIF90aGlzLnN0YXRlID0ge1xyXG4gICAgICAgICAgICBjb250ZXh0dWFsTWVudUl0ZW1zOiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgIHN1Yk1lbnVJZDogVXRpbGl0aWVzXzEuZ2V0SWQoJ0NvbnRleHR1YWxNZW51JylcclxuICAgICAgICB9O1xyXG4gICAgICAgIF90aGlzLl93YXJuRGVwcmVjYXRpb25zKHtcclxuICAgICAgICAgICAgJ3RhcmdldFBvaW50JzogJ3RhcmdldCcsXHJcbiAgICAgICAgICAgICd1c2VUYXJnZXRQb2ludCc6ICd0YXJnZXQnLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgIF90aGlzLl9pc0ZvY3VzaW5nUHJldmlvdXNFbGVtZW50ID0gZmFsc2U7XHJcbiAgICAgICAgX3RoaXMuX2lzU2Nyb2xsSWRsZSA9IHRydWU7XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgQ29udGV4dHVhbE1lbnVfMSA9IENvbnRleHR1YWxNZW51O1xyXG4gICAgQ29udGV4dHVhbE1lbnUucHJvdG90eXBlLmRpc21pc3MgPSBmdW5jdGlvbiAoZXYsIGRpc21pc3NBbGwpIHtcclxuICAgICAgICB2YXIgb25EaXNtaXNzID0gdGhpcy5wcm9wcy5vbkRpc21pc3M7XHJcbiAgICAgICAgaWYgKG9uRGlzbWlzcykge1xyXG4gICAgICAgICAgICBvbkRpc21pc3MoZXYsIGRpc21pc3NBbGwpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBDb250ZXh0dWFsTWVudS5wcm90b3R5cGUuY29tcG9uZW50V2lsbFVwZGF0ZSA9IGZ1bmN0aW9uIChuZXdQcm9wcykge1xyXG4gICAgICAgIGlmIChuZXdQcm9wcy50YXJnZXQgIT09IHRoaXMucHJvcHMudGFyZ2V0KSB7XHJcbiAgICAgICAgICAgIHZhciBuZXdUYXJnZXQgPSBuZXdQcm9wcy50YXJnZXQ7XHJcbiAgICAgICAgICAgIHRoaXMuX3NldFRhcmdldFdpbmRvd0FuZEVsZW1lbnQobmV3VGFyZ2V0KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLy8gSW52b2tlZCBvbmNlLCBib3RoIG9uIHRoZSBjbGllbnQgYW5kIHNlcnZlciwgaW1tZWRpYXRlbHkgYmVmb3JlIHRoZSBpbml0aWFsIHJlbmRlcmluZyBvY2N1cnMuXHJcbiAgICBDb250ZXh0dWFsTWVudS5wcm90b3R5cGUuY29tcG9uZW50V2lsbE1vdW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB0YXJnZXQgPSB0aGlzLnByb3BzLnRhcmdldDtcclxuICAgICAgICB0aGlzLl9zZXRUYXJnZXRXaW5kb3dBbmRFbGVtZW50KHRhcmdldCk7XHJcbiAgICAgICAgdGhpcy5fcHJldmlvdXNBY3RpdmVFbGVtZW50ID0gdGhpcy5fdGFyZ2V0V2luZG93ID8gdGhpcy5fdGFyZ2V0V2luZG93LmRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgOiBudWxsO1xyXG4gICAgfTtcclxuICAgIC8vIEludm9rZWQgb25jZSwgb25seSBvbiB0aGUgY2xpZW50IChub3Qgb24gdGhlIHNlcnZlciksIGltbWVkaWF0ZWx5IGFmdGVyIHRoZSBpbml0aWFsIHJlbmRlcmluZyBvY2N1cnMuXHJcbiAgICBDb250ZXh0dWFsTWVudS5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5fZXZlbnRzLm9uKHRoaXMuX3RhcmdldFdpbmRvdywgJ3Jlc2l6ZScsIHRoaXMuZGlzbWlzcyk7XHJcbiAgICAgICAgaWYgKHRoaXMucHJvcHMub25NZW51T3BlbmVkKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvcHMub25NZW51T3BlbmVkKHRoaXMucHJvcHMpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvLyBJbnZva2VkIGltbWVkaWF0ZWx5IGJlZm9yZSBhIGNvbXBvbmVudCBpcyB1bm1vdW50ZWQgZnJvbSB0aGUgRE9NLlxyXG4gICAgQ29udGV4dHVhbE1lbnUucHJvdG90eXBlLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgaWYgKHRoaXMuX2lzRm9jdXNpbmdQcmV2aW91c0VsZW1lbnQgJiYgdGhpcy5fcHJldmlvdXNBY3RpdmVFbGVtZW50KSB7XHJcbiAgICAgICAgICAgIC8vIFRoaXMgc2xpZ2h0IGRlbGF5IGlzIHJlcXVpcmVkIHNvIHRoYXQgd2UgY2FuIHVud2luZCB0aGUgc3RhY2ssIGxldCByZWFjdCB0cnkgdG8gbWVzcyB3aXRoIGZvY3VzLCBhbmQgdGhlblxyXG4gICAgICAgICAgICAvLyBhcHBseSB0aGUgY29ycmVjdCBmb2N1cy4gV2l0aG91dCB0aGUgc2V0VGltZW91dCwgd2UgZW5kIHVwIGZvY3VzaW5nIHRoZSBjb3JyZWN0IHRoaW5nLCBhbmQgdGhlbiBSZWFjdCB3YW50c1xyXG4gICAgICAgICAgICAvLyB0byByZXNldCB0aGUgZm9jdXMgYmFjayB0byB0aGUgdGhpbmcgaXQgdGhpbmtzIHNob3VsZCBoYXZlIGJlZW4gZm9jdXNlZC5cclxuICAgICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7IHJldHVybiBfdGhpcy5fcHJldmlvdXNBY3RpdmVFbGVtZW50LmZvY3VzKCk7IH0sIDApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5wcm9wcy5vbk1lbnVEaXNtaXNzZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5wcm9wcy5vbk1lbnVEaXNtaXNzZWQodGhpcy5wcm9wcyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuX2V2ZW50cy5kaXNwb3NlKCk7XHJcbiAgICAgICAgdGhpcy5fYXN5bmMuZGlzcG9zZSgpO1xyXG4gICAgfTtcclxuICAgIENvbnRleHR1YWxNZW51LnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgX2EgPSB0aGlzLnByb3BzLCBjbGFzc05hbWUgPSBfYS5jbGFzc05hbWUsIGl0ZW1zID0gX2EuaXRlbXMsIGlzQmVha1Zpc2libGUgPSBfYS5pc0JlYWtWaXNpYmxlLCBsYWJlbEVsZW1lbnRJZCA9IF9hLmxhYmVsRWxlbWVudElkLCBpZCA9IF9hLmlkLCB0YXJnZXRQb2ludCA9IF9hLnRhcmdldFBvaW50LCB1c2VUYXJnZXRQb2ludCA9IF9hLnVzZVRhcmdldFBvaW50LCBiZWFrV2lkdGggPSBfYS5iZWFrV2lkdGgsIGRpcmVjdGlvbmFsSGludCA9IF9hLmRpcmVjdGlvbmFsSGludCwgZGlyZWN0aW9uYWxIaW50Rm9yUlRMID0gX2EuZGlyZWN0aW9uYWxIaW50Rm9yUlRMLCBnYXBTcGFjZSA9IF9hLmdhcFNwYWNlLCBjb3ZlclRhcmdldCA9IF9hLmNvdmVyVGFyZ2V0LCBhcmlhTGFiZWwgPSBfYS5hcmlhTGFiZWwsIGRvTm90TGF5ZXIgPSBfYS5kb05vdExheWVyLCBhcnJvd0RpcmVjdGlvbiA9IF9hLmFycm93RGlyZWN0aW9uLCB0YXJnZXQgPSBfYS50YXJnZXQsIGJvdW5kcyA9IF9hLmJvdW5kcywgdXNlVGFyZ2V0V2lkdGggPSBfYS51c2VUYXJnZXRXaWR0aCwgdXNlVGFyZ2V0QXNNaW5XaWR0aCA9IF9hLnVzZVRhcmdldEFzTWluV2lkdGgsIGRpcmVjdGlvbmFsSGludEZpeGVkID0gX2EuZGlyZWN0aW9uYWxIaW50Rml4ZWQsIHNob3VsZEZvY3VzT25Nb3VudCA9IF9hLnNob3VsZEZvY3VzT25Nb3VudCwgdGl0bGUgPSBfYS50aXRsZSwgY3VzdG9tU3R5bGVzID0gX2Euc3R5bGVzLCB0aGVtZSA9IF9hLnRoZW1lLCBjYWxsb3V0UHJvcHMgPSBfYS5jYWxsb3V0UHJvcHMsIF9iID0gX2Eub25SZW5kZXJTdWJNZW51LCBvblJlbmRlclN1Yk1lbnUgPSBfYiA9PT0gdm9pZCAwID8gdGhpcy5fb25SZW5kZXJTdWJNZW51IDogX2I7XHJcbiAgICAgICAgdmFyIG1lbnVDbGFzc05hbWVzID0gdGhpcy5wcm9wcy5nZXRNZW51Q2xhc3NOYW1lcyB8fCBDb250ZXh0dWFsTWVudV9jbGFzc05hbWVzXzEuZ2V0Q29udGV4dHVhbE1lbnVDbGFzc05hbWVzO1xyXG4gICAgICAgIHRoaXMuX2NsYXNzTmFtZXMgPSBtZW51Q2xhc3NOYW1lcyh0aGVtZSwgY2xhc3NOYW1lKTtcclxuICAgICAgICB2YXIgaGFzSWNvbnMgPSBpdGVtc0hhdmVJY29ucyhpdGVtcyk7XHJcbiAgICAgICAgZnVuY3Rpb24gaXRlbXNIYXZlSWNvbnMoY29udGV4dHVhbE1lbnVJdGVtcykge1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIGNvbnRleHR1YWxNZW51SXRlbXNfMSA9IGNvbnRleHR1YWxNZW51SXRlbXM7IF9pIDwgY29udGV4dHVhbE1lbnVJdGVtc18xLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSBjb250ZXh0dWFsTWVudUl0ZW1zXzFbX2ldO1xyXG4gICAgICAgICAgICAgICAgaWYgKCEhaXRlbS5pY29uIHx8ICEhaXRlbS5pY29uUHJvcHMpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChpdGVtLml0ZW1UeXBlID09PSBDb250ZXh0dWFsTWVudV90eXBlc18xLkNvbnRleHR1YWxNZW51SXRlbVR5cGUuU2VjdGlvbiAmJiBpdGVtLnNlY3Rpb25Qcm9wcyAmJiBpdGVtc0hhdmVJY29ucyhpdGVtLnNlY3Rpb25Qcm9wcy5pdGVtcykpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBoYXNDaGVja21hcmtzID0gY2FuQW55TWVudUl0ZW1zQ2hlY2soaXRlbXMpO1xyXG4gICAgICAgIHZhciBzdWJtZW51UHJvcHMgPSB0aGlzLnN0YXRlLmV4cGFuZGVkTWVudUl0ZW1LZXkgPyB0aGlzLl9nZXRTdWJtZW51UHJvcHMoKSA6IG51bGw7XHJcbiAgICAgICAgaXNCZWFrVmlzaWJsZSA9IGlzQmVha1Zpc2libGUgPT09IHVuZGVmaW5lZCA/IHRoaXMucHJvcHMucmVzcG9uc2l2ZU1vZGUgPD0gd2l0aFJlc3BvbnNpdmVNb2RlXzEuUmVzcG9uc2l2ZU1vZGUubWVkaXVtIDogaXNCZWFrVmlzaWJsZTtcclxuICAgICAgICAvKipcclxuICAgICAgICAgKiBXaGVuIHVzZVRhcmdldFdpZHRoIGlzIHRydWUsIGdldCB0aGUgd2lkdGggb2YgdGhlIHRhcmdldCBlbGVtZW50IGFuZCBhcHBseSBpdCBmb3IgdGhlIGNvbnRleHQgbWVudSBjb250YWluZXJcclxuICAgICAgICAgKi9cclxuICAgICAgICB2YXIgY29udGV4dE1lbnVTdHlsZTtcclxuICAgICAgICB2YXIgdGFyZ2V0QXNIdG1sRWxlbWVudCA9IHRoaXMuX3RhcmdldDtcclxuICAgICAgICBpZiAoKHVzZVRhcmdldFdpZHRoIHx8IHVzZVRhcmdldEFzTWluV2lkdGgpICYmIHRhcmdldEFzSHRtbEVsZW1lbnQgJiYgdGFyZ2V0QXNIdG1sRWxlbWVudC5vZmZzZXRXaWR0aCkge1xyXG4gICAgICAgICAgICB2YXIgdGFyZ2V0V2lkdGggPSB0YXJnZXRBc0h0bWxFbGVtZW50Lm9mZnNldFdpZHRoO1xyXG4gICAgICAgICAgICBpZiAodXNlVGFyZ2V0V2lkdGgpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRleHRNZW51U3R5bGUgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHRhcmdldFdpZHRoXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHVzZVRhcmdldEFzTWluV2lkdGgpIHtcclxuICAgICAgICAgICAgICAgIGNvbnRleHRNZW51U3R5bGUgPSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWluV2lkdGg6IHRhcmdldFdpZHRoXHJcbiAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIFRoZSBtZW51IHNob3VsZCBvbmx5IHJldHVybiBpZiBpdGVtcyB3ZXJlIHByb3ZpZGVkLCBpZiBubyBpdGVtcyB3ZXJlIHByb3ZpZGVkIHRoZW4gaXQgc2hvdWxkIG5vdCBhcHBlYXIuXHJcbiAgICAgICAgaWYgKGl0ZW1zICYmIGl0ZW1zLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgICAgdmFyIGluZGV4Q29ycmVjdGlvbl8xID0gMDtcclxuICAgICAgICAgICAgdmFyIHRvdGFsSXRlbUNvdW50XzEgPSAwO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDAsIGl0ZW1zXzEgPSBpdGVtczsgX2kgPCBpdGVtc18xLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGl0ZW0gPSBpdGVtc18xW19pXTtcclxuICAgICAgICAgICAgICAgIGlmIChpdGVtLml0ZW1UeXBlICE9PSBDb250ZXh0dWFsTWVudV90eXBlc18xLkNvbnRleHR1YWxNZW51SXRlbVR5cGUuRGl2aWRlciAmJlxyXG4gICAgICAgICAgICAgICAgICAgIGl0ZW0uaXRlbVR5cGUgIT09IENvbnRleHR1YWxNZW51X3R5cGVzXzEuQ29udGV4dHVhbE1lbnVJdGVtVHlwZS5IZWFkZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICB0b3RhbEl0ZW1Db3VudF8xKys7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KENhbGxvdXRfMS5DYWxsb3V0LCB0c2xpYl8xLl9fYXNzaWduKHt9LCBjYWxsb3V0UHJvcHMsIHsgdGFyZ2V0OiB1c2VUYXJnZXRQb2ludCA/IHRhcmdldFBvaW50IDogdGFyZ2V0LCBpc0JlYWtWaXNpYmxlOiBpc0JlYWtWaXNpYmxlLCBiZWFrV2lkdGg6IGJlYWtXaWR0aCwgZGlyZWN0aW9uYWxIaW50OiBkaXJlY3Rpb25hbEhpbnQsIGRpcmVjdGlvbmFsSGludEZvclJUTDogZGlyZWN0aW9uYWxIaW50Rm9yUlRMLCBnYXBTcGFjZTogZ2FwU3BhY2UsIGNvdmVyVGFyZ2V0OiBjb3ZlclRhcmdldCwgZG9Ob3RMYXllcjogZG9Ob3RMYXllciwgY2xhc3NOYW1lOiAnbXMtQ29udGV4dHVhbE1lbnUtQ2FsbG91dCcsIHNldEluaXRpYWxGb2N1czogc2hvdWxkRm9jdXNPbk1vdW50LCBvbkRpc21pc3M6IHRoaXMucHJvcHMub25EaXNtaXNzLCBvblNjcm9sbDogdGhpcy5fb25TY3JvbGwsIGJvdW5kczogYm91bmRzLCBkaXJlY3Rpb25hbEhpbnRGaXhlZDogZGlyZWN0aW9uYWxIaW50Rml4ZWQgfSksXHJcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgcm9sZTogJ21lbnUnLCBzdHlsZTogY29udGV4dE1lbnVTdHlsZSwgcmVmOiBmdW5jdGlvbiAoaG9zdCkgeyByZXR1cm4gX3RoaXMuX2hvc3QgPSBob3N0OyB9LCBpZDogaWQsIGNsYXNzTmFtZTogdGhpcy5fY2xhc3NOYW1lcy5jb250YWluZXIsIHRhYkluZGV4OiAwLCBvbktleURvd246IHRoaXMuX29uTWVudUtleURvd24gfSxcclxuICAgICAgICAgICAgICAgICAgICB0aXRsZSAmJiBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiB0aGlzLl9jbGFzc05hbWVzLnRpdGxlLCByb2xlOiAnaGVhZGluZycsIFwiYXJpYS1sZXZlbFwiOiAxIH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiIFwiLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0aXRsZSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgXCIgXCIpLFxyXG4gICAgICAgICAgICAgICAgICAgIChpdGVtcyAmJiBpdGVtcy5sZW5ndGgpID8gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoRm9jdXNab25lXzEuRm9jdXNab25lLCB7IGNsYXNzTmFtZTogdGhpcy5fY2xhc3NOYW1lcy5yb290LCBkaXJlY3Rpb246IGFycm93RGlyZWN0aW9uLCBpc0NpcmN1bGFyTmF2aWdhdGlvbjogdHJ1ZSwgYWxsb3dUYWJLZXk6IHRydWUgfSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInVsXCIsIHsgXCJhcmlhLWxhYmVsXCI6IGFyaWFMYWJlbCwgXCJhcmlhLWxhYmVsbGVkYnlcIjogbGFiZWxFbGVtZW50SWQsIGNsYXNzTmFtZTogdGhpcy5fY2xhc3NOYW1lcy5saXN0LCBvbktleURvd246IHRoaXMuX29uS2V5RG93biB9LCBpdGVtcy5tYXAoZnVuY3Rpb24gKGl0ZW0sIGluZGV4KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXRlbS5pdGVtVHlwZSA9PT0gQ29udGV4dHVhbE1lbnVfdHlwZXNfMS5Db250ZXh0dWFsTWVudUl0ZW1UeXBlLkRpdmlkZXIgfHxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpdGVtLml0ZW1UeXBlID09PSBDb250ZXh0dWFsTWVudV90eXBlc18xLkNvbnRleHR1YWxNZW51SXRlbVR5cGUuSGVhZGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXhDb3JyZWN0aW9uXzErKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5fcmVuZGVyTWVudUl0ZW0oaXRlbSwgaW5kZXgsIGluZGV4IC0gaW5kZXhDb3JyZWN0aW9uXzEsIHRvdGFsSXRlbUNvdW50XzEsIGhhc0NoZWNrbWFya3MsIGhhc0ljb25zKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSkpKSkgOiAobnVsbCksXHJcbiAgICAgICAgICAgICAgICAgICAgc3VibWVudVByb3BzICYmIG9uUmVuZGVyU3ViTWVudShzdWJtZW51UHJvcHMsIHRoaXMuX29uUmVuZGVyU3ViTWVudSkpKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQ29udGV4dHVhbE1lbnUucHJvdG90eXBlLl9vblJlbmRlclN1Yk1lbnUgPSBmdW5jdGlvbiAoc3ViTWVudVByb3BzKSB7XHJcbiAgICAgICAgcmV0dXJuIFJlYWN0LmNyZWF0ZUVsZW1lbnQoQ29udGV4dHVhbE1lbnVfMSwgdHNsaWJfMS5fX2Fzc2lnbih7fSwgc3ViTWVudVByb3BzKSk7XHJcbiAgICB9O1xyXG4gICAgQ29udGV4dHVhbE1lbnUucHJvdG90eXBlLl9yZW5kZXJNZW51SXRlbSA9IGZ1bmN0aW9uIChpdGVtLCBpbmRleCwgZm9jdXNhYmxlRWxlbWVudEluZGV4LCB0b3RhbEl0ZW1Db3VudCwgaGFzQ2hlY2ttYXJrcywgaGFzSWNvbnMpIHtcclxuICAgICAgICB2YXIgcmVuZGVyZWRJdGVtcyA9IFtdO1xyXG4gICAgICAgIHZhciBpY29uUHJvcHMgPSB0aGlzLl9nZXRJY29uUHJvcHMoaXRlbSk7XHJcbiAgICAgICAgLy8gV2Ugb25seSBzZW5kIGEgZGl2aWRlckNsYXNzTmFtZSB3aGVuIHRoZSBpdGVtIHRvIGJlIHJlbmRlcmVkIGlzIGEgZGl2aWRlci4gRm9yIGFsbCBvdGhlciBjYXNlcywgdGhlIGRlZmF1bHQgZGl2aWRlciBzdHlsZSBpcyB1c2VkLlxyXG4gICAgICAgIHZhciBkaXZpZGVyQ2xhc3NOYW1lID0gaXRlbS5pdGVtVHlwZSA9PT0gQ29udGV4dHVhbE1lbnVfdHlwZXNfMS5Db250ZXh0dWFsTWVudUl0ZW1UeXBlLkRpdmlkZXIgPyBpdGVtLmNsYXNzTmFtZSA6IHVuZGVmaW5lZDtcclxuICAgICAgICB2YXIgc3ViTWVudUljb25DbGFzc05hbWUgPSBpdGVtLnN1Ym1lbnVJY29uUHJvcHMgPyBpdGVtLnN1Ym1lbnVJY29uUHJvcHMuY2xhc3NOYW1lIDogJyc7XHJcbiAgICAgICAgdmFyIGdldENsYXNzTmFtZXMgPSBpdGVtLmdldEl0ZW1DbGFzc05hbWVzIHx8IENvbnRleHR1YWxNZW51X2NsYXNzTmFtZXNfMS5nZXRJdGVtQ2xhc3NOYW1lcztcclxuICAgICAgICB2YXIgaXRlbUNsYXNzTmFtZXMgPSBnZXRDbGFzc05hbWVzKHRoaXMucHJvcHMudGhlbWUsIHRoaXMuX2lzSXRlbURpc2FibGVkKGl0ZW0pLCAodGhpcy5zdGF0ZS5leHBhbmRlZE1lbnVJdGVtS2V5ID09PSBpdGVtLmtleSksICEhZ2V0SXNDaGVja2VkKGl0ZW0pLCAhIWl0ZW0uaHJlZiwgKGljb25Qcm9wcy5pY29uTmFtZSAhPT0gJ05vbmUnKSwgaXRlbS5jbGFzc05hbWUsIGRpdmlkZXJDbGFzc05hbWUsIGljb25Qcm9wcy5jbGFzc05hbWUsIHN1Yk1lbnVJY29uQ2xhc3NOYW1lKTtcclxuICAgICAgICBpZiAoaXRlbS5uYW1lID09PSAnLScpIHtcclxuICAgICAgICAgICAgaXRlbS5pdGVtVHlwZSA9IENvbnRleHR1YWxNZW51X3R5cGVzXzEuQ29udGV4dHVhbE1lbnVJdGVtVHlwZS5EaXZpZGVyO1xyXG4gICAgICAgIH1cclxuICAgICAgICBzd2l0Y2ggKGl0ZW0uaXRlbVR5cGUpIHtcclxuICAgICAgICAgICAgY2FzZSBDb250ZXh0dWFsTWVudV90eXBlc18xLkNvbnRleHR1YWxNZW51SXRlbVR5cGUuRGl2aWRlcjpcclxuICAgICAgICAgICAgICAgIHJlbmRlcmVkSXRlbXMucHVzaCh0aGlzLl9yZW5kZXJTZXBhcmF0b3IoaW5kZXgsIGl0ZW1DbGFzc05hbWVzKSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBDb250ZXh0dWFsTWVudV90eXBlc18xLkNvbnRleHR1YWxNZW51SXRlbVR5cGUuSGVhZGVyOlxyXG4gICAgICAgICAgICAgICAgcmVuZGVyZWRJdGVtcy5wdXNoKHRoaXMuX3JlbmRlclNlcGFyYXRvcihpbmRleCwgaXRlbUNsYXNzTmFtZXMpKTtcclxuICAgICAgICAgICAgICAgIHZhciBoZWFkZXJJdGVtID0gdGhpcy5fcmVuZGVySGVhZGVyTWVudUl0ZW0oaXRlbSwgaXRlbUNsYXNzTmFtZXMsIGluZGV4LCBoYXNDaGVja21hcmtzLCBoYXNJY29ucyk7XHJcbiAgICAgICAgICAgICAgICByZW5kZXJlZEl0ZW1zLnB1c2godGhpcy5fcmVuZGVyTGlzdEl0ZW0oaGVhZGVySXRlbSwgaXRlbS5rZXkgfHwgaW5kZXgsIGl0ZW1DbGFzc05hbWVzLCBpdGVtLnRpdGxlKSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSBDb250ZXh0dWFsTWVudV90eXBlc18xLkNvbnRleHR1YWxNZW51SXRlbVR5cGUuU2VjdGlvbjpcclxuICAgICAgICAgICAgICAgIHJlbmRlcmVkSXRlbXMucHVzaCh0aGlzLl9yZW5kZXJTZWN0aW9uSXRlbShpdGVtLCBpdGVtQ2xhc3NOYW1lcywgaW5kZXgsIGhhc0NoZWNrbWFya3MsIGhhc0ljb25zKSk7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgIHZhciBtZW51SXRlbSA9IHRoaXMuX3JlbmRlck5vcm1hbEl0ZW0oaXRlbSwgaXRlbUNsYXNzTmFtZXMsIGluZGV4LCBmb2N1c2FibGVFbGVtZW50SW5kZXgsIHRvdGFsSXRlbUNvdW50LCBoYXNDaGVja21hcmtzLCBoYXNJY29ucyk7XHJcbiAgICAgICAgICAgICAgICByZW5kZXJlZEl0ZW1zLnB1c2godGhpcy5fcmVuZGVyTGlzdEl0ZW0obWVudUl0ZW0sIGl0ZW0ua2V5IHx8IGluZGV4LCBpdGVtQ2xhc3NOYW1lcywgaXRlbS50aXRsZSkpO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiByZW5kZXJlZEl0ZW1zO1xyXG4gICAgfTtcclxuICAgIENvbnRleHR1YWxNZW51LnByb3RvdHlwZS5fcmVuZGVyU2VjdGlvbkl0ZW0gPSBmdW5jdGlvbiAoaXRlbSwgbWVudUNsYXNzTmFtZXMsIGluZGV4LCBoYXNDaGVja21hcmtzLCBoYXNJY29ucykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdmFyIHNlY3Rpb24gPSBpdGVtLnNlY3Rpb25Qcm9wcztcclxuICAgICAgICBpZiAoIXNlY3Rpb24pIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICB2YXIgaGVhZGVySXRlbTtcclxuICAgICAgICBpZiAoc2VjdGlvbi50aXRsZSkge1xyXG4gICAgICAgICAgICB2YXIgaGVhZGVyQ29udGV4dHVhbE1lbnVJdGVtID0ge1xyXG4gICAgICAgICAgICAgICAga2V5OiBcInNlY3Rpb24tXCIgKyBzZWN0aW9uLnRpdGxlICsgXCItdGl0bGVcIixcclxuICAgICAgICAgICAgICAgIGl0ZW1UeXBlOiBDb250ZXh0dWFsTWVudV90eXBlc18xLkNvbnRleHR1YWxNZW51SXRlbVR5cGUuSGVhZGVyLFxyXG4gICAgICAgICAgICAgICAgbmFtZTogc2VjdGlvbi50aXRsZSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgaGVhZGVySXRlbSA9IHRoaXMuX3JlbmRlckhlYWRlck1lbnVJdGVtKGhlYWRlckNvbnRleHR1YWxNZW51SXRlbSwgbWVudUNsYXNzTmFtZXMsIGluZGV4LCBoYXNDaGVja21hcmtzLCBoYXNJY29ucyk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChzZWN0aW9uLml0ZW1zICYmIHNlY3Rpb24uaXRlbXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJsaVwiLCB7IHJvbGU6ICdwcmVzZW50YXRpb24nLCBrZXk6IHNlY3Rpb24ua2V5IH0sXHJcbiAgICAgICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgcm9sZTogJ2dyb3VwJyB9LFxyXG4gICAgICAgICAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJ1bFwiLCB7IGNsYXNzTmFtZTogdGhpcy5fY2xhc3NOYW1lcy5saXN0IH0sXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlY3Rpb24udG9wRGl2aWRlciAmJiB0aGlzLl9yZW5kZXJTZXBhcmF0b3IoaW5kZXgsIG1lbnVDbGFzc05hbWVzLCB0cnVlLCB0cnVlKSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVySXRlbSAmJiB0aGlzLl9yZW5kZXJMaXN0SXRlbShoZWFkZXJJdGVtLCBpdGVtLmtleSB8fCBpbmRleCwgbWVudUNsYXNzTmFtZXMsIGl0ZW0udGl0bGUpLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWN0aW9uLml0ZW1zLm1hcChmdW5jdGlvbiAoY29udGV4dHVhbE1lbnVJdGVtLCBpdGVtc0luZGV4KSB7IHJldHVybiAoX3RoaXMuX3JlbmRlck1lbnVJdGVtKGNvbnRleHR1YWxNZW51SXRlbSwgaXRlbXNJbmRleCwgaXRlbXNJbmRleCwgc2VjdGlvbi5pdGVtcy5sZW5ndGgsIGhhc0NoZWNrbWFya3MsIGhhc0ljb25zKSk7IH0pLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICBzZWN0aW9uLmJvdHRvbURpdmlkZXIgJiYgdGhpcy5fcmVuZGVyU2VwYXJhdG9yKGluZGV4LCBtZW51Q2xhc3NOYW1lcywgZmFsc2UsIHRydWUpKSkpKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQ29udGV4dHVhbE1lbnUucHJvdG90eXBlLl9yZW5kZXJMaXN0SXRlbSA9IGZ1bmN0aW9uIChjb250ZW50LCBrZXksIGNsYXNzTmFtZXMsIHRpdGxlKSB7XHJcbiAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwibGlcIiwgeyByb2xlOiAncHJlc2VudGF0aW9uJywgdGl0bGU6IHRpdGxlLCBrZXk6IGtleSwgY2xhc3NOYW1lOiBjbGFzc05hbWVzLml0ZW0gfSwgY29udGVudCkpO1xyXG4gICAgfTtcclxuICAgIENvbnRleHR1YWxNZW51LnByb3RvdHlwZS5fcmVuZGVyU2VwYXJhdG9yID0gZnVuY3Rpb24gKGluZGV4LCBjbGFzc05hbWVzLCB0b3AsIGZyb21TZWN0aW9uKSB7XHJcbiAgICAgICAgaWYgKGZyb21TZWN0aW9uIHx8IGluZGV4ID4gMCkge1xyXG4gICAgICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJsaVwiLCB7IHJvbGU6ICdzZXBhcmF0b3InLCBrZXk6ICdzZXBhcmF0b3ItJyArIGluZGV4ICsgKHRvcCA9PT0gdW5kZWZpbmVkID8gJycgOiAodG9wID8gJy10b3AnIDogJy1ib3R0b20nKSksIGNsYXNzTmFtZTogY2xhc3NOYW1lcy5kaXZpZGVyIH0pKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICB9O1xyXG4gICAgQ29udGV4dHVhbE1lbnUucHJvdG90eXBlLl9yZW5kZXJOb3JtYWxJdGVtID0gZnVuY3Rpb24gKGl0ZW0sIGNsYXNzTmFtZXMsIGluZGV4LCBmb2N1c2FibGVFbGVtZW50SW5kZXgsIHRvdGFsSXRlbUNvdW50LCBoYXNDaGVja21hcmtzLCBoYXNJY29ucykge1xyXG4gICAgICAgIGlmIChpdGVtLm9uUmVuZGVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBbaXRlbS5vblJlbmRlcihpdGVtLCB0aGlzLmRpc21pc3MpXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGl0ZW0uaHJlZikge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5fcmVuZGVyQW5jaG9yTWVudUl0ZW0oaXRlbSwgY2xhc3NOYW1lcywgaW5kZXgsIGZvY3VzYWJsZUVsZW1lbnRJbmRleCwgdG90YWxJdGVtQ291bnQsIGhhc0NoZWNrbWFya3MsIGhhc0ljb25zKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGl0ZW0uc3BsaXQgJiYgaGFzU3VibWVudUl0ZW1zKGl0ZW0pKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0aGlzLl9yZW5kZXJTcGxpdEJ1dHRvbihpdGVtLCBjbGFzc05hbWVzLCBpbmRleCwgZm9jdXNhYmxlRWxlbWVudEluZGV4LCB0b3RhbEl0ZW1Db3VudCwgaGFzQ2hlY2ttYXJrcywgaGFzSWNvbnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fcmVuZGVyQnV0dG9uSXRlbShpdGVtLCBjbGFzc05hbWVzLCBpbmRleCwgZm9jdXNhYmxlRWxlbWVudEluZGV4LCB0b3RhbEl0ZW1Db3VudCwgaGFzQ2hlY2ttYXJrcywgaGFzSWNvbnMpO1xyXG4gICAgfTtcclxuICAgIENvbnRleHR1YWxNZW51LnByb3RvdHlwZS5fcmVuZGVySGVhZGVyTWVudUl0ZW0gPSBmdW5jdGlvbiAoaXRlbSwgY2xhc3NOYW1lcywgaW5kZXgsIGhhc0NoZWNrbWFya3MsIGhhc0ljb25zKSB7XHJcbiAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiB0aGlzLl9jbGFzc05hbWVzLmhlYWRlciwgc3R5bGU6IGl0ZW0uc3R5bGUsIHJvbGU6ICdoZWFkaW5nJywgXCJhcmlhLWxldmVsXCI6IHRoaXMucHJvcHMudGl0bGUgPyAyIDogMSB9LCB0aGlzLl9yZW5kZXJNZW51SXRlbUNoaWxkcmVuKGl0ZW0sIGNsYXNzTmFtZXMsIGluZGV4LCBoYXNDaGVja21hcmtzLCBoYXNJY29ucykpKTtcclxuICAgIH07XHJcbiAgICBDb250ZXh0dWFsTWVudS5wcm90b3R5cGUuX3JlbmRlckFuY2hvck1lbnVJdGVtID0gZnVuY3Rpb24gKGl0ZW0sIGNsYXNzTmFtZXMsIGluZGV4LCBmb2N1c2FibGVFbGVtZW50SW5kZXgsIHRvdGFsSXRlbUNvdW50LCBoYXNDaGVja21hcmtzLCBoYXNJY29ucykge1xyXG4gICAgICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCBudWxsLFxyXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KFwiYVwiLCB0c2xpYl8xLl9fYXNzaWduKHt9LCBVdGlsaXRpZXNfMS5nZXROYXRpdmVQcm9wcyhpdGVtLCBVdGlsaXRpZXNfMS5hbmNob3JQcm9wZXJ0aWVzKSwgeyBocmVmOiBpdGVtLmhyZWYsIHRhcmdldDogaXRlbS50YXJnZXQsIGNsYXNzTmFtZTogY2xhc3NOYW1lcy5yb290LCByb2xlOiAnbWVudWl0ZW0nLCBcImFyaWEtcG9zaW5zZXRcIjogZm9jdXNhYmxlRWxlbWVudEluZGV4ICsgMSwgXCJhcmlhLXNldHNpemVcIjogdG90YWxJdGVtQ291bnQsIFwiYXJpYS1kaXNhYmxlZFwiOiB0aGlzLl9pc0l0ZW1EaXNhYmxlZChpdGVtKSwgc3R5bGU6IGl0ZW0uc3R5bGUsIG9uQ2xpY2s6IHRoaXMuX29uQW5jaG9yQ2xpY2suYmluZCh0aGlzLCBpdGVtKSB9KSwgdGhpcy5fcmVuZGVyTWVudUl0ZW1DaGlsZHJlbihpdGVtLCBjbGFzc05hbWVzLCBpbmRleCwgaGFzQ2hlY2ttYXJrcywgaGFzSWNvbnMpKSkpO1xyXG4gICAgfTtcclxuICAgIENvbnRleHR1YWxNZW51LnByb3RvdHlwZS5fcmVuZGVyQnV0dG9uSXRlbSA9IGZ1bmN0aW9uIChpdGVtLCBjbGFzc05hbWVzLCBpbmRleCwgZm9jdXNhYmxlRWxlbWVudEluZGV4LCB0b3RhbEl0ZW1Db3VudCwgaGFzQ2hlY2ttYXJrcywgaGFzSWNvbnMpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBfYSA9IHRoaXMuc3RhdGUsIGV4cGFuZGVkTWVudUl0ZW1LZXkgPSBfYS5leHBhbmRlZE1lbnVJdGVtS2V5LCBzdWJNZW51SWQgPSBfYS5zdWJNZW51SWQ7XHJcbiAgICAgICAgdmFyIGFyaWFMYWJlbCA9ICcnO1xyXG4gICAgICAgIGlmIChpdGVtLmFyaWFMYWJlbCkge1xyXG4gICAgICAgICAgICBhcmlhTGFiZWwgPSBpdGVtLmFyaWFMYWJlbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAoaXRlbS5uYW1lKSB7XHJcbiAgICAgICAgICAgIGFyaWFMYWJlbCA9IGl0ZW0ubmFtZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGlzQ2hlY2tlZCA9IGdldElzQ2hlY2tlZChpdGVtKTtcclxuICAgICAgICB2YXIgY2FuQ2hlY2sgPSBpc0NoZWNrZWQgIT09IG51bGw7XHJcbiAgICAgICAgdmFyIGRlZmF1bHRSb2xlID0gY2FuQ2hlY2sgPyAnbWVudWl0ZW1jaGVja2JveCcgOiAnbWVudWl0ZW0nO1xyXG4gICAgICAgIHZhciBpdGVtQnV0dG9uUHJvcGVydGllcyA9IHtcclxuICAgICAgICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWVzLnJvb3QsXHJcbiAgICAgICAgICAgIG9uQ2xpY2s6IHRoaXMuX29uSXRlbUNsaWNrLmJpbmQodGhpcywgaXRlbSksXHJcbiAgICAgICAgICAgIG9uS2V5RG93bjogaGFzU3VibWVudUl0ZW1zKGl0ZW0pID8gdGhpcy5fb25JdGVtS2V5RG93bi5iaW5kKHRoaXMsIGl0ZW0pIDogbnVsbCxcclxuICAgICAgICAgICAgb25Nb3VzZUVudGVyOiB0aGlzLl9vbkl0ZW1Nb3VzZUVudGVyLmJpbmQodGhpcywgaXRlbSksXHJcbiAgICAgICAgICAgIG9uTW91c2VMZWF2ZTogdGhpcy5fb25Nb3VzZUl0ZW1MZWF2ZS5iaW5kKHRoaXMsIGl0ZW0pLFxyXG4gICAgICAgICAgICBvbk1vdXNlRG93bjogZnVuY3Rpb24gKGV2KSB7IHJldHVybiBfdGhpcy5fb25JdGVtTW91c2VEb3duKGl0ZW0sIGV2KTsgfSxcclxuICAgICAgICAgICAgb25Nb3VzZU1vdmU6IHRoaXMuX29uSXRlbU1vdXNlTW92ZS5iaW5kKHRoaXMsIGl0ZW0pLFxyXG4gICAgICAgICAgICBkaXNhYmxlZDogdGhpcy5faXNJdGVtRGlzYWJsZWQoaXRlbSksXHJcbiAgICAgICAgICAgIGhyZWY6IGl0ZW0uaHJlZixcclxuICAgICAgICAgICAgdGl0bGU6IGl0ZW0udGl0bGUsXHJcbiAgICAgICAgICAgICdhcmlhLWxhYmVsJzogYXJpYUxhYmVsLFxyXG4gICAgICAgICAgICAnYXJpYS1oYXNwb3B1cCc6IGhhc1N1Ym1lbnVJdGVtcyhpdGVtKSB8fCBudWxsLFxyXG4gICAgICAgICAgICAnYXJpYS1vd25zJzogaXRlbS5rZXkgPT09IGV4cGFuZGVkTWVudUl0ZW1LZXkgPyBzdWJNZW51SWQgOiBudWxsLFxyXG4gICAgICAgICAgICAnYXJpYS1leHBhbmRlZCc6IGhhc1N1Ym1lbnVJdGVtcyhpdGVtKSA/IGl0ZW0ua2V5ID09PSBleHBhbmRlZE1lbnVJdGVtS2V5IDogbnVsbCxcclxuICAgICAgICAgICAgJ2FyaWEtY2hlY2tlZCc6IGlzQ2hlY2tlZCxcclxuICAgICAgICAgICAgJ2FyaWEtcG9zaW5zZXQnOiBmb2N1c2FibGVFbGVtZW50SW5kZXggKyAxLFxyXG4gICAgICAgICAgICAnYXJpYS1zZXRzaXplJzogdG90YWxJdGVtQ291bnQsXHJcbiAgICAgICAgICAgICdhcmlhLWRpc2FibGVkJzogdGhpcy5faXNJdGVtRGlzYWJsZWQoaXRlbSksXHJcbiAgICAgICAgICAgIHJvbGU6IGl0ZW0ucm9sZSB8fCBkZWZhdWx0Um9sZSxcclxuICAgICAgICAgICAgc3R5bGU6IGl0ZW0uc3R5bGVcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiLCB0c2xpYl8xLl9fYXNzaWduKHt9LCBVdGlsaXRpZXNfMS5nZXROYXRpdmVQcm9wcyhpdGVtLCBVdGlsaXRpZXNfMS5idXR0b25Qcm9wZXJ0aWVzKSwgaXRlbUJ1dHRvblByb3BlcnRpZXMsIHsgY2hpbGRyZW46IHRoaXMuX3JlbmRlck1lbnVJdGVtQ2hpbGRyZW4oaXRlbSwgY2xhc3NOYW1lcywgaW5kZXgsIGhhc0NoZWNrbWFya3MsIGhhc0ljb25zKSB9KSkpO1xyXG4gICAgfTtcclxuICAgIENvbnRleHR1YWxNZW51LnByb3RvdHlwZS5fcmVuZGVyU3BsaXRCdXR0b24gPSBmdW5jdGlvbiAoaXRlbSwgY2xhc3NOYW1lcywgaW5kZXgsIGZvY3VzYWJsZUVsZW1lbnRJbmRleCwgdG90YWxJdGVtQ291bnQsIGhhc0NoZWNrbWFya3MsIGhhc0ljb25zKSB7XHJcbiAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgXCJhcmlhLWxhYmVsbGVkYnlcIjogaXRlbS5hcmlhTGFiZWwsIFwiYXJpYS1kaXNhYmxlZFwiOiB0aGlzLl9pc0l0ZW1EaXNhYmxlZChpdGVtKSwgXCJhcmlhLWhhc3BvcHVwXCI6IHRydWUsIFwiYXJpYS1kZXNjcmliZWRieVwiOiBpdGVtLmFyaWFEZXNjcmlwdGlvbiwgXCJhcmlhLWNoZWNrZWRcIjogaXRlbS5pc0NoZWNrZWQgfHwgaXRlbS5jaGVja2VkIH0sXHJcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHsgXCJhcmlhLWhpZGRlblwiOiB0cnVlLCBjbGFzc05hbWU6IGNsYXNzTmFtZXMuc3BsaXRDb250YWluZXIgfSxcclxuICAgICAgICAgICAgICAgIHRoaXMuX3JlbmRlclNwbGl0UHJpbWFyeUJ1dHRvbihpdGVtLCBjbGFzc05hbWVzLCBpbmRleCwgaGFzQ2hlY2ttYXJrcywgaGFzSWNvbnMpLFxyXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyU3BsaXREaXZpZGVyKGl0ZW0pLFxyXG4gICAgICAgICAgICAgICAgdGhpcy5fcmVuZGVyU3BsaXRJY29uQnV0dG9uKGl0ZW0sIGNsYXNzTmFtZXMsIGluZGV4KSkpKTtcclxuICAgIH07XHJcbiAgICBDb250ZXh0dWFsTWVudS5wcm90b3R5cGUuX3JlbmRlclNwbGl0UHJpbWFyeUJ1dHRvbiA9IGZ1bmN0aW9uIChpdGVtLCBjbGFzc05hbWVzLCBpbmRleCwgaGFzQ2hlY2ttYXJrcywgaGFzSWNvbnMpIHtcclxuICAgICAgICB2YXIgaXNDaGVja2VkID0gZ2V0SXNDaGVja2VkKGl0ZW0pO1xyXG4gICAgICAgIHZhciBjYW5DaGVjayA9IGlzQ2hlY2tlZCAhPT0gbnVsbDtcclxuICAgICAgICB2YXIgZGVmYXVsdFJvbGUgPSBjYW5DaGVjayA/ICdtZW51aXRlbWNoZWNrYm94JyA6ICdtZW51aXRlbSc7XHJcbiAgICAgICAgdmFyIGl0ZW1Qcm9wcyA9IHtcclxuICAgICAgICAgICAga2V5OiBpdGVtLmtleSxcclxuICAgICAgICAgICAgb25DbGljazogdGhpcy5fZXhlY3V0ZUl0ZW1DbGljay5iaW5kKHRoaXMsIGl0ZW0pLFxyXG4gICAgICAgICAgICBkaXNhYmxlZDogdGhpcy5faXNJdGVtRGlzYWJsZWQoaXRlbSkgfHwgaXRlbS5wcmltYXJ5RGlzYWJsZWQsXHJcbiAgICAgICAgICAgIG5hbWU6IGl0ZW0ubmFtZSxcclxuICAgICAgICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWVzLnNwbGl0UHJpbWFyeSxcclxuICAgICAgICAgICAgcm9sZTogaXRlbS5yb2xlIHx8IGRlZmF1bHRSb2xlLFxyXG4gICAgICAgICAgICBjYW5DaGVjazogaXRlbS5jYW5DaGVjayxcclxuICAgICAgICAgICAgaXNDaGVja2VkOiBpdGVtLmlzQ2hlY2tlZCxcclxuICAgICAgICAgICAgY2hlY2tlZDogaXRlbS5jaGVja2VkLFxyXG4gICAgICAgICAgICBpY29uOiBpdGVtLmljb24sXHJcbiAgICAgICAgICAgIGljb25Qcm9wczogaXRlbS5pY29uUHJvcHNcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KCdidXR0b24nLCBVdGlsaXRpZXNfMS5nZXROYXRpdmVQcm9wcyhpdGVtUHJvcHMsIFV0aWxpdGllc18xLmJ1dHRvblByb3BlcnRpZXMpLCB0aGlzLl9yZW5kZXJNZW51SXRlbUNoaWxkcmVuKGl0ZW1Qcm9wcywgY2xhc3NOYW1lcywgaW5kZXgsIGhhc0NoZWNrbWFya3MsIGhhc0ljb25zKSk7XHJcbiAgICB9O1xyXG4gICAgQ29udGV4dHVhbE1lbnUucHJvdG90eXBlLl9yZW5kZXJTcGxpdEljb25CdXR0b24gPSBmdW5jdGlvbiAoaXRlbSwgY2xhc3NOYW1lcywgaW5kZXgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBpdGVtUHJvcHMgPSB7XHJcbiAgICAgICAgICAgIG9uQ2xpY2s6IHRoaXMuX29uSXRlbUNsaWNrLmJpbmQodGhpcywgaXRlbSksXHJcbiAgICAgICAgICAgIGRpc2FibGVkOiB0aGlzLl9pc0l0ZW1EaXNhYmxlZChpdGVtKSxcclxuICAgICAgICAgICAgY2xhc3NOYW1lOiBjbGFzc05hbWVzLnNwbGl0TWVudSxcclxuICAgICAgICAgICAgc3ViTWVudVByb3BzOiBpdGVtLnN1Yk1lbnVQcm9wcyxcclxuICAgICAgICAgICAgc3VibWVudUljb25Qcm9wczogaXRlbS5zdWJtZW51SWNvblByb3BzLFxyXG4gICAgICAgICAgICBzcGxpdDogdHJ1ZSxcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KCdidXR0b24nLCBVdGlsaXRpZXNfMS5hc3NpZ24oe30sIFV0aWxpdGllc18xLmdldE5hdGl2ZVByb3BzKGl0ZW1Qcm9wcywgVXRpbGl0aWVzXzEuYnV0dG9uUHJvcGVydGllcyksIHtcclxuICAgICAgICAgICAgb25LZXlEb3duOiB0aGlzLl9vbkl0ZW1LZXlEb3duLmJpbmQodGhpcywgaXRlbSksXHJcbiAgICAgICAgICAgIG9uTW91c2VFbnRlcjogdGhpcy5fb25JdGVtTW91c2VFbnRlci5iaW5kKHRoaXMsIGl0ZW0pLFxyXG4gICAgICAgICAgICBvbk1vdXNlTGVhdmU6IHRoaXMuX29uTW91c2VJdGVtTGVhdmUuYmluZCh0aGlzLCBpdGVtKSxcclxuICAgICAgICAgICAgb25Nb3VzZURvd246IGZ1bmN0aW9uIChldikgeyByZXR1cm4gX3RoaXMuX29uSXRlbU1vdXNlRG93bihpdGVtLCBldik7IH0sXHJcbiAgICAgICAgICAgIG9uTW91c2VNb3ZlOiB0aGlzLl9vbkl0ZW1Nb3VzZU1vdmUuYmluZCh0aGlzLCBpdGVtKVxyXG4gICAgICAgIH0pLCB0aGlzLl9yZW5kZXJNZW51SXRlbUNoaWxkcmVuKGl0ZW1Qcm9wcywgY2xhc3NOYW1lcywgaW5kZXgsIGZhbHNlLCBmYWxzZSkpO1xyXG4gICAgfTtcclxuICAgIENvbnRleHR1YWxNZW51LnByb3RvdHlwZS5fcmVuZGVyU3BsaXREaXZpZGVyID0gZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgICB2YXIgZ2V0RGl2aWRlckNsYXNzbmFtZXMgPSBpdGVtLmdldFNwbGl0QnV0dG9uVmVydGljYWxEaXZpZGVyQ2xhc3NOYW1lcyB8fCBDb250ZXh0dWFsTWVudV9jbGFzc05hbWVzXzEuZ2V0U3BsaXRCdXR0b25WZXJ0aWNhbERpdmlkZXJDbGFzc05hbWVzO1xyXG4gICAgICAgIHJldHVybiBSZWFjdC5jcmVhdGVFbGVtZW50KERpdmlkZXJfMS5WZXJ0aWNhbERpdmlkZXIsIHsgZ2V0Q2xhc3NOYW1lczogZ2V0RGl2aWRlckNsYXNzbmFtZXMgfSk7XHJcbiAgICB9O1xyXG4gICAgQ29udGV4dHVhbE1lbnUucHJvdG90eXBlLl9yZW5kZXJNZW51SXRlbUNoaWxkcmVuID0gZnVuY3Rpb24gKGl0ZW0sIGNsYXNzTmFtZXMsIGluZGV4LCBoYXNDaGVja21hcmtzLCBoYXNJY29ucykge1xyXG4gICAgICAgIHZhciBpc0l0ZW1DaGVja2VkID0gZ2V0SXNDaGVja2VkKGl0ZW0pO1xyXG4gICAgICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogaXRlbS5zcGxpdCA/IGNsYXNzTmFtZXMubGlua0NvbnRlbnRNZW51IDogY2xhc3NOYW1lcy5saW5rQ29udGVudCB9LFxyXG4gICAgICAgICAgICAoaGFzQ2hlY2ttYXJrcykgPyAoUmVhY3QuY3JlYXRlRWxlbWVudChJY29uXzEuSWNvbiwgeyBpY29uTmFtZTogaXNJdGVtQ2hlY2tlZCA9PT0gdHJ1ZSA/ICdDaGVja01hcmsnIDogJycsIGNsYXNzTmFtZTogY2xhc3NOYW1lcy5jaGVja21hcmtJY29uLCBvbkNsaWNrOiB0aGlzLl9vbkl0ZW1DbGljay5iaW5kKHRoaXMsIGl0ZW0pIH0pKSA6IChudWxsKSxcclxuICAgICAgICAgICAgKGhhc0ljb25zKSA/ICh0aGlzLl9yZW5kZXJJY29uKGl0ZW0sIGNsYXNzTmFtZXMpKSA6IChudWxsKSxcclxuICAgICAgICAgICAgaXRlbS5uYW1lID8gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIsIHsgY2xhc3NOYW1lOiBjbGFzc05hbWVzLmxhYmVsIH0sIGl0ZW0ubmFtZSkpIDogbnVsbCxcclxuICAgICAgICAgICAgaGFzU3VibWVudUl0ZW1zKGl0ZW0pID8gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoSWNvbl8xLkljb24sIHRzbGliXzEuX19hc3NpZ24oeyBpY29uTmFtZTogVXRpbGl0aWVzXzEuZ2V0UlRMKCkgPyAnQ2hldnJvbkxlZnQnIDogJ0NoZXZyb25SaWdodCcgfSwgaXRlbS5zdWJtZW51SWNvblByb3BzLCB7IGNsYXNzTmFtZTogY2xhc3NOYW1lcy5zdWJNZW51SWNvbiB9KSkpIDogKG51bGwpKSk7XHJcbiAgICB9O1xyXG4gICAgQ29udGV4dHVhbE1lbnUucHJvdG90eXBlLl9nZXRJY29uUHJvcHMgPSBmdW5jdGlvbiAoaXRlbSkge1xyXG4gICAgICAgIHZhciBpY29uUHJvcHMgPSBpdGVtLmljb25Qcm9wcyA/IGl0ZW0uaWNvblByb3BzIDoge1xyXG4gICAgICAgICAgICBpY29uTmFtZTogaXRlbS5pY29uXHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gaWNvblByb3BzO1xyXG4gICAgfTtcclxuICAgIENvbnRleHR1YWxNZW51LnByb3RvdHlwZS5fcmVuZGVySWNvbiA9IGZ1bmN0aW9uIChpdGVtLCBjbGFzc05hbWVzKSB7XHJcbiAgICAgICAgLy8gT25seSBwcmVzZW50IHRvIGFsbG93IGNvbnRpbnVlZCB1c2Ugb2YgaXRlbS5pY29uIHdoaWNoIGlzIGRlcHJlY2F0ZWQuXHJcbiAgICAgICAgdmFyIGljb25Qcm9wcyA9IHRoaXMuX2dldEljb25Qcm9wcyhpdGVtKTtcclxuICAgICAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChJY29uXzEuSWNvbiwgdHNsaWJfMS5fX2Fzc2lnbih7fSwgaWNvblByb3BzLCB7IGNsYXNzTmFtZTogY2xhc3NOYW1lcy5pY29uIH0pKTtcclxuICAgIH07XHJcbiAgICBDb250ZXh0dWFsTWVudS5wcm90b3R5cGUuX29uS2V5RG93biA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgIHZhciBzdWJtZW51Q2xvc2VLZXkgPSBVdGlsaXRpZXNfMS5nZXRSVEwoKSA/IDM5IC8qIHJpZ2h0ICovIDogMzcgLyogbGVmdCAqLztcclxuICAgICAgICBpZiAoZXYud2hpY2ggPT09IDI3IC8qIGVzY2FwZSAqL1xyXG4gICAgICAgICAgICB8fCAoZXYud2hpY2ggPT09IHN1Ym1lbnVDbG9zZUtleSAmJiB0aGlzLnByb3BzLmlzU3ViTWVudSAmJiB0aGlzLnByb3BzLmFycm93RGlyZWN0aW9uID09PSBGb2N1c1pvbmVfMS5Gb2N1c1pvbmVEaXJlY3Rpb24udmVydGljYWwpKSB7XHJcbiAgICAgICAgICAgIC8vIFdoZW4gYSB1c2VyIHByZXNzZXMgZXNjYXBlLCB3ZSB3aWxsIHRyeSB0byByZWZvY3VzIHRoZSBwcmV2aW91cyBmb2N1c2VkIGVsZW1lbnQuXHJcbiAgICAgICAgICAgIHRoaXMuX2lzRm9jdXNpbmdQcmV2aW91c0VsZW1lbnQgPSB0cnVlO1xyXG4gICAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICAgICAgdGhpcy5kaXNtaXNzKGV2KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQ29udGV4dHVhbE1lbnUucHJvdG90eXBlLl9vbk1lbnVLZXlEb3duID0gZnVuY3Rpb24gKGV2KSB7XHJcbiAgICAgICAgaWYgKGV2LndoaWNoID09PSAyNyAvKiBlc2NhcGUgKi8pIHtcclxuICAgICAgICAgICAgdGhpcy5faXNGb2N1c2luZ1ByZXZpb3VzRWxlbWVudCA9IHRydWU7XHJcbiAgICAgICAgICAgIGV2LnByZXZlbnREZWZhdWx0KCk7XHJcbiAgICAgICAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgICAgICAgICB0aGlzLmRpc21pc3MoZXYpO1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICghdGhpcy5faG9zdCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBlbGVtZW50VG9Gb2N1cyA9IGV2LndoaWNoID09PSAzOCAvKiB1cCAqLyA/XHJcbiAgICAgICAgICAgIFV0aWxpdGllc18xLmdldExhc3RGb2N1c2FibGUodGhpcy5faG9zdCwgdGhpcy5faG9zdC5sYXN0Q2hpbGQsIHRydWUpIDpcclxuICAgICAgICAgICAgZXYud2hpY2ggPT09IDQwIC8qIGRvd24gKi8gP1xyXG4gICAgICAgICAgICAgICAgVXRpbGl0aWVzXzEuZ2V0Rmlyc3RGb2N1c2FibGUodGhpcy5faG9zdCwgdGhpcy5faG9zdC5maXJzdENoaWxkLCB0cnVlKSA6XHJcbiAgICAgICAgICAgICAgICBudWxsO1xyXG4gICAgICAgIGlmIChlbGVtZW50VG9Gb2N1cykge1xyXG4gICAgICAgICAgICBlbGVtZW50VG9Gb2N1cy5mb2N1cygpO1xyXG4gICAgICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBTY3JvbGwgaGFuZGxlciBmb3IgdGhlIGNhbGxvdXQgdG8gbWFrZSBzdXJlIHRoZSBtb3VzZSBldmVudHNcclxuICAgICAqIGZvciB1cGRhdGluZyBmb2N1cyBhcmUgbm90IGludGVyYWN0aW5nIGR1cmluZyBzY3JvbGxcclxuICAgICAqL1xyXG4gICAgQ29udGV4dHVhbE1lbnUucHJvdG90eXBlLl9vblNjcm9sbCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGlmICghdGhpcy5faXNTY3JvbGxJZGxlICYmIHRoaXMuX3Njcm9sbElkbGVUaW1lb3V0SWQgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLl9hc3luYy5jbGVhclRpbWVvdXQodGhpcy5fc2Nyb2xsSWRsZVRpbWVvdXRJZCk7XHJcbiAgICAgICAgICAgIHRoaXMuX3Njcm9sbElkbGVUaW1lb3V0SWQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLl9pc1Njcm9sbElkbGUgPSBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fc2Nyb2xsSWRsZVRpbWVvdXRJZCA9IHRoaXMuX2FzeW5jLnNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyBfdGhpcy5faXNTY3JvbGxJZGxlID0gdHJ1ZTsgfSwgdGhpcy5fc2Nyb2xsSWRsZURlbGF5KTtcclxuICAgIH07XHJcbiAgICBDb250ZXh0dWFsTWVudS5wcm90b3R5cGUuX29uSXRlbU1vdXNlRW50ZXIgPSBmdW5jdGlvbiAoaXRlbSwgZXYpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGlmICghdGhpcy5faXNTY3JvbGxJZGxlKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHRhcmdldEVsZW1lbnQgPSBldi5jdXJyZW50VGFyZ2V0O1xyXG4gICAgICAgIGlmIChpdGVtLmtleSAhPT0gdGhpcy5zdGF0ZS5leHBhbmRlZE1lbnVJdGVtS2V5KSB7XHJcbiAgICAgICAgICAgIGlmIChoYXNTdWJtZW51SXRlbXMoaXRlbSkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2VudGVyVGltZXJJZCA9IHRoaXMuX2FzeW5jLnNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX29uSXRlbVN1Yk1lbnVFeHBhbmQoaXRlbSwgdGFyZ2V0RWxlbWVudCk7IH0sIDUwMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9lbnRlclRpbWVySWQgPSB0aGlzLl9hc3luYy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9vblN1Yk1lbnVEaXNtaXNzKGV2KTsgfSwgNTAwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0YXJnZXRFbGVtZW50LmZvY3VzKCk7XHJcbiAgICB9O1xyXG4gICAgQ29udGV4dHVhbE1lbnUucHJvdG90eXBlLl9vbkl0ZW1Nb3VzZU1vdmUgPSBmdW5jdGlvbiAoaXRlbSwgZXYpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciB0YXJnZXRFbGVtZW50ID0gZXYuY3VycmVudFRhcmdldDtcclxuICAgICAgICBpZiAoIXRoaXMuX2lzU2Nyb2xsSWRsZSB8fCB0YXJnZXRFbGVtZW50ID09PSB0aGlzLl90YXJnZXRXaW5kb3cuZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChpdGVtLmtleSAhPT0gdGhpcy5zdGF0ZS5leHBhbmRlZE1lbnVJdGVtS2V5KSB7XHJcbiAgICAgICAgICAgIGlmIChoYXNTdWJtZW51SXRlbXMoaXRlbSkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2VudGVyVGltZXJJZCA9IHRoaXMuX2FzeW5jLnNldFRpbWVvdXQoZnVuY3Rpb24gKCkgeyByZXR1cm4gX3RoaXMuX29uSXRlbVN1Yk1lbnVFeHBhbmQoaXRlbSwgdGFyZ2V0RWxlbWVudCk7IH0sIDUwMCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9lbnRlclRpbWVySWQgPSB0aGlzLl9hc3luYy5zZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHsgcmV0dXJuIF90aGlzLl9vblN1Yk1lbnVEaXNtaXNzKGV2KTsgfSwgNTAwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICB0YXJnZXRFbGVtZW50LmZvY3VzKCk7XHJcbiAgICB9O1xyXG4gICAgQ29udGV4dHVhbE1lbnUucHJvdG90eXBlLl9vbk1vdXNlSXRlbUxlYXZlID0gZnVuY3Rpb24gKGl0ZW0sIGV2KSB7XHJcbiAgICAgICAgaWYgKCF0aGlzLl9pc1Njcm9sbElkbGUpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5fZW50ZXJUaW1lcklkICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgdGhpcy5fYXN5bmMuY2xlYXJUaW1lb3V0KHRoaXMuX2VudGVyVGltZXJJZCk7XHJcbiAgICAgICAgICAgIHRoaXMuX2VudGVyVGltZXJJZCA9IHVuZGVmaW5lZDtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGl0ZW0ua2V5ID09PSB0aGlzLnN0YXRlLmV4cGFuZGVkTWVudUl0ZW1LZXkgJiYgaGFzU3VibWVudUl0ZW1zKGl0ZW0pKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogSUUxMSBmb2N1cygpIG1ldGhvZCBmb3JjZXMgcGFyZW50cyB0byBzY3JvbGwgdG8gdG9wIG9mIGVsZW1lbnQuXHJcbiAgICAgICAgICogRWRnZSBhbmQgSUUgZXhwb3NlIGEgc2V0QWN0aXZlKCkgZnVuY3Rpb24gZm9yIGZvY3VzYWJsZSBkaXZzIHRoYXRcclxuICAgICAgICAgKiBzZXRzIHRoZSBwYWdlIGZvY3VzIGJ1dCBkb2VzIG5vdCBzY3JvbGwgdGhlIHBhcmVudCBlbGVtZW50LlxyXG4gICAgICAgICAqL1xyXG4gICAgICAgIGlmICh0aGlzLl9ob3N0LnNldEFjdGl2ZSkge1xyXG4gICAgICAgICAgICB0aGlzLl9ob3N0LnNldEFjdGl2ZSgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgdGhpcy5faG9zdC5mb2N1cygpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBDb250ZXh0dWFsTWVudS5wcm90b3R5cGUuX29uSXRlbU1vdXNlRG93biA9IGZ1bmN0aW9uIChpdGVtLCBldikge1xyXG4gICAgICAgIGlmIChpdGVtLm9uTW91c2VEb3duKSB7XHJcbiAgICAgICAgICAgIGl0ZW0ub25Nb3VzZURvd24oaXRlbSwgZXYpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBDb250ZXh0dWFsTWVudS5wcm90b3R5cGUuX29uSXRlbUNsaWNrID0gZnVuY3Rpb24gKGl0ZW0sIGV2KSB7XHJcbiAgICAgICAgdmFyIGl0ZW1zID0gZ2V0U3VibWVudUl0ZW1zKGl0ZW0pO1xyXG4gICAgICAgIGlmICghaXRlbXMgfHwgIWl0ZW1zLmxlbmd0aCkge1xyXG4gICAgICAgICAgICB0aGlzLl9leGVjdXRlSXRlbUNsaWNrKGl0ZW0sIGV2KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChpdGVtLmtleSA9PT0gdGhpcy5zdGF0ZS5leHBhbmRlZE1lbnVJdGVtS2V5KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9vblN1Yk1lbnVEaXNtaXNzKGV2KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX29uSXRlbVN1Yk1lbnVFeHBhbmQoaXRlbSwgZXYuY3VycmVudFRhcmdldCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZXYuc3RvcFByb3BhZ2F0aW9uKCk7XHJcbiAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcclxuICAgIH07XHJcbiAgICBDb250ZXh0dWFsTWVudS5wcm90b3R5cGUuX29uQW5jaG9yQ2xpY2sgPSBmdW5jdGlvbiAoaXRlbSwgZXYpIHtcclxuICAgICAgICB0aGlzLl9leGVjdXRlSXRlbUNsaWNrKGl0ZW0sIGV2KTtcclxuICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgIH07XHJcbiAgICBDb250ZXh0dWFsTWVudS5wcm90b3R5cGUuX2V4ZWN1dGVJdGVtQ2xpY2sgPSBmdW5jdGlvbiAoaXRlbSwgZXYpIHtcclxuICAgICAgICBpZiAoaXRlbS5vbkNsaWNrKSB7XHJcbiAgICAgICAgICAgIGl0ZW0ub25DbGljayhldiwgaXRlbSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMucHJvcHMub25JdGVtQ2xpY2spIHtcclxuICAgICAgICAgICAgdGhpcy5wcm9wcy5vbkl0ZW1DbGljayhldiwgaXRlbSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgICFldi5kZWZhdWx0UHJldmVudGVkICYmIHRoaXMuZGlzbWlzcyhldiwgdHJ1ZSk7XHJcbiAgICB9O1xyXG4gICAgQ29udGV4dHVhbE1lbnUucHJvdG90eXBlLl9vbkl0ZW1LZXlEb3duID0gZnVuY3Rpb24gKGl0ZW0sIGV2KSB7XHJcbiAgICAgICAgdmFyIG9wZW5LZXkgPSBVdGlsaXRpZXNfMS5nZXRSVEwoKSA/IDM3IC8qIGxlZnQgKi8gOiAzOSAvKiByaWdodCAqLztcclxuICAgICAgICBpZiAoZXYud2hpY2ggPT09IG9wZW5LZXkpIHtcclxuICAgICAgICAgICAgdGhpcy5fb25JdGVtU3ViTWVudUV4cGFuZChpdGVtLCBldi5jdXJyZW50VGFyZ2V0KTtcclxuICAgICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgQ29udGV4dHVhbE1lbnUucHJvdG90eXBlLl9vbkl0ZW1TdWJNZW51RXhwYW5kID0gZnVuY3Rpb24gKGl0ZW0sIHRhcmdldCkge1xyXG4gICAgICAgIGlmICh0aGlzLnN0YXRlLmV4cGFuZGVkTWVudUl0ZW1LZXkgIT09IGl0ZW0ua2V5KSB7XHJcbiAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlLmV4cGFuZGVkTWVudUl0ZW1LZXkpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX29uU3ViTWVudURpc21pc3MoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcclxuICAgICAgICAgICAgICAgIGV4cGFuZGVkTWVudUl0ZW1LZXk6IGl0ZW0ua2V5LFxyXG4gICAgICAgICAgICAgICAgc3VibWVudVRhcmdldDogdGFyZ2V0XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBDb250ZXh0dWFsTWVudS5wcm90b3R5cGUuX2dldFN1Ym1lbnVQcm9wcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX2EgPSB0aGlzLnN0YXRlLCBzdWJtZW51VGFyZ2V0ID0gX2Euc3VibWVudVRhcmdldCwgZXhwYW5kZWRNZW51SXRlbUtleSA9IF9hLmV4cGFuZGVkTWVudUl0ZW1LZXk7XHJcbiAgICAgICAgdmFyIGl0ZW0gPSB0aGlzLl9maW5kSXRlbUJ5S2V5KGV4cGFuZGVkTWVudUl0ZW1LZXkpO1xyXG4gICAgICAgIHZhciBzdWJtZW51UHJvcHMgPSBudWxsO1xyXG4gICAgICAgIGlmIChpdGVtKSB7XHJcbiAgICAgICAgICAgIHN1Ym1lbnVQcm9wcyA9IHtcclxuICAgICAgICAgICAgICAgIGl0ZW1zOiBnZXRTdWJtZW51SXRlbXMoaXRlbSksXHJcbiAgICAgICAgICAgICAgICB0YXJnZXQ6IHN1Ym1lbnVUYXJnZXQsXHJcbiAgICAgICAgICAgICAgICBvbkRpc21pc3M6IHRoaXMuX29uU3ViTWVudURpc21pc3MsXHJcbiAgICAgICAgICAgICAgICBpc1N1Yk1lbnU6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBpZDogdGhpcy5zdGF0ZS5zdWJNZW51SWQsXHJcbiAgICAgICAgICAgICAgICBzaG91bGRGb2N1c09uTW91bnQ6IHRydWUsXHJcbiAgICAgICAgICAgICAgICBkaXJlY3Rpb25hbEhpbnQ6IFV0aWxpdGllc18xLmdldFJUTCgpID8gOCAvKiBsZWZ0VG9wRWRnZSAqLyA6IDExIC8qIHJpZ2h0VG9wRWRnZSAqLyxcclxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogdGhpcy5wcm9wcy5jbGFzc05hbWUsXHJcbiAgICAgICAgICAgICAgICBnYXBTcGFjZTogMCxcclxuICAgICAgICAgICAgICAgIGlzQmVha1Zpc2libGU6IGZhbHNlXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIGlmIChpdGVtLnN1Yk1lbnVQcm9wcykge1xyXG4gICAgICAgICAgICAgICAgVXRpbGl0aWVzXzEuYXNzaWduKHN1Ym1lbnVQcm9wcywgaXRlbS5zdWJNZW51UHJvcHMpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBzdWJtZW51UHJvcHM7XHJcbiAgICB9O1xyXG4gICAgQ29udGV4dHVhbE1lbnUucHJvdG90eXBlLl9maW5kSXRlbUJ5S2V5ID0gZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgIHZhciBpdGVtcyA9IHRoaXMucHJvcHMuaXRlbXM7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ZpbmRJdGVtQnlLZXlGcm9tSXRlbXMoa2V5LCBpdGVtcyk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXR1cm5zIHRoZSBpdGVtIHRoYXQgbWF0aGVzIGEgZ2l2ZW4ga2V5IGlmIGFueS5cclxuICAgICAqIEBwYXJhbSBrZXkgVGhlIGtleSBvZiB0aGUgaXRlbSB0byBtYXRjaFxyXG4gICAgICogQHBhcmFtIGl0ZW1zIFRoZSBpdGVtcyB0byBsb29rIGZvciB0aGUga2V5XHJcbiAgICAgKi9cclxuICAgIENvbnRleHR1YWxNZW51LnByb3RvdHlwZS5fZmluZEl0ZW1CeUtleUZyb21JdGVtcyA9IGZ1bmN0aW9uIChrZXksIGl0ZW1zKSB7XHJcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBpdGVtc18yID0gaXRlbXM7IF9pIDwgaXRlbXNfMi5sZW5ndGg7IF9pKyspIHtcclxuICAgICAgICAgICAgdmFyIGl0ZW0gPSBpdGVtc18yW19pXTtcclxuICAgICAgICAgICAgaWYgKGl0ZW0uaXRlbVR5cGUgPT09IENvbnRleHR1YWxNZW51X3R5cGVzXzEuQ29udGV4dHVhbE1lbnVJdGVtVHlwZS5TZWN0aW9uICYmIGl0ZW0uc2VjdGlvblByb3BzKSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgbWF0Y2ggPSB0aGlzLl9maW5kSXRlbUJ5S2V5RnJvbUl0ZW1zKGtleSwgaXRlbS5zZWN0aW9uUHJvcHMuaXRlbXMpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIG1hdGNoO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGl0ZW0ua2V5ICYmIGl0ZW0ua2V5ID09PSBrZXkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBpdGVtO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIENvbnRleHR1YWxNZW51LnByb3RvdHlwZS5fb25TdWJNZW51RGlzbWlzcyA9IGZ1bmN0aW9uIChldiwgZGlzbWlzc0FsbCkge1xyXG4gICAgICAgIGlmIChkaXNtaXNzQWxsKSB7XHJcbiAgICAgICAgICAgIHRoaXMuZGlzbWlzcyhldiwgZGlzbWlzc0FsbCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcclxuICAgICAgICAgICAgICAgIGRpc21pc3NlZE1lbnVJdGVtS2V5OiB0aGlzLnN0YXRlLmV4cGFuZGVkTWVudUl0ZW1LZXksXHJcbiAgICAgICAgICAgICAgICBleHBhbmRlZE1lbnVJdGVtS2V5OiB1bmRlZmluZWQsXHJcbiAgICAgICAgICAgICAgICBzdWJtZW51VGFyZ2V0OiB1bmRlZmluZWRcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIENvbnRleHR1YWxNZW51LnByb3RvdHlwZS5fc2V0VGFyZ2V0V2luZG93QW5kRWxlbWVudCA9IGZ1bmN0aW9uICh0YXJnZXQpIHtcclxuICAgICAgICBpZiAodGFyZ2V0KSB7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGFyZ2V0ID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgICAgdmFyIGN1cnJlbnREb2MgPSBVdGlsaXRpZXNfMS5nZXREb2N1bWVudCgpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdGFyZ2V0ID0gY3VycmVudERvYyA/IGN1cnJlbnREb2MucXVlcnlTZWxlY3Rvcih0YXJnZXQpIDogbnVsbDtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3RhcmdldFdpbmRvdyA9IFV0aWxpdGllc18xLmdldFdpbmRvdygpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKHRhcmdldC5zdG9wUHJvcGFnYXRpb24pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3RhcmdldFdpbmRvdyA9IFV0aWxpdGllc18xLmdldFdpbmRvdyh0YXJnZXQudG9FbGVtZW50KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3RhcmdldCA9IHRhcmdldDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIGlmICh0YXJnZXQueCAhPT0gdW5kZWZpbmVkICYmIHRhcmdldC55ICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX3RhcmdldFdpbmRvdyA9IFV0aWxpdGllc18xLmdldFdpbmRvdygpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgdmFyIHRhcmdldEVsZW1lbnQgPSB0YXJnZXQ7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl90YXJnZXRXaW5kb3cgPSBVdGlsaXRpZXNfMS5nZXRXaW5kb3codGFyZ2V0RWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl90YXJnZXQgPSB0YXJnZXQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3RhcmdldFdpbmRvdyA9IFV0aWxpdGllc18xLmdldFdpbmRvdygpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBDb250ZXh0dWFsTWVudS5wcm90b3R5cGUuX2lzSXRlbURpc2FibGVkID0gZnVuY3Rpb24gKGl0ZW0pIHtcclxuICAgICAgICByZXR1cm4gISEoaXRlbS5pc0Rpc2FibGVkIHx8IGl0ZW0uZGlzYWJsZWQpO1xyXG4gICAgfTtcclxuICAgIC8vIFRoZSBkZWZhdWx0IENvbnRleHR1YWxNZW51IHByb3BlcnRpZXMgaGF2ZSBubyBpdGVtcyBhbmQgYmVhaywgdGhlIGRlZmF1bHQgc3VibWVudSBkaXJlY3Rpb24gaXMgcmlnaHQgYW5kIHRvcC5cclxuICAgIENvbnRleHR1YWxNZW51LmRlZmF1bHRQcm9wcyA9IHtcclxuICAgICAgICBpdGVtczogW10sXHJcbiAgICAgICAgc2hvdWxkRm9jdXNPbk1vdW50OiB0cnVlLFxyXG4gICAgICAgIGdhcFNwYWNlOiAwLFxyXG4gICAgICAgIGRpcmVjdGlvbmFsSGludDogNyAvKiBib3R0b21BdXRvRWRnZSAqLyxcclxuICAgICAgICBiZWFrV2lkdGg6IDE2LFxyXG4gICAgICAgIGFycm93RGlyZWN0aW9uOiBGb2N1c1pvbmVfMS5Gb2N1c1pvbmVEaXJlY3Rpb24udmVydGljYWwsXHJcbiAgICAgICAgZ2V0TWVudUNsYXNzTmFtZXM6IENvbnRleHR1YWxNZW51X2NsYXNzTmFtZXNfMS5nZXRDb250ZXh0dWFsTWVudUNsYXNzTmFtZXMsXHJcbiAgICB9O1xyXG4gICAgdHNsaWJfMS5fX2RlY29yYXRlKFtcclxuICAgICAgICBVdGlsaXRpZXNfMS5hdXRvYmluZFxyXG4gICAgXSwgQ29udGV4dHVhbE1lbnUucHJvdG90eXBlLCBcImRpc21pc3NcIiwgbnVsbCk7XHJcbiAgICB0c2xpYl8xLl9fZGVjb3JhdGUoW1xyXG4gICAgICAgIFV0aWxpdGllc18xLmF1dG9iaW5kXHJcbiAgICBdLCBDb250ZXh0dWFsTWVudS5wcm90b3R5cGUsIFwiX29uS2V5RG93blwiLCBudWxsKTtcclxuICAgIHRzbGliXzEuX19kZWNvcmF0ZShbXHJcbiAgICAgICAgVXRpbGl0aWVzXzEuYXV0b2JpbmRcclxuICAgIF0sIENvbnRleHR1YWxNZW51LnByb3RvdHlwZSwgXCJfb25NZW51S2V5RG93blwiLCBudWxsKTtcclxuICAgIHRzbGliXzEuX19kZWNvcmF0ZShbXHJcbiAgICAgICAgVXRpbGl0aWVzXzEuYXV0b2JpbmRcclxuICAgIF0sIENvbnRleHR1YWxNZW51LnByb3RvdHlwZSwgXCJfb25TY3JvbGxcIiwgbnVsbCk7XHJcbiAgICB0c2xpYl8xLl9fZGVjb3JhdGUoW1xyXG4gICAgICAgIFV0aWxpdGllc18xLmF1dG9iaW5kXHJcbiAgICBdLCBDb250ZXh0dWFsTWVudS5wcm90b3R5cGUsIFwiX29uTW91c2VJdGVtTGVhdmVcIiwgbnVsbCk7XHJcbiAgICB0c2xpYl8xLl9fZGVjb3JhdGUoW1xyXG4gICAgICAgIFV0aWxpdGllc18xLmF1dG9iaW5kXHJcbiAgICBdLCBDb250ZXh0dWFsTWVudS5wcm90b3R5cGUsIFwiX29uU3ViTWVudURpc21pc3NcIiwgbnVsbCk7XHJcbiAgICBDb250ZXh0dWFsTWVudSA9IENvbnRleHR1YWxNZW51XzEgPSB0c2xpYl8xLl9fZGVjb3JhdGUoW1xyXG4gICAgICAgIFV0aWxpdGllc18xLmN1c3RvbWl6YWJsZSgnQ29udGV4dHVhbE1lbnUnLCBbJ3RoZW1lJ10pLFxyXG4gICAgICAgIHdpdGhSZXNwb25zaXZlTW9kZV8xLndpdGhSZXNwb25zaXZlTW9kZVxyXG4gICAgXSwgQ29udGV4dHVhbE1lbnUpO1xyXG4gICAgcmV0dXJuIENvbnRleHR1YWxNZW51O1xyXG4gICAgdmFyIENvbnRleHR1YWxNZW51XzE7XHJcbn0oVXRpbGl0aWVzXzEuQmFzZUNvbXBvbmVudCkpO1xyXG5leHBvcnRzLkNvbnRleHR1YWxNZW51ID0gQ29udGV4dHVhbE1lbnU7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUNvbnRleHR1YWxNZW51LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xyXG52YXIgU3R5bGluZ18xID0gcmVxdWlyZShcIi4uLy4uL1N0eWxpbmdcIik7XHJcbnZhciBVdGlsaXRpZXNfMSA9IHJlcXVpcmUoXCIuLi8uLi9VdGlsaXRpZXNcIik7XHJcbnZhciBDb250ZXh0dWFsTWVudUl0ZW1IZWlnaHQgPSAnMzJweCc7XHJcbnZhciBnZXRJdGVtSGlnaENvbnRyYXN0U3R5bGVzID0gVXRpbGl0aWVzXzEubWVtb2l6ZUZ1bmN0aW9uKGZ1bmN0aW9uICgpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgc2VsZWN0b3JzOiAoX2EgPSB7fSxcclxuICAgICAgICAgICAgX2FbU3R5bGluZ18xLkhpZ2hDb250cmFzdFNlbGVjdG9yXSA9IHtcclxuICAgICAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogJ0hpZ2hsaWdodCcsXHJcbiAgICAgICAgICAgICAgICBib3JkZXJDb2xvcjogJ0hpZ2hsaWdodCcsXHJcbiAgICAgICAgICAgICAgICBjb2xvcjogJ0hpZ2hsaWdodFRleHQnLFxyXG4gICAgICAgICAgICAgICAgTXNIaWdoQ29udHJhc3RBZGp1c3Q6ICdub25lJ1xyXG4gICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICBfYSksXHJcbiAgICB9O1xyXG4gICAgdmFyIF9hO1xyXG59KTtcclxuZXhwb3J0cy5nZXRNZW51SXRlbVN0eWxlcyA9IFV0aWxpdGllc18xLm1lbW9pemVGdW5jdGlvbihmdW5jdGlvbiAodGhlbWUpIHtcclxuICAgIHZhciBzZW1hbnRpY0NvbG9ycyA9IHRoZW1lLnNlbWFudGljQ29sb3JzLCBmb250cyA9IHRoZW1lLmZvbnRzO1xyXG4gICAgdmFyIENvbnRleHR1YWxNZW51SXRlbUJhY2tncm91bmRIb3ZlckNvbG9yID0gc2VtYW50aWNDb2xvcnMubWVudUl0ZW1CYWNrZ3JvdW5kSG92ZXJlZDtcclxuICAgIHZhciBDb250ZXh0dWFsTWVudUl0ZW1CYWNrZ3JvdW5kU2VsZWN0ZWRDb2xvciA9IHNlbWFudGljQ29sb3JzLm1lbnVJdGVtQmFja2dyb3VuZENoZWNrZWQ7XHJcbiAgICB2YXIgbWVudUl0ZW1TdHlsZXMgPSB7XHJcbiAgICAgICAgaXRlbTogW1xyXG4gICAgICAgICAgICBmb250cy5tZWRpdW0sXHJcbiAgICAgICAgICAgIHtcclxuICAgICAgICAgICAgICAgIGNvbG9yOiBzZW1hbnRpY0NvbG9ycy5ib2R5VGV4dCxcclxuICAgICAgICAgICAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxyXG4gICAgICAgICAgICAgICAgYm94U2l6aW5nOiAnYm9yZGVyLWJveCcsXHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICBdLFxyXG4gICAgICAgIGRpdmlkZXI6IHtcclxuICAgICAgICAgICAgZGlzcGxheTogJ2Jsb2NrJyxcclxuICAgICAgICAgICAgaGVpZ2h0OiAnMXB4JyxcclxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBzZW1hbnRpY0NvbG9ycy5ib2R5RGl2aWRlcixcclxuICAgICAgICAgICAgcG9zaXRpb246ICdyZWxhdGl2ZSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIHJvb3Q6IFtcclxuICAgICAgICAgICAgU3R5bGluZ18xLmdldEZvY3VzU3R5bGUodGhlbWUpLFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmb250OiAnaW5oZXJpdCcsXHJcbiAgICAgICAgICAgICAgICBjb2xvcjogJ2luaGVyaXQnLFxyXG4gICAgICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiAndHJhbnNwYXJlbnQnLFxyXG4gICAgICAgICAgICAgICAgYm9yZGVyOiAnbm9uZScsXHJcbiAgICAgICAgICAgICAgICB3aWR0aDogJzEwMCUnLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBDb250ZXh0dWFsTWVudUl0ZW1IZWlnaHQsXHJcbiAgICAgICAgICAgICAgICBsaW5lSGVpZ2h0OiBDb250ZXh0dWFsTWVudUl0ZW1IZWlnaHQsXHJcbiAgICAgICAgICAgICAgICBkaXNwbGF5OiAnYmxvY2snLFxyXG4gICAgICAgICAgICAgICAgY3Vyc29yOiAncG9pbnRlcicsXHJcbiAgICAgICAgICAgICAgICBwYWRkaW5nOiAnMHB4IDZweCcsXHJcbiAgICAgICAgICAgICAgICB0ZXh0QWxpZ246ICdsZWZ0JyxcclxuICAgICAgICAgICAgfSxcclxuICAgICAgICBdLFxyXG4gICAgICAgIHJvb3REaXNhYmxlZDoge1xyXG4gICAgICAgICAgICBjb2xvcjogc2VtYW50aWNDb2xvcnMuZGlzYWJsZWRCb2R5VGV4dCxcclxuICAgICAgICAgICAgY3Vyc29yOiAnZGVmYXVsdCcsXHJcbiAgICAgICAgICAgIHBvaW50ZXJFdmVudHM6ICdub25lJyxcclxuICAgICAgICB9LFxyXG4gICAgICAgIHJvb3RIb3ZlcmVkOiB0c2xpYl8xLl9fYXNzaWduKHsgYmFja2dyb3VuZENvbG9yOiBDb250ZXh0dWFsTWVudUl0ZW1CYWNrZ3JvdW5kSG92ZXJDb2xvciB9LCBnZXRJdGVtSGlnaENvbnRyYXN0U3R5bGVzKCkpLFxyXG4gICAgICAgIHJvb3RGb2N1c2VkOiB0c2xpYl8xLl9fYXNzaWduKHsgYmFja2dyb3VuZENvbG9yOiBDb250ZXh0dWFsTWVudUl0ZW1CYWNrZ3JvdW5kSG92ZXJDb2xvciB9LCBnZXRJdGVtSGlnaENvbnRyYXN0U3R5bGVzKCkpLFxyXG4gICAgICAgIHJvb3RDaGVja2VkOiB0c2xpYl8xLl9fYXNzaWduKHt9LCBnZXRJdGVtSGlnaENvbnRyYXN0U3R5bGVzKCkpLFxyXG4gICAgICAgIHJvb3RQcmVzc2VkOiB0c2xpYl8xLl9fYXNzaWduKHsgYmFja2dyb3VuZENvbG9yOiBDb250ZXh0dWFsTWVudUl0ZW1CYWNrZ3JvdW5kU2VsZWN0ZWRDb2xvciB9LCBnZXRJdGVtSGlnaENvbnRyYXN0U3R5bGVzKCkpLFxyXG4gICAgICAgIHJvb3RFeHBhbmRlZDogdHNsaWJfMS5fX2Fzc2lnbih7IGJhY2tncm91bmRDb2xvcjogQ29udGV4dHVhbE1lbnVJdGVtQmFja2dyb3VuZFNlbGVjdGVkQ29sb3IsIGNvbG9yOiBzZW1hbnRpY0NvbG9ycy5ib2R5VGV4dENoZWNrZWQgfSwgZ2V0SXRlbUhpZ2hDb250cmFzdFN0eWxlcygpKSxcclxuICAgICAgICBsaW5rQ29udGVudDoge1xyXG4gICAgICAgICAgICB3aGl0ZVNwYWNlOiAnbm93cmFwJyxcclxuICAgICAgICAgICAgaGVpZ2h0OiAnaW5oZXJpdCcsXHJcbiAgICAgICAgICAgIGRpc3BsYXk6ICdmbGV4JyxcclxuICAgICAgICAgICAgYWxpZ25JdGVtczogJ2NlbnRlcicsXHJcbiAgICAgICAgICAgIG1heFdpZHRoOiAnMTAwJSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIGFuY2hvckxpbms6IHtcclxuICAgICAgICAgICAgcGFkZGluZzogJzBweCA2cHgnLFxyXG4gICAgICAgICAgICB0ZXh0UmVuZGVyaW5nOiAnYXV0bycsXHJcbiAgICAgICAgICAgIGNvbG9yOiAnaW5oZXJpdCcsXHJcbiAgICAgICAgICAgIGxldHRlclNwYWNpbmc6ICdub3JtYWwnLFxyXG4gICAgICAgICAgICB3b3JkU3BhY2luZzogJ25vcm1hbCcsXHJcbiAgICAgICAgICAgIHRleHRUcmFuc2Zvcm06ICdub25lJyxcclxuICAgICAgICAgICAgdGV4dEluZGVudDogJzBweCcsXHJcbiAgICAgICAgICAgIHRleHRTaGFkb3c6ICdub25lJyxcclxuICAgICAgICAgICAgdGV4dERlY29yYXRpb246ICdub25lJyxcclxuICAgICAgICAgICAgYm94U2l6aW5nOiAnYm9yZGVyLWJveCdcclxuICAgICAgICB9LFxyXG4gICAgICAgIGxhYmVsOiB7XHJcbiAgICAgICAgICAgIG1hcmdpbjogJzAgNHB4JyxcclxuICAgICAgICAgICAgdmVydGljYWxBbGlnbjogJ21pZGRsZScsXHJcbiAgICAgICAgICAgIGRpc3BsYXk6ICdpbmxpbmUtYmxvY2snLFxyXG4gICAgICAgICAgICBmbGV4R3JvdzogJzEnLFxyXG4gICAgICAgICAgICB0ZXh0T3ZlcmZsb3c6ICdlbGxpcHNpcycsXHJcbiAgICAgICAgICAgIG92ZXJmbG93OiAnaGlkZGVuJyxcclxuICAgICAgICAgICAgd2hpdGVTcGFjZTogJ25vd3JhcCdcclxuICAgICAgICB9LFxyXG4gICAgICAgIGljb246IHtcclxuICAgICAgICAgICAgZGlzcGxheTogJ2lubGluZS1ibG9jaycsXHJcbiAgICAgICAgICAgIG1pbkhlaWdodDogJzFweCcsXHJcbiAgICAgICAgICAgIG1heEhlaWdodDogQ29udGV4dHVhbE1lbnVJdGVtSGVpZ2h0LFxyXG4gICAgICAgICAgICB3aWR0aDogJzE0cHgnLFxyXG4gICAgICAgICAgICBtYXJnaW46ICcwIDRweCcsXHJcbiAgICAgICAgICAgIHZlcnRpY2FsQWxpZ246ICdtaWRkbGUnLFxyXG4gICAgICAgICAgICBmbGV4U2hyaW5rOiAnMCcsXHJcbiAgICAgICAgfSxcclxuICAgICAgICBpY29uQ29sb3I6IHtcclxuICAgICAgICAgICAgY29sb3I6IHNlbWFudGljQ29sb3JzLm1lbnVJY29uLFxyXG4gICAgICAgICAgICBzZWxlY3RvcnM6IChfYSA9IHt9LFxyXG4gICAgICAgICAgICAgICAgX2FbU3R5bGluZ18xLkhpZ2hDb250cmFzdFNlbGVjdG9yXSA9IHtcclxuICAgICAgICAgICAgICAgICAgICBjb2xvcjogJ0hpZ2hsaWdodFRleHQnLFxyXG4gICAgICAgICAgICAgICAgfSxcclxuICAgICAgICAgICAgICAgIF9hKVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY2hlY2ttYXJrSWNvbjoge1xyXG4gICAgICAgICAgICBjb2xvcjogc2VtYW50aWNDb2xvcnMuYm9keVN1YnRleHQsXHJcbiAgICAgICAgICAgIHNlbGVjdG9yczogKF9iID0ge30sXHJcbiAgICAgICAgICAgICAgICBfYltTdHlsaW5nXzEuSGlnaENvbnRyYXN0U2VsZWN0b3JdID0ge1xyXG4gICAgICAgICAgICAgICAgICAgIGNvbG9yOiAnSGlnaGxpZ2h0VGV4dCcsXHJcbiAgICAgICAgICAgICAgICB9LFxyXG4gICAgICAgICAgICAgICAgX2IpXHJcbiAgICAgICAgfSxcclxuICAgICAgICBzdWJNZW51SWNvbjoge1xyXG4gICAgICAgICAgICBoZWlnaHQ6IENvbnRleHR1YWxNZW51SXRlbUhlaWdodCxcclxuICAgICAgICAgICAgbGluZUhlaWdodDogQ29udGV4dHVhbE1lbnVJdGVtSGVpZ2h0LFxyXG4gICAgICAgICAgICB0ZXh0QWxpZ246ICdjZW50ZXInLFxyXG4gICAgICAgICAgICBkaXNwbGF5OiAnaW5saW5lLWJsb2NrJyxcclxuICAgICAgICAgICAgdmVydGljYWxBbGlnbjogJ21pZGRsZScsXHJcbiAgICAgICAgICAgIGZsZXhTaHJpbms6ICcwJyxcclxuICAgICAgICAgICAgZm9udFNpemU6IFN0eWxpbmdfMS5Gb250U2l6ZXMubWluaVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc3BsaXRCdXR0b25GbGV4Q29udGFpbmVyOiB7XHJcbiAgICAgICAgICAgIGRpc3BsYXk6ICdmbGV4JyxcclxuICAgICAgICAgICAgaGVpZ2h0OiBDb250ZXh0dWFsTWVudUl0ZW1IZWlnaHQsXHJcbiAgICAgICAgICAgIGZsZXhXcmFwOiAnbm93cmFwJyxcclxuICAgICAgICAgICAganVzdGlmeUNvbnRlbnQ6ICdjZW50ZXInLFxyXG4gICAgICAgICAgICBhbGlnbkl0ZW1zOiAnY2VudGVyJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc3BsaXRCdXR0b25TZXBhcmF0b3I6IHt9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFN0eWxpbmdfMS5jb25jYXRTdHlsZVNldHMobWVudUl0ZW1TdHlsZXMpO1xyXG4gICAgdmFyIF9hLCBfYjtcclxufSk7XHJcbmV4cG9ydHMuZ2V0U3R5bGVzID0gVXRpbGl0aWVzXzEubWVtb2l6ZUZ1bmN0aW9uKGZ1bmN0aW9uICh0aGVtZSkge1xyXG4gICAgdmFyIHNlbWFudGljQ29sb3JzID0gdGhlbWUuc2VtYW50aWNDb2xvcnMsIGZvbnRzID0gdGhlbWUuZm9udHM7XHJcbiAgICB2YXIgQ29udGV4dHVhbE1lbnVCYWNrZ3JvdW5kID0gc2VtYW50aWNDb2xvcnMuYm9keUJhY2tncm91bmQ7XHJcbiAgICB2YXIgQ29udGV4dHVhbE1lbnVIZWFkZXJDb2xvciA9IHNlbWFudGljQ29sb3JzLm1lbnVIZWFkZXI7XHJcbiAgICB2YXIgc3R5bGVzID0ge1xyXG4gICAgICAgIHJvb3Q6IHtcclxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiBDb250ZXh0dWFsTWVudUJhY2tncm91bmQsXHJcbiAgICAgICAgICAgIG1pbldpZHRoOiAnMTgwcHgnLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgY29udGFpbmVyOiB7fSxcclxuICAgICAgICBsaXN0OiB7XHJcbiAgICAgICAgICAgIGxpc3RTdHlsZVR5cGU6ICdub25lJyxcclxuICAgICAgICAgICAgbWFyZ2luOiAnMCcsXHJcbiAgICAgICAgICAgIHBhZGRpbmc6ICcwJyxcclxuICAgICAgICAgICAgbGluZUhlaWdodDogJzAnLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgdGl0bGU6IHtcclxuICAgICAgICAgICAgZm9udFNpemU6ICcxNnB4JyxcclxuICAgICAgICAgICAgcGFkZGluZ1JpZ2h0OiAnMTRweCcsXHJcbiAgICAgICAgICAgIHBhZGRpbmdMZWZ0OiAnMTRweCcsXHJcbiAgICAgICAgICAgIHBhZGRpbmdCb3R0b206ICc1cHgnLFxyXG4gICAgICAgICAgICBwYWRkaW5nVG9wOiAnNXB4JyxcclxuICAgICAgICAgICAgYmFja2dyb3VuZENvbG9yOiB0aGVtZS5wYWxldHRlLm5ldXRyYWxMaWdodFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgaGVhZGVyOiBbXHJcbiAgICAgICAgICAgIGZvbnRzLnNtYWxsLFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBmb250V2VpZ2h0OiBTdHlsaW5nXzEuRm9udFdlaWdodHMuc2VtaWJvbGQsXHJcbiAgICAgICAgICAgICAgICBjb2xvcjogQ29udGV4dHVhbE1lbnVIZWFkZXJDb2xvcixcclxuICAgICAgICAgICAgICAgIGJhY2tncm91bmQ6ICdub25lJyxcclxuICAgICAgICAgICAgICAgIGJvcmRlcjogJ25vbmUnLFxyXG4gICAgICAgICAgICAgICAgaGVpZ2h0OiBDb250ZXh0dWFsTWVudUl0ZW1IZWlnaHQsXHJcbiAgICAgICAgICAgICAgICBsaW5lSGVpZ2h0OiBDb250ZXh0dWFsTWVudUl0ZW1IZWlnaHQsXHJcbiAgICAgICAgICAgICAgICBjdXJzb3I6ICdkZWZhdWx0JyxcclxuICAgICAgICAgICAgICAgIHBhZGRpbmc6ICcwcHggNnB4JyxcclxuICAgICAgICAgICAgICAgIHVzZXJTZWxlY3Q6ICdub25lJyxcclxuICAgICAgICAgICAgICAgIHRleHRBbGlnbjogJ2xlZnQnLFxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgXSxcclxuICAgIH07XHJcbiAgICByZXR1cm4gU3R5bGluZ18xLmNvbmNhdFN0eWxlU2V0cyhzdHlsZXMpO1xyXG59KTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q29udGV4dHVhbE1lbnUuc3R5bGVzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBEaXJlY3Rpb25hbEhpbnRfMSA9IHJlcXVpcmUoXCIuLi8uLi9jb21tb24vRGlyZWN0aW9uYWxIaW50XCIpO1xyXG5leHBvcnRzLkRpcmVjdGlvbmFsSGludCA9IERpcmVjdGlvbmFsSGludF8xLkRpcmVjdGlvbmFsSGludDtcclxudmFyIENvbnRleHR1YWxNZW51SXRlbVR5cGU7XHJcbihmdW5jdGlvbiAoQ29udGV4dHVhbE1lbnVJdGVtVHlwZSkge1xyXG4gICAgQ29udGV4dHVhbE1lbnVJdGVtVHlwZVtDb250ZXh0dWFsTWVudUl0ZW1UeXBlW1wiTm9ybWFsXCJdID0gMF0gPSBcIk5vcm1hbFwiO1xyXG4gICAgQ29udGV4dHVhbE1lbnVJdGVtVHlwZVtDb250ZXh0dWFsTWVudUl0ZW1UeXBlW1wiRGl2aWRlclwiXSA9IDFdID0gXCJEaXZpZGVyXCI7XHJcbiAgICBDb250ZXh0dWFsTWVudUl0ZW1UeXBlW0NvbnRleHR1YWxNZW51SXRlbVR5cGVbXCJIZWFkZXJcIl0gPSAyXSA9IFwiSGVhZGVyXCI7XHJcbiAgICBDb250ZXh0dWFsTWVudUl0ZW1UeXBlW0NvbnRleHR1YWxNZW51SXRlbVR5cGVbXCJTZWN0aW9uXCJdID0gM10gPSBcIlNlY3Rpb25cIjtcclxufSkoQ29udGV4dHVhbE1lbnVJdGVtVHlwZSA9IGV4cG9ydHMuQ29udGV4dHVhbE1lbnVJdGVtVHlwZSB8fCAoZXhwb3J0cy5Db250ZXh0dWFsTWVudUl0ZW1UeXBlID0ge30pKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Q29udGV4dHVhbE1lbnUudHlwZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XHJcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL0NvbnRleHR1YWxNZW51XCIpLCBleHBvcnRzKTtcclxudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vQ29udGV4dHVhbE1lbnUudHlwZXNcIiksIGV4cG9ydHMpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgVXRpbGl0aWVzXzEgPSByZXF1aXJlKFwiLi4vLi4vVXRpbGl0aWVzXCIpO1xyXG52YXIgU3R5bGluZ18xID0gcmVxdWlyZShcIi4uLy4uL1N0eWxpbmdcIik7XHJcbmV4cG9ydHMuZ2V0RGl2aWRlckNsYXNzTmFtZXMgPSBVdGlsaXRpZXNfMS5tZW1vaXplRnVuY3Rpb24oZnVuY3Rpb24gKHRoZW1lKSB7XHJcbiAgICByZXR1cm4gU3R5bGluZ18xLm1lcmdlU3R5bGVTZXRzKHtcclxuICAgICAgICB3cmFwcGVyOiB7XHJcbiAgICAgICAgICAgIGRpc3BsYXk6ICdpbmxpbmUtZmxleCcsXHJcbiAgICAgICAgICAgIGhlaWdodDogJzEwMCUnLFxyXG4gICAgICAgICAgICBhbGlnbkl0ZW1zOiAnY2VudGVyJ1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgZGl2aWRlcjoge1xyXG4gICAgICAgICAgICB3aWR0aDogMSxcclxuICAgICAgICAgICAgaGVpZ2h0OiAnMTAwJScsXHJcbiAgICAgICAgICAgIGJhY2tncm91bmRDb2xvcjogdGhlbWUucGFsZXR0ZS5uZXV0cmFsVGVydGlhcnlBbHRcclxuICAgICAgICB9XHJcbiAgICB9KTtcclxufSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPVZlcnRpY2FsRGl2aWRlci5jbGFzc05hbWVzLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBSZWFjdCA9IHJlcXVpcmUoXCJyZWFjdFwiKTtcclxudmFyIFZlcnRpY2FsRGl2aWRlcl9jbGFzc05hbWVzXzEgPSByZXF1aXJlKFwiLi9WZXJ0aWNhbERpdmlkZXIuY2xhc3NOYW1lc1wiKTtcclxudmFyIFN0eWxpbmdfMSA9IHJlcXVpcmUoXCIuLi8uLi9TdHlsaW5nXCIpO1xyXG5leHBvcnRzLlZlcnRpY2FsRGl2aWRlciA9IGZ1bmN0aW9uIChwcm9wcykge1xyXG4gICAgdmFyIHRoZW1lID0gU3R5bGluZ18xLmdldFRoZW1lKCk7XHJcbiAgICB2YXIgY2xhc3NOYW1lcyA9IHByb3BzLmdldENsYXNzTmFtZXMgPyBwcm9wcy5nZXRDbGFzc05hbWVzKHRoZW1lKSA6IFZlcnRpY2FsRGl2aWRlcl9jbGFzc05hbWVzXzEuZ2V0RGl2aWRlckNsYXNzTmFtZXModGhlbWUpO1xyXG4gICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwic3BhblwiLCB7IGNsYXNzTmFtZTogY2xhc3NOYW1lcy53cmFwcGVyIH0sXHJcbiAgICAgICAgUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgeyBjbGFzc05hbWU6IGNsYXNzTmFtZXMuZGl2aWRlciB9KSkpO1xyXG59O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1WZXJ0aWNhbERpdmlkZXIuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XHJcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL1ZlcnRpY2FsRGl2aWRlclwiKSwgZXhwb3J0cyk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBVdGlsaXRpZXNfMSA9IHJlcXVpcmUoXCIuLi8uLi9VdGlsaXRpZXNcIik7XHJcbnZhciBTdHlsaW5nXzEgPSByZXF1aXJlKFwiLi4vLi4vU3R5bGluZ1wiKTtcclxudmFyIGluaGVyaXRGb250ID0geyBmb250RmFtaWx5OiAnaW5oZXJpdCcgfTtcclxuZXhwb3J0cy5nZXRDbGFzc05hbWVzID0gVXRpbGl0aWVzXzEubWVtb2l6ZUZ1bmN0aW9uKGZ1bmN0aW9uICh0aGVtZSwgY2xhc3NOYW1lLCBpc0ZvY3VzVmlzaWJsZSkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICByb290OiBTdHlsaW5nXzEubWVyZ2VTdHlsZXMoW1xyXG4gICAgICAgICAgICAnbXMtRmFicmljJyxcclxuICAgICAgICAgICAgaXNGb2N1c1Zpc2libGUgJiYgJ2lzLWZvY3VzVmlzaWJsZScsXHJcbiAgICAgICAgICAgIGNsYXNzTmFtZSxcclxuICAgICAgICAgICAgdGhlbWUuZm9udHMubWVkaXVtLFxyXG4gICAgICAgICAgICB7XHJcbiAgICAgICAgICAgICAgICBjb2xvcjogdGhlbWUucGFsZXR0ZS5uZXV0cmFsUHJpbWFyeSxcclxuICAgICAgICAgICAgICAgIHNlbGVjdG9yczoge1xyXG4gICAgICAgICAgICAgICAgICAgICcmIGJ1dHRvbic6IGluaGVyaXRGb250LFxyXG4gICAgICAgICAgICAgICAgICAgICcmIGlucHV0JzogaW5oZXJpdEZvbnQsXHJcbiAgICAgICAgICAgICAgICAgICAgJyYgdGV4dGFyZWEnOiBpbmhlcml0Rm9udFxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgXSlcclxuICAgIH07XHJcbn0pO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1GYWJyaWMuY2xhc3NOYW1lcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcclxudmFyIFJlYWN0ID0gcmVxdWlyZShcInJlYWN0XCIpO1xyXG52YXIgVXRpbGl0aWVzXzEgPSByZXF1aXJlKFwiLi4vLi4vVXRpbGl0aWVzXCIpO1xyXG52YXIgRmFicmljX2NsYXNzTmFtZXNfMSA9IHJlcXVpcmUoXCIuL0ZhYnJpYy5jbGFzc05hbWVzXCIpO1xyXG52YXIgRElSRUNUSU9OQUxfS0VZX0NPREVTID0gW1xyXG4gICAgMzggLyogdXAgKi8sXHJcbiAgICA0MCAvKiBkb3duICovLFxyXG4gICAgMzcgLyogbGVmdCAqLyxcclxuICAgIDM5IC8qIHJpZ2h0ICovLFxyXG4gICAgMzYgLyogaG9tZSAqLyxcclxuICAgIDM1IC8qIGVuZCAqLyxcclxuICAgIDkgLyogdGFiICovLFxyXG4gICAgMzMgLyogcGFnZVVwICovLFxyXG4gICAgMzQgLyogcGFnZURvd24gKi9cclxuXTtcclxuLy8gV2Ugd2lsbCB0cmFjayB0aGUgbGFzdCBmb2N1cyB2aXNpYmlsaXR5IHN0YXRlIHNvIHRoYXQgaWYgd2UgdGVhciBkb3duIGFuZCByZWNyZWF0ZVxyXG4vLyB0aGUgRmFicmljIGNvbXBvbmVudCwgd2Ugd2lsbCB1c2UgdGhlIGxhc3Qga25vd24gdmFsdWUgYXMgdGhlIGRlZmF1bHQuXHJcbnZhciBfbGFzdElzRm9jdXNWaXNpYmxlID0gZmFsc2U7XHJcbi8vIEVuc3VyZSB0aGF0IHRoZSBIVE1MIGVsZW1lbnQgaGFzIGEgZGlyIHNwZWNpZmllZC4gVGhpcyBoZWxwcyB0byBlbnN1cmUgUlRML0xUUiBtYWNyb3MgaW4gY3NzIGZvciBhbGwgY29tcG9uZW50cyB3aWxsIHdvcmsuXHJcbmlmICh0eXBlb2YgKGRvY3VtZW50KSA9PT0gJ29iamVjdCcgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50ICYmICFkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkaXInKSkge1xyXG4gICAgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNldEF0dHJpYnV0ZSgnZGlyJywgJ2x0cicpO1xyXG59XHJcbnZhciBGYWJyaWMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhGYWJyaWMsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBGYWJyaWMocHJvcHMpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBwcm9wcykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5zdGF0ZSA9IHtcclxuICAgICAgICAgICAgaXNGb2N1c1Zpc2libGU6IF9sYXN0SXNGb2N1c1Zpc2libGVcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIEZhYnJpYy5wcm90b3R5cGUuY29tcG9uZW50RGlkTW91bnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5fZXZlbnRzLm9uKGRvY3VtZW50LmJvZHksICdtb3VzZWRvd24nLCB0aGlzLl9vbk1vdXNlRG93biwgdHJ1ZSk7XHJcbiAgICAgICAgdGhpcy5fZXZlbnRzLm9uKGRvY3VtZW50LmJvZHksICdrZXlkb3duJywgdGhpcy5fb25LZXlEb3duLCB0cnVlKTtcclxuICAgIH07XHJcbiAgICBGYWJyaWMucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgaXNGb2N1c1Zpc2libGUgPSB0aGlzLnN0YXRlLmlzRm9jdXNWaXNpYmxlO1xyXG4gICAgICAgIHZhciBjbGFzc05hbWUgPSB0aGlzLnByb3BzLmNsYXNzTmFtZTtcclxuICAgICAgICB2YXIgY2xhc3NOYW1lcyA9IEZhYnJpY19jbGFzc05hbWVzXzEuZ2V0Q2xhc3NOYW1lcyh0aGlzLnByb3BzLnRoZW1lLCBjbGFzc05hbWUsIGlzRm9jdXNWaXNpYmxlKTtcclxuICAgICAgICB2YXIgZGl2UHJvcHMgPSBVdGlsaXRpZXNfMS5nZXROYXRpdmVQcm9wcyh0aGlzLnByb3BzLCBVdGlsaXRpZXNfMS5kaXZQcm9wZXJ0aWVzKTtcclxuICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgdHNsaWJfMS5fX2Fzc2lnbih7fSwgZGl2UHJvcHMsIHsgY2xhc3NOYW1lOiBjbGFzc05hbWVzLnJvb3QsIHJlZjogdGhpcy5fcmVzb2x2ZVJlZignX3Jvb3QnKSB9KSkpO1xyXG4gICAgfTtcclxuICAgIEZhYnJpYy5wcm90b3R5cGUuX29uTW91c2VEb3duID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLnN0YXRlLmlzRm9jdXNWaXNpYmxlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuc2V0U3RhdGUoe1xyXG4gICAgICAgICAgICAgICAgaXNGb2N1c1Zpc2libGU6IGZhbHNlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBfbGFzdElzRm9jdXNWaXNpYmxlID0gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEZhYnJpYy5wcm90b3R5cGUuX29uS2V5RG93biA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgIGlmICghdGhpcy5zdGF0ZS5pc0ZvY3VzVmlzaWJsZSAmJiBESVJFQ1RJT05BTF9LRVlfQ09ERVMuaW5kZXhPZihldi53aGljaCkgPiAtMSkge1xyXG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcclxuICAgICAgICAgICAgICAgIGlzRm9jdXNWaXNpYmxlOiB0cnVlXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgICBfbGFzdElzRm9jdXNWaXNpYmxlID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRmFicmljID0gdHNsaWJfMS5fX2RlY29yYXRlKFtcclxuICAgICAgICBVdGlsaXRpZXNfMS5jdXN0b21pemFibGUoJ0ZhYnJpYycsIFsndGhlbWUnXSlcclxuICAgIF0sIEZhYnJpYyk7XHJcbiAgICByZXR1cm4gRmFicmljO1xyXG59KFV0aWxpdGllc18xLkJhc2VDb21wb25lbnQpKTtcclxuZXhwb3J0cy5GYWJyaWMgPSBGYWJyaWM7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUZhYnJpYy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgdHNsaWJfMSA9IHJlcXVpcmUoXCJ0c2xpYlwiKTtcclxudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vRmFicmljXCIpLCBleHBvcnRzKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XHJcbnZhciBSZWFjdCA9IHJlcXVpcmUoXCJyZWFjdFwiKTtcclxudmFyIEZvY3VzWm9uZV90eXBlc18xID0gcmVxdWlyZShcIi4vRm9jdXNab25lLnR5cGVzXCIpO1xyXG52YXIgVXRpbGl0aWVzXzEgPSByZXF1aXJlKFwiLi4vLi4vVXRpbGl0aWVzXCIpO1xyXG52YXIgSVNfRk9DVVNBQkxFX0FUVFJJQlVURSA9ICdkYXRhLWlzLWZvY3VzYWJsZSc7XHJcbnZhciBJU19FTlRFUl9ESVNBQkxFRF9BVFRSSUJVVEUgPSAnZGF0YS1kaXNhYmxlLWNsaWNrLW9uLWVudGVyJztcclxudmFyIEZPQ1VTWk9ORV9JRF9BVFRSSUJVVEUgPSAnZGF0YS1mb2N1c3pvbmUtaWQnO1xyXG52YXIgVEFCSU5ERVggPSAndGFiaW5kZXgnO1xyXG52YXIgX2FsbEluc3RhbmNlcyA9IHt9O1xyXG52YXIgQUxMT1dFRF9JTlBVVF9UWVBFUyA9IFsndGV4dCcsICdudW1iZXInLCAncGFzc3dvcmQnLCAnZW1haWwnLCAndGVsJywgJ3VybCcsICdzZWFyY2gnXTtcclxudmFyIEFMTE9XX1ZJUlRVQUxfRUxFTUVOVFMgPSBmYWxzZTtcclxudmFyIEZvY3VzWm9uZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIHRzbGliXzEuX19leHRlbmRzKEZvY3VzWm9uZSwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEZvY3VzWm9uZShwcm9wcykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHByb3BzKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLl93YXJuRGVwcmVjYXRpb25zKHsgcm9vdFByb3BzOiB1bmRlZmluZWQgfSk7XHJcbiAgICAgICAgX3RoaXMuX2lkID0gVXRpbGl0aWVzXzEuZ2V0SWQoJ0ZvY3VzWm9uZScpO1xyXG4gICAgICAgIF90aGlzLl9mb2N1c0FsaWdubWVudCA9IHtcclxuICAgICAgICAgICAgbGVmdDogMCxcclxuICAgICAgICAgICAgdG9wOiAwXHJcbiAgICAgICAgfTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICBGb2N1c1pvbmUucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIF9hbGxJbnN0YW5jZXNbdGhpcy5faWRdID0gdGhpcztcclxuICAgICAgICBpZiAodGhpcy5fcm9vdCkge1xyXG4gICAgICAgICAgICB2YXIgd2luZG93RWxlbWVudCA9IHRoaXMuX3Jvb3Qub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztcclxuICAgICAgICAgICAgdmFyIHBhcmVudEVsZW1lbnQgPSBVdGlsaXRpZXNfMS5nZXRQYXJlbnQodGhpcy5fcm9vdCwgQUxMT1dfVklSVFVBTF9FTEVNRU5UUyk7XHJcbiAgICAgICAgICAgIHdoaWxlIChwYXJlbnRFbGVtZW50ICYmXHJcbiAgICAgICAgICAgICAgICBwYXJlbnRFbGVtZW50ICE9PSBkb2N1bWVudC5ib2R5ICYmXHJcbiAgICAgICAgICAgICAgICBwYXJlbnRFbGVtZW50Lm5vZGVUeXBlID09PSAxKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoVXRpbGl0aWVzXzEuaXNFbGVtZW50Rm9jdXNab25lKHBhcmVudEVsZW1lbnQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faXNJbm5lclpvbmUgPSB0cnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcGFyZW50RWxlbWVudCA9IFV0aWxpdGllc18xLmdldFBhcmVudChwYXJlbnRFbGVtZW50LCBBTExPV19WSVJUVUFMX0VMRU1FTlRTKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2lzSW5uZXJab25lKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9ldmVudHMub24od2luZG93RWxlbWVudCwgJ2tleWRvd24nLCB0aGlzLl9vbktleURvd25DYXB0dXJlLCB0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAvLyBBc3NpZ24gaW5pdGlhbCB0YWIgaW5kZXhlcyBzbyB0aGF0IHdlIGNhbiBzZXQgaW5pdGlhbCBmb2N1cyBhcyBhcHByb3ByaWF0ZS5cclxuICAgICAgICAgICAgdGhpcy5fdXBkYXRlVGFiSW5kZXhlcygpO1xyXG4gICAgICAgICAgICBpZiAodGhpcy5wcm9wcy5kZWZhdWx0QWN0aXZlRWxlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fYWN0aXZlRWxlbWVudCA9IFV0aWxpdGllc18xLmdldERvY3VtZW50KCkucXVlcnlTZWxlY3Rvcih0aGlzLnByb3BzLmRlZmF1bHRBY3RpdmVFbGVtZW50KTtcclxuICAgICAgICAgICAgICAgIHRoaXMuZm9jdXMoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBGb2N1c1pvbmUucHJvdG90eXBlLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGRlbGV0ZSBfYWxsSW5zdGFuY2VzW3RoaXMuX2lkXTtcclxuICAgIH07XHJcbiAgICBGb2N1c1pvbmUucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX2EgPSB0aGlzLnByb3BzLCByb290UHJvcHMgPSBfYS5yb290UHJvcHMsIGFyaWFEZXNjcmliZWRCeSA9IF9hLmFyaWFEZXNjcmliZWRCeSwgYXJpYUxhYmVsbGVkQnkgPSBfYS5hcmlhTGFiZWxsZWRCeSwgY2xhc3NOYW1lID0gX2EuY2xhc3NOYW1lO1xyXG4gICAgICAgIHZhciBkaXZQcm9wcyA9IFV0aWxpdGllc18xLmdldE5hdGl2ZVByb3BzKHRoaXMucHJvcHMsIFV0aWxpdGllc18xLmRpdlByb3BlcnRpZXMpO1xyXG4gICAgICAgIHZhciBUYWcgPSB0aGlzLnByb3BzLmVsZW1lbnRUeXBlIHx8ICdkaXYnO1xyXG4gICAgICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChUYWcsIHRzbGliXzEuX19hc3NpZ24oeyByb2xlOiAncHJlc2VudGF0aW9uJyB9LCBkaXZQcm9wcywgcm9vdFByb3BzLCB7IGNsYXNzTmFtZTogVXRpbGl0aWVzXzEuY3NzKCdtcy1Gb2N1c1pvbmUnLCBjbGFzc05hbWUpLCByZWY6IHRoaXMuX3Jlc29sdmVSZWYoJ19yb290JyksIFwiZGF0YS1mb2N1c3pvbmUtaWRcIjogdGhpcy5faWQsIFwiYXJpYS1sYWJlbGxlZGJ5XCI6IGFyaWFMYWJlbGxlZEJ5LCBcImFyaWEtZGVzY3JpYmVkYnlcIjogYXJpYURlc2NyaWJlZEJ5LCBvbktleURvd246IHRoaXMuX29uS2V5RG93biwgb25Gb2N1czogdGhpcy5fb25Gb2N1cywgb25Nb3VzZURvd25DYXB0dXJlOiB0aGlzLl9vbk1vdXNlRG93biB9KSwgdGhpcy5wcm9wcy5jaGlsZHJlbikpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogU2V0cyBmb2N1cyB0byB0aGUgZmlyc3QgdGFiYmFibGUgaXRlbSBpbiB0aGUgem9uZS5cclxuICAgICAqIEByZXR1cm5zIFRydWUgaWYgZm9jdXMgY291bGQgYmUgc2V0IHRvIGFuIGFjdGl2ZSBlbGVtZW50LCBmYWxzZSBpZiBubyBvcGVyYXRpb24gd2FzIHRha2VuLlxyXG4gICAgICovXHJcbiAgICBGb2N1c1pvbmUucHJvdG90eXBlLmZvY3VzID0gZnVuY3Rpb24gKGZvcmNlSW50b0ZpcnN0RWxlbWVudCkge1xyXG4gICAgICAgIGlmIChmb3JjZUludG9GaXJzdEVsZW1lbnQgPT09IHZvaWQgMCkgeyBmb3JjZUludG9GaXJzdEVsZW1lbnQgPSBmYWxzZTsgfVxyXG4gICAgICAgIGlmICh0aGlzLl9yb290KSB7XHJcbiAgICAgICAgICAgIGlmICghZm9yY2VJbnRvRmlyc3RFbGVtZW50ICYmIHRoaXMuX3Jvb3QuZ2V0QXR0cmlidXRlKElTX0ZPQ1VTQUJMRV9BVFRSSUJVVEUpID09PSAndHJ1ZScgJiYgdGhpcy5faXNJbm5lclpvbmUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBvd25lclpvbmVFbGVtZW50ID0gdGhpcy5fZ2V0T3duZXJab25lKHRoaXMuX3Jvb3QpO1xyXG4gICAgICAgICAgICAgICAgaWYgKG93bmVyWm9uZUVsZW1lbnQgIT09IHRoaXMuX3Jvb3QpIHtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgb3duZXJab25lID0gX2FsbEluc3RhbmNlc1tvd25lclpvbmVFbGVtZW50LmdldEF0dHJpYnV0ZShGT0NVU1pPTkVfSURfQVRUUklCVVRFKV07XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICEhb3duZXJab25lICYmIG93bmVyWm9uZS5mb2N1c0VsZW1lbnQodGhpcy5fcm9vdCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fYWN0aXZlRWxlbWVudCAmJiBVdGlsaXRpZXNfMS5lbGVtZW50Q29udGFpbnModGhpcy5fcm9vdCwgdGhpcy5fYWN0aXZlRWxlbWVudClcclxuICAgICAgICAgICAgICAgICYmIFV0aWxpdGllc18xLmlzRWxlbWVudFRhYmJhYmxlKHRoaXMuX2FjdGl2ZUVsZW1lbnQpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3RpdmVFbGVtZW50LmZvY3VzKCk7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHZhciBmaXJzdENoaWxkID0gdGhpcy5fcm9vdC5maXJzdENoaWxkO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm9jdXNFbGVtZW50KFV0aWxpdGllc18xLmdldE5leHRFbGVtZW50KHRoaXMuX3Jvb3QsIGZpcnN0Q2hpbGQsIHRydWUpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZXRzIGZvY3VzIHRvIGEgc3BlY2lmaWMgY2hpbGQgZWxlbWVudCB3aXRoaW4gdGhlIHpvbmUuIFRoaXMgY2FuIGJlIHVzZWQgaW4gY29uanVuY3Rpb24gd2l0aFxyXG4gICAgICogb25CZWZvcmVGb2N1cyB0byBjcmVhdGVkIGRlbGF5ZWQgZm9jdXMgc2NlbmFyaW9zIChsaWtlIGFuaW1hdGUgdGhlIHNjcm9sbCBwb3NpdGlvbiB0byB0aGUgY29ycmVjdFxyXG4gICAgICogbG9jYXRpb24gYW5kIHRoZW4gZm9jdXMuKVxyXG4gICAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudCBUaGUgY2hpbGQgZWxlbWVudCB3aXRoaW4gdGhlIHpvbmUgdG8gZm9jdXMuXHJcbiAgICAgKiBAcmV0dXJucyBUcnVlIGlmIGZvY3VzIGNvdWxkIGJlIHNldCB0byBhbiBhY3RpdmUgZWxlbWVudCwgZmFsc2UgaWYgbm8gb3BlcmF0aW9uIHdhcyB0YWtlbi5cclxuICAgICAqL1xyXG4gICAgRm9jdXNab25lLnByb3RvdHlwZS5mb2N1c0VsZW1lbnQgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xyXG4gICAgICAgIHZhciBvbkJlZm9yZUZvY3VzID0gdGhpcy5wcm9wcy5vbkJlZm9yZUZvY3VzO1xyXG4gICAgICAgIGlmIChvbkJlZm9yZUZvY3VzICYmICFvbkJlZm9yZUZvY3VzKGVsZW1lbnQpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGVsZW1lbnQpIHtcclxuICAgICAgICAgICAgdGhpcy5fc2V0QWN0aXZlRWxlbWVudChlbGVtZW50KTtcclxuICAgICAgICAgICAgaWYgKHRoaXMuX2FjdGl2ZUVsZW1lbnQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2FjdGl2ZUVsZW1lbnQuZm9jdXMoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfTtcclxuICAgIEZvY3VzWm9uZS5wcm90b3R5cGUuX29uRm9jdXMgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICB2YXIgb25BY3RpdmVFbGVtZW50Q2hhbmdlZCA9IHRoaXMucHJvcHMub25BY3RpdmVFbGVtZW50Q2hhbmdlZDtcclxuICAgICAgICBpZiAodGhpcy5faXNJbW1lZGlhdGVEZXNjZW5kYW50T2Zab25lKGV2LnRhcmdldCkpIHtcclxuICAgICAgICAgICAgdGhpcy5fYWN0aXZlRWxlbWVudCA9IGV2LnRhcmdldDtcclxuICAgICAgICAgICAgdGhpcy5fc2V0Rm9jdXNBbGlnbm1lbnQodGhpcy5fYWN0aXZlRWxlbWVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB2YXIgcGFyZW50RWxlbWVudCA9IGV2LnRhcmdldDtcclxuICAgICAgICAgICAgd2hpbGUgKHBhcmVudEVsZW1lbnQgJiYgcGFyZW50RWxlbWVudCAhPT0gdGhpcy5fcm9vdCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKFV0aWxpdGllc18xLmlzRWxlbWVudFRhYmJhYmxlKHBhcmVudEVsZW1lbnQpICYmIHRoaXMuX2lzSW1tZWRpYXRlRGVzY2VuZGFudE9mWm9uZShwYXJlbnRFbGVtZW50KSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2FjdGl2ZUVsZW1lbnQgPSBwYXJlbnRFbGVtZW50O1xyXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgcGFyZW50RWxlbWVudCA9IFV0aWxpdGllc18xLmdldFBhcmVudChwYXJlbnRFbGVtZW50LCBBTExPV19WSVJUVUFMX0VMRU1FTlRTKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAob25BY3RpdmVFbGVtZW50Q2hhbmdlZCkge1xyXG4gICAgICAgICAgICBvbkFjdGl2ZUVsZW1lbnRDaGFuZ2VkKHRoaXMuX2FjdGl2ZUVsZW1lbnQsIGV2KTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBIYW5kbGUgZ2xvYmFsIHRhYiBwcmVzc2VzIHNvIHRoYXQgd2UgY2FuIHBhdGNoIHRhYmluZGV4ZXMgb24gdGhlIGZseS5cclxuICAgICAqL1xyXG4gICAgRm9jdXNab25lLnByb3RvdHlwZS5fb25LZXlEb3duQ2FwdHVyZSA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgIGlmIChldi53aGljaCA9PT0gOSAvKiB0YWIgKi8pIHtcclxuICAgICAgICAgICAgdGhpcy5fdXBkYXRlVGFiSW5kZXhlcygpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBGb2N1c1pvbmUucHJvdG90eXBlLl9vbk1vdXNlRG93biA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgIHZhciBkaXNhYmxlZCA9IHRoaXMucHJvcHMuZGlzYWJsZWQ7XHJcbiAgICAgICAgaWYgKGRpc2FibGVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIHRhcmdldCA9IGV2LnRhcmdldDtcclxuICAgICAgICB2YXIgcGF0aCA9IFtdO1xyXG4gICAgICAgIHdoaWxlICh0YXJnZXQgJiYgdGFyZ2V0ICE9PSB0aGlzLl9yb290KSB7XHJcbiAgICAgICAgICAgIHBhdGgucHVzaCh0YXJnZXQpO1xyXG4gICAgICAgICAgICB0YXJnZXQgPSBVdGlsaXRpZXNfMS5nZXRQYXJlbnQodGFyZ2V0LCBBTExPV19WSVJUVUFMX0VMRU1FTlRTKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgd2hpbGUgKHBhdGgubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIHRhcmdldCA9IHBhdGgucG9wKCk7XHJcbiAgICAgICAgICAgIGlmICh0YXJnZXQgJiYgVXRpbGl0aWVzXzEuaXNFbGVtZW50VGFiYmFibGUodGFyZ2V0KSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fc2V0QWN0aXZlRWxlbWVudCh0YXJnZXQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmIChVdGlsaXRpZXNfMS5pc0VsZW1lbnRGb2N1c1pvbmUodGFyZ2V0KSkge1xyXG4gICAgICAgICAgICAgICAgLy8gU3RvcCBoZXJlIHNpbmNlIHRoZSBmb2N1cyB6b25lIHdpbGwgdGFrZSBjYXJlIG9mIGl0cyBvd24gY2hpbGRyZW4uXHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBGb2N1c1pvbmUucHJvdG90eXBlLl9zZXRBY3RpdmVFbGVtZW50ID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcclxuICAgICAgICB2YXIgcHJldmlvdXNBY3RpdmVFbGVtZW50ID0gdGhpcy5fYWN0aXZlRWxlbWVudDtcclxuICAgICAgICB0aGlzLl9hY3RpdmVFbGVtZW50ID0gZWxlbWVudDtcclxuICAgICAgICBpZiAocHJldmlvdXNBY3RpdmVFbGVtZW50KSB7XHJcbiAgICAgICAgICAgIGlmIChVdGlsaXRpZXNfMS5pc0VsZW1lbnRGb2N1c1pvbmUocHJldmlvdXNBY3RpdmVFbGVtZW50KSkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdXBkYXRlVGFiSW5kZXhlcyhwcmV2aW91c0FjdGl2ZUVsZW1lbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHByZXZpb3VzQWN0aXZlRWxlbWVudC50YWJJbmRleCA9IC0xO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5fYWN0aXZlRWxlbWVudCkge1xyXG4gICAgICAgICAgICBpZiAoIXRoaXMuX2ZvY3VzQWxpZ25tZW50KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9zZXRGb2N1c0FsaWdubWVudChlbGVtZW50LCB0cnVlLCB0cnVlKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl9hY3RpdmVFbGVtZW50LnRhYkluZGV4ID0gMDtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBIYW5kbGUgdGhlIGtleXN0cm9rZXMuXHJcbiAgICAgKi9cclxuICAgIEZvY3VzWm9uZS5wcm90b3R5cGUuX29uS2V5RG93biA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgIHZhciBfYSA9IHRoaXMucHJvcHMsIGRpcmVjdGlvbiA9IF9hLmRpcmVjdGlvbiwgZGlzYWJsZWQgPSBfYS5kaXNhYmxlZCwgaXNJbm5lclpvbmVLZXlzdHJva2UgPSBfYS5pc0lubmVyWm9uZUtleXN0cm9rZTtcclxuICAgICAgICBpZiAoZGlzYWJsZWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCA9PT0gdGhpcy5fcm9vdCAmJiB0aGlzLl9pc0lubmVyWm9uZSkge1xyXG4gICAgICAgICAgICAvLyBJZiB0aGlzIGVsZW1lbnQgaGFzIGZvY3VzLCBpdCBpcyBiZWluZyBjb250cm9sbGVkIGJ5IGEgcGFyZW50LlxyXG4gICAgICAgICAgICAvLyBJZ25vcmUgdGhlIGtleXN0cm9rZS5cclxuICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAodGhpcy5wcm9wcy5vbktleURvd24pIHtcclxuICAgICAgICAgICAgdGhpcy5wcm9wcy5vbktleURvd24oZXYpO1xyXG4gICAgICAgICAgICBpZiAoZXYuaXNEZWZhdWx0UHJldmVudGVkKCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoaXNJbm5lclpvbmVLZXlzdHJva2UgJiZcclxuICAgICAgICAgICAgaXNJbm5lclpvbmVLZXlzdHJva2UoZXYpICYmXHJcbiAgICAgICAgICAgIHRoaXMuX2lzSW1tZWRpYXRlRGVzY2VuZGFudE9mWm9uZShldi50YXJnZXQpKSB7XHJcbiAgICAgICAgICAgIC8vIFRyeSB0byBmb2N1c1xyXG4gICAgICAgICAgICB2YXIgaW5uZXJab25lID0gdGhpcy5fZ2V0Rmlyc3RJbm5lclpvbmUoKTtcclxuICAgICAgICAgICAgaWYgKGlubmVyWm9uZSkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFpbm5lclpvbmUuZm9jdXModHJ1ZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAoVXRpbGl0aWVzXzEuaXNFbGVtZW50Rm9jdXNTdWJab25lKGV2LnRhcmdldCkpIHtcclxuICAgICAgICAgICAgICAgIGlmICghdGhpcy5mb2N1c0VsZW1lbnQoVXRpbGl0aWVzXzEuZ2V0TmV4dEVsZW1lbnQoZXYudGFyZ2V0LCBldi50YXJnZXQuZmlyc3RDaGlsZCwgdHJ1ZSkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGV2LmFsdEtleSkge1xyXG4gICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKGV2LndoaWNoKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDMyIC8qIHNwYWNlICovOlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl90cnlJbnZva2VDbGlja0ZvckZvY3VzYWJsZShldi50YXJnZXQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICBjYXNlIDM3IC8qIGxlZnQgKi86XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpcmVjdGlvbiAhPT0gRm9jdXNab25lX3R5cGVzXzEuRm9jdXNab25lRGlyZWN0aW9uLnZlcnRpY2FsICYmIHRoaXMuX21vdmVGb2N1c0xlZnQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAzOSAvKiByaWdodCAqLzpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZGlyZWN0aW9uICE9PSBGb2N1c1pvbmVfdHlwZXNfMS5Gb2N1c1pvbmVEaXJlY3Rpb24udmVydGljYWwgJiYgdGhpcy5fbW92ZUZvY3VzUmlnaHQoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAzOCAvKiB1cCAqLzpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoZGlyZWN0aW9uICE9PSBGb2N1c1pvbmVfdHlwZXNfMS5Gb2N1c1pvbmVEaXJlY3Rpb24uaG9yaXpvbnRhbCAmJiB0aGlzLl9tb3ZlRm9jdXNVcCgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQwIC8qIGRvd24gKi86XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKGRpcmVjdGlvbiAhPT0gRm9jdXNab25lX3R5cGVzXzEuRm9jdXNab25lRGlyZWN0aW9uLmhvcml6b250YWwgJiYgdGhpcy5fbW92ZUZvY3VzRG93bigpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICBjYXNlIDkgLyogdGFiICovOlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnByb3BzLmFsbG93VGFiS2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChkaXJlY3Rpb24gPT09IEZvY3VzWm9uZV90eXBlc18xLkZvY3VzWm9uZURpcmVjdGlvbi52ZXJ0aWNhbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV2LnNoaWZ0S2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbW92ZUZvY3VzVXAoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX21vdmVGb2N1c0Rvd24oKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGRpcmVjdGlvbiA9PT0gRm9jdXNab25lX3R5cGVzXzEuRm9jdXNab25lRGlyZWN0aW9uLmhvcml6b250YWwgfHwgZGlyZWN0aW9uID09PSBGb2N1c1pvbmVfdHlwZXNfMS5Gb2N1c1pvbmVEaXJlY3Rpb24uYmlkaXJlY3Rpb25hbCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGV2LnNoaWZ0S2V5KSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbW92ZUZvY3VzTGVmdCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbW92ZUZvY3VzUmlnaHQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgICAgIGNhc2UgMzYgLyogaG9tZSAqLzpcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5faXNFbGVtZW50SW5wdXQoZXYudGFyZ2V0KSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAhdGhpcy5fc2hvdWxkSW5wdXRMb3NlRm9jdXMoZXYudGFyZ2V0LCBmYWxzZSkpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICB2YXIgZmlyc3RDaGlsZCA9IHRoaXMuX3Jvb3QuZmlyc3RDaGlsZDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5mb2N1c0VsZW1lbnQoVXRpbGl0aWVzXzEuZ2V0TmV4dEVsZW1lbnQodGhpcy5fcm9vdCwgZmlyc3RDaGlsZCwgdHJ1ZSkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICBjYXNlIDM1IC8qIGVuZCAqLzpcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5faXNFbGVtZW50SW5wdXQoZXYudGFyZ2V0KSAmJlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAhdGhpcy5fc2hvdWxkSW5wdXRMb3NlRm9jdXMoZXYudGFyZ2V0LCB0cnVlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIHZhciBsYXN0Q2hpbGQgPSB0aGlzLl9yb290Lmxhc3RDaGlsZDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5mb2N1c0VsZW1lbnQoVXRpbGl0aWVzXzEuZ2V0UHJldmlvdXNFbGVtZW50KHRoaXMuX3Jvb3QsIGxhc3RDaGlsZCwgdHJ1ZSwgdHJ1ZSwgdHJ1ZSkpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICBjYXNlIDEzIC8qIGVudGVyICovOlxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLl90cnlJbnZva2VDbGlja0ZvckZvY3VzYWJsZShldi50YXJnZXQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICBldi5wcmV2ZW50RGVmYXVsdCgpO1xyXG4gICAgICAgIGV2LnN0b3BQcm9wYWdhdGlvbigpO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogV2FsayB1cCB0aGUgZG9tIHRyeSB0byBmaW5kIGEgZm9jdXNhYmxlIGVsZW1lbnQuXHJcbiAgICAgKi9cclxuICAgIEZvY3VzWm9uZS5wcm90b3R5cGUuX3RyeUludm9rZUNsaWNrRm9yRm9jdXNhYmxlID0gZnVuY3Rpb24gKHRhcmdldCkge1xyXG4gICAgICAgIGlmICh0YXJnZXQgPT09IHRoaXMuX3Jvb3QpIHtcclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkbyB7XHJcbiAgICAgICAgICAgIGlmICh0YXJnZXQudGFnTmFtZSA9PT0gJ0JVVFRPTicgfHwgdGFyZ2V0LnRhZ05hbWUgPT09ICdBJyB8fCB0YXJnZXQudGFnTmFtZSA9PT0gJ0lOUFVUJyB8fCB0YXJnZXQudGFnTmFtZSA9PT0gJ1RFWFRBUkVBJykge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9pc0ltbWVkaWF0ZURlc2NlbmRhbnRPZlpvbmUodGFyZ2V0KSAmJlxyXG4gICAgICAgICAgICAgICAgdGFyZ2V0LmdldEF0dHJpYnV0ZShJU19GT0NVU0FCTEVfQVRUUklCVVRFKSA9PT0gJ3RydWUnICYmXHJcbiAgICAgICAgICAgICAgICB0YXJnZXQuZ2V0QXR0cmlidXRlKElTX0VOVEVSX0RJU0FCTEVEX0FUVFJJQlVURSkgIT09ICd0cnVlJykge1xyXG4gICAgICAgICAgICAgICAgVXRpbGl0aWVzXzEuRXZlbnRHcm91cC5yYWlzZSh0YXJnZXQsICdjbGljaycsIG51bGwsIHRydWUpO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgdGFyZ2V0ID0gVXRpbGl0aWVzXzEuZ2V0UGFyZW50KHRhcmdldCwgQUxMT1dfVklSVFVBTF9FTEVNRU5UUyk7XHJcbiAgICAgICAgfSB3aGlsZSAodGFyZ2V0ICE9PSB0aGlzLl9yb290KTtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBUcmF2ZXJzZSB0byBmaW5kIGZpcnN0IGNoaWxkIHpvbmUuXHJcbiAgICAgKi9cclxuICAgIEZvY3VzWm9uZS5wcm90b3R5cGUuX2dldEZpcnN0SW5uZXJab25lID0gZnVuY3Rpb24gKHJvb3RFbGVtZW50KSB7XHJcbiAgICAgICAgcm9vdEVsZW1lbnQgPSByb290RWxlbWVudCB8fCB0aGlzLl9hY3RpdmVFbGVtZW50IHx8IHRoaXMuX3Jvb3Q7XHJcbiAgICAgICAgaWYgKFV0aWxpdGllc18xLmlzRWxlbWVudEZvY3VzWm9uZShyb290RWxlbWVudCkpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9hbGxJbnN0YW5jZXNbcm9vdEVsZW1lbnQuZ2V0QXR0cmlidXRlKEZPQ1VTWk9ORV9JRF9BVFRSSUJVVEUpXTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGNoaWxkID0gcm9vdEVsZW1lbnQuZmlyc3RFbGVtZW50Q2hpbGQ7XHJcbiAgICAgICAgd2hpbGUgKGNoaWxkKSB7XHJcbiAgICAgICAgICAgIGlmIChVdGlsaXRpZXNfMS5pc0VsZW1lbnRGb2N1c1pvbmUoY2hpbGQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gX2FsbEluc3RhbmNlc1tjaGlsZC5nZXRBdHRyaWJ1dGUoRk9DVVNaT05FX0lEX0FUVFJJQlVURSldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHZhciBtYXRjaCA9IHRoaXMuX2dldEZpcnN0SW5uZXJab25lKGNoaWxkKTtcclxuICAgICAgICAgICAgaWYgKG1hdGNoKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gbWF0Y2g7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgY2hpbGQgPSBjaGlsZC5uZXh0RWxlbWVudFNpYmxpbmc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfTtcclxuICAgIEZvY3VzWm9uZS5wcm90b3R5cGUuX21vdmVGb2N1cyA9IGZ1bmN0aW9uIChpc0ZvcndhcmQsIGdldERpc3RhbmNlRnJvbUNlbnRlciwgZXYpIHtcclxuICAgICAgICB2YXIgZWxlbWVudCA9IHRoaXMuX2FjdGl2ZUVsZW1lbnQ7XHJcbiAgICAgICAgdmFyIGNhbmRpZGF0ZURpc3RhbmNlID0gLTE7XHJcbiAgICAgICAgdmFyIGNhbmRpZGF0ZUVsZW1lbnQgPSB1bmRlZmluZWQ7XHJcbiAgICAgICAgdmFyIGNoYW5nZWRGb2N1cyA9IGZhbHNlO1xyXG4gICAgICAgIHZhciBpc0JpZGlyZWN0aW9uYWwgPSB0aGlzLnByb3BzLmRpcmVjdGlvbiA9PT0gRm9jdXNab25lX3R5cGVzXzEuRm9jdXNab25lRGlyZWN0aW9uLmJpZGlyZWN0aW9uYWw7XHJcbiAgICAgICAgaWYgKCFlbGVtZW50KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHRoaXMuX2lzRWxlbWVudElucHV0KGVsZW1lbnQpKSB7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fc2hvdWxkSW5wdXRMb3NlRm9jdXMoZWxlbWVudCwgaXNGb3J3YXJkKSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBhY3RpdmVSZWN0ID0gaXNCaWRpcmVjdGlvbmFsID8gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKSA6IG51bGw7XHJcbiAgICAgICAgZG8ge1xyXG4gICAgICAgICAgICBlbGVtZW50ID0gKGlzRm9yd2FyZCA/XHJcbiAgICAgICAgICAgICAgICBVdGlsaXRpZXNfMS5nZXROZXh0RWxlbWVudCh0aGlzLl9yb290LCBlbGVtZW50KSA6XHJcbiAgICAgICAgICAgICAgICBVdGlsaXRpZXNfMS5nZXRQcmV2aW91c0VsZW1lbnQodGhpcy5fcm9vdCwgZWxlbWVudCkpO1xyXG4gICAgICAgICAgICBpZiAoaXNCaWRpcmVjdGlvbmFsKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoZWxlbWVudCkge1xyXG4gICAgICAgICAgICAgICAgICAgIHZhciB0YXJnZXRSZWN0ID0gZWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcclxuICAgICAgICAgICAgICAgICAgICB2YXIgZWxlbWVudERpc3RhbmNlID0gZ2V0RGlzdGFuY2VGcm9tQ2VudGVyKGFjdGl2ZVJlY3QsIHRhcmdldFJlY3QpO1xyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50RGlzdGFuY2UgPT09IC0xICYmIGNhbmRpZGF0ZURpc3RhbmNlID09PSAtMSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYW5kaWRhdGVFbGVtZW50ID0gZWxlbWVudDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChlbGVtZW50RGlzdGFuY2UgPiAtMSAmJiAoY2FuZGlkYXRlRGlzdGFuY2UgPT09IC0xIHx8IGVsZW1lbnREaXN0YW5jZSA8IGNhbmRpZGF0ZURpc3RhbmNlKSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYW5kaWRhdGVEaXN0YW5jZSA9IGVsZW1lbnREaXN0YW5jZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FuZGlkYXRlRWxlbWVudCA9IGVsZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChjYW5kaWRhdGVEaXN0YW5jZSA+PSAwICYmIGVsZW1lbnREaXN0YW5jZSA8IDApIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgY2FuZGlkYXRlRWxlbWVudCA9IGVsZW1lbnQ7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0gd2hpbGUgKGVsZW1lbnQpO1xyXG4gICAgICAgIC8vIEZvY3VzIHRoZSBjbG9zZXN0IGNhbmRpZGF0ZVxyXG4gICAgICAgIGlmIChjYW5kaWRhdGVFbGVtZW50ICYmIGNhbmRpZGF0ZUVsZW1lbnQgIT09IHRoaXMuX2FjdGl2ZUVsZW1lbnQpIHtcclxuICAgICAgICAgICAgY2hhbmdlZEZvY3VzID0gdHJ1ZTtcclxuICAgICAgICAgICAgdGhpcy5mb2N1c0VsZW1lbnQoY2FuZGlkYXRlRWxlbWVudCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMucHJvcHMuaXNDaXJjdWxhck5hdmlnYXRpb24pIHtcclxuICAgICAgICAgICAgaWYgKGlzRm9yd2FyZCkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZm9jdXNFbGVtZW50KFV0aWxpdGllc18xLmdldE5leHRFbGVtZW50KHRoaXMuX3Jvb3QsIHRoaXMuX3Jvb3QuZmlyc3RFbGVtZW50Q2hpbGQsIHRydWUpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmZvY3VzRWxlbWVudChVdGlsaXRpZXNfMS5nZXRQcmV2aW91c0VsZW1lbnQodGhpcy5fcm9vdCwgdGhpcy5fcm9vdC5sYXN0RWxlbWVudENoaWxkLCB0cnVlLCB0cnVlLCB0cnVlKSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGNoYW5nZWRGb2N1cztcclxuICAgIH07XHJcbiAgICBGb2N1c1pvbmUucHJvdG90eXBlLl9tb3ZlRm9jdXNEb3duID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciB0YXJnZXRUb3AgPSAtMTtcclxuICAgICAgICB2YXIgbGVmdEFsaWdubWVudCA9IHRoaXMuX2ZvY3VzQWxpZ25tZW50LmxlZnQ7XHJcbiAgICAgICAgaWYgKHRoaXMuX21vdmVGb2N1cyh0cnVlLCBmdW5jdGlvbiAoYWN0aXZlUmVjdCwgdGFyZ2V0UmVjdCkge1xyXG4gICAgICAgICAgICB2YXIgZGlzdGFuY2UgPSAtMTtcclxuICAgICAgICAgICAgLy8gQ2xpZW50UmVjdCB2YWx1ZXMgY2FuIGJlIGZsb2F0cyB0aGF0IGRpZmZlciBieSB2ZXJ5IHNtYWxsIGZyYWN0aW9ucyBvZiBhIGRlY2ltYWwuXHJcbiAgICAgICAgICAgIC8vIElmIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gdG9wIGFuZCBib3R0b20gYXJlIHdpdGhpbiBhIHBpeGVsIHRoZW4gd2Ugc2hvdWxkIHRyZWF0XHJcbiAgICAgICAgICAgIC8vIHRoZW0gYXMgZXF1aXZhbGVudCBieSB1c2luZyBNYXRoLmZsb29yLiBGb3IgaW5zdGFuY2UgNS4yMjIyIGFuZCA1LjIyMjIyMSBzaG91bGQgYmUgZXF1aXZhbGVudCxcclxuICAgICAgICAgICAgLy8gYnV0IHdpdGhvdXQgTWF0aC5GbG9vciB0aGV5IHdpbGwgYmUgaGFuZGxlZCBpbmNvcnJlY3RseS5cclxuICAgICAgICAgICAgdmFyIHRhcmdldFJlY3RUb3AgPSBNYXRoLmZsb29yKHRhcmdldFJlY3QudG9wKTtcclxuICAgICAgICAgICAgdmFyIGFjdGl2ZVJlY3RCb3R0b20gPSBNYXRoLmZsb29yKGFjdGl2ZVJlY3QuYm90dG9tKTtcclxuICAgICAgICAgICAgaWYgKHRhcmdldFJlY3RUb3AgPCBhY3RpdmVSZWN0Qm90dG9tKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gOTk5OTk5OTk5O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICgodGFyZ2V0VG9wID09PSAtMSAmJiB0YXJnZXRSZWN0VG9wID49IGFjdGl2ZVJlY3RCb3R0b20pIHx8XHJcbiAgICAgICAgICAgICAgICAodGFyZ2V0UmVjdFRvcCA9PT0gdGFyZ2V0VG9wKSkge1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0VG9wID0gdGFyZ2V0UmVjdFRvcDtcclxuICAgICAgICAgICAgICAgIGlmIChsZWZ0QWxpZ25tZW50ID49IHRhcmdldFJlY3QubGVmdCAmJiBsZWZ0QWxpZ25tZW50IDw9ICh0YXJnZXRSZWN0LmxlZnQgKyB0YXJnZXRSZWN0LndpZHRoKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIGRpc3RhbmNlID0gMDtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIGRpc3RhbmNlID0gTWF0aC5hYnMoKHRhcmdldFJlY3QubGVmdCArICh0YXJnZXRSZWN0LndpZHRoIC8gMikpIC0gbGVmdEFsaWdubWVudCk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGRpc3RhbmNlO1xyXG4gICAgICAgIH0pKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3NldEZvY3VzQWxpZ25tZW50KHRoaXMuX2FjdGl2ZUVsZW1lbnQsIGZhbHNlLCB0cnVlKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH07XHJcbiAgICBGb2N1c1pvbmUucHJvdG90eXBlLl9tb3ZlRm9jdXNVcCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgdGFyZ2V0VG9wID0gLTE7XHJcbiAgICAgICAgdmFyIGxlZnRBbGlnbm1lbnQgPSB0aGlzLl9mb2N1c0FsaWdubWVudC5sZWZ0O1xyXG4gICAgICAgIGlmICh0aGlzLl9tb3ZlRm9jdXMoZmFsc2UsIGZ1bmN0aW9uIChhY3RpdmVSZWN0LCB0YXJnZXRSZWN0KSB7XHJcbiAgICAgICAgICAgIHZhciBkaXN0YW5jZSA9IC0xO1xyXG4gICAgICAgICAgICAvLyBDbGllbnRSZWN0IHZhbHVlcyBjYW4gYmUgZmxvYXRzIHRoYXQgZGlmZmVyIGJ5IHZlcnkgc21hbGwgZnJhY3Rpb25zIG9mIGEgZGVjaW1hbC5cclxuICAgICAgICAgICAgLy8gSWYgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiB0b3AgYW5kIGJvdHRvbSBhcmUgd2l0aGluIGEgcGl4ZWwgdGhlbiB3ZSBzaG91bGQgdHJlYXRcclxuICAgICAgICAgICAgLy8gdGhlbSBhcyBlcXVpdmFsZW50IGJ5IHVzaW5nIE1hdGguZmxvb3IuIEZvciBpbnN0YW5jZSA1LjIyMjIgYW5kIDUuMjIyMjIxIHNob3VsZCBiZSBlcXVpdmFsZW50LFxyXG4gICAgICAgICAgICAvLyBidXQgd2l0aG91dCBNYXRoLkZsb29yIHRoZXkgd2lsbCBiZSBoYW5kbGVkIGluY29ycmVjdGx5LlxyXG4gICAgICAgICAgICB2YXIgdGFyZ2V0UmVjdEJvdHRvbSA9IE1hdGguZmxvb3IodGFyZ2V0UmVjdC5ib3R0b20pO1xyXG4gICAgICAgICAgICB2YXIgdGFyZ2V0UmVjdFRvcCA9IE1hdGguZmxvb3IodGFyZ2V0UmVjdC50b3ApO1xyXG4gICAgICAgICAgICB2YXIgYWN0aXZlUmVjdFRvcCA9IE1hdGguZmxvb3IoYWN0aXZlUmVjdC50b3ApO1xyXG4gICAgICAgICAgICBpZiAodGFyZ2V0UmVjdEJvdHRvbSA+IGFjdGl2ZVJlY3RUb3ApIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiA5OTk5OTk5OTk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKCh0YXJnZXRUb3AgPT09IC0xICYmIHRhcmdldFJlY3RCb3R0b20gPD0gYWN0aXZlUmVjdFRvcCkgfHxcclxuICAgICAgICAgICAgICAgICh0YXJnZXRSZWN0VG9wID09PSB0YXJnZXRUb3ApKSB7XHJcbiAgICAgICAgICAgICAgICB0YXJnZXRUb3AgPSB0YXJnZXRSZWN0VG9wO1xyXG4gICAgICAgICAgICAgICAgaWYgKGxlZnRBbGlnbm1lbnQgPj0gdGFyZ2V0UmVjdC5sZWZ0ICYmIGxlZnRBbGlnbm1lbnQgPD0gKHRhcmdldFJlY3QubGVmdCArIHRhcmdldFJlY3Qud2lkdGgpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlzdGFuY2UgPSAwO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgZGlzdGFuY2UgPSBNYXRoLmFicygodGFyZ2V0UmVjdC5sZWZ0ICsgKHRhcmdldFJlY3Qud2lkdGggLyAyKSkgLSBsZWZ0QWxpZ25tZW50KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZGlzdGFuY2U7XHJcbiAgICAgICAgfSkpIHtcclxuICAgICAgICAgICAgdGhpcy5fc2V0Rm9jdXNBbGlnbm1lbnQodGhpcy5fYWN0aXZlRWxlbWVudCwgZmFsc2UsIHRydWUpO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfTtcclxuICAgIEZvY3VzWm9uZS5wcm90b3R5cGUuX21vdmVGb2N1c0xlZnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICBpZiAodGhpcy5fbW92ZUZvY3VzKFV0aWxpdGllc18xLmdldFJUTCgpLCBmdW5jdGlvbiAoYWN0aXZlUmVjdCwgdGFyZ2V0UmVjdCkge1xyXG4gICAgICAgICAgICB2YXIgZGlzdGFuY2UgPSAtMTtcclxuICAgICAgICAgICAgaWYgKHRhcmdldFJlY3QuYm90dG9tID4gYWN0aXZlUmVjdC50b3AgJiZcclxuICAgICAgICAgICAgICAgIHRhcmdldFJlY3QucmlnaHQgPD0gYWN0aXZlUmVjdC5yaWdodCAmJlxyXG4gICAgICAgICAgICAgICAgX3RoaXMucHJvcHMuZGlyZWN0aW9uICE9PSBGb2N1c1pvbmVfdHlwZXNfMS5Gb2N1c1pvbmVEaXJlY3Rpb24udmVydGljYWwpIHtcclxuICAgICAgICAgICAgICAgIGRpc3RhbmNlID0gYWN0aXZlUmVjdC5yaWdodCAtIHRhcmdldFJlY3QucmlnaHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGRpc3RhbmNlO1xyXG4gICAgICAgIH0pKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3NldEZvY3VzQWxpZ25tZW50KHRoaXMuX2FjdGl2ZUVsZW1lbnQsIHRydWUsIGZhbHNlKTtcclxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH07XHJcbiAgICBGb2N1c1pvbmUucHJvdG90eXBlLl9tb3ZlRm9jdXNSaWdodCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIGlmICh0aGlzLl9tb3ZlRm9jdXMoIVV0aWxpdGllc18xLmdldFJUTCgpLCBmdW5jdGlvbiAoYWN0aXZlUmVjdCwgdGFyZ2V0UmVjdCkge1xyXG4gICAgICAgICAgICB2YXIgZGlzdGFuY2UgPSAtMTtcclxuICAgICAgICAgICAgaWYgKHRhcmdldFJlY3QudG9wIDwgYWN0aXZlUmVjdC5ib3R0b20gJiZcclxuICAgICAgICAgICAgICAgIHRhcmdldFJlY3QubGVmdCA+PSBhY3RpdmVSZWN0LmxlZnQgJiZcclxuICAgICAgICAgICAgICAgIF90aGlzLnByb3BzLmRpcmVjdGlvbiAhPT0gRm9jdXNab25lX3R5cGVzXzEuRm9jdXNab25lRGlyZWN0aW9uLnZlcnRpY2FsKSB7XHJcbiAgICAgICAgICAgICAgICBkaXN0YW5jZSA9IHRhcmdldFJlY3QubGVmdCAtIGFjdGl2ZVJlY3QubGVmdDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICByZXR1cm4gZGlzdGFuY2U7XHJcbiAgICAgICAgfSkpIHtcclxuICAgICAgICAgICAgdGhpcy5fc2V0Rm9jdXNBbGlnbm1lbnQodGhpcy5fYWN0aXZlRWxlbWVudCwgdHJ1ZSwgZmFsc2UpO1xyXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfTtcclxuICAgIEZvY3VzWm9uZS5wcm90b3R5cGUuX3NldEZvY3VzQWxpZ25tZW50ID0gZnVuY3Rpb24gKGVsZW1lbnQsIGlzSG9yaXpvbnRhbCwgaXNWZXJ0aWNhbCkge1xyXG4gICAgICAgIGlmICh0aGlzLnByb3BzLmRpcmVjdGlvbiA9PT0gRm9jdXNab25lX3R5cGVzXzEuRm9jdXNab25lRGlyZWN0aW9uLmJpZGlyZWN0aW9uYWwgJiZcclxuICAgICAgICAgICAgKCF0aGlzLl9mb2N1c0FsaWdubWVudCB8fCBpc0hvcml6b250YWwgfHwgaXNWZXJ0aWNhbCkpIHtcclxuICAgICAgICAgICAgdmFyIHJlY3QgPSBlbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xyXG4gICAgICAgICAgICB2YXIgbGVmdCA9IHJlY3QubGVmdCArIChyZWN0LndpZHRoIC8gMik7XHJcbiAgICAgICAgICAgIHZhciB0b3BfMSA9IHJlY3QudG9wICsgKHJlY3QuaGVpZ2h0IC8gMik7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fZm9jdXNBbGlnbm1lbnQpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2ZvY3VzQWxpZ25tZW50ID0geyBsZWZ0OiBsZWZ0LCB0b3A6IHRvcF8xIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGlzSG9yaXpvbnRhbCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fZm9jdXNBbGlnbm1lbnQubGVmdCA9IGxlZnQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgaWYgKGlzVmVydGljYWwpIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2ZvY3VzQWxpZ25tZW50LnRvcCA9IHRvcF8xO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEZvY3VzWm9uZS5wcm90b3R5cGUuX2lzSW1tZWRpYXRlRGVzY2VuZGFudE9mWm9uZSA9IGZ1bmN0aW9uIChlbGVtZW50KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2dldE93bmVyWm9uZShlbGVtZW50KSA9PT0gdGhpcy5fcm9vdDtcclxuICAgIH07XHJcbiAgICBGb2N1c1pvbmUucHJvdG90eXBlLl9nZXRPd25lclpvbmUgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xyXG4gICAgICAgIHZhciBwYXJlbnRFbGVtZW50ID0gVXRpbGl0aWVzXzEuZ2V0UGFyZW50KGVsZW1lbnQsIEFMTE9XX1ZJUlRVQUxfRUxFTUVOVFMpO1xyXG4gICAgICAgIHdoaWxlIChwYXJlbnRFbGVtZW50ICYmIHBhcmVudEVsZW1lbnQgIT09IHRoaXMuX3Jvb3QgJiYgcGFyZW50RWxlbWVudCAhPT0gZG9jdW1lbnQuYm9keSkge1xyXG4gICAgICAgICAgICBpZiAoVXRpbGl0aWVzXzEuaXNFbGVtZW50Rm9jdXNab25lKHBhcmVudEVsZW1lbnQpKSB7XHJcbiAgICAgICAgICAgICAgICByZXR1cm4gcGFyZW50RWxlbWVudDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBwYXJlbnRFbGVtZW50ID0gVXRpbGl0aWVzXzEuZ2V0UGFyZW50KHBhcmVudEVsZW1lbnQsIEFMTE9XX1ZJUlRVQUxfRUxFTUVOVFMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGhpcy5fcm9vdDtcclxuICAgIH07XHJcbiAgICBGb2N1c1pvbmUucHJvdG90eXBlLl91cGRhdGVUYWJJbmRleGVzID0gZnVuY3Rpb24gKGVsZW1lbnQpIHtcclxuICAgICAgICBpZiAoIWVsZW1lbnQpIHtcclxuICAgICAgICAgICAgdGhpcy5fZGVmYXVsdEZvY3VzRWxlbWVudCA9IG51bGw7XHJcbiAgICAgICAgICAgIGVsZW1lbnQgPSB0aGlzLl9yb290O1xyXG4gICAgICAgICAgICBpZiAodGhpcy5fYWN0aXZlRWxlbWVudCAmJiAhVXRpbGl0aWVzXzEuZWxlbWVudENvbnRhaW5zKGVsZW1lbnQsIHRoaXMuX2FjdGl2ZUVsZW1lbnQpKSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9hY3RpdmVFbGVtZW50ID0gbnVsbDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICAvLyBJZiBhY3RpdmUgZWxlbWVudCBjaGFuZ2VzIHN0YXRlIHRvIGRpc2FibGVkLCBzZXQgaXQgdG8gbnVsbC5cclxuICAgICAgICAvLyBPdGhlcndpc2UsIHdlIGxvc2Uga2V5Ym9hcmQgYWNjZXNzaWJpbGl0eSB0byBvdGhlciBlbGVtZW50cyBpbiBmb2N1cyB6b25lLlxyXG4gICAgICAgIGlmICh0aGlzLl9hY3RpdmVFbGVtZW50ICYmICFVdGlsaXRpZXNfMS5pc0VsZW1lbnRUYWJiYWJsZSh0aGlzLl9hY3RpdmVFbGVtZW50KSkge1xyXG4gICAgICAgICAgICB0aGlzLl9hY3RpdmVFbGVtZW50ID0gbnVsbDtcclxuICAgICAgICB9XHJcbiAgICAgICAgdmFyIGNoaWxkTm9kZXMgPSBlbGVtZW50LmNoaWxkcmVuO1xyXG4gICAgICAgIGZvciAodmFyIGNoaWxkSW5kZXggPSAwOyBjaGlsZE5vZGVzICYmIGNoaWxkSW5kZXggPCBjaGlsZE5vZGVzLmxlbmd0aDsgY2hpbGRJbmRleCsrKSB7XHJcbiAgICAgICAgICAgIHZhciBjaGlsZCA9IGNoaWxkTm9kZXNbY2hpbGRJbmRleF07XHJcbiAgICAgICAgICAgIGlmICghVXRpbGl0aWVzXzEuaXNFbGVtZW50Rm9jdXNab25lKGNoaWxkKSkge1xyXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGl0ZW0gaXMgZXhwbGljaXRseSBzZXQgdG8gbm90IGJlIGZvY3VzYWJsZSB0aGVuIFRBQklOREVYIG5lZWRzIHRvIGJlIHNldCB0byAtMS5cclxuICAgICAgICAgICAgICAgIGlmIChjaGlsZC5nZXRBdHRyaWJ1dGUgJiYgY2hpbGQuZ2V0QXR0cmlidXRlKElTX0ZPQ1VTQUJMRV9BVFRSSUJVVEUpID09PSAnZmFsc2UnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQuc2V0QXR0cmlidXRlKFRBQklOREVYLCAnLTEnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGlmIChVdGlsaXRpZXNfMS5pc0VsZW1lbnRUYWJiYWJsZShjaGlsZCkpIHtcclxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5wcm9wcy5kaXNhYmxlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjaGlsZC5zZXRBdHRyaWJ1dGUoVEFCSU5ERVgsICctMScpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmICghdGhpcy5faXNJbm5lclpvbmUgJiYgKCghdGhpcy5fYWN0aXZlRWxlbWVudCAmJiAhdGhpcy5fZGVmYXVsdEZvY3VzRWxlbWVudCkgfHwgdGhpcy5fYWN0aXZlRWxlbWVudCA9PT0gY2hpbGQpKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX2RlZmF1bHRGb2N1c0VsZW1lbnQgPSBjaGlsZDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNoaWxkLmdldEF0dHJpYnV0ZShUQUJJTkRFWCkgIT09ICcwJykge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQuc2V0QXR0cmlidXRlKFRBQklOREVYLCAnMCcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKGNoaWxkLmdldEF0dHJpYnV0ZShUQUJJTkRFWCkgIT09ICctMScpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2hpbGQuc2V0QXR0cmlidXRlKFRBQklOREVYLCAnLTEnKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjaGlsZC50YWdOYW1lID09PSAnc3ZnJyAmJiBjaGlsZC5nZXRBdHRyaWJ1dGUoJ2ZvY3VzYWJsZScpICE9PSAnZmFsc2UnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gRGlzZ3VzdGluZyBJRSBoYWNrLiBTYWQgZmFjZS5cclxuICAgICAgICAgICAgICAgICAgICBjaGlsZC5zZXRBdHRyaWJ1dGUoJ2ZvY3VzYWJsZScsICdmYWxzZScpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGVsc2UgaWYgKGNoaWxkLmdldEF0dHJpYnV0ZShJU19GT0NVU0FCTEVfQVRUUklCVVRFKSA9PT0gJ3RydWUnKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoIXRoaXMuX2lzSW5uZXJab25lICYmICgoIXRoaXMuX2FjdGl2ZUVsZW1lbnQgJiYgIXRoaXMuX2RlZmF1bHRGb2N1c0VsZW1lbnQpIHx8IHRoaXMuX2FjdGl2ZUVsZW1lbnQgPT09IGNoaWxkKSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2RlZmF1bHRGb2N1c0VsZW1lbnQgPSBjaGlsZDtcclxuICAgICAgICAgICAgICAgICAgICBpZiAoY2hpbGQuZ2V0QXR0cmlidXRlKFRBQklOREVYKSAhPT0gJzAnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNoaWxkLnNldEF0dHJpYnV0ZShUQUJJTkRFWCwgJzAnKTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjaGlsZC5nZXRBdHRyaWJ1dGUoVEFCSU5ERVgpICE9PSAnLTEnKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2hpbGQuc2V0QXR0cmlidXRlKFRBQklOREVYLCAnLTEnKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB0aGlzLl91cGRhdGVUYWJJbmRleGVzKGNoaWxkKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgRm9jdXNab25lLnByb3RvdHlwZS5faXNFbGVtZW50SW5wdXQgPSBmdW5jdGlvbiAoZWxlbWVudCkge1xyXG4gICAgICAgIGlmIChlbGVtZW50ICYmIGVsZW1lbnQudGFnTmFtZSAmJiAoZWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdpbnB1dCcgfHwgZWxlbWVudC50YWdOYW1lLnRvTG93ZXJDYXNlKCkgPT09ICd0ZXh0YXJlYScpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgRm9jdXNab25lLnByb3RvdHlwZS5fc2hvdWxkSW5wdXRMb3NlRm9jdXMgPSBmdW5jdGlvbiAoZWxlbWVudCwgaXNGb3J3YXJkKSB7XHJcbiAgICAgICAgaWYgKGVsZW1lbnQgJiZcclxuICAgICAgICAgICAgZWxlbWVudC50eXBlICYmXHJcbiAgICAgICAgICAgIEFMTE9XRURfSU5QVVRfVFlQRVMuaW5kZXhPZihlbGVtZW50LnR5cGUudG9Mb3dlckNhc2UoKSkgPiAtMSkge1xyXG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9uU3RhcnQgPSBlbGVtZW50LnNlbGVjdGlvblN0YXJ0O1xyXG4gICAgICAgICAgICB2YXIgc2VsZWN0aW9uRW5kID0gZWxlbWVudC5zZWxlY3Rpb25FbmQ7XHJcbiAgICAgICAgICAgIHZhciBpc1JhbmdlU2VsZWN0ZWQgPSBzZWxlY3Rpb25TdGFydCAhPT0gc2VsZWN0aW9uRW5kO1xyXG4gICAgICAgICAgICB2YXIgaW5wdXRWYWx1ZSA9IGVsZW1lbnQudmFsdWU7XHJcbiAgICAgICAgICAgIC8vIFdlIHNob3VsZG4ndCBsb3NlIGZvY3VzIGluIHRoZSBmb2xsb3dpbmcgY2FzZXM6XHJcbiAgICAgICAgICAgIC8vIDEuIFRoZXJlIGlzIHJhbmdlIHNlbGVjdGVkLlxyXG4gICAgICAgICAgICAvLyAyLiBXaGVuIHNlbGVjdGlvbiBzdGFydCBpcyBsYXJnZXIgdGhhbiAwIGFuZCBpdCBpcyBiYWNrd2FyZC5cclxuICAgICAgICAgICAgLy8gMy4gd2hlbiBzZWxlY3Rpb24gc3RhcnQgaXMgbm90IHRoZSBlbmQgb2YgbGVuZ2h0IGFuZCBpdCBpcyBmb3J3YXJkLlxyXG4gICAgICAgICAgICBpZiAoaXNSYW5nZVNlbGVjdGVkIHx8XHJcbiAgICAgICAgICAgICAgICAoc2VsZWN0aW9uU3RhcnQgPiAwICYmICFpc0ZvcndhcmQpIHx8XHJcbiAgICAgICAgICAgICAgICAoc2VsZWN0aW9uU3RhcnQgIT09IGlucHV0VmFsdWUubGVuZ3RoICYmIGlzRm9yd2FyZCkpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdHJ1ZTtcclxuICAgIH07XHJcbiAgICBGb2N1c1pvbmUuZGVmYXVsdFByb3BzID0ge1xyXG4gICAgICAgIGlzQ2lyY3VsYXJOYXZpZ2F0aW9uOiBmYWxzZSxcclxuICAgICAgICBkaXJlY3Rpb246IEZvY3VzWm9uZV90eXBlc18xLkZvY3VzWm9uZURpcmVjdGlvbi5iaWRpcmVjdGlvbmFsXHJcbiAgICB9O1xyXG4gICAgdHNsaWJfMS5fX2RlY29yYXRlKFtcclxuICAgICAgICBVdGlsaXRpZXNfMS5hdXRvYmluZFxyXG4gICAgXSwgRm9jdXNab25lLnByb3RvdHlwZSwgXCJfb25Gb2N1c1wiLCBudWxsKTtcclxuICAgIHRzbGliXzEuX19kZWNvcmF0ZShbXHJcbiAgICAgICAgVXRpbGl0aWVzXzEuYXV0b2JpbmRcclxuICAgIF0sIEZvY3VzWm9uZS5wcm90b3R5cGUsIFwiX29uTW91c2VEb3duXCIsIG51bGwpO1xyXG4gICAgdHNsaWJfMS5fX2RlY29yYXRlKFtcclxuICAgICAgICBVdGlsaXRpZXNfMS5hdXRvYmluZFxyXG4gICAgXSwgRm9jdXNab25lLnByb3RvdHlwZSwgXCJfb25LZXlEb3duXCIsIG51bGwpO1xyXG4gICAgcmV0dXJuIEZvY3VzWm9uZTtcclxufShVdGlsaXRpZXNfMS5CYXNlQ29tcG9uZW50KSk7XHJcbmV4cG9ydHMuRm9jdXNab25lID0gRm9jdXNab25lO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1Gb2N1c1pvbmUuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIEZvY3VzWm9uZURpcmVjdGlvbjtcclxuKGZ1bmN0aW9uIChGb2N1c1pvbmVEaXJlY3Rpb24pIHtcclxuICAgIC8qKiBPbmx5IHJlYWN0IHRvIHVwL2Rvd24gYXJyb3dzLiAqL1xyXG4gICAgRm9jdXNab25lRGlyZWN0aW9uW0ZvY3VzWm9uZURpcmVjdGlvbltcInZlcnRpY2FsXCJdID0gMF0gPSBcInZlcnRpY2FsXCI7XHJcbiAgICAvKiogT25seSByZWFjdCB0byBsZWZ0L3JpZ2h0IGFycm93cy4gKi9cclxuICAgIEZvY3VzWm9uZURpcmVjdGlvbltGb2N1c1pvbmVEaXJlY3Rpb25bXCJob3Jpem9udGFsXCJdID0gMV0gPSBcImhvcml6b250YWxcIjtcclxuICAgIC8qKiBSZWFjdCB0byBhbGwgYXJyb3dzLiAqL1xyXG4gICAgRm9jdXNab25lRGlyZWN0aW9uW0ZvY3VzWm9uZURpcmVjdGlvbltcImJpZGlyZWN0aW9uYWxcIl0gPSAyXSA9IFwiYmlkaXJlY3Rpb25hbFwiO1xyXG59KShGb2N1c1pvbmVEaXJlY3Rpb24gPSBleHBvcnRzLkZvY3VzWm9uZURpcmVjdGlvbiB8fCAoZXhwb3J0cy5Gb2N1c1pvbmVEaXJlY3Rpb24gPSB7fSkpO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1Gb2N1c1pvbmUudHlwZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XHJcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL0ZvY3VzWm9uZVwiKSwgZXhwb3J0cyk7XHJcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL0ZvY3VzWm9uZS50eXBlc1wiKSwgZXhwb3J0cyk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciBTdHlsaW5nXzEgPSByZXF1aXJlKFwiLi4vLi4vU3R5bGluZ1wiKTtcclxudmFyIFV0aWxpdGllc18xID0gcmVxdWlyZShcIi4uLy4uL1V0aWxpdGllc1wiKTtcclxuZXhwb3J0cy5nZXRDbGFzc05hbWVzID0gVXRpbGl0aWVzXzEubWVtb2l6ZUZ1bmN0aW9uKGZ1bmN0aW9uIChjdXN0b21TdHlsZXMpIHtcclxuICAgIHJldHVybiBTdHlsaW5nXzEubWVyZ2VTdHlsZVNldHMoe1xyXG4gICAgICAgIHJvb3Q6IHtcclxuICAgICAgICAgICAgZGlzcGxheTogJ2lubGluZS1ibG9jaydcclxuICAgICAgICB9LFxyXG4gICAgICAgIHJvb3RIYXNQbGFjZUhvbGRlcjoge1xyXG4gICAgICAgICAgICB3aWR0aDogJzFlbSdcclxuICAgICAgICB9LFxyXG4gICAgICAgIGltYWdlQ29udGFpbmVyOiB7XHJcbiAgICAgICAgICAgIG92ZXJmbG93OiAnaGlkZGVuJ1xyXG4gICAgICAgIH1cclxuICAgIH0sIGN1c3RvbVN0eWxlcyk7XHJcbn0pO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1JY29uLmNsYXNzTmFtZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XHJcbi8qIHRzbGludDpkaXNhYmxlICovXHJcbnZhciBSZWFjdCA9IHJlcXVpcmUoXCJyZWFjdFwiKTtcclxuLyogdHNsaW50OmVuYWJsZSAqL1xyXG52YXIgSWNvbl90eXBlc18xID0gcmVxdWlyZShcIi4vSWNvbi50eXBlc1wiKTtcclxudmFyIEltYWdlXzEgPSByZXF1aXJlKFwiLi4vSW1hZ2UvSW1hZ2VcIik7XHJcbnZhciBVdGlsaXRpZXNfMSA9IHJlcXVpcmUoXCIuLi8uLi9VdGlsaXRpZXNcIik7XHJcbnZhciBTdHlsaW5nXzEgPSByZXF1aXJlKFwiLi4vLi4vU3R5bGluZ1wiKTtcclxudmFyIEljb25fY2xhc3NOYW1lc18xID0gcmVxdWlyZShcIi4vSWNvbi5jbGFzc05hbWVzXCIpO1xyXG5leHBvcnRzLkljb24gPSBmdW5jdGlvbiAocHJvcHMpIHtcclxuICAgIHZhciBhcmlhTGFiZWwgPSBwcm9wcy5hcmlhTGFiZWwsIGNsYXNzTmFtZSA9IHByb3BzLmNsYXNzTmFtZSwgc3R5bGVzID0gcHJvcHMuc3R5bGVzLCBpY29uTmFtZSA9IHByb3BzLmljb25OYW1lO1xyXG4gICAgdmFyIGNsYXNzTmFtZXMgPSBJY29uX2NsYXNzTmFtZXNfMS5nZXRDbGFzc05hbWVzKHN0eWxlcyk7XHJcbiAgICBpZiAocHJvcHMuaWNvblR5cGUgPT09IEljb25fdHlwZXNfMS5JY29uVHlwZS5pbWFnZSB8fCBwcm9wcy5pY29uVHlwZSA9PT0gSWNvbl90eXBlc18xLkljb25UeXBlLkltYWdlKSB7XHJcbiAgICAgICAgdmFyIGNvbnRhaW5lckNsYXNzTmFtZSA9IFV0aWxpdGllc18xLmNzcygnbXMtSWNvbicsICdtcy1JY29uLWltYWdlQ29udGFpbmVyJywgY2xhc3NOYW1lcy5yb290LCBjbGFzc05hbWVzLmltYWdlQ29udGFpbmVyLCBjbGFzc05hbWUpO1xyXG4gICAgICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCB7IGNsYXNzTmFtZTogVXRpbGl0aWVzXzEuY3NzKGNvbnRhaW5lckNsYXNzTmFtZSwgY2xhc3NOYW1lcy5yb290KSB9LFxyXG4gICAgICAgICAgICBSZWFjdC5jcmVhdGVFbGVtZW50KEltYWdlXzEuSW1hZ2UsIHRzbGliXzEuX19hc3NpZ24oe30sIHByb3BzLmltYWdlUHJvcHMpKSkpO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodHlwZW9mIGljb25OYW1lID09PSAnc3RyaW5nJyAmJiBpY29uTmFtZS5sZW5ndGggPT09IDApIHtcclxuICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJpXCIsIHRzbGliXzEuX19hc3NpZ24oeyBcImFyaWEtbGFiZWxcIjogYXJpYUxhYmVsIH0sIChhcmlhTGFiZWwgPyB7fSA6IHtcclxuICAgICAgICAgICAgcm9sZTogJ3ByZXNlbnRhdGlvbicsXHJcbiAgICAgICAgICAgICdhcmlhLWhpZGRlbic6IHRydWVcclxuICAgICAgICB9KSwgVXRpbGl0aWVzXzEuZ2V0TmF0aXZlUHJvcHMocHJvcHMsIFV0aWxpdGllc18xLmh0bWxFbGVtZW50UHJvcGVydGllcyksIHsgY2xhc3NOYW1lOiBVdGlsaXRpZXNfMS5jc3MoJ21zLUljb24gbXMtSWNvbi1wbGFjZUhvbGRlcicsIGNsYXNzTmFtZXMucm9vdEhhc1BsYWNlSG9sZGVyLCBwcm9wcy5jbGFzc05hbWUpIH0pKSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB2YXIgaWNvbkRlZmluaXRpb24gPSBTdHlsaW5nXzEuZ2V0SWNvbihpY29uTmFtZSkgfHwge1xyXG4gICAgICAgICAgICBzdWJzZXQ6IHtcclxuICAgICAgICAgICAgICAgIGNsYXNzTmFtZTogdW5kZWZpbmVkXHJcbiAgICAgICAgICAgIH0sXHJcbiAgICAgICAgICAgIGNvZGU6IHVuZGVmaW5lZFxyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiaVwiLCB0c2xpYl8xLl9fYXNzaWduKHsgXCJhcmlhLWxhYmVsXCI6IGFyaWFMYWJlbCB9LCAoYXJpYUxhYmVsID8ge30gOiB7XHJcbiAgICAgICAgICAgIHJvbGU6ICdwcmVzZW50YXRpb24nLFxyXG4gICAgICAgICAgICAnYXJpYS1oaWRkZW4nOiB0cnVlLFxyXG4gICAgICAgICAgICAnZGF0YS1pY29uLW5hbWUnOiBpY29uTmFtZSxcclxuICAgICAgICB9KSwgVXRpbGl0aWVzXzEuZ2V0TmF0aXZlUHJvcHMocHJvcHMsIFV0aWxpdGllc18xLmh0bWxFbGVtZW50UHJvcGVydGllcyksIHsgY2xhc3NOYW1lOiBVdGlsaXRpZXNfMS5jc3MoJ21zLUljb24nLCAvLyBkYW5nZXJvdXM/XHJcbiAgICAgICAgICAgIGljb25EZWZpbml0aW9uLnN1YnNldC5jbGFzc05hbWUsIGNsYXNzTmFtZXMucm9vdCwgcHJvcHMuY2xhc3NOYW1lKSB9KSwgaWNvbkRlZmluaXRpb24uY29kZSkpO1xyXG4gICAgfVxyXG59O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1JY29uLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbi8vIFBsZWFzZSBrZWVwIGFscGhhYmV0aXplZFxyXG52YXIgSWNvblR5cGU7XHJcbihmdW5jdGlvbiAoSWNvblR5cGUpIHtcclxuICAgIC8qKlxyXG4gICAgICogUmVuZGVyIHVzaW5nIHRoZSBmYWJyaWMgaWNvbiBmb250LlxyXG4gICAgICovXHJcbiAgICBJY29uVHlwZVtJY29uVHlwZVtcImRlZmF1bHRcIl0gPSAwXSA9IFwiZGVmYXVsdFwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZW5kZXIgdXNpbmcgYW4gaW1hZ2UsIHdoZXJlIGltYWdlUHJvcHMgd291bGQgYmUgdXNlZC5cclxuICAgICAqL1xyXG4gICAgSWNvblR5cGVbSWNvblR5cGVbXCJpbWFnZVwiXSA9IDFdID0gXCJpbWFnZVwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBEZXByZWNhdGVkLCB1c2UgZGVmYXVsdC5cclxuICAgICAqIEBkZXByZWNhdGVkXHJcbiAgICAgKi9cclxuICAgIEljb25UeXBlW0ljb25UeXBlW1wiRGVmYXVsdFwiXSA9IDEwMDAwMF0gPSBcIkRlZmF1bHRcIjtcclxuICAgIC8qKlxyXG4gICAgICogRGVwcmVjYXRlZCwgdXNlIGltYWdlLlxyXG4gICAgICogQGRlcHJlY2F0ZWRcclxuICAgICAqL1xyXG4gICAgSWNvblR5cGVbSWNvblR5cGVbXCJJbWFnZVwiXSA9IDEwMDAwMV0gPSBcIkltYWdlXCI7XHJcbn0pKEljb25UeXBlID0gZXhwb3J0cy5JY29uVHlwZSB8fCAoZXhwb3J0cy5JY29uVHlwZSA9IHt9KSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUljb24udHlwZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XHJcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL0ljb25cIiksIGV4cG9ydHMpO1xyXG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9JY29uLnR5cGVzXCIpLCBleHBvcnRzKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XHJcbi8qIHRzbGludDpkaXNhYmxlOm5vLXVudXNlZC12YXJpYWJsZSAqL1xyXG52YXIgUmVhY3QgPSByZXF1aXJlKFwicmVhY3RcIik7XHJcbi8qIHRzbGludDplbmFibGU6bm8tdW51c2VkLXZhcmlhYmxlICovXHJcbnZhciBVdGlsaXRpZXNfMSA9IHJlcXVpcmUoXCIuLi8uLi9VdGlsaXRpZXNcIik7XHJcbnZhciBJbWFnZV90eXBlc18xID0gcmVxdWlyZShcIi4vSW1hZ2UudHlwZXNcIik7XHJcbnZhciBTdHlsaW5nXzEgPSByZXF1aXJlKFwiLi4vLi4vU3R5bGluZ1wiKTtcclxudmFyIHN0eWxlc0ltcG9ydCA9IHJlcXVpcmUoXCIuL0ltYWdlLnNjc3NcIik7XHJcbnZhciBzdHlsZXMgPSBzdHlsZXNJbXBvcnQ7XHJcbmV4cG9ydHMuQ292ZXJTdHlsZU1hcCA9IChfYSA9IHt9LFxyXG4gICAgX2FbSW1hZ2VfdHlwZXNfMS5JbWFnZUNvdmVyU3R5bGUubGFuZHNjYXBlXSA9ICdtcy1JbWFnZS1pbWFnZS0tbGFuZHNjYXBlICcgKyBzdHlsZXMuaW1hZ2VJc0xhbmRzY2FwZSxcclxuICAgIF9hW0ltYWdlX3R5cGVzXzEuSW1hZ2VDb3ZlclN0eWxlLnBvcnRyYWl0XSA9ICdtcy1JbWFnZS1pbWFnZS0tcG9ydHJhaXQgJyArIHN0eWxlcy5pbWFnZUlzUG9ydHJhaXQsXHJcbiAgICBfYSk7XHJcbmV4cG9ydHMuSW1hZ2VGaXRNYXAgPSAoX2IgPSB7fSxcclxuICAgIF9iW0ltYWdlX3R5cGVzXzEuSW1hZ2VGaXQuY2VudGVyXSA9ICdtcy1JbWFnZS1pbWFnZS0tY2VudGVyICcgKyBzdHlsZXMuaW1hZ2VJc0NlbnRlcixcclxuICAgIF9iW0ltYWdlX3R5cGVzXzEuSW1hZ2VGaXQuY29udGFpbl0gPSAnbXMtSW1hZ2UtaW1hZ2UtLWNvbnRhaW4gJyArIHN0eWxlcy5pbWFnZUlzQ29udGFpbixcclxuICAgIF9iW0ltYWdlX3R5cGVzXzEuSW1hZ2VGaXQuY292ZXJdID0gJ21zLUltYWdlLWltYWdlLS1jb3ZlciAnICsgc3R5bGVzLmltYWdlSXNDb3ZlcixcclxuICAgIF9iW0ltYWdlX3R5cGVzXzEuSW1hZ2VGaXQubm9uZV0gPSAnbXMtSW1hZ2UtaW1hZ2UtLW5vbmUgJyArIHN0eWxlcy5pbWFnZUlzTm9uZSxcclxuICAgIF9iKTtcclxudmFyIEtFWV9QUkVGSVggPSAnZmFicmljSW1hZ2UnO1xyXG52YXIgSW1hZ2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhJbWFnZSwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEltYWdlKHByb3BzKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgcHJvcHMpIHx8IHRoaXM7XHJcbiAgICAgICAgLy8gTWFrZSBhbiBpbml0aWFsIGFzc3VtcHRpb24gYWJvdXQgdGhlIGltYWdlIGxheW91dCB1bnRpbCB3ZSBjYW5cclxuICAgICAgICAvLyBjaGVjayB0aGUgcmVuZGVyZWQgZWxlbWVudC4gVGhlIHZhbHVlIGhlcmUgb25seSB0YWtlcyBlZmZlY3Qgd2hlblxyXG4gICAgICAgIC8vIHNob3VsZFN0YXJ0VmlzaWJsZSBpcyB0cnVlLlxyXG4gICAgICAgIF90aGlzLl9jb3ZlclN0eWxlID0gSW1hZ2VfdHlwZXNfMS5JbWFnZUNvdmVyU3R5bGUucG9ydHJhaXQ7XHJcbiAgICAgICAgX3RoaXMuc3RhdGUgPSB7XHJcbiAgICAgICAgICAgIGxvYWRTdGF0ZTogSW1hZ2VfdHlwZXNfMS5JbWFnZUxvYWRTdGF0ZS5ub3RMb2FkZWRcclxuICAgICAgICB9O1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIEltYWdlLnByb3RvdHlwZS5jb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzID0gZnVuY3Rpb24gKG5leHRQcm9wcykge1xyXG4gICAgICAgIGlmIChuZXh0UHJvcHMuc3JjICE9PSB0aGlzLnByb3BzLnNyYykge1xyXG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcclxuICAgICAgICAgICAgICAgIGxvYWRTdGF0ZTogSW1hZ2VfdHlwZXNfMS5JbWFnZUxvYWRTdGF0ZS5ub3RMb2FkZWRcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc3RhdGUubG9hZFN0YXRlID09PSBJbWFnZV90eXBlc18xLkltYWdlTG9hZFN0YXRlLmxvYWRlZCkge1xyXG4gICAgICAgICAgICB0aGlzLl9jb21wdXRlQ292ZXJTdHlsZShuZXh0UHJvcHMpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBJbWFnZS5wcm90b3R5cGUuY29tcG9uZW50RGlkVXBkYXRlID0gZnVuY3Rpb24gKHByZXZQcm9wcywgcHJldlN0YXRlKSB7XHJcbiAgICAgICAgdGhpcy5fY2hlY2tJbWFnZUxvYWRlZCgpO1xyXG4gICAgICAgIGlmICh0aGlzLnByb3BzLm9uTG9hZGluZ1N0YXRlQ2hhbmdlXHJcbiAgICAgICAgICAgICYmIHByZXZTdGF0ZS5sb2FkU3RhdGUgIT09IHRoaXMuc3RhdGUubG9hZFN0YXRlKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvcHMub25Mb2FkaW5nU3RhdGVDaGFuZ2UodGhpcy5zdGF0ZS5sb2FkU3RhdGUpO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBJbWFnZS5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBpbWFnZVByb3BzID0gVXRpbGl0aWVzXzEuZ2V0TmF0aXZlUHJvcHModGhpcy5wcm9wcywgVXRpbGl0aWVzXzEuaW1hZ2VQcm9wZXJ0aWVzLCBbJ3dpZHRoJywgJ2hlaWdodCddKTtcclxuICAgICAgICB2YXIgX2EgPSB0aGlzLnByb3BzLCBzcmMgPSBfYS5zcmMsIGFsdCA9IF9hLmFsdCwgd2lkdGggPSBfYS53aWR0aCwgaGVpZ2h0ID0gX2EuaGVpZ2h0LCBzaG91bGRGYWRlSW4gPSBfYS5zaG91bGRGYWRlSW4sIHNob3VsZFN0YXJ0VmlzaWJsZSA9IF9hLnNob3VsZFN0YXJ0VmlzaWJsZSwgY2xhc3NOYW1lID0gX2EuY2xhc3NOYW1lLCBpbWFnZUZpdCA9IF9hLmltYWdlRml0LCByb2xlID0gX2Eucm9sZSwgbWF4aW1pemVGcmFtZSA9IF9hLm1heGltaXplRnJhbWU7XHJcbiAgICAgICAgdmFyIGxvYWRTdGF0ZSA9IHRoaXMuc3RhdGUubG9hZFN0YXRlO1xyXG4gICAgICAgIHZhciBjb3ZlclN0eWxlID0gdGhpcy5wcm9wcy5jb3ZlclN0eWxlICE9PSB1bmRlZmluZWQgPyB0aGlzLnByb3BzLmNvdmVyU3R5bGUgOiB0aGlzLl9jb3ZlclN0eWxlO1xyXG4gICAgICAgIHZhciBsb2FkZWQgPSBsb2FkU3RhdGUgPT09IEltYWdlX3R5cGVzXzEuSW1hZ2VMb2FkU3RhdGUubG9hZGVkIHx8IChsb2FkU3RhdGUgPT09IEltYWdlX3R5cGVzXzEuSW1hZ2VMb2FkU3RhdGUubm90TG9hZGVkICYmIHRoaXMucHJvcHMuc2hvdWxkU3RhcnRWaXNpYmxlKTtcclxuICAgICAgICAvLyBJZiBpbWFnZSBkaW1lbnNpb25zIGFyZW4ndCBzcGVjaWZpZWQsIHRoZSBuYXR1cmFsIHNpemUgb2YgdGhlIGltYWdlIGlzIHVzZWQuXHJcbiAgICAgICAgcmV0dXJuIChSZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHsgY2xhc3NOYW1lOiBVdGlsaXRpZXNfMS5jc3MoJ21zLUltYWdlJywgc3R5bGVzLnJvb3QsIGNsYXNzTmFtZSwgKF9iID0ge30sXHJcbiAgICAgICAgICAgICAgICBfYlsnbXMtSW1hZ2UtLW1heGltaXplRnJhbWUgJyArIHN0eWxlcy5yb290SXNNYXhpbWl6ZUZyYW1lXSA9IG1heGltaXplRnJhbWUsXHJcbiAgICAgICAgICAgICAgICBfYikpLCBzdHlsZTogeyB3aWR0aDogd2lkdGgsIGhlaWdodDogaGVpZ2h0IH0sIHJlZjogdGhpcy5fcmVzb2x2ZVJlZignX2ZyYW1lRWxlbWVudCcpIH0sXHJcbiAgICAgICAgICAgIFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIiwgdHNsaWJfMS5fX2Fzc2lnbih7fSwgaW1hZ2VQcm9wcywgeyBvbkxvYWQ6IHRoaXMuX29uSW1hZ2VMb2FkZWQsIG9uRXJyb3I6IHRoaXMuX29uSW1hZ2VFcnJvciwga2V5OiBLRVlfUFJFRklYICsgdGhpcy5wcm9wcy5zcmMgfHwgJycsIGNsYXNzTmFtZTogVXRpbGl0aWVzXzEuY3NzKCdtcy1JbWFnZS1pbWFnZScsIHN0eWxlcy5pbWFnZSwgZXhwb3J0cy5Db3ZlclN0eWxlTWFwW2NvdmVyU3R5bGVdLCAoaW1hZ2VGaXQgIT09IHVuZGVmaW5lZCkgJiYgZXhwb3J0cy5JbWFnZUZpdE1hcFtpbWFnZUZpdF0sICFsb2FkZWQgJiYgJ2lzLW5vdExvYWRlZCcsIGxvYWRlZCAmJiAnaXMtbG9hZGVkICcgKyBzdHlsZXMuaW1hZ2VJc0xvYWRlZCwgc2hvdWxkRmFkZUluICYmICdpcy1mYWRlSW4nLCBsb2FkU3RhdGUgPT09IEltYWdlX3R5cGVzXzEuSW1hZ2VMb2FkU3RhdGUuZXJyb3IgJiYgJ2lzLWVycm9yJywgbG9hZGVkICYmIHNob3VsZEZhZGVJbiAmJiAhc2hvdWxkU3RhcnRWaXNpYmxlICYmIFN0eWxpbmdfMS5BbmltYXRpb25DbGFzc05hbWVzLmZhZGVJbjQwMCwgKF9jID0ge30sXHJcbiAgICAgICAgICAgICAgICAgICAgX2NbJ21zLUltYWdlLWltYWdlLS1zY2FsZVdpZHRoICcgKyBzdHlsZXMuaW1hZ2VJc1NjYWxlV2lkdGhdID0gKGltYWdlRml0ID09PSB1bmRlZmluZWQgJiYgISF3aWR0aCAmJiAhaGVpZ2h0KSxcclxuICAgICAgICAgICAgICAgICAgICBfY1snbXMtSW1hZ2UtaW1hZ2UtLXNjYWxlSGVpZ2h0ICcgKyBzdHlsZXMuaW1hZ2VJc1NjYWxlSGVpZ2h0XSA9IChpbWFnZUZpdCA9PT0gdW5kZWZpbmVkICYmICF3aWR0aCAmJiAhIWhlaWdodCksXHJcbiAgICAgICAgICAgICAgICAgICAgX2NbJ21zLUltYWdlLWltYWdlLS1zY2FsZVdpZHRoSGVpZ2h0ICcgKyBzdHlsZXMuaW1hZ2VJc1NjYWxlV2lkdGhIZWlnaHRdID0gKGltYWdlRml0ID09PSB1bmRlZmluZWQgJiYgISF3aWR0aCAmJiAhIWhlaWdodCksXHJcbiAgICAgICAgICAgICAgICAgICAgX2MpKSwgcmVmOiB0aGlzLl9yZXNvbHZlUmVmKCdfaW1hZ2VFbGVtZW50JyksIHNyYzogc3JjLCBhbHQ6IGFsdCwgcm9sZTogcm9sZSB9KSkpKTtcclxuICAgICAgICB2YXIgX2IsIF9jO1xyXG4gICAgfTtcclxuICAgIEltYWdlLnByb3RvdHlwZS5fb25JbWFnZUxvYWRlZCA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgIHZhciBfYSA9IHRoaXMucHJvcHMsIHNyYyA9IF9hLnNyYywgb25Mb2FkID0gX2Eub25Mb2FkO1xyXG4gICAgICAgIGlmIChvbkxvYWQpIHtcclxuICAgICAgICAgICAgb25Mb2FkKGV2KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgdGhpcy5fY29tcHV0ZUNvdmVyU3R5bGUodGhpcy5wcm9wcyk7XHJcbiAgICAgICAgaWYgKHNyYykge1xyXG4gICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcclxuICAgICAgICAgICAgICAgIGxvYWRTdGF0ZTogSW1hZ2VfdHlwZXNfMS5JbWFnZUxvYWRTdGF0ZS5sb2FkZWRcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIEltYWdlLnByb3RvdHlwZS5fY2hlY2tJbWFnZUxvYWRlZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgc3JjID0gdGhpcy5wcm9wcy5zcmM7XHJcbiAgICAgICAgdmFyIGxvYWRTdGF0ZSA9IHRoaXMuc3RhdGUubG9hZFN0YXRlO1xyXG4gICAgICAgIGlmIChsb2FkU3RhdGUgPT09IEltYWdlX3R5cGVzXzEuSW1hZ2VMb2FkU3RhdGUubm90TG9hZGVkKSB7XHJcbiAgICAgICAgICAgIC8vIHRlc3RpbmcgaWYgbmF0dXJhbFdpZHRoIGFuZCBuYXR1cmFsSGVpZ2h0IGFyZSBncmVhdGVyIHRoYW4gemVybyBpcyBiZXR0ZXIgdGhhbiBjaGVja2luZ1xyXG4gICAgICAgICAgICAvLyAuY29tcGxldGUsIGJlY2F1c2UgLmNvbXBsZXRlIHdpbGwgYWxzbyBiZSBzZXQgdG8gdHJ1ZSBpZiB0aGUgaW1hZ2UgYnJlYWtzLiBIb3dldmVyLFxyXG4gICAgICAgICAgICAvLyBmb3Igc29tZSBicm93c2VycywgU1ZHIGltYWdlcyBkbyBub3QgaGF2ZSBhIG5hdHVyYWxXaWR0aCBvciBuYXR1cmFsSGVpZ2h0LCBzbyBmYWxsIGJhY2tcclxuICAgICAgICAgICAgLy8gdG8gY2hlY2tpbmcgLmNvbXBsZXRlIGZvciB0aGVzZSBpbWFnZXMuXHJcbiAgICAgICAgICAgIHZhciBpc0xvYWRlZCA9IHNyYyAmJiB0aGlzLl9pbWFnZUVsZW1lbnQgJiYgKHRoaXMuX2ltYWdlRWxlbWVudC5uYXR1cmFsV2lkdGggPiAwICYmIHRoaXMuX2ltYWdlRWxlbWVudC5uYXR1cmFsSGVpZ2h0ID4gMCkgfHxcclxuICAgICAgICAgICAgICAgICh0aGlzLl9pbWFnZUVsZW1lbnQuY29tcGxldGUgJiYgSW1hZ2UuX3N2Z1JlZ2V4LnRlc3Qoc3JjKSk7XHJcbiAgICAgICAgICAgIGlmIChpc0xvYWRlZCkge1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fY29tcHV0ZUNvdmVyU3R5bGUodGhpcy5wcm9wcyk7XHJcbiAgICAgICAgICAgICAgICB0aGlzLnNldFN0YXRlKHtcclxuICAgICAgICAgICAgICAgICAgICBsb2FkU3RhdGU6IEltYWdlX3R5cGVzXzEuSW1hZ2VMb2FkU3RhdGUubG9hZGVkXHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBJbWFnZS5wcm90b3R5cGUuX2NvbXB1dGVDb3ZlclN0eWxlID0gZnVuY3Rpb24gKHByb3BzKSB7XHJcbiAgICAgICAgdmFyIGltYWdlRml0ID0gcHJvcHMuaW1hZ2VGaXQsIHdpZHRoID0gcHJvcHMud2lkdGgsIGhlaWdodCA9IHByb3BzLmhlaWdodDtcclxuICAgICAgICAvLyBEbyBub3QgY29tcHV0ZSBjb3ZlciBzdHlsZSBpZiBpdCB3YXMgYWxyZWFkeSBzcGVjaWZpZWQgaW4gcHJvcHNcclxuICAgICAgICBpZiAoKGltYWdlRml0ID09PSBJbWFnZV90eXBlc18xLkltYWdlRml0LmNvdmVyIHx8IGltYWdlRml0ID09PSBJbWFnZV90eXBlc18xLkltYWdlRml0LmNvbnRhaW4pICYmXHJcbiAgICAgICAgICAgIHRoaXMucHJvcHMuY292ZXJTdHlsZSA9PT0gdW5kZWZpbmVkICYmXHJcbiAgICAgICAgICAgIHRoaXMuX2ltYWdlRWxlbWVudCkge1xyXG4gICAgICAgICAgICAvLyBEZXRlcm1pbmUgdGhlIGRlc2lyZWQgcmF0aW8gdXNpbmcgdGhlIHdpZHRoIGFuZCBoZWlnaHQgcHJvcHMuXHJcbiAgICAgICAgICAgIC8vIElmIHRob3NlIHByb3BzIGFyZW4ndCBhdmFpbGFibGUsIG1lYXN1cmUgbWVhc3VyZSB0aGUgZnJhbWUuXHJcbiAgICAgICAgICAgIHZhciBkZXNpcmVkUmF0aW8gPSB2b2lkIDA7XHJcbiAgICAgICAgICAgIGlmICghIXdpZHRoICYmICEhaGVpZ2h0KSB7XHJcbiAgICAgICAgICAgICAgICBkZXNpcmVkUmF0aW8gPSB3aWR0aCAvIGhlaWdodDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGRlc2lyZWRSYXRpbyA9IHRoaXMuX2ZyYW1lRWxlbWVudC5jbGllbnRXaWR0aCAvIHRoaXMuX2ZyYW1lRWxlbWVudC5jbGllbnRIZWlnaHQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgLy8gRXhhbWluZSB0aGUgc291cmNlIGltYWdlIHRvIGRldGVybWluZSBpdHMgb3JpZ2luYWwgcmF0aW8uXHJcbiAgICAgICAgICAgIHZhciBuYXR1cmFsUmF0aW8gPSB0aGlzLl9pbWFnZUVsZW1lbnQubmF0dXJhbFdpZHRoIC8gdGhpcy5faW1hZ2VFbGVtZW50Lm5hdHVyYWxIZWlnaHQ7XHJcbiAgICAgICAgICAgIC8vIFNob3VsZCB3ZSBjcm9wIGZyb20gdGhlIHRvcCBvciB0aGUgc2lkZXM/XHJcbiAgICAgICAgICAgIGlmIChuYXR1cmFsUmF0aW8gPiBkZXNpcmVkUmF0aW8pIHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2NvdmVyU3R5bGUgPSBJbWFnZV90eXBlc18xLkltYWdlQ292ZXJTdHlsZS5sYW5kc2NhcGU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9jb3ZlclN0eWxlID0gSW1hZ2VfdHlwZXNfMS5JbWFnZUNvdmVyU3R5bGUucG9ydHJhaXQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgSW1hZ2UucHJvdG90eXBlLl9vbkltYWdlRXJyb3IgPSBmdW5jdGlvbiAoZXYpIHtcclxuICAgICAgICBpZiAodGhpcy5wcm9wcy5vbkVycm9yKSB7XHJcbiAgICAgICAgICAgIHRoaXMucHJvcHMub25FcnJvcihldik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHRoaXMuc2V0U3RhdGUoe1xyXG4gICAgICAgICAgICBsb2FkU3RhdGU6IEltYWdlX3R5cGVzXzEuSW1hZ2VMb2FkU3RhdGUuZXJyb3JcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBJbWFnZS5kZWZhdWx0UHJvcHMgPSB7XHJcbiAgICAgICAgc2hvdWxkRmFkZUluOiB0cnVlXHJcbiAgICB9O1xyXG4gICAgSW1hZ2UuX3N2Z1JlZ2V4ID0gL1xcLnN2ZyQvaTtcclxuICAgIHRzbGliXzEuX19kZWNvcmF0ZShbXHJcbiAgICAgICAgVXRpbGl0aWVzXzEuYXV0b2JpbmRcclxuICAgIF0sIEltYWdlLnByb3RvdHlwZSwgXCJfb25JbWFnZUxvYWRlZFwiLCBudWxsKTtcclxuICAgIHRzbGliXzEuX19kZWNvcmF0ZShbXHJcbiAgICAgICAgVXRpbGl0aWVzXzEuYXV0b2JpbmRcclxuICAgIF0sIEltYWdlLnByb3RvdHlwZSwgXCJfb25JbWFnZUVycm9yXCIsIG51bGwpO1xyXG4gICAgcmV0dXJuIEltYWdlO1xyXG59KFV0aWxpdGllc18xLkJhc2VDb21wb25lbnQpKTtcclxuZXhwb3J0cy5JbWFnZSA9IEltYWdlO1xyXG52YXIgX2EsIF9iO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1JbWFnZS5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4vKiB0c2xpbnQ6ZGlzYWJsZSAqL1xyXG52YXIgbG9hZF90aGVtZWRfc3R5bGVzXzEgPSByZXF1aXJlKFwiQG1pY3Jvc29mdC9sb2FkLXRoZW1lZC1zdHlsZXNcIik7XHJcbmxvYWRfdGhlbWVkX3N0eWxlc18xLmxvYWRTdHlsZXMoW3sgXCJyYXdTdHJpbmdcIjogXCIucm9vdF83NjZlZGUyMXtvdmVyZmxvdzpoaWRkZW59LnJvb3RJc01heGltaXplRnJhbWVfNzY2ZWRlMjF7aGVpZ2h0OjEwMCU7d2lkdGg6MTAwJX0uaW1hZ2VfNzY2ZWRlMjF7ZGlzcGxheTpibG9jaztvcGFjaXR5OjB9LmltYWdlXzc2NmVkZTIxLmltYWdlSXNMb2FkZWRfNzY2ZWRlMjF7b3BhY2l0eToxfS5pbWFnZUlzQ2VudGVyXzc2NmVkZTIxLC5pbWFnZUlzQ29udGFpbl83NjZlZGUyMSwuaW1hZ2VJc0NvdmVyXzc2NmVkZTIxe3Bvc2l0aW9uOnJlbGF0aXZlO3RvcDo1MCV9W2Rpcj0nbHRyJ10gLmltYWdlSXNDZW50ZXJfNzY2ZWRlMjEsW2Rpcj0nbHRyJ10gLmltYWdlSXNDb250YWluXzc2NmVkZTIxLFtkaXI9J2x0ciddIC5pbWFnZUlzQ292ZXJfNzY2ZWRlMjF7bGVmdDo1MCV9W2Rpcj0ncnRsJ10gLmltYWdlSXNDZW50ZXJfNzY2ZWRlMjEsW2Rpcj0ncnRsJ10gLmltYWdlSXNDb250YWluXzc2NmVkZTIxLFtkaXI9J3J0bCddIC5pbWFnZUlzQ292ZXJfNzY2ZWRlMjF7cmlnaHQ6NTAlfWh0bWxbZGlyPSdsdHInXSAuaW1hZ2VJc0NlbnRlcl83NjZlZGUyMSxodG1sW2Rpcj0nbHRyJ10gLmltYWdlSXNDb250YWluXzc2NmVkZTIxLGh0bWxbZGlyPSdsdHInXSAuaW1hZ2VJc0NvdmVyXzc2NmVkZTIxey13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZSgtNTAlLCAtNTAlKTt0cmFuc2Zvcm06dHJhbnNsYXRlKC01MCUsIC01MCUpfWh0bWxbZGlyPSdydGwnXSAuaW1hZ2VJc0NlbnRlcl83NjZlZGUyMSxodG1sW2Rpcj0ncnRsJ10gLmltYWdlSXNDb250YWluXzc2NmVkZTIxLGh0bWxbZGlyPSdydGwnXSAuaW1hZ2VJc0NvdmVyXzc2NmVkZTIxey13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZSg1MCUsIC01MCUpO3RyYW5zZm9ybTp0cmFuc2xhdGUoNTAlLCAtNTAlKX0uaW1hZ2VJc0NvbnRhaW5fNzY2ZWRlMjEuaW1hZ2VJc0xhbmRzY2FwZV83NjZlZGUyMXt3aWR0aDoxMDAlO2hlaWdodDphdXRvfS5pbWFnZUlzQ29udGFpbl83NjZlZGUyMS5pbWFnZUlzUG9ydHJhaXRfNzY2ZWRlMjF7aGVpZ2h0OjEwMCU7d2lkdGg6YXV0b30uaW1hZ2VJc0NvdmVyXzc2NmVkZTIxLmltYWdlSXNMYW5kc2NhcGVfNzY2ZWRlMjF7aGVpZ2h0OjEwMCU7d2lkdGg6YXV0b30uaW1hZ2VJc0NvdmVyXzc2NmVkZTIxLmltYWdlSXNQb3J0cmFpdF83NjZlZGUyMXt3aWR0aDoxMDAlO2hlaWdodDphdXRvfS5pbWFnZUlzTm9uZV83NjZlZGUyMXtoZWlnaHQ6YXV0bzt3aWR0aDphdXRvfS5pbWFnZUlzU2NhbGVXaWR0aEhlaWdodF83NjZlZGUyMXtoZWlnaHQ6MTAwJTt3aWR0aDoxMDAlfS5pbWFnZUlzU2NhbGVXaWR0aF83NjZlZGUyMXtoZWlnaHQ6YXV0bzt3aWR0aDoxMDAlfS5pbWFnZUlzU2NhbGVIZWlnaHRfNzY2ZWRlMjF7aGVpZ2h0OjEwMCU7d2lkdGg6YXV0b31cXG5cIiB9XSk7XHJcbmV4cG9ydHMucm9vdCA9IFwicm9vdF83NjZlZGUyMVwiO1xyXG5leHBvcnRzLnJvb3RJc01heGltaXplRnJhbWUgPSBcInJvb3RJc01heGltaXplRnJhbWVfNzY2ZWRlMjFcIjtcclxuZXhwb3J0cy5pbWFnZSA9IFwiaW1hZ2VfNzY2ZWRlMjFcIjtcclxuZXhwb3J0cy5pbWFnZUlzTG9hZGVkID0gXCJpbWFnZUlzTG9hZGVkXzc2NmVkZTIxXCI7XHJcbmV4cG9ydHMuaW1hZ2VJc0NlbnRlciA9IFwiaW1hZ2VJc0NlbnRlcl83NjZlZGUyMVwiO1xyXG5leHBvcnRzLmltYWdlSXNDb250YWluID0gXCJpbWFnZUlzQ29udGFpbl83NjZlZGUyMVwiO1xyXG5leHBvcnRzLmltYWdlSXNDb3ZlciA9IFwiaW1hZ2VJc0NvdmVyXzc2NmVkZTIxXCI7XHJcbmV4cG9ydHMuaW1hZ2VJc0xhbmRzY2FwZSA9IFwiaW1hZ2VJc0xhbmRzY2FwZV83NjZlZGUyMVwiO1xyXG5leHBvcnRzLmltYWdlSXNQb3J0cmFpdCA9IFwiaW1hZ2VJc1BvcnRyYWl0Xzc2NmVkZTIxXCI7XHJcbmV4cG9ydHMuaW1hZ2VJc05vbmUgPSBcImltYWdlSXNOb25lXzc2NmVkZTIxXCI7XHJcbmV4cG9ydHMuaW1hZ2VJc1NjYWxlV2lkdGhIZWlnaHQgPSBcImltYWdlSXNTY2FsZVdpZHRoSGVpZ2h0Xzc2NmVkZTIxXCI7XHJcbmV4cG9ydHMuaW1hZ2VJc1NjYWxlV2lkdGggPSBcImltYWdlSXNTY2FsZVdpZHRoXzc2NmVkZTIxXCI7XHJcbmV4cG9ydHMuaW1hZ2VJc1NjYWxlSGVpZ2h0ID0gXCJpbWFnZUlzU2NhbGVIZWlnaHRfNzY2ZWRlMjFcIjtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SW1hZ2Uuc2Nzcy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4vKipcclxuICogVGhlIHBvc3NpYmxlIG1ldGhvZHMgdGhhdCBjYW4gYmUgdXNlZCB0byBmaXQgdGhlIGltYWdlLlxyXG4gKi9cclxudmFyIEltYWdlRml0O1xyXG4oZnVuY3Rpb24gKEltYWdlRml0KSB7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBpbWFnZSBpcyBub3Qgc2NhbGVkLiBUaGUgaW1hZ2UgaXMgY2VudGVyZWQgYW5kIGNyb3BwZWQgd2l0aGluIHRoZSBjb250ZW50IGJveC5cclxuICAgICAqL1xyXG4gICAgSW1hZ2VGaXRbSW1hZ2VGaXRbXCJjZW50ZXJcIl0gPSAwXSA9IFwiY2VudGVyXCI7XHJcbiAgICAvKipcclxuICAgICAqIFRoZSBpbWFnZSBpcyBzY2FsZWQgdG8gbWFpbnRhaW4gaXRzIGFzcGVjdCByYXRpbyB3aGlsZSBiZWluZyBmdWxseSBjb250YWluZWQgd2l0aGluIHRoZSBmcmFtZS4gVGhlIGltYWdlIHdpbGxcclxuICAgICAqIGJlIGNlbnRlcmVkIGhvcml6b250YWxseSBhbmQgdmVydGljYWxseSB3aXRoaW4gdGhlIGZyYW1lLiBUaGUgc3BhY2UgaW4gdGhlIHRvcCBhbmQgYm90dG9tIG9yIGluIHRoZSBzaWRlcyBvZlxyXG4gICAgICogdGhlIGZyYW1lIHdpbGwgYmUgZW1wdHkgZGVwZW5kaW5nIG9uIHRoZSBkaWZmZXJlbmNlIGluIGFzcGVjdCByYXRpbyBiZXR3ZWVuIHRoZSBpbWFnZSBhbmQgdGhlIGZyYW1lLlxyXG4gICAgICovXHJcbiAgICBJbWFnZUZpdFtJbWFnZUZpdFtcImNvbnRhaW5cIl0gPSAxXSA9IFwiY29udGFpblwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgaW1hZ2UgaXMgc2NhbGVkIHRvIG1haW50YWluIGl0cyBhc3BlY3QgcmF0aW8gd2hpbGUgZmlsbGluZyB0aGUgZnJhbWUuIFBvcnRpb25zIG9mIHRoZSBpbWFnZSB3aWxsIGJlIGNyb3BwZWQgZnJvbVxyXG4gICAgICogdGhlIHRvcCBhbmQgYm90dG9tLCBvciBmcm9tIHRoZSBzaWRlcywgZGVwZW5kaW5nIG9uIHRoZSBkaWZmZXJlbmNlIGluIGFzcGVjdCByYXRpbyBiZXR3ZWVuIHRoZSBpbWFnZSBhbmQgdGhlIGZyYW1lLlxyXG4gICAgICovXHJcbiAgICBJbWFnZUZpdFtJbWFnZUZpdFtcImNvdmVyXCJdID0gMl0gPSBcImNvdmVyXCI7XHJcbiAgICAvKipcclxuICAgICAqIE5laXRoZXIgdGhlIGltYWdlIG5vciB0aGUgZnJhbWUgYXJlIHNjYWxlZC4gSWYgdGhlaXIgc2l6ZXMgZG8gbm90IG1hdGNoLCB0aGUgaW1hZ2Ugd2lsbCBlaXRoZXIgYmUgY3JvcHBlZCBvciB0aGVcclxuICAgICAqIGZyYW1lIHdpbGwgaGF2ZSBlbXB0eSBzcGFjZS5cclxuICAgICAqL1xyXG4gICAgSW1hZ2VGaXRbSW1hZ2VGaXRbXCJub25lXCJdID0gM10gPSBcIm5vbmVcIjtcclxufSkoSW1hZ2VGaXQgPSBleHBvcnRzLkltYWdlRml0IHx8IChleHBvcnRzLkltYWdlRml0ID0ge30pKTtcclxuLyoqXHJcbiAqIFRoZSBjb3ZlciBzdHlsZSB0byBiZSB1c2VkIG9uIHRoZSBpbWFnZVxyXG4gKi9cclxudmFyIEltYWdlQ292ZXJTdHlsZTtcclxuKGZ1bmN0aW9uIChJbWFnZUNvdmVyU3R5bGUpIHtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGltYWdlIHdpbGwgYmUgc2hvd24gYXQgMTAwJSBoZWlnaHQgb2YgY29udGFpbmVyIGFuZCB0aGUgd2lkdGggd2lsbCBiZSBzY2FsZWQgYWNjb3JkaW5nbHlcclxuICAgICAqL1xyXG4gICAgSW1hZ2VDb3ZlclN0eWxlW0ltYWdlQ292ZXJTdHlsZVtcImxhbmRzY2FwZVwiXSA9IDBdID0gXCJsYW5kc2NhcGVcIjtcclxuICAgIC8qKlxyXG4gICAgICogVGhlIGltYWdlIHdpbGwgYmUgc2hvd24gYXQgMTAwJSB3aWR0aCBvZiBjb250YWluZXIgYW5kIHRoZSBoZWlnaHQgd2lsbCBiZSBzY2FsZWQgYWNjb3JkaW5nbHlcclxuICAgICAqL1xyXG4gICAgSW1hZ2VDb3ZlclN0eWxlW0ltYWdlQ292ZXJTdHlsZVtcInBvcnRyYWl0XCJdID0gMV0gPSBcInBvcnRyYWl0XCI7XHJcbn0pKEltYWdlQ292ZXJTdHlsZSA9IGV4cG9ydHMuSW1hZ2VDb3ZlclN0eWxlIHx8IChleHBvcnRzLkltYWdlQ292ZXJTdHlsZSA9IHt9KSk7XHJcbnZhciBJbWFnZUxvYWRTdGF0ZTtcclxuKGZ1bmN0aW9uIChJbWFnZUxvYWRTdGF0ZSkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgaW1hZ2UgaGFzIG5vdCB5ZXQgYmVlbiBsb2FkZWQsIGFuZCB0aGVyZSBpcyBubyBlcnJvciB5ZXQuXHJcbiAgICAgKi9cclxuICAgIEltYWdlTG9hZFN0YXRlW0ltYWdlTG9hZFN0YXRlW1wibm90TG9hZGVkXCJdID0gMF0gPSBcIm5vdExvYWRlZFwiO1xyXG4gICAgLyoqXHJcbiAgICAgKiBUaGUgaW1hZ2UgaGFzIGJlZW4gbG9hZGVkIHN1Y2Nlc3NmdWxseS5cclxuICAgICAqL1xyXG4gICAgSW1hZ2VMb2FkU3RhdGVbSW1hZ2VMb2FkU3RhdGVbXCJsb2FkZWRcIl0gPSAxXSA9IFwibG9hZGVkXCI7XHJcbiAgICAvKipcclxuICAgICAqIEFuIGVycm9yIGhhcyBiZWVuIGVuY291bnRlcmVkIHdoaWxlIGxvYWRpbmcgdGhlIGltYWdlLlxyXG4gICAgICovXHJcbiAgICBJbWFnZUxvYWRTdGF0ZVtJbWFnZUxvYWRTdGF0ZVtcImVycm9yXCJdID0gMl0gPSBcImVycm9yXCI7XHJcbiAgICAvKipcclxuICAgICAqIERlcHJlY2F0ZWQgYXQgdjEuMy42LCB0byByZXBsYWNlIHRoZSBzcmMgaW4gY2FzZSBvZiBlcnJvcnMsIHVzZSBvbkxvYWRpbmdTdGF0ZUNoYW5nZSBpbnN0ZWFkXHJcbiAgICAgKiBhbmQgcmVyZW5kZXIgdGhlIEltYWdlIHdpdGggYSBkaWZmZXJlbmNlIHNyYy5cclxuICAgICAqIEBkZXByZWNhdGVkXHJcbiAgICAgKi9cclxuICAgIEltYWdlTG9hZFN0YXRlW0ltYWdlTG9hZFN0YXRlW1wiZXJyb3JMb2FkZWRcIl0gPSAzXSA9IFwiZXJyb3JMb2FkZWRcIjtcclxufSkoSW1hZ2VMb2FkU3RhdGUgPSBleHBvcnRzLkltYWdlTG9hZFN0YXRlIHx8IChleHBvcnRzLkltYWdlTG9hZFN0YXRlID0ge30pKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9SW1hZ2UudHlwZXMuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XHJcbi8qIHRzbGludDpkaXNhYmxlOm5vLXVudXNlZC12YXJpYWJsZSAqL1xyXG52YXIgUmVhY3QgPSByZXF1aXJlKFwicmVhY3RcIik7XHJcbnZhciBSZWFjdERPTSA9IHJlcXVpcmUoXCJyZWFjdC1kb21cIik7XHJcbi8qIHRzbGludDplbmFibGU6bm8tdW51c2VkLXZhcmlhYmxlICovXHJcbnZhciBGYWJyaWNfMSA9IHJlcXVpcmUoXCIuLi8uLi9GYWJyaWNcIik7XHJcbnZhciBVdGlsaXRpZXNfMSA9IHJlcXVpcmUoXCIuLi8uLi9VdGlsaXRpZXNcIik7XHJcbnZhciBzdHlsZXNJbXBvcnQgPSByZXF1aXJlKFwiLi9MYXllci5zY3NzXCIpO1xyXG52YXIgc3R5bGVzID0gc3R5bGVzSW1wb3J0O1xyXG52YXIgX2xheWVyc0J5SG9zdElkID0ge307XHJcbnZhciBfZGVmYXVsdEhvc3RTZWxlY3RvcjtcclxudmFyIExheWVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoTGF5ZXIsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBMYXllcihwcm9wcykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHByb3BzKSB8fCB0aGlzO1xyXG4gICAgICAgIF90aGlzLl93YXJuRGVwcmVjYXRpb25zKHtcclxuICAgICAgICAgICAgb25MYXllck1vdW50ZWQ6ICdvbkxheWVyRGlkTW91bnQnXHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgaWYgKF90aGlzLnByb3BzLmhvc3RJZCkge1xyXG4gICAgICAgICAgICBpZiAoIV9sYXllcnNCeUhvc3RJZFtfdGhpcy5wcm9wcy5ob3N0SWRdKSB7XHJcbiAgICAgICAgICAgICAgICBfbGF5ZXJzQnlIb3N0SWRbX3RoaXMucHJvcHMuaG9zdElkXSA9IFtdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIF9sYXllcnNCeUhvc3RJZFtfdGhpcy5wcm9wcy5ob3N0SWRdLnB1c2goX3RoaXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFVzZWQgZm9yIG5vdGlmeWluZyBhcHBsaWNhYmxlIExheWVycyB0aGF0IGEgaG9zdCBpcyBhdmFpbGFibGUvdW5hdmFpbGFibGUgYW5kIHRvIHJlLWV2YWx1YXRlIExheWVycyB0aGF0XHJcbiAgICAgKiBjYXJlIGFib3V0IHRoZSBzcGVjaWZpYyBob3N0LlxyXG4gICAgICovXHJcbiAgICBMYXllci5ub3RpZnlIb3N0Q2hhbmdlZCA9IGZ1bmN0aW9uIChpZCkge1xyXG4gICAgICAgIGlmIChfbGF5ZXJzQnlIb3N0SWRbaWRdKSB7XHJcbiAgICAgICAgICAgIF9sYXllcnNCeUhvc3RJZFtpZF0uZm9yRWFjaChmdW5jdGlvbiAobGF5ZXIpIHsgcmV0dXJuIGxheWVyLmZvcmNlVXBkYXRlKCk7IH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFNldHMgdGhlIGRlZmF1bHQgdGFyZ2V0IHNlbGVjdG9yIHRvIHVzZSB3aGVuIGRldGVybWluaW5nIHRoZSBob3N0IGluIHdoaWNoXHJcbiAgICAgKiBMYXllcmVkIGNvbnRlbnQgd2lsbCBiZSBpbmplY3RlZCBpbnRvLiBJZiBub3QgcHJvdmlkZWQsIGFuIGVsZW1lbnQgd2lsbCBiZVxyXG4gICAgICogY3JlYXRlZCBhdCB0aGUgZW5kIG9mIHRoZSBkb2N1bWVudCBib2R5LlxyXG4gICAgICpcclxuICAgICAqIFBhc3NpbmcgaW4gYSBmYWxzZXkgdmFsdWUgd2lsbCBjbGVhciB0aGUgZGVmYXVsdCB0YXJnZXQgYW5kIHJlc2V0IGJhY2sgdG9cclxuICAgICAqIHVzaW5nIGEgY3JlYXRlZCBlbGVtZW50IGF0IHRoZSBlbmQgb2YgZG9jdW1lbnQgYm9keS5cclxuICAgICAqL1xyXG4gICAgTGF5ZXIuc2V0RGVmYXVsdFRhcmdldCA9IGZ1bmN0aW9uIChzZWxlY3Rvcikge1xyXG4gICAgICAgIF9kZWZhdWx0SG9zdFNlbGVjdG9yID0gc2VsZWN0b3I7XHJcbiAgICB9O1xyXG4gICAgTGF5ZXIucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHRoaXMuY29tcG9uZW50RGlkVXBkYXRlKCk7XHJcbiAgICB9O1xyXG4gICAgTGF5ZXIucHJvdG90eXBlLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XHJcbiAgICAgICAgdGhpcy5fcmVtb3ZlTGF5ZXJFbGVtZW50KCk7XHJcbiAgICAgICAgaWYgKHRoaXMucHJvcHMuaG9zdElkKSB7XHJcbiAgICAgICAgICAgIF9sYXllcnNCeUhvc3RJZFt0aGlzLnByb3BzLmhvc3RJZF0gPSBfbGF5ZXJzQnlIb3N0SWRbdGhpcy5wcm9wcy5ob3N0SWRdLmZpbHRlcihmdW5jdGlvbiAobGF5ZXIpIHsgcmV0dXJuIGxheWVyICE9PSBfdGhpczsgfSk7XHJcbiAgICAgICAgICAgIGlmICghX2xheWVyc0J5SG9zdElkW3RoaXMucHJvcHMuaG9zdElkXS5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIGRlbGV0ZSBfbGF5ZXJzQnlIb3N0SWRbdGhpcy5wcm9wcy5ob3N0SWRdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIExheWVyLnByb3RvdHlwZS5jb21wb25lbnREaWRVcGRhdGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcclxuICAgICAgICB2YXIgaG9zdCA9IHRoaXMuX2dldEhvc3QoKTtcclxuICAgICAgICBpZiAoaG9zdCAhPT0gdGhpcy5faG9zdCkge1xyXG4gICAgICAgICAgICB0aGlzLl9yZW1vdmVMYXllckVsZW1lbnQoKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGhvc3QpIHtcclxuICAgICAgICAgICAgdGhpcy5faG9zdCA9IGhvc3Q7XHJcbiAgICAgICAgICAgIGlmICghdGhpcy5fbGF5ZXJFbGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgZG9jID0gVXRpbGl0aWVzXzEuZ2V0RG9jdW1lbnQodGhpcy5fcm9vdEVsZW1lbnQpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbGF5ZXJFbGVtZW50ID0gZG9jLmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fbGF5ZXJFbGVtZW50LmNsYXNzTmFtZSA9IFV0aWxpdGllc18xLmNzcygnbXMtTGF5ZXInLCAoX2EgPSB7fSxcclxuICAgICAgICAgICAgICAgICAgICBfYVsnbXMtTGF5ZXItLWZpeGVkICcgKyBzdHlsZXMucm9vdElzRml4ZWRdID0gIXRoaXMucHJvcHMuaG9zdElkLFxyXG4gICAgICAgICAgICAgICAgICAgIF9hKSk7XHJcbiAgICAgICAgICAgICAgICBob3N0LmFwcGVuZENoaWxkKHRoaXMuX2xheWVyRWxlbWVudCk7XHJcbiAgICAgICAgICAgICAgICBVdGlsaXRpZXNfMS5zZXRWaXJ0dWFsUGFyZW50KHRoaXMuX2xheWVyRWxlbWVudCwgdGhpcy5fcm9vdEVsZW1lbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIC8vIFVzaW5nIHRoaXMgJ3Vuc3RhYmxlJyBtZXRob2QgYWxsb3dzIHVzIHRvIHJldGFpbiB0aGUgUmVhY3QgY29udGV4dCBhY3Jvc3MgdGhlIGxheWVyIHByb2plY3Rpb24uXHJcbiAgICAgICAgICAgIFJlYWN0RE9NLnVuc3RhYmxlX3JlbmRlclN1YnRyZWVJbnRvQ29udGFpbmVyKHRoaXMsIChSZWFjdC5jcmVhdGVFbGVtZW50KEZhYnJpY18xLkZhYnJpYywgeyBjbGFzc05hbWU6IFV0aWxpdGllc18xLmNzcygnbXMtTGF5ZXItY29udGVudCcsIHN0eWxlcy5jb250ZW50KSB9LCB0aGlzLnByb3BzLmNoaWxkcmVuKSksIHRoaXMuX2xheWVyRWxlbWVudCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5faGFzTW91bnRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLl9oYXNNb3VudGVkID0gdHJ1ZTtcclxuICAgICAgICAgICAgICAgICAgICAvLyBUT0RPOiBAZGVwcmVjYXRlZCBjbGVhbnVwIHJlcXVpcmVkLlxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChfdGhpcy5wcm9wcy5vbkxheWVyTW91bnRlZCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5wcm9wcy5vbkxheWVyTW91bnRlZCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5wcm9wcy5vbkxheWVyRGlkTW91bnQoKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBfYTtcclxuICAgIH07XHJcbiAgICBMYXllci5wcm90b3R5cGUucmVuZGVyID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChcInNwYW5cIiwgeyBjbGFzc05hbWU6ICdtcy1MYXllcicsIHJlZjogdGhpcy5fcmVzb2x2ZVJlZignX3Jvb3RFbGVtZW50JykgfSkpO1xyXG4gICAgfTtcclxuICAgIExheWVyLnByb3RvdHlwZS5fcmVtb3ZlTGF5ZXJFbGVtZW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9sYXllckVsZW1lbnQpIHtcclxuICAgICAgICAgICAgdGhpcy5wcm9wcy5vbkxheWVyV2lsbFVubW91bnQoKTtcclxuICAgICAgICAgICAgUmVhY3RET00udW5tb3VudENvbXBvbmVudEF0Tm9kZSh0aGlzLl9sYXllckVsZW1lbnQpO1xyXG4gICAgICAgICAgICB2YXIgcGFyZW50Tm9kZSA9IHRoaXMuX2xheWVyRWxlbWVudC5wYXJlbnROb2RlO1xyXG4gICAgICAgICAgICBpZiAocGFyZW50Tm9kZSkge1xyXG4gICAgICAgICAgICAgICAgcGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLl9sYXllckVsZW1lbnQpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHRoaXMuX2xheWVyRWxlbWVudCA9IHVuZGVmaW5lZDtcclxuICAgICAgICAgICAgdGhpcy5faGFzTW91bnRlZCA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBMYXllci5wcm90b3R5cGUuX2dldEhvc3QgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGhvc3RJZCA9IHRoaXMucHJvcHMuaG9zdElkO1xyXG4gICAgICAgIHZhciBkb2MgPSBVdGlsaXRpZXNfMS5nZXREb2N1bWVudCh0aGlzLl9yb290RWxlbWVudCk7XHJcbiAgICAgICAgaWYgKGhvc3RJZCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZG9jLmdldEVsZW1lbnRCeUlkKGhvc3RJZCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gX2RlZmF1bHRIb3N0U2VsZWN0b3IgPyBkb2MucXVlcnlTZWxlY3RvcihfZGVmYXVsdEhvc3RTZWxlY3RvcikgOiBkb2MuYm9keTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgTGF5ZXIuZGVmYXVsdFByb3BzID0ge1xyXG4gICAgICAgIG9uTGF5ZXJEaWRNb3VudDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9LFxyXG4gICAgICAgIG9uTGF5ZXJXaWxsVW5tb3VudDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdW5kZWZpbmVkOyB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIExheWVyO1xyXG59KFV0aWxpdGllc18xLkJhc2VDb21wb25lbnQpKTtcclxuZXhwb3J0cy5MYXllciA9IExheWVyO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1MYXllci5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG4vKiB0c2xpbnQ6ZGlzYWJsZSAqL1xyXG52YXIgbG9hZF90aGVtZWRfc3R5bGVzXzEgPSByZXF1aXJlKFwiQG1pY3Jvc29mdC9sb2FkLXRoZW1lZC1zdHlsZXNcIik7XHJcbmxvYWRfdGhlbWVkX3N0eWxlc18xLmxvYWRTdHlsZXMoW3sgXCJyYXdTdHJpbmdcIjogXCIucm9vdElzRml4ZWRfMDVlMDQ5ZjZ7cG9zaXRpb246Zml4ZWQ7ei1pbmRleDoxMDAwMDAwO3RvcDowO2xlZnQ6MDt3aWR0aDoxMDB2dztoZWlnaHQ6MTAwdmg7dmlzaWJpbGl0eTpoaWRkZW59LmNvbnRlbnRfMDVlMDQ5ZjZ7dmlzaWJpbGl0eTp2aXNpYmxlfVxcblwiIH1dKTtcclxuZXhwb3J0cy5yb290SXNGaXhlZCA9IFwicm9vdElzRml4ZWRfMDVlMDQ5ZjZcIjtcclxuZXhwb3J0cy5jb250ZW50ID0gXCJjb250ZW50XzA1ZTA0OWY2XCI7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPUxheWVyLnNjc3MuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XHJcbnZhciBSZWFjdCA9IHJlcXVpcmUoXCJyZWFjdFwiKTtcclxudmFyIFV0aWxpdGllc18xID0gcmVxdWlyZShcIi4uLy4uL1V0aWxpdGllc1wiKTtcclxudmFyIExheWVyXzEgPSByZXF1aXJlKFwiLi9MYXllclwiKTtcclxudmFyIExheWVySG9zdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIHRzbGliXzEuX19leHRlbmRzKExheWVySG9zdCwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIExheWVySG9zdCgpIHtcclxuICAgICAgICByZXR1cm4gX3N1cGVyICE9PSBudWxsICYmIF9zdXBlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIHx8IHRoaXM7XHJcbiAgICB9XHJcbiAgICBMYXllckhvc3QucHJvdG90eXBlLnNob3VsZENvbXBvbmVudFVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9O1xyXG4gICAgTGF5ZXJIb3N0LnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBMYXllcl8xLkxheWVyLm5vdGlmeUhvc3RDaGFuZ2VkKHRoaXMucHJvcHMuaWQpO1xyXG4gICAgfTtcclxuICAgIExheWVySG9zdC5wcm90b3R5cGUuY29tcG9uZW50V2lsbFVubW91bnQgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgTGF5ZXJfMS5MYXllci5ub3RpZnlIb3N0Q2hhbmdlZCh0aGlzLnByb3BzLmlkKTtcclxuICAgIH07XHJcbiAgICBMYXllckhvc3QucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgdHNsaWJfMS5fX2Fzc2lnbih7fSwgdGhpcy5wcm9wcywgeyBjbGFzc05hbWU6IFV0aWxpdGllc18xLmNzcygnbXMtTGF5ZXJIb3N0JywgdGhpcy5wcm9wcy5jbGFzc05hbWUpIH0pKSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIExheWVySG9zdDtcclxufShVdGlsaXRpZXNfMS5CYXNlQ29tcG9uZW50KSk7XHJcbmV4cG9ydHMuTGF5ZXJIb3N0ID0gTGF5ZXJIb3N0O1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1MYXllckhvc3QuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XHJcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL0xheWVyXCIpLCBleHBvcnRzKTtcclxudHNsaWJfMS5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vTGF5ZXJIb3N0XCIpLCBleHBvcnRzKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XHJcbnZhciBSZWFjdCA9IHJlcXVpcmUoXCJyZWFjdFwiKTtcclxudmFyIFV0aWxpdGllc18xID0gcmVxdWlyZShcIi4uLy4uL1V0aWxpdGllc1wiKTtcclxuLyoqXHJcbiAqIFRoaXMgYWRkcyBhY2Nlc3NpYmlsaXR5IHRvIERpYWxvZyBhbmQgUGFuZWwgY29udHJvbHNcclxuICovXHJcbnZhciBQb3B1cCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIHRzbGliXzEuX19leHRlbmRzKFBvcHVwLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gUG9wdXAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgUG9wdXAucHJvdG90eXBlLmNvbXBvbmVudFdpbGxNb3VudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLl9vcmlnaW5hbEZvY3VzZWRFbGVtZW50ID0gVXRpbGl0aWVzXzEuZ2V0RG9jdW1lbnQoKS5hY3RpdmVFbGVtZW50O1xyXG4gICAgfTtcclxuICAgIFBvcHVwLnByb3RvdHlwZS5jb21wb25lbnREaWRNb3VudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB0aGlzLl9ldmVudHMub24odGhpcy5yZWZzLnJvb3QsICdmb2N1cycsIHRoaXMuX29uRm9jdXMsIHRydWUpO1xyXG4gICAgICAgIHRoaXMuX2V2ZW50cy5vbih0aGlzLnJlZnMucm9vdCwgJ2JsdXInLCB0aGlzLl9vbkJsdXIsIHRydWUpO1xyXG4gICAgICAgIGlmIChVdGlsaXRpZXNfMS5kb2VzRWxlbWVudENvbnRhaW5Gb2N1cyh0aGlzLnJlZnMucm9vdCkpIHtcclxuICAgICAgICAgICAgdGhpcy5fY29udGFpbnNGb2N1cyA9IHRydWU7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIFBvcHVwLnByb3RvdHlwZS5jb21wb25lbnRXaWxsVW5tb3VudCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBpZiAodGhpcy5wcm9wcy5zaG91bGRSZXN0b3JlRm9jdXMgJiZcclxuICAgICAgICAgICAgdGhpcy5fb3JpZ2luYWxGb2N1c2VkRWxlbWVudCAmJlxyXG4gICAgICAgICAgICB0aGlzLl9jb250YWluc0ZvY3VzICYmXHJcbiAgICAgICAgICAgIHRoaXMuX29yaWdpbmFsRm9jdXNlZEVsZW1lbnQgIT09IHdpbmRvdykge1xyXG4gICAgICAgICAgICAvLyBUaGlzIHNsaWdodCBkZWxheSBpcyByZXF1aXJlZCBzbyB0aGF0IHdlIGNhbiB1bndpbmQgdGhlIHN0YWNrLCBsZXQgcmVhY3QgdHJ5IHRvIG1lc3Mgd2l0aCBmb2N1cywgYW5kIHRoZW5cclxuICAgICAgICAgICAgLy8gYXBwbHkgdGhlIGNvcnJlY3QgZm9jdXMuIFdpdGhvdXQgdGhlIHNldFRpbWVvdXQsIHdlIGVuZCB1cCBmb2N1c2luZyB0aGUgY29ycmVjdCB0aGluZywgYW5kIHRoZW4gUmVhY3Qgd2FudHNcclxuICAgICAgICAgICAgLy8gdG8gcmVzZXQgdGhlIGZvY3VzIGJhY2sgdG8gdGhlIHRoaW5nIGl0IHRoaW5rcyBzaG91bGQgaGF2ZSBiZWVuIGZvY3VzZWQuXHJcbiAgICAgICAgICAgIGlmICh0aGlzLl9vcmlnaW5hbEZvY3VzZWRFbGVtZW50KSB7XHJcbiAgICAgICAgICAgICAgICB0aGlzLl9vcmlnaW5hbEZvY3VzZWRFbGVtZW50LmZvY3VzKCk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgUG9wdXAucHJvdG90eXBlLnJlbmRlciA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICB2YXIgX2EgPSB0aGlzLnByb3BzLCByb2xlID0gX2Eucm9sZSwgY2xhc3NOYW1lID0gX2EuY2xhc3NOYW1lLCBhcmlhTGFiZWwgPSBfYS5hcmlhTGFiZWwsIGFyaWFMYWJlbGxlZEJ5ID0gX2EuYXJpYUxhYmVsbGVkQnksIGFyaWFEZXNjcmliZWRCeSA9IF9hLmFyaWFEZXNjcmliZWRCeTtcclxuICAgICAgICByZXR1cm4gKFJlYWN0LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIiwgdHNsaWJfMS5fX2Fzc2lnbih7IHJlZjogJ3Jvb3QnIH0sIFV0aWxpdGllc18xLmdldE5hdGl2ZVByb3BzKHRoaXMucHJvcHMsIFV0aWxpdGllc18xLmRpdlByb3BlcnRpZXMpLCB7IGNsYXNzTmFtZTogY2xhc3NOYW1lLCByb2xlOiByb2xlLCBcImFyaWEtbGFiZWxcIjogYXJpYUxhYmVsLCBcImFyaWEtbGFiZWxsZWRieVwiOiBhcmlhTGFiZWxsZWRCeSwgXCJhcmlhLWRlc2NyaWJlZGJ5XCI6IGFyaWFEZXNjcmliZWRCeSwgb25LZXlEb3duOiB0aGlzLl9vbktleURvd24gfSksIHRoaXMucHJvcHMuY2hpbGRyZW4pKTtcclxuICAgIH07XHJcbiAgICBQb3B1cC5wcm90b3R5cGUuX29uS2V5RG93biA9IGZ1bmN0aW9uIChldikge1xyXG4gICAgICAgIHN3aXRjaCAoZXYud2hpY2gpIHtcclxuICAgICAgICAgICAgY2FzZSAyNyAvKiBlc2NhcGUgKi86XHJcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wcm9wcy5vbkRpc21pc3MpIHtcclxuICAgICAgICAgICAgICAgICAgICB0aGlzLnByb3BzLm9uRGlzbWlzcyhldik7XHJcbiAgICAgICAgICAgICAgICAgICAgZXYucHJldmVudERlZmF1bHQoKTtcclxuICAgICAgICAgICAgICAgICAgICBldi5zdG9wUHJvcGFnYXRpb24oKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbiAgICBQb3B1cC5wcm90b3R5cGUuX29uRm9jdXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5fY29udGFpbnNGb2N1cyA9IHRydWU7XHJcbiAgICB9O1xyXG4gICAgUG9wdXAucHJvdG90eXBlLl9vbkJsdXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdGhpcy5fY29udGFpbnNGb2N1cyA9IGZhbHNlO1xyXG4gICAgfTtcclxuICAgIFBvcHVwLmRlZmF1bHRQcm9wcyA9IHtcclxuICAgICAgICBzaG91bGRSZXN0b3JlRm9jdXM6IHRydWVcclxuICAgIH07XHJcbiAgICB0c2xpYl8xLl9fZGVjb3JhdGUoW1xyXG4gICAgICAgIFV0aWxpdGllc18xLmF1dG9iaW5kXHJcbiAgICBdLCBQb3B1cC5wcm90b3R5cGUsIFwiX29uS2V5RG93blwiLCBudWxsKTtcclxuICAgIHJldHVybiBQb3B1cDtcclxufShVdGlsaXRpZXNfMS5CYXNlQ29tcG9uZW50KSk7XHJcbmV4cG9ydHMuUG9wdXAgPSBQb3B1cDtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9UG9wdXAuanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XHJcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL1BvcHVwXCIpLCBleHBvcnRzKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XHJcbnZhciBVdGlsaXRpZXNfMSA9IHJlcXVpcmUoXCIuLi8uLi9VdGlsaXRpZXNcIik7XHJcbnZhciBCYXNlRGVjb3JhdG9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoQmFzZURlY29yYXRvciwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIEJhc2VEZWNvcmF0b3IocHJvcHMpIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBwcm9wcykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy5fc2hvdWxkVXBkYXRlQ29tcG9uZW50UmVmID0gZmFsc2U7XHJcbiAgICAgICAgX3RoaXMuX3VwZGF0ZUNvbXBvc2VkQ29tcG9uZW50UmVmID0gX3RoaXMuX3VwZGF0ZUNvbXBvc2VkQ29tcG9uZW50UmVmLmJpbmQoX3RoaXMpO1xyXG4gICAgICAgIHJldHVybiBfdGhpcztcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlcyB0aGUgcmVmIHRvIHRoZSBjb21wb25lbnQgY29tcG9zZWQgYnkgdGhlIGRlY29yYXRvciwgd2hpY2ggd2lsbCBhbHNvIHRha2UgY2FyZSBvZiBob2lzdGluZ1xyXG4gICAgICogKGFuZCB1bmhvaXN0aW5nIGFzIGFwcHJvcHJpYXRlKSBtZXRob2RzIGZyb20gc2FpZCBjb21wb25lbnQuXHJcbiAgICAgKlxyXG4gICAgICogUGFzcyB0aGlzIG1ldGhvZCBhcyB0aGUgYXJndW1lbnQgdG8gdGhlICdyZWYnIHByb3BlcnR5IG9mIHRoZSBjb21wb3NlZCBjb21wb25lbnQuXHJcbiAgICAgKi9cclxuICAgIEJhc2VEZWNvcmF0b3IucHJvdG90eXBlLl91cGRhdGVDb21wb3NlZENvbXBvbmVudFJlZiA9IGZ1bmN0aW9uIChjb21wb3NlZENvbXBvbmVudEluc3RhbmNlKSB7XHJcbiAgICAgICAgdGhpcy5fY29tcG9zZWRDb21wb25lbnRJbnN0YW5jZSA9IGNvbXBvc2VkQ29tcG9uZW50SW5zdGFuY2U7XHJcbiAgICAgICAgaWYgKGNvbXBvc2VkQ29tcG9uZW50SW5zdGFuY2UpIHtcclxuICAgICAgICAgICAgdGhpcy5faG9pc3RlZCA9IFV0aWxpdGllc18xLmhvaXN0TWV0aG9kcyh0aGlzLCBjb21wb3NlZENvbXBvbmVudEluc3RhbmNlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSBpZiAodGhpcy5faG9pc3RlZCkge1xyXG4gICAgICAgICAgICBVdGlsaXRpZXNfMS51bmhvaXN0TWV0aG9kcyh0aGlzLCB0aGlzLl9ob2lzdGVkKTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIEJhc2VEZWNvcmF0b3I7XHJcbn0oVXRpbGl0aWVzXzEuQmFzZUNvbXBvbmVudCkpO1xyXG5leHBvcnRzLkJhc2VEZWNvcmF0b3IgPSBCYXNlRGVjb3JhdG9yO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1CYXNlRGVjb3JhdG9yLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xyXG52YXIgUmVhY3QgPSByZXF1aXJlKFwicmVhY3RcIik7XHJcbnZhciBCYXNlRGVjb3JhdG9yXzEgPSByZXF1aXJlKFwiLi9CYXNlRGVjb3JhdG9yXCIpO1xyXG52YXIgVXRpbGl0aWVzXzEgPSByZXF1aXJlKFwiLi4vLi4vVXRpbGl0aWVzXCIpO1xyXG52YXIgUmVzcG9uc2l2ZU1vZGU7XHJcbihmdW5jdGlvbiAoUmVzcG9uc2l2ZU1vZGUpIHtcclxuICAgIFJlc3BvbnNpdmVNb2RlW1Jlc3BvbnNpdmVNb2RlW1wic21hbGxcIl0gPSAwXSA9IFwic21hbGxcIjtcclxuICAgIFJlc3BvbnNpdmVNb2RlW1Jlc3BvbnNpdmVNb2RlW1wibWVkaXVtXCJdID0gMV0gPSBcIm1lZGl1bVwiO1xyXG4gICAgUmVzcG9uc2l2ZU1vZGVbUmVzcG9uc2l2ZU1vZGVbXCJsYXJnZVwiXSA9IDJdID0gXCJsYXJnZVwiO1xyXG4gICAgUmVzcG9uc2l2ZU1vZGVbUmVzcG9uc2l2ZU1vZGVbXCJ4TGFyZ2VcIl0gPSAzXSA9IFwieExhcmdlXCI7XHJcbiAgICBSZXNwb25zaXZlTW9kZVtSZXNwb25zaXZlTW9kZVtcInh4TGFyZ2VcIl0gPSA0XSA9IFwieHhMYXJnZVwiO1xyXG4gICAgUmVzcG9uc2l2ZU1vZGVbUmVzcG9uc2l2ZU1vZGVbXCJ4eHhMYXJnZVwiXSA9IDVdID0gXCJ4eHhMYXJnZVwiO1xyXG59KShSZXNwb25zaXZlTW9kZSA9IGV4cG9ydHMuUmVzcG9uc2l2ZU1vZGUgfHwgKGV4cG9ydHMuUmVzcG9uc2l2ZU1vZGUgPSB7fSkpO1xyXG52YXIgUkVTUE9OU0lWRV9NQVhfQ09OU1RSQUlOVCA9IFtcclxuICAgIDQ3OSxcclxuICAgIDYzOSxcclxuICAgIDEwMjMsXHJcbiAgICAxMzY1LFxyXG4gICAgMTkxOSxcclxuICAgIDk5OTk5OTk5XHJcbl07XHJcbnZhciBfZGVmYXVsdE1vZGU7XHJcbi8qKlxyXG4gKiBBbGxvd3MgYSBzZXJ2ZXIgcmVuZGVyZWQgc2NlbmFyaW8gdG8gcHJvdmlkZSBhIGRlZmF1bHQgcmVzcG9uc2l2ZSBtb2RlLlxyXG4gKi9cclxuZnVuY3Rpb24gc2V0UmVzcG9uc2l2ZU1vZGUocmVzcG9uc2l2ZU1vZGUpIHtcclxuICAgIF9kZWZhdWx0TW9kZSA9IHJlc3BvbnNpdmVNb2RlO1xyXG59XHJcbmV4cG9ydHMuc2V0UmVzcG9uc2l2ZU1vZGUgPSBzZXRSZXNwb25zaXZlTW9kZTtcclxuZnVuY3Rpb24gd2l0aFJlc3BvbnNpdmVNb2RlKENvbXBvc2VkQ29tcG9uZW50KSB7XHJcbiAgICByZXR1cm4gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgICAgIHRzbGliXzEuX19leHRlbmRzKFdpdGhSZXNwb25zaXZlTW9kZSwgX3N1cGVyKTtcclxuICAgICAgICBmdW5jdGlvbiBXaXRoUmVzcG9uc2l2ZU1vZGUocHJvcHMpIHtcclxuICAgICAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgcHJvcHMpIHx8IHRoaXM7XHJcbiAgICAgICAgICAgIF90aGlzLl91cGRhdGVDb21wb3NlZENvbXBvbmVudFJlZiA9IF90aGlzLl91cGRhdGVDb21wb3NlZENvbXBvbmVudFJlZi5iaW5kKF90aGlzKTtcclxuICAgICAgICAgICAgX3RoaXMuc3RhdGUgPSB7XHJcbiAgICAgICAgICAgICAgICByZXNwb25zaXZlTW9kZTogX3RoaXMuX2dldFJlc3BvbnNpdmVNb2RlKClcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgICAgIH1cclxuICAgICAgICBXaXRoUmVzcG9uc2l2ZU1vZGUucHJvdG90eXBlLmNvbXBvbmVudERpZE1vdW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICB0aGlzLl9ldmVudHMub24od2luZG93LCAncmVzaXplJywgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHJlc3BvbnNpdmVNb2RlID0gX3RoaXMuX2dldFJlc3BvbnNpdmVNb2RlKCk7XHJcbiAgICAgICAgICAgICAgICBpZiAocmVzcG9uc2l2ZU1vZGUgIT09IF90aGlzLnN0YXRlLnJlc3BvbnNpdmVNb2RlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuc2V0U3RhdGUoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zaXZlTW9kZTogcmVzcG9uc2l2ZU1vZGVcclxuICAgICAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICBXaXRoUmVzcG9uc2l2ZU1vZGUucHJvdG90eXBlLmNvbXBvbmVudFdpbGxVbm1vdW50ID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB0aGlzLl9ldmVudHMuZGlzcG9zZSgpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgV2l0aFJlc3BvbnNpdmVNb2RlLnByb3RvdHlwZS5yZW5kZXIgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciByZXNwb25zaXZlTW9kZSA9IHRoaXMuc3RhdGUucmVzcG9uc2l2ZU1vZGU7XHJcbiAgICAgICAgICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChDb21wb3NlZENvbXBvbmVudCwgdHNsaWJfMS5fX2Fzc2lnbih7IHJlZjogdGhpcy5fdXBkYXRlQ29tcG9zZWRDb21wb25lbnRSZWYsIHJlc3BvbnNpdmVNb2RlOiByZXNwb25zaXZlTW9kZSB9LCB0aGlzLnByb3BzKSkpO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgV2l0aFJlc3BvbnNpdmVNb2RlLnByb3RvdHlwZS5fZ2V0UmVzcG9uc2l2ZU1vZGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciByZXNwb25zaXZlTW9kZSA9IFJlc3BvbnNpdmVNb2RlLnNtYWxsO1xyXG4gICAgICAgICAgICB2YXIgd2luID0gVXRpbGl0aWVzXzEuZ2V0V2luZG93KCk7XHJcbiAgICAgICAgICAgIGlmICh0eXBlb2Ygd2luICE9PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICB3aGlsZSAod2luLmlubmVyV2lkdGggPiBSRVNQT05TSVZFX01BWF9DT05TVFJBSU5UW3Jlc3BvbnNpdmVNb2RlXSkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXNwb25zaXZlTW9kZSsrO1xyXG4gICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gUmV0dXJuIGEgYmVzdCBlZmZvcnQgcmVzdWx0IGluIGNhc2VzIHdoZXJlIHdlJ3JlIGluIHRoZSBicm93c2VyIGJ1dCBpdCB0aHJvd3Mgb24gZ2V0dGluZyBpbm5lcldpZHRoLlxyXG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNpdmVNb2RlID0gUmVzcG9uc2l2ZU1vZGUubGFyZ2U7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBpZiAoX2RlZmF1bHRNb2RlICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgICAgICAgICAgICByZXNwb25zaXZlTW9kZSA9IF9kZWZhdWx0TW9kZTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQ29udGVudCB3YXMgcmVuZGVyZWQgaW4gYSBzZXJ2ZXIgZW52aXJvbm1lbnQgd2l0aG91dCBwcm92aWRpbmcgYSBkZWZhdWx0IHJlc3BvbnNpdmUgbW9kZS4gJyArXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICdDYWxsIHNldFJlc3BvbnNpdmVNb2RlIHRvIGRlZmluZSB3aGF0IHRoZSByZXNwb25zaXZlIG1vZGUgaXMuJyk7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNpdmVNb2RlO1xyXG4gICAgICAgIH07XHJcbiAgICAgICAgcmV0dXJuIFdpdGhSZXNwb25zaXZlTW9kZTtcclxuICAgIH0oQmFzZURlY29yYXRvcl8xLkJhc2VEZWNvcmF0b3IpKTtcclxufVxyXG5leHBvcnRzLndpdGhSZXNwb25zaXZlTW9kZSA9IHdpdGhSZXNwb25zaXZlTW9kZTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9d2l0aFJlc3BvbnNpdmVNb2RlLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xyXG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9wb3NpdGlvbmluZy9pbmRleFwiKSwgZXhwb3J0cyk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBvc2l0aW9uaW5nLmpzLm1hcCIsIlwidXNlIHN0cmljdFwiO1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XHJcbnZhciB0c2xpYl8xID0gcmVxdWlyZShcInRzbGliXCIpO1xyXG50c2xpYl8xLl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9wb3NpdGlvbmluZ1wiKSwgZXhwb3J0cyk7XHJcbnRzbGliXzEuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL3Bvc2l0aW9uaW5nLnR5cGVzXCIpLCBleHBvcnRzKTtcclxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIiwiXCJ1c2Ugc3RyaWN0XCI7XHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxudmFyIHRzbGliXzEgPSByZXF1aXJlKFwidHNsaWJcIik7XHJcbnZhciBVdGlsaXRpZXNfMSA9IHJlcXVpcmUoXCIuLi8uLi9VdGlsaXRpZXNcIik7XHJcbnZhciBwb3NpdGlvbmluZ190eXBlc18xID0gcmVxdWlyZShcIi4vcG9zaXRpb25pbmcudHlwZXNcIik7XHJcbnZhciBSZWN0YW5nbGUgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhSZWN0YW5nbGUsIF9zdXBlcik7XHJcbiAgICBmdW5jdGlvbiBSZWN0YW5nbGUoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlciAhPT0gbnVsbCAmJiBfc3VwZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSB8fCB0aGlzO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFJlY3RhbmdsZTtcclxufShVdGlsaXRpZXNfMS5SZWN0YW5nbGUpKTtcclxuZXhwb3J0cy5SZWN0YW5nbGUgPSBSZWN0YW5nbGU7XHJcbmZ1bmN0aW9uIF9jcmVhdGVQb3NpdGlvbkRhdGEodGFyZ2V0RWRnZSwgYWxpZ25tZW50RWRnZSwgaXNBdXRvKSB7XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICAgIHRhcmdldEVkZ2U6IHRhcmdldEVkZ2UsXHJcbiAgICAgICAgYWxpZ25tZW50RWRnZTogYWxpZ25tZW50RWRnZSxcclxuICAgICAgICBpc0F1dG86IGlzQXV0b1xyXG4gICAgfTtcclxufVxyXG4vLyBDdXJyZW50bHkgdGhlIGJlYWtQZXJjZW50IGlzIHNldCB0byA1MCBmb3IgYWxsIHBvc2l0aW9ucyBtZWFuaW5nIHRoYXQgaXQgc2hvdWxkIHRlbmQgdG8gdGhlIGNlbnRlciBvZiB0aGUgdGFyZ2V0XHJcbnZhciBEaXJlY3Rpb25hbERpY3Rpb25hcnkgPSAoX2EgPSB7fSxcclxuICAgIF9hWzAgLyogdG9wTGVmdEVkZ2UgKi9dID0gX2NyZWF0ZVBvc2l0aW9uRGF0YShwb3NpdGlvbmluZ190eXBlc18xLlJlY3RhbmdsZUVkZ2UudG9wLCBwb3NpdGlvbmluZ190eXBlc18xLlJlY3RhbmdsZUVkZ2UubGVmdCksXHJcbiAgICBfYVsxIC8qIHRvcENlbnRlciAqL10gPSBfY3JlYXRlUG9zaXRpb25EYXRhKHBvc2l0aW9uaW5nX3R5cGVzXzEuUmVjdGFuZ2xlRWRnZS50b3ApLFxyXG4gICAgX2FbMiAvKiB0b3BSaWdodEVkZ2UgKi9dID0gX2NyZWF0ZVBvc2l0aW9uRGF0YShwb3NpdGlvbmluZ190eXBlc18xLlJlY3RhbmdsZUVkZ2UudG9wLCBwb3NpdGlvbmluZ190eXBlc18xLlJlY3RhbmdsZUVkZ2UucmlnaHQpLFxyXG4gICAgX2FbMyAvKiB0b3BBdXRvRWRnZSAqL10gPSBfY3JlYXRlUG9zaXRpb25EYXRhKHBvc2l0aW9uaW5nX3R5cGVzXzEuUmVjdGFuZ2xlRWRnZS50b3AsIHVuZGVmaW5lZCwgdHJ1ZSksXHJcbiAgICBfYVs0IC8qIGJvdHRvbUxlZnRFZGdlICovXSA9IF9jcmVhdGVQb3NpdGlvbkRhdGEocG9zaXRpb25pbmdfdHlwZXNfMS5SZWN0YW5nbGVFZGdlLmJvdHRvbSwgcG9zaXRpb25pbmdfdHlwZXNfMS5SZWN0YW5nbGVFZGdlLmxlZnQpLFxyXG4gICAgX2FbNSAvKiBib3R0b21DZW50ZXIgKi9dID0gX2NyZWF0ZVBvc2l0aW9uRGF0YShwb3NpdGlvbmluZ190eXBlc18xLlJlY3RhbmdsZUVkZ2UuYm90dG9tKSxcclxuICAgIF9hWzYgLyogYm90dG9tUmlnaHRFZGdlICovXSA9IF9jcmVhdGVQb3NpdGlvbkRhdGEocG9zaXRpb25pbmdfdHlwZXNfMS5SZWN0YW5nbGVFZGdlLmJvdHRvbSwgcG9zaXRpb25pbmdfdHlwZXNfMS5SZWN0YW5nbGVFZGdlLnJpZ2h0KSxcclxuICAgIF9hWzcgLyogYm90dG9tQXV0b0VkZ2UgKi9dID0gX2NyZWF0ZVBvc2l0aW9uRGF0YShwb3NpdGlvbmluZ190eXBlc18xLlJlY3RhbmdsZUVkZ2UuYm90dG9tLCB1bmRlZmluZWQsIHRydWUpLFxyXG4gICAgX2FbOCAvKiBsZWZ0VG9wRWRnZSAqL10gPSBfY3JlYXRlUG9zaXRpb25EYXRhKHBvc2l0aW9uaW5nX3R5cGVzXzEuUmVjdGFuZ2xlRWRnZS5sZWZ0LCBwb3NpdGlvbmluZ190eXBlc18xLlJlY3RhbmdsZUVkZ2UudG9wKSxcclxuICAgIF9hWzkgLyogbGVmdENlbnRlciAqL10gPSBfY3JlYXRlUG9zaXRpb25EYXRhKHBvc2l0aW9uaW5nX3R5cGVzXzEuUmVjdGFuZ2xlRWRnZS5sZWZ0KSxcclxuICAgIF9hWzEwIC8qIGxlZnRCb3R0b21FZGdlICovXSA9IF9jcmVhdGVQb3NpdGlvbkRhdGEocG9zaXRpb25pbmdfdHlwZXNfMS5SZWN0YW5nbGVFZGdlLmxlZnQsIHBvc2l0aW9uaW5nX3R5cGVzXzEuUmVjdGFuZ2xlRWRnZS5ib3R0b20pLFxyXG4gICAgX2FbMTEgLyogcmlnaHRUb3BFZGdlICovXSA9IF9jcmVhdGVQb3NpdGlvbkRhdGEocG9zaXRpb25pbmdfdHlwZXNfMS5SZWN0YW5nbGVFZGdlLnJpZ2h0LCBwb3NpdGlvbmluZ190eXBlc18xLlJlY3RhbmdsZUVkZ2UudG9wKSxcclxuICAgIF9hWzEyIC8qIHJpZ2h0Q2VudGVyICovXSA9IF9jcmVhdGVQb3NpdGlvbkRhdGEocG9zaXRpb25pbmdfdHlwZXNfMS5SZWN0YW5nbGVFZGdlLnJpZ2h0KSxcclxuICAgIF9hWzEzIC8qIHJpZ2h0Qm90dG9tRWRnZSAqL10gPSBfY3JlYXRlUG9zaXRpb25EYXRhKHBvc2l0aW9uaW5nX3R5cGVzXzEuUmVjdGFuZ2xlRWRnZS5yaWdodCwgcG9zaXRpb25pbmdfdHlwZXNfMS5SZWN0YW5nbGVFZGdlLmJvdHRvbSksXHJcbiAgICBfYSk7XHJcbi8qKlxyXG4gKiBAZGVwcmVjYXRlZCB3aWxsIGJlIHJlbW92ZWQgaW4gNi4wLlxyXG4gKi9cclxudmFyIFNMSURFX0FOSU1BVElPTlMgPSAoX2IgPSB7fSxcclxuICAgIF9iW3Bvc2l0aW9uaW5nX3R5cGVzXzEuUmVjdGFuZ2xlRWRnZS50b3BdID0gJ3NsaWRlVXBJbjIwJyxcclxuICAgIF9iW3Bvc2l0aW9uaW5nX3R5cGVzXzEuUmVjdGFuZ2xlRWRnZS5ib3R0b21dID0gJ3NsaWRlRG93bkluMjAnLFxyXG4gICAgX2JbcG9zaXRpb25pbmdfdHlwZXNfMS5SZWN0YW5nbGVFZGdlLmxlZnRdID0gJ3NsaWRlTGVmdEluMjAnLFxyXG4gICAgX2JbcG9zaXRpb25pbmdfdHlwZXNfMS5SZWN0YW5nbGVFZGdlLnJpZ2h0XSA9ICdzbGlkZVJpZ2h0SW4yMCcsXHJcbiAgICBfYik7XHJcbi8qKlxyXG4gKiBEbyBub3QgY2FsbCBtZXRob2RzIGZyb20gdGhpcyBkaXJlY3RseSwgdXNlIGVpdGhlciBwb3NpdGlvbkNhbGxvdXQgb3IgcG9zaXRpb25FbGVtZW50IG9yIG1ha2UgYW5vdGhlciBmdW5jdGlvbiB0aGF0XHJcbiAqIHV0aWxpemVzIHRoZW0uXHJcbiAqL1xyXG52YXIgcG9zaXRpb25pbmdGdW5jdGlvbnM7XHJcbihmdW5jdGlvbiAocG9zaXRpb25pbmdGdW5jdGlvbnMpIHtcclxuICAgIGZ1bmN0aW9uIF9pc1JlY3RhbmdsZVdpdGhpbkJvdW5kcyhyZWN0LCBib3VuZGluZ1JlY3QpIHtcclxuICAgICAgICBpZiAocmVjdC50b3AgPCBib3VuZGluZ1JlY3QudG9wKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJlY3QuYm90dG9tID4gYm91bmRpbmdSZWN0LmJvdHRvbSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyZWN0LmxlZnQgPCBib3VuZGluZ1JlY3QubGVmdCkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyZWN0LnJpZ2h0ID4gYm91bmRpbmdSZWN0LnJpZ2h0KSB7XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdldHMgYWxsIG9mIHRoZSBlZGdlcyBvZiBhIHJlY3RhbmdsZSB0aGF0IGFyZSBvdXRzaWRlIG9mIHRoZSBnaXZlbiBib3VuZHMuXHJcbiAgICAgKiBJZiB0aGVyZSBhcmUgbm8gb3V0IG9mIGJvdW5kcyBlZGdlcyBpdCByZXR1cm5zIGFuIGVtcHR5IGFycmF5LlxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBfZ2V0T3V0T2ZCb3VuZHNFZGdlcyhyZWN0LCBib3VuZGluZ1JlY3QpIHtcclxuICAgICAgICB2YXIgb3V0T2ZCb3VuZHMgPSBuZXcgQXJyYXkoKTtcclxuICAgICAgICBpZiAocmVjdC50b3AgPCBib3VuZGluZ1JlY3QudG9wKSB7XHJcbiAgICAgICAgICAgIG91dE9mQm91bmRzLnB1c2gocG9zaXRpb25pbmdfdHlwZXNfMS5SZWN0YW5nbGVFZGdlLnRvcCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChyZWN0LmJvdHRvbSA+IGJvdW5kaW5nUmVjdC5ib3R0b20pIHtcclxuICAgICAgICAgICAgb3V0T2ZCb3VuZHMucHVzaChwb3NpdGlvbmluZ190eXBlc18xLlJlY3RhbmdsZUVkZ2UuYm90dG9tKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKHJlY3QubGVmdCA8IGJvdW5kaW5nUmVjdC5sZWZ0KSB7XHJcbiAgICAgICAgICAgIG91dE9mQm91bmRzLnB1c2gocG9zaXRpb25pbmdfdHlwZXNfMS5SZWN0YW5nbGVFZGdlLmxlZnQpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAocmVjdC5yaWdodCA+IGJvdW5kaW5nUmVjdC5yaWdodCkge1xyXG4gICAgICAgICAgICBvdXRPZkJvdW5kcy5wdXNoKHBvc2l0aW9uaW5nX3R5cGVzXzEuUmVjdGFuZ2xlRWRnZS5yaWdodCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBvdXRPZkJvdW5kcztcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIF9nZXRFZGdlVmFsdWUocmVjdCwgZWRnZSkge1xyXG4gICAgICAgIHJldHVybiByZWN0W3Bvc2l0aW9uaW5nX3R5cGVzXzEuUmVjdGFuZ2xlRWRnZVtlZGdlXV07XHJcbiAgICB9XHJcbiAgICBmdW5jdGlvbiBfc2V0RWRnZVZhbHVlKHJlY3QsIGVkZ2UsIHZhbHVlKSB7XHJcbiAgICAgICAgcmVjdFtwb3NpdGlvbmluZ190eXBlc18xLlJlY3RhbmdsZUVkZ2VbZWRnZV1dID0gdmFsdWU7XHJcbiAgICAgICAgcmV0dXJuIHJlY3Q7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIG1pZGRsZSB2YWx1ZSBvZiBhbiBlZGdlLiBPbmx5IHJldHVybnMgMSB2YWx1ZSByYXRoZXIgdGhhbiB4eSBjb29yZGluYXRlcyBhc1xyXG4gICAgICogdGhlIGl0c2VsZiBhbHJlYWR5IGNvbnRhaW5zIHRoZSBvdGhlciBjb29yZGluYXRlLlxyXG4gICAgICogRm9yIGluc3RhbmNlLCBhIGJvdHRvbSBlZGdlJ3MgY3VycmVudCB2YWx1ZSBpcyBpdCdzIHkgY29vcmRpbmF0ZSwgc28gdGhlIG51bWJlciByZXR1cm5lZCBpcyB0aGUgeC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1JlY3RhbmdsZX0gcmVjdFxyXG4gICAgICogQHBhcmFtIHtSZWN0YW5nbGVFZGdlfSBlZGdlXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBfZ2V0Q2VudGVyVmFsdWUocmVjdCwgZWRnZSkge1xyXG4gICAgICAgIHZhciBlZGdlcyA9IF9nZXRGbGFua2luZ0VkZ2VzKGVkZ2UpO1xyXG4gICAgICAgIHJldHVybiAoX2dldEVkZ2VWYWx1ZShyZWN0LCBlZGdlcy5wb3NpdGl2ZUVkZ2UpICsgX2dldEVkZ2VWYWx1ZShyZWN0LCBlZGdlcy5uZWdhdGl2ZUVkZ2UpKSAvIDI7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEZsaXBzIHRoZSB2YWx1ZSBkZXBlbmRpbmcgb24gdGhlIGVkZ2UuXHJcbiAgICAgKiBJZiB0aGUgZWRnZSBpcyBhIFwicG9zaXRpdmVcIiBlZGdlLCBUb3Agb3IgTGVmdCwgdGhlbiB0aGUgdmFsdWUgc2hvdWxkIHN0YXkgYXMgaXQgaXMuXHJcbiAgICAgKiBJZiB0aGUgZWRnZSBpcyBhIFwibmVnYXRpdmVcIiBlZGdlLCBCb3R0b20gb3IgUmlnaHQsIHRoZW4gdGhlIHZhbHVlIHNob3VsZCBiZSBmbGlwcGVkLlxyXG4gICAgICogVGhpcyBpcyB0byBhY2NvdW50IGZvciB0aGUgZmFjdCB0aGF0IHRoZSBjb29yZGluYXRlcyBhcmUgZWZmZWN0aXZlbHkgcmV2ZXNlcnZlZCBpbiBjZXJ0YWluIGNhc2VzIGZvciB0aGUgXCJuZWdhdGl2ZVwiIGVkZ2VzLlxyXG4gICAgICogRm9yIGV4YW1wbGUsIHdoZW4gdGVzdGluZyB0byBzZWUgaWYgYSBib3R0b20gZWRnZSAxIGlzIHdpdGhpbiB0aGUgYm91bmRzIG9mIGFub3RoZXIgYm90dG9tIGVkZ2UgMi5cclxuICAgICAqIElmIGVkZ2UgMSBpcyBncmVhdGVyIHRoYW4gZWRnZSAyIHRoZW4gaXQgaXMgb3V0IG9mIGJvdW5kcy4gVGhpcyBpcyByZXZlcnNlZCBmb3IgdG9wIGVkZ2UgMSBhbmQgdG9wIGVkZ2UgMi5cclxuICAgICAqIElmIHRvcCBlZGdlIDEgaXMgbGVzcyB0aGFuIGVkZ2UgMiB0aGVuIGl0IGlzIG91dCBvZiBib3VuZHMuXHJcbiAgICAgKlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7UmVjdGFuZ2xlRWRnZX0gZWRnZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlXHJcbiAgICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBfZ2V0UmVsYXRpdmVFZGdlVmFsdWUoZWRnZSwgdmFsdWUpIHtcclxuICAgICAgICBpZiAoZWRnZSA+IDApIHtcclxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlICogLTE7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgZnVuY3Rpb24gX2dldFJlbGF0aXZlUmVjdEVkZ2VWYWx1ZShlZGdlLCByZWN0KSB7XHJcbiAgICAgICAgcmV0dXJuIF9nZXRSZWxhdGl2ZUVkZ2VWYWx1ZShlZGdlLCBfZ2V0RWRnZVZhbHVlKHJlY3QsIGVkZ2UpKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIF9nZXRSZWxhdGl2ZUVkZ2VEaWZmZXJlbmNlKHJlY3QsIGhvc3RSZWN0LCBlZGdlKSB7XHJcbiAgICAgICAgdmFyIGVkZ2VEaWZmZXJlbmNlID0gX2dldEVkZ2VWYWx1ZShyZWN0LCBlZGdlKSAtIF9nZXRFZGdlVmFsdWUoaG9zdFJlY3QsIGVkZ2UpO1xyXG4gICAgICAgIHJldHVybiBfZ2V0UmVsYXRpdmVFZGdlVmFsdWUoZWRnZSwgZWRnZURpZmZlcmVuY2UpO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBNb3ZlcyB0aGUgZWRnZSBvZiBhIHJlY3RhbmdsZSB0byB0aGUgdmFsdWUgZ2l2ZW4uIEl0IG9ubHkgbW92ZXMgdGhlIGVkZ2UgaW4gYSBsaW5lYXIgZGlyZWN0aW9uIGJhc2VkIG9uIHRoYXQgZWRnZS5cclxuICAgICAqIEZvciBleGFtcGxlLCBpZiBpdCdzIGEgYm90dG9tIGVkZ2UgaXQgd2lsbCBvbmx5IGNoYW5nZSB5IGNvb3JkaW5hdGVzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7UmVjdGFuZ2xlfSByZWN0XHJcbiAgICAgKiBAcGFyYW0ge1JlY3RhbmdsZUVkZ2V9IGVkZ2VcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBuZXdWYWx1ZVxyXG4gICAgICogQHJldHVybnMge1JlY3RhbmdsZX1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gX21vdmVFZGdlKHJlY3QsIGVkZ2UsIG5ld1ZhbHVlKSB7XHJcbiAgICAgICAgdmFyIGRpZmZlcmVuY2UgPSBfZ2V0RWRnZVZhbHVlKHJlY3QsIGVkZ2UpIC0gbmV3VmFsdWU7XHJcbiAgICAgICAgcmVjdCA9IF9zZXRFZGdlVmFsdWUocmVjdCwgZWRnZSwgbmV3VmFsdWUpO1xyXG4gICAgICAgIHJlY3QgPSBfc2V0RWRnZVZhbHVlKHJlY3QsIGVkZ2UgKiAtMSwgX2dldEVkZ2VWYWx1ZShyZWN0LCBlZGdlICogLTEpIC0gZGlmZmVyZW5jZSk7XHJcbiAgICAgICAgcmV0dXJuIHJlY3Q7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEFsaWducyB0aGUgZWRnZSBvbiB0aGUgcGFzc2VkIGluIHJlY3QgdG8gdGhlIHRhcmdldC4gSWYgdGhlcmUgaXMgYSBnYXAgdGhlbiBpdCB3aWxsIGhhdmUgdGhhdCBzcGFjZSBiZXR3ZWVuIHRoZSB0d28uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtSZWN0YW5nbGV9IHJlY3RcclxuICAgICAqIEBwYXJhbSB7UmVjdGFuZ2xlfSB0YXJnZXRcclxuICAgICAqIEBwYXJhbSB7UmVjdGFuZ2xlRWRnZX0gZWRnZVxyXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IFtnYXA9MF1cclxuICAgICAqIEByZXR1cm5zIHtSZWN0YW5nbGV9XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIF9hbGlnbkVkZ2VzKHJlY3QsIHRhcmdldCwgZWRnZSwgZ2FwKSB7XHJcbiAgICAgICAgaWYgKGdhcCA9PT0gdm9pZCAwKSB7IGdhcCA9IDA7IH1cclxuICAgICAgICByZXR1cm4gX21vdmVFZGdlKHJlY3QsIGVkZ2UsIF9nZXRFZGdlVmFsdWUodGFyZ2V0LCBlZGdlKSArIF9nZXRSZWxhdGl2ZUVkZ2VWYWx1ZShlZGdlLCBnYXApKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQWxpZ25zIHRoZSB0YXJnZXRFZGdlIG9uIHRoZSBwYXNzZWQgaW4gdGFyZ2V0IHRvIHRoZSByZWN0cyBjb3JyZXNwb25kaW5nIG9wcG9zaXRlIGVkZ2UuXHJcbiAgICAgKiBGb3IgaW5zdGFuY2UgaWYgdGFyZ2V0RWRnZSBpcyBib3R0b20sIHRoZW4gdGhlIHJlY3RzIHRvcCB3aWxsIGJlIG1vdmVkIHRvIG1hdGNoIGl0LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7UmVjdGFuZ2xlfSByZWN0XHJcbiAgICAgKiBAcGFyYW0ge1JlY3RhbmdsZX0gdGFyZ2V0XHJcbiAgICAgKiBAcGFyYW0ge1JlY3RhbmdsZUVkZ2V9IHRhcmdldEVkZ2VcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZ2FwPTBdXHJcbiAgICAgKiBAcmV0dXJucyB7UmVjdGFuZ2xlfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBfYWxpZ25PcHBvc2l0ZUVkZ2VzKHJlY3QsIHRhcmdldCwgdGFyZ2V0RWRnZSwgZ2FwKSB7XHJcbiAgICAgICAgaWYgKGdhcCA9PT0gdm9pZCAwKSB7IGdhcCA9IDA7IH1cclxuICAgICAgICB2YXIgb3Bwb3NpdGVFZGdlID0gdGFyZ2V0RWRnZSAqIC0xO1xyXG4gICAgICAgIHZhciBhZGp1c3RlZEdhcCA9IF9nZXRSZWxhdGl2ZUVkZ2VWYWx1ZShvcHBvc2l0ZUVkZ2UsIGdhcCk7XHJcbiAgICAgICAgcmV0dXJuIF9tb3ZlRWRnZShyZWN0LCB0YXJnZXRFZGdlICogLTEsIF9nZXRFZGdlVmFsdWUodGFyZ2V0LCB0YXJnZXRFZGdlKSArIGFkanVzdGVkR2FwKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogVGVzdHMgdG8gc2VlIGlmIHRoZSBnaXZlbiBlZGdlIGlzIHdpdGhpbiB0aGUgYm91bmRzIG9mIHRoZSBnaXZlbiByZWN0YW5nbGUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtSZWN0YW5nbGV9IHJlY3RcclxuICAgICAqIEBwYXJhbSB7UmVjdGFuZ2xlfSBib3VuZHNcclxuICAgICAqIEBwYXJhbSB7UmVjdGFuZ2xlRWRnZX0gZWRnZVxyXG4gICAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIF9pc0VkZ2VJbkJvdW5kcyhyZWN0LCBib3VuZHMsIGVkZ2UpIHtcclxuICAgICAgICB2YXIgYWRqdXN0ZWRSZWN0VmFsdWUgPSBfZ2V0UmVsYXRpdmVSZWN0RWRnZVZhbHVlKGVkZ2UsIHJlY3QpO1xyXG4gICAgICAgIHJldHVybiBhZGp1c3RlZFJlY3RWYWx1ZSA+IF9nZXRSZWxhdGl2ZVJlY3RFZGdlVmFsdWUoZWRnZSwgYm91bmRzKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogQXR0ZW1wdHMgdG8gbW92ZSB0aGUgcmVjdGFuZ2xlIHRocm91Z2ggdmFyaW91cyBzaWRlcyBvZiB0aGUgdGFyZ2V0IHRvIGZpbmQgYSBwbGFjZSB0byBmaXQuXHJcbiAgICAgKiBJZiBubyBmaXQgaXMgZm91bmQsIHRoZSBvcmlnaW5hbCBwb3NpdGlvbiBzaG91bGQgYmUgcmV0dXJuZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtSZWN0YW5nbGV9IHJlY3RcclxuICAgICAqIEBwYXJhbSB7UmVjdGFuZ2xlfSB0YXJnZXRcclxuICAgICAqIEBwYXJhbSB7UmVjdGFuZ2xlfSBib3VuZGluZ1xyXG4gICAgICogQHBhcmFtIHtJUG9zaXRpb25EaXJlY3Rpb25hbEhpbnREYXRhfSBwb3NpdGlvbkRhdGFcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZ2FwPTBdXHJcbiAgICAgKiBAcmV0dXJucyB7SUVsZW1lbnRQb3NpdGlvbn1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gX2ZsaXBUb0ZpdChyZWN0LCB0YXJnZXQsIGJvdW5kaW5nLCBwb3NpdGlvbkRhdGEsIGdhcCkge1xyXG4gICAgICAgIGlmIChnYXAgPT09IHZvaWQgMCkgeyBnYXAgPSAwOyB9XHJcbiAgICAgICAgdmFyIGRpcmVjdGlvbnMgPSBbcG9zaXRpb25pbmdfdHlwZXNfMS5SZWN0YW5nbGVFZGdlLmxlZnQsIHBvc2l0aW9uaW5nX3R5cGVzXzEuUmVjdGFuZ2xlRWRnZS5yaWdodCwgcG9zaXRpb25pbmdfdHlwZXNfMS5SZWN0YW5nbGVFZGdlLmJvdHRvbSwgcG9zaXRpb25pbmdfdHlwZXNfMS5SZWN0YW5nbGVFZGdlLnRvcF07XHJcbiAgICAgICAgdmFyIGN1cnJlbnRFc3RpbWF0ZSA9IHJlY3Q7XHJcbiAgICAgICAgdmFyIGN1cnJlbnRFZGdlID0gcG9zaXRpb25EYXRhLnRhcmdldEVkZ2U7XHJcbiAgICAgICAgdmFyIGN1cnJlbnRBbGlnbm1lbnQgPSBwb3NpdGlvbkRhdGEuYWxpZ25tZW50RWRnZTtcclxuICAgICAgICAvLyBLZWVwIHN3aXRjaGluZyBzaWRlcyB1bnRpbCBvbmUgaXMgZm91bmQgd2l0aCBlbm91Z2ggc3BhY2UuIElmIGFsbCBzaWRlcyBkb24ndCBmaXQgdGhlbiByZXR1cm4gdGhlIHVubW9kaWZpZWQgZWxlbWVudC5cclxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xyXG4gICAgICAgICAgICBpZiAoIV9pc0VkZ2VJbkJvdW5kcyhjdXJyZW50RXN0aW1hdGUsIGJvdW5kaW5nLCBjdXJyZW50RWRnZSkpIHtcclxuICAgICAgICAgICAgICAgIGRpcmVjdGlvbnMuc3BsaWNlKGRpcmVjdGlvbnMuaW5kZXhPZihjdXJyZW50RWRnZSksIDEpO1xyXG4gICAgICAgICAgICAgICAgaWYgKGRpcmVjdGlvbnMuaW5kZXhPZihjdXJyZW50RWRnZSAqIC0xKSA+IC0xKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEVkZ2UgPSBjdXJyZW50RWRnZSAqIC0xO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY3VycmVudEFsaWdubWVudCA9IGN1cnJlbnRFZGdlO1xyXG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRFZGdlID0gZGlyZWN0aW9ucy5zbGljZSgtMSlbMF07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBjdXJyZW50RXN0aW1hdGUgPSBfZXN0aW1hdGVQb3NpdGlvbihyZWN0LCB0YXJnZXQsIHsgdGFyZ2V0RWRnZTogY3VycmVudEVkZ2UsIGFsaWdubWVudEVkZ2U6IGN1cnJlbnRBbGlnbm1lbnQgfSwgZ2FwKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICAgICAgZWxlbWVudFJlY3RhbmdsZTogY3VycmVudEVzdGltYXRlLFxyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldEVkZ2U6IGN1cnJlbnRFZGdlLFxyXG4gICAgICAgICAgICAgICAgICAgIGFsaWdubWVudEVkZ2U6IGN1cnJlbnRBbGlnbm1lbnRcclxuICAgICAgICAgICAgICAgIH07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgZWxlbWVudFJlY3RhbmdsZTogcmVjdCxcclxuICAgICAgICAgICAgdGFyZ2V0RWRnZTogcG9zaXRpb25EYXRhLnRhcmdldEVkZ2UsXHJcbiAgICAgICAgICAgIGFsaWdubWVudEVkZ2U6IGN1cnJlbnRBbGlnbm1lbnRcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBBZGp1c3RzIGEgZWxlbWVudCByZWN0YW5nbGUgdG8gZml0IHdpdGhpbiB0aGUgYm91bmRzIGdpdmVuLiBJZiBkaXJlY3Rpb25hbEhpbnRGaXhlZCBvciBjb3ZlcnRhcmdldCBpcyBwYXNzZWQgaW5cclxuICAgICAqIHRoZW4gdGhlIGVsZW1lbnQgd2lsbCBub3QgZmxpcCBzaWRlcyBvbiB0aGUgdGFyZ2V0LiBUaGV5IHdpbGwsIGhvd2V2ZXIsIGJlIG51ZGdlZCB0byBmaXQgd2l0aGluIHRoZSBib3VuZHMgZ2l2ZW4uXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtSZWN0YW5nbGV9IGVsZW1lbnRcclxuICAgICAqIEBwYXJhbSB7UmVjdGFuZ2xlfSB0YXJnZXRcclxuICAgICAqIEBwYXJhbSB7UmVjdGFuZ2xlfSBib3VuZGluZ1xyXG4gICAgICogQHBhcmFtIHtJUG9zaXRpb25EaXJlY3Rpb25hbEhpbnREYXRhfSBwb3NpdGlvbkRhdGFcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBbZ2FwPTBdXHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtkaXJlY3Rpb25hbEhpbnRGaXhlZF1cclxuICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2NvdmVyVGFyZ2V0XVxyXG4gICAgICogQHJldHVybnMge0lFbGVtZW50UG9zaXRpb259XHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIF9hZGp1c3RGaXRXaXRoaW5Cb3VuZHMoZWxlbWVudCwgdGFyZ2V0LCBib3VuZGluZywgcG9zaXRpb25EYXRhLCBnYXAsIGRpcmVjdGlvbmFsSGludEZpeGVkLCBjb3ZlclRhcmdldCkge1xyXG4gICAgICAgIGlmIChnYXAgPT09IHZvaWQgMCkgeyBnYXAgPSAwOyB9XHJcbiAgICAgICAgdmFyIGFsaWdubWVudEVkZ2UgPSBwb3NpdGlvbkRhdGEuYWxpZ25tZW50RWRnZTtcclxuICAgICAgICB2YXIgZWxlbWVudEVzdGltYXRlID0ge1xyXG4gICAgICAgICAgICBlbGVtZW50UmVjdGFuZ2xlOiBlbGVtZW50LFxyXG4gICAgICAgICAgICB0YXJnZXRFZGdlOiBwb3NpdGlvbkRhdGEudGFyZ2V0RWRnZSxcclxuICAgICAgICAgICAgYWxpZ25tZW50RWRnZTogYWxpZ25tZW50RWRnZVxyXG4gICAgICAgIH07XHJcbiAgICAgICAgaWYgKCFkaXJlY3Rpb25hbEhpbnRGaXhlZCAmJiAhY292ZXJUYXJnZXQpIHtcclxuICAgICAgICAgICAgZWxlbWVudEVzdGltYXRlID0gX2ZsaXBUb0ZpdChlbGVtZW50LCB0YXJnZXQsIGJvdW5kaW5nLCBwb3NpdGlvbkRhdGEsIGdhcCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHZhciBvdXRPZkJvdW5kcyA9IF9nZXRPdXRPZkJvdW5kc0VkZ2VzKGVsZW1lbnQsIGJvdW5kaW5nKTtcclxuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIG91dE9mQm91bmRzXzEgPSBvdXRPZkJvdW5kczsgX2kgPCBvdXRPZkJvdW5kc18xLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgICAgICB2YXIgZGlyZWN0aW9uID0gb3V0T2ZCb3VuZHNfMVtfaV07XHJcbiAgICAgICAgICAgIGVsZW1lbnRFc3RpbWF0ZS5lbGVtZW50UmVjdGFuZ2xlID0gX2FsaWduRWRnZXMoZWxlbWVudEVzdGltYXRlLmVsZW1lbnRSZWN0YW5nbGUsIGJvdW5kaW5nLCBkaXJlY3Rpb24pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gZWxlbWVudEVzdGltYXRlO1xyXG4gICAgfVxyXG4gICAgLyoqXHJcbiAgICAgKiBNb3ZlcyB0aGUgbWlkZGxlIHBvaW50IG9uIGFuIGVkZ2UgdG8gdGhlIHBvaW50IGdpdmVuLlxyXG4gICAgICogT25seSBtb3ZlcyBpbiBvbmUgZGlyZWN0aW9uLiBGb3IgaW5zdGFuY2UgaWYgYSBib3R0b20gZWRnZSBpcyBwYXNzZWQgaW4sIHRoZW5cclxuICAgICAqIHRoZSBib3R0b20gZWRnZSB3aWxsIGJlIG1vdmVkIGluIHRoZSB4IGF4aXMgdG8gbWF0Y2ggdGhlIHBvaW50LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7UmVjdGFuZ2xlfSByZWN0XHJcbiAgICAgKiBAcGFyYW0ge1JlY3RhbmdsZUVkZ2V9IGVkZ2VcclxuICAgICAqIEBwYXJhbSB7bnVtYmVyfSBwb2ludFxyXG4gICAgICogQHJldHVybnMge1JlY3RhbmdsZX1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gX2NlbnRlckVkZ2VUb1BvaW50KHJlY3QsIGVkZ2UsIHBvaW50KSB7XHJcbiAgICAgICAgdmFyIHBvc2l0aXZlRWRnZSA9IF9nZXRGbGFua2luZ0VkZ2VzKGVkZ2UpLnBvc2l0aXZlRWRnZTtcclxuICAgICAgICB2YXIgZWxlbWVudE1pZGRsZSA9IF9nZXRDZW50ZXJWYWx1ZShyZWN0LCBlZGdlKTtcclxuICAgICAgICB2YXIgZGlzdGFuY2VUb01pZGRsZSA9IGVsZW1lbnRNaWRkbGUgLSBfZ2V0RWRnZVZhbHVlKHJlY3QsIHBvc2l0aXZlRWRnZSk7XHJcbiAgICAgICAgcmV0dXJuIF9tb3ZlRWRnZShyZWN0LCBwb3NpdGl2ZUVkZ2UsIHBvaW50IC0gZGlzdGFuY2VUb01pZGRsZSk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIE1vdmVzIHRoZSBlbGVtZW50IHJlY3RhbmdsZSB0byBiZSBhcHByb3ByaWF0ZWx5IHBvc2l0aW9uZWQgcmVsYXRpdmUgdG8gYSBnaXZlbiB0YXJnZXQuXHJcbiAgICAgKiBEb2VzIG5vdCBmbGlwIG9yIGFkanVzdCB0aGUgZWxlbWVudC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ge1JlY3RhbmdsZX0gZWxlbWVudFRvUG9zaXRpb25cclxuICAgICAqIEBwYXJhbSB7UmVjdGFuZ2xlfSB0YXJnZXRcclxuICAgICAqIEBwYXJhbSB7SVBvc2l0aW9uRGlyZWN0aW9uYWxIaW50RGF0YX0gcG9zaXRpb25EYXRhXHJcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gW2dhcD0wXVxyXG4gICAgICogQHBhcmFtIHtib29sZWFufSBbY292ZXJUYXJnZXRdXHJcbiAgICAgKiBAcmV0dXJucyB7UmVjdGFuZ2xlfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBfZXN0aW1hdGVQb3NpdGlvbihlbGVtZW50VG9Qb3NpdGlvbiwgdGFyZ2V0LCBwb3NpdGlvbkRhdGEsIGdhcCwgY292ZXJUYXJnZXQpIHtcclxuICAgICAgICBpZiAoZ2FwID09PSB2b2lkIDApIHsgZ2FwID0gMDsgfVxyXG4gICAgICAgIHZhciBlc3RpbWF0ZWRFbGVtZW50UG9zaXRpb247XHJcbiAgICAgICAgdmFyIGFsaWdubWVudEVkZ2UgPSBwb3NpdGlvbkRhdGEuYWxpZ25tZW50RWRnZSwgdGFyZ2V0RWRnZSA9IHBvc2l0aW9uRGF0YS50YXJnZXRFZGdlO1xyXG4gICAgICAgIHZhciBlbGVtZW50RWRnZSA9IGNvdmVyVGFyZ2V0ID8gdGFyZ2V0RWRnZSA6IHRhcmdldEVkZ2UgKiAtMTtcclxuICAgICAgICBlc3RpbWF0ZWRFbGVtZW50UG9zaXRpb24gPSBjb3ZlclRhcmdldCA/IF9hbGlnbkVkZ2VzKGVsZW1lbnRUb1Bvc2l0aW9uLCB0YXJnZXQsIHRhcmdldEVkZ2UsIGdhcCkgOlxyXG4gICAgICAgICAgICBfYWxpZ25PcHBvc2l0ZUVkZ2VzKGVsZW1lbnRUb1Bvc2l0aW9uLCB0YXJnZXQsIHRhcmdldEVkZ2UsIGdhcCk7XHJcbiAgICAgICAgLy8gaWYgbm8gYWxpZ25tZW50IGVkZ2UgaXMgcHJvdmlkZWQgaXQncyBzdXBwb3NlZCB0byBiZSBjZW50ZXJlZC5cclxuICAgICAgICBpZiAoIWFsaWdubWVudEVkZ2UpIHtcclxuICAgICAgICAgICAgdmFyIHRhcmdldE1pZGRsZVBvaW50ID0gX2dldENlbnRlclZhbHVlKHRhcmdldCwgdGFyZ2V0RWRnZSk7XHJcbiAgICAgICAgICAgIGVzdGltYXRlZEVsZW1lbnRQb3NpdGlvbiA9IF9jZW50ZXJFZGdlVG9Qb2ludChlc3RpbWF0ZWRFbGVtZW50UG9zaXRpb24sIGVsZW1lbnRFZGdlLCB0YXJnZXRNaWRkbGVQb2ludCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICBlc3RpbWF0ZWRFbGVtZW50UG9zaXRpb24gPSBfYWxpZ25FZGdlcyhlc3RpbWF0ZWRFbGVtZW50UG9zaXRpb24sIHRhcmdldCwgYWxpZ25tZW50RWRnZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBlc3RpbWF0ZWRFbGVtZW50UG9zaXRpb247XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybnMgdGhlIG5vbi1vcHBvc2l0ZSBlZGdlcyBvZiB0aGUgdGFyZ2V0IGVkZ2UuXHJcbiAgICAgKiBGb3IgaW5zdGFuY2UgaWYgYm90dG9tIGlzIHBhc3NlZCBpbiB0aGVuIGxlZnQgYW5kIHJpZ2h0IHdpbGwgYmUgcmV0dXJuZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHtSZWN0YW5nbGVFZGdlfSBlZGdlXHJcbiAgICAgKiBAcmV0dXJucyB7eyBmaXJzdEVkZ2U6IFJlY3RhbmdsZUVkZ2UsIHNlY29uZEVkZ2U6IFJlY3RhbmdsZUVkZ2UgfX1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gX2dldEZsYW5raW5nRWRnZXMoZWRnZSkge1xyXG4gICAgICAgIGlmIChlZGdlID09PSBwb3NpdGlvbmluZ190eXBlc18xLlJlY3RhbmdsZUVkZ2UudG9wIHx8IGVkZ2UgPT09IHBvc2l0aW9uaW5nX3R5cGVzXzEuUmVjdGFuZ2xlRWRnZS5ib3R0b20pIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHBvc2l0aXZlRWRnZTogcG9zaXRpb25pbmdfdHlwZXNfMS5SZWN0YW5nbGVFZGdlLmxlZnQsXHJcbiAgICAgICAgICAgICAgICBuZWdhdGl2ZUVkZ2U6IHBvc2l0aW9uaW5nX3R5cGVzXzEuUmVjdGFuZ2xlRWRnZS5yaWdodFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgICAgIHBvc2l0aXZlRWRnZTogcG9zaXRpb25pbmdfdHlwZXNfMS5SZWN0YW5nbGVFZGdlLnRvcCxcclxuICAgICAgICAgICAgICAgIG5lZ2F0aXZlRWRnZTogcG9zaXRpb25pbmdfdHlwZXNfMS5SZWN0YW5nbGVFZGdlLmJvdHRvbVxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogRmluYWxpemVzIHRoZSBlbGVtZW50IHBvc2l0b24gYmFzZWQgb24gdGhlIGhvc3RFbGVtZW50LiBPbmx5IHJldHVybnMgdGhlXHJcbiAgICAgKiByZWN0YW5nbGUgdmFsdWVzIHRvIHBvc2l0aW9uIHN1Y2ggdGhhdCB0aGV5IGFyZSBhbmNob3JlZCB0byB0aGUgdGFyZ2V0LlxyXG4gICAgICogVGhpcyBoZWxwcyBwcmV2ZW50IHJlc2l6aW5nIGZyb20gbG9va2luZyB2ZXJ5IHN0cmFuZ2UuXHJcbiAgICAgKiBGb3IgaW5zdGFuY2UsIGlmIHRoZSB0YXJnZXQgZWRnZSBpcyB0b3AgYW5kIGFsaWduZWQgd2l0aCB0aGUgbGVmdCBzaWRlIHRoZW5cclxuICAgICAqIHRoZSBib3R0b20gYW5kIGxlZnQgdmFsdWVzIGFyZSByZXR1cm5lZCBzbyBhcyB0aGUgY2FsbG91IHNocmlua3MgaXQgc2hyaW5rcyB0b3dhcmRzIHRoYXQgY29ybmVyLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7UmVjdGFuZ2xlfSBlbGVtZW50UmVjdGFuZ2xlXHJcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBob3N0RWxlbWVudFxyXG4gICAgICogQHBhcmFtIHtSZWN0YW5nbGVFZGdlfSB0YXJnZXRFZGdlXHJcbiAgICAgKiBAcGFyYW0ge1JlY3RhbmdsZUVkZ2V9IFthbGlnbm1lbnRFZGdlXVxyXG4gICAgICogQHJldHVybnMge0lQYXJ0aWFsSVJlY3RhbmdsZX1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gX2ZpbmFsaXplRWxlbWVudFBvc2l0aW9uKGVsZW1lbnRSZWN0YW5nbGUsIGhvc3RFbGVtZW50LCB0YXJnZXRFZGdlLCBhbGlnbm1lbnRFZGdlKSB7XHJcbiAgICAgICAgdmFyIHJldHVyblZhbHVlID0ge307XHJcbiAgICAgICAgdmFyIGhvc3RSZWN0ID0gX2dldFJlY3RhbmdsZUZyb21IVE1MRWxlbWVudChob3N0RWxlbWVudCk7XHJcbiAgICAgICAgdmFyIGVsZW1lbnRFZGdlID0gdGFyZ2V0RWRnZSAqIC0xO1xyXG4gICAgICAgIHZhciBlbGVtZW50RWRnZVN0cmluZyA9IHBvc2l0aW9uaW5nX3R5cGVzXzEuUmVjdGFuZ2xlRWRnZVtlbGVtZW50RWRnZV07XHJcbiAgICAgICAgdmFyIHJldHVybkVkZ2UgPSBhbGlnbm1lbnRFZGdlID8gYWxpZ25tZW50RWRnZSA6IF9nZXRGbGFua2luZ0VkZ2VzKHRhcmdldEVkZ2UpLnBvc2l0aXZlRWRnZTtcclxuICAgICAgICByZXR1cm5WYWx1ZVtlbGVtZW50RWRnZVN0cmluZ10gPSBfZ2V0UmVsYXRpdmVFZGdlRGlmZmVyZW5jZShlbGVtZW50UmVjdGFuZ2xlLCBob3N0UmVjdCwgZWxlbWVudEVkZ2UpO1xyXG4gICAgICAgIHJldHVyblZhbHVlW3Bvc2l0aW9uaW5nX3R5cGVzXzEuUmVjdGFuZ2xlRWRnZVtyZXR1cm5FZGdlXV0gPSBfZ2V0UmVsYXRpdmVFZGdlRGlmZmVyZW5jZShlbGVtZW50UmVjdGFuZ2xlLCBob3N0UmVjdCwgcmV0dXJuRWRnZSk7XHJcbiAgICAgICAgcmV0dXJuIHJldHVyblZhbHVlO1xyXG4gICAgfVxyXG4gICAgLy8gU2luY2UgdGhlIGJlYWsgaXMgcm90YXRlZCA0NSBkZWdyZWVzIHRoZSBhY3R1YWwgaGVpZ2h0L3dpZHRoIGlzIHRoZSBsZW5ndGggb2YgdGhlIGRpYWdvbmFsLlxyXG4gICAgLy8gV2Ugc3RpbGwgd2FudCB0byBwb3NpdGlvbiB0aGUgYmVhayBiYXNlZCBvbiBpdCdzIG1pZHBvaW50IHdoaWNoIGRvZXMgbm90IGNoYW5nZS4gSXQgd2lsbFxyXG4gICAgLy8gYmUgYXQgKGJlYWt3aWR0aCAvIDIsIGJlYWt3aWR0aCAvIDIpXHJcbiAgICBmdW5jdGlvbiBfY2FsY3VsYXRlQWN0dWFsQmVha1dpZHRoSW5QaXhlbHMoYmVha1dpZHRoKSB7XHJcbiAgICAgICAgcmV0dXJuIE1hdGguc3FydChiZWFrV2lkdGggKiBiZWFrV2lkdGggKiAyKTtcclxuICAgIH1cclxuICAgIHBvc2l0aW9uaW5nRnVuY3Rpb25zLl9jYWxjdWxhdGVBY3R1YWxCZWFrV2lkdGhJblBpeGVscyA9IF9jYWxjdWxhdGVBY3R1YWxCZWFrV2lkdGhJblBpeGVscztcclxuICAgIC8qKlxyXG4gICAgICogUmV0dXJucyB0aGUgYXBwcm9wcmlhdGUgSVBvc2l0aW9uRGF0YSBiYXNlZCBvbiB0aGUgcHJvcHMgYWx0ZXJlZCBmb3IgUlRMLlxyXG4gICAgICogSWYgZGlyZWN0aW9uYWxIaW50Rm9yUlRMIGlzIHBhc3NlZCBpbiB0aGF0IGlzIHVzZWQgaWYgdGhlIHBhZ2UgaXMgUlRMLlxyXG4gICAgICogSWYgYSBkaXJlY3Rpb25hbEhpbnQgaXMgc3BlY2lmaWVkIGFuZCBubyBkaXJlY3Rpb25hbEhpbnRGb3JSVEwgaXMgYXZhaWxhYmxlIGFuZCB0aGUgcGFnZSBpcyBSVEwgdGhlIGhpbnQgd2lsbCBiZSBmbGlwcGVkLlxyXG4gICAgICogRm9yIGluc3RhbmNlIGJvdHRvbUxlZnRFZGdlIHdvdWxkIGJlY29tZSBib3R0b21SaWdodEVkZ2UuXHJcbiAgICAgKiBJZiB0aGVyZSBpcyBubyBkaXJlY3Rpb25hbEhpbnQgcGFzc2VkIGluIGJvdHRvbUF1dG9FZGdlIGlzIGNob3NlbiBhdXRvbWF0aWNhbGx5LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7SVBvc2l0aW9uUHJvcHN9IHByb3BzXHJcbiAgICAgKiBAcmV0dXJucyB7SVBvc2l0aW9uRGlyZWN0aW9uYWxIaW50RGF0YX1cclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gX2dldFBvc2l0aW9uRGF0YShkaXJlY3Rpb25hbEhpbnQsIGRpcmVjdGlvbmFsSGludEZvclJUTCkge1xyXG4gICAgICAgIGlmIChkaXJlY3Rpb25hbEhpbnQgPT09IHZvaWQgMCkgeyBkaXJlY3Rpb25hbEhpbnQgPSA3IC8qIGJvdHRvbUF1dG9FZGdlICovOyB9XHJcbiAgICAgICAgdmFyIHBvc2l0aW9uSW5mb3JtYXRpb24gPSB0c2xpYl8xLl9fYXNzaWduKHt9LCBEaXJlY3Rpb25hbERpY3Rpb25hcnlbZGlyZWN0aW9uYWxIaW50XSk7XHJcbiAgICAgICAgaWYgKFV0aWxpdGllc18xLmdldFJUTCgpKSB7XHJcbiAgICAgICAgICAgIC8vIElmIGFsaWdubWVudCBlZGdlIGV4aXN0cyBhbmQgdGhhdCBhbGlnbm1lbnQgZWRnZSBpcyAtMiBvciAyLCByaWdodCBvciBsZWZ0LCB0aGVuIGZsaXAgaXQuXHJcbiAgICAgICAgICAgIHBvc2l0aW9uSW5mb3JtYXRpb24uYWxpZ25tZW50RWRnZSA9IHBvc2l0aW9uSW5mb3JtYXRpb24uYWxpZ25tZW50RWRnZSAmJiBwb3NpdGlvbkluZm9ybWF0aW9uLmFsaWdubWVudEVkZ2UgJSAyID09PSAwXHJcbiAgICAgICAgICAgICAgICA/IHBvc2l0aW9uSW5mb3JtYXRpb24uYWxpZ25tZW50RWRnZSAqIC0xIDogdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICByZXR1cm4gZGlyZWN0aW9uYWxIaW50Rm9yUlRMICE9PSB1bmRlZmluZWQgP1xyXG4gICAgICAgICAgICAgICAgRGlyZWN0aW9uYWxEaWN0aW9uYXJ5W2RpcmVjdGlvbmFsSGludEZvclJUTF0gOlxyXG4gICAgICAgICAgICAgICAgcG9zaXRpb25JbmZvcm1hdGlvbjtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHBvc2l0aW9uSW5mb3JtYXRpb247XHJcbiAgICB9XHJcbiAgICBwb3NpdGlvbmluZ0Z1bmN0aW9ucy5fZ2V0UG9zaXRpb25EYXRhID0gX2dldFBvc2l0aW9uRGF0YTtcclxuICAgIC8qKlxyXG4gICAgICogR2V0J3MgdGhlIGFsaWdubWVudCBkYXRhIGZvciB0aGUgZ2l2ZW4gaW5mb3JtYXRpb24uIFRoaXMgb25seSByZWFsbHkgbWF0dGVycyBpZiB0aGUgcG9zaXRpb25pbmcgaXMgQXV0by5cclxuICAgICAqIElmIGl0IGlzIGF1dG8gdGhlbiB0aGUgYWxpZ25tZW50RWRnZSBzaG91bGQgYmUgY2hvc2VuIGJhc2VkIG9uIHRoZSB0YXJnZXQgZWRnZSdzIHBvc2l0aW9uIHJlbGF0aXZlIHRvXHJcbiAgICAgKiB0aGUgY2VudGVyIG9mIHRoZSBwYWdlLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB7SVBvc2l0aW9uRGlyZWN0aW9uYWxIaW50RGF0YX0gcG9zaXRpb25EYXRhXHJcbiAgICAgKiBAcGFyYW0ge1JlY3RhbmdsZX0gdGFyZ2V0XHJcbiAgICAgKiBAcGFyYW0ge1JlY3RhbmdsZX0gYm91bmRpbmdSZWN0XHJcbiAgICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtjb3ZlclRhcmdldF1cclxuICAgICAqIEByZXR1cm5zIHtJUG9zaXRpb25EaXJlY3Rpb25hbEhpbnREYXRhfVxyXG4gICAgICovXHJcbiAgICBmdW5jdGlvbiBfZ2V0QWxpZ25tZW50RGF0YShwb3NpdGlvbkRhdGEsIHRhcmdldCwgYm91bmRpbmdSZWN0LCBjb3ZlclRhcmdldCkge1xyXG4gICAgICAgIGlmIChwb3NpdGlvbkRhdGEuaXNBdXRvKSB7XHJcbiAgICAgICAgICAgIHBvc2l0aW9uRGF0YS5hbGlnbm1lbnRFZGdlID0gZ2V0Q2xvc2VzdEVkZ2UocG9zaXRpb25EYXRhLnRhcmdldEVkZ2UsIHRhcmdldCwgYm91bmRpbmdSZWN0KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHBvc2l0aW9uRGF0YTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGdldENsb3Nlc3RFZGdlKHRhcmdldEVkZ2UsIHRhcmdldCwgYm91bmRpbmdSZWN0KSB7XHJcbiAgICAgICAgdmFyIHRhcmdldENlbnRlciA9IF9nZXRDZW50ZXJWYWx1ZSh0YXJnZXQsIHRhcmdldEVkZ2UpO1xyXG4gICAgICAgIHZhciBib3VuZGluZ0NlbnRlciA9IF9nZXRDZW50ZXJWYWx1ZShib3VuZGluZ1JlY3QsIHRhcmdldEVkZ2UpO1xyXG4gICAgICAgIHZhciBfYSA9IF9nZXRGbGFua2luZ0VkZ2VzKHRhcmdldEVkZ2UpLCBwb3NpdGl2ZUVkZ2UgPSBfYS5wb3NpdGl2ZUVkZ2UsIG5lZ2F0aXZlRWRnZSA9IF9hLm5lZ2F0aXZlRWRnZTtcclxuICAgICAgICBpZiAodGFyZ2V0Q2VudGVyIDw9IGJvdW5kaW5nQ2VudGVyKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBwb3NpdGl2ZUVkZ2U7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gbmVnYXRpdmVFZGdlO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIF9wb3NpdGlvbkVsZW1lbnRXaXRoaW5Cb3VuZHMoZWxlbWVudFRvUG9zaXRpb24sIHRhcmdldCwgYm91bmRpbmcsIHBvc2l0aW9uRGF0YSwgZ2FwLCBkaXJlY3Rpb25hbEhpbnRGaXhlZCwgY292ZXJUYXJnZXQpIHtcclxuICAgICAgICB2YXIgZXN0aW1hdGVkRWxlbWVudFBvc2l0aW9uID0gX2VzdGltYXRlUG9zaXRpb24oZWxlbWVudFRvUG9zaXRpb24sIHRhcmdldCwgcG9zaXRpb25EYXRhLCBnYXAsIGNvdmVyVGFyZ2V0KTtcclxuICAgICAgICBpZiAoX2lzUmVjdGFuZ2xlV2l0aGluQm91bmRzKGVzdGltYXRlZEVsZW1lbnRQb3NpdGlvbiwgYm91bmRpbmcpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgICAgICBlbGVtZW50UmVjdGFuZ2xlOiBlc3RpbWF0ZWRFbGVtZW50UG9zaXRpb24sXHJcbiAgICAgICAgICAgICAgICB0YXJnZXRFZGdlOiBwb3NpdGlvbkRhdGEudGFyZ2V0RWRnZSxcclxuICAgICAgICAgICAgICAgIGFsaWdubWVudEVkZ2U6IHBvc2l0aW9uRGF0YS5hbGlnbm1lbnRFZGdlXHJcbiAgICAgICAgICAgIH07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICByZXR1cm4gX2FkanVzdEZpdFdpdGhpbkJvdW5kcyhlbGVtZW50VG9Qb3NpdGlvbiwgdGFyZ2V0LCBib3VuZGluZywgcG9zaXRpb25EYXRhLCBnYXAsIGRpcmVjdGlvbmFsSGludEZpeGVkLCBjb3ZlclRhcmdldCk7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgcG9zaXRpb25pbmdGdW5jdGlvbnMuX3Bvc2l0aW9uRWxlbWVudFdpdGhpbkJvdW5kcyA9IF9wb3NpdGlvbkVsZW1lbnRXaXRoaW5Cb3VuZHM7XHJcbiAgICBmdW5jdGlvbiBfZmluYWxpemVCZWFrUG9zaXRpb24oZWxlbWVudFBvc2l0aW9uLCBwb3NpdGlvbmVkQmVhaykge1xyXG4gICAgICAgIHZhciB0YXJnZXRFZGdlID0gZWxlbWVudFBvc2l0aW9uLnRhcmdldEVkZ2UgKiAtMTtcclxuICAgICAgICAvLyBUaGUgXCJob3N0XCIgZWxlbWVudCB0aGF0IHdlIHdpbGwgdXNlIHRvIGhlbHAgcG9zaXRpb24gdGhlIGJlYWsuXHJcbiAgICAgICAgdmFyIGFjdHVhbEVsZW1lbnQgPSBuZXcgUmVjdGFuZ2xlKDAsIGVsZW1lbnRQb3NpdGlvbi5lbGVtZW50UmVjdGFuZ2xlLndpZHRoLCAwLCBlbGVtZW50UG9zaXRpb24uZWxlbWVudFJlY3RhbmdsZS5oZWlnaHQpO1xyXG4gICAgICAgIHZhciByZXR1cm5FZGdlID0gZWxlbWVudFBvc2l0aW9uLmFsaWdubWVudEVkZ2UgPyBlbGVtZW50UG9zaXRpb24uYWxpZ25tZW50RWRnZSA6IF9nZXRGbGFua2luZ0VkZ2VzKHRhcmdldEVkZ2UpLnBvc2l0aXZlRWRnZTtcclxuICAgICAgICB2YXIgcmV0dXJuVmFsdWUgPSB7fTtcclxuICAgICAgICByZXR1cm5WYWx1ZVtwb3NpdGlvbmluZ190eXBlc18xLlJlY3RhbmdsZUVkZ2VbdGFyZ2V0RWRnZV1dID0gX2dldEVkZ2VWYWx1ZShwb3NpdGlvbmVkQmVhaywgdGFyZ2V0RWRnZSk7XHJcbiAgICAgICAgcmV0dXJuVmFsdWVbcG9zaXRpb25pbmdfdHlwZXNfMS5SZWN0YW5nbGVFZGdlW3JldHVybkVkZ2VdXSA9IF9nZXRSZWxhdGl2ZUVkZ2VEaWZmZXJlbmNlKHBvc2l0aW9uZWRCZWFrLCBhY3R1YWxFbGVtZW50LCByZXR1cm5FZGdlKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBlbGVtZW50UG9zaXRpb246IHRzbGliXzEuX19hc3NpZ24oe30sIHJldHVyblZhbHVlKSxcclxuICAgICAgICAgICAgY2xvc2VzdEVkZ2U6IGdldENsb3Nlc3RFZGdlKGVsZW1lbnRQb3NpdGlvbi50YXJnZXRFZGdlLCBwb3NpdGlvbmVkQmVhaywgYWN0dWFsRWxlbWVudCksXHJcbiAgICAgICAgICAgIHRhcmdldEVkZ2U6IHRhcmdldEVkZ2VcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgcG9zaXRpb25pbmdGdW5jdGlvbnMuX2ZpbmFsaXplQmVha1Bvc2l0aW9uID0gX2ZpbmFsaXplQmVha1Bvc2l0aW9uO1xyXG4gICAgZnVuY3Rpb24gX3Bvc2l0aW9uQmVhayhiZWFrV2lkdGgsIGVsZW1lbnRQb3NpdGlvbikge1xyXG4gICAgICAgIHZhciB0YXJnZXQgPSBlbGVtZW50UG9zaXRpb24udGFyZ2V0UmVjdGFuZ2xlO1xyXG4gICAgICAgIC8qKiBOb3RlIGFib3V0IGJlYWsgcG9zaXRpb25pbmc6IFRoZSBhY3R1YWwgYmVhayB3aWR0aCBvbmx5IG1hdHRlcnMgZm9yIGdldHRpbmcgdGhlIGdhcCBiZXR3ZWVuIHRoZSBjYWxsb3V0IGFuZCB0YXJnZXQsIGl0IGRvZXMgbm90IGltcGFjdCB0aGUgYmVhayBwbGFjZW1lbnQgd2l0aGluIHRoZSBjYWxsb3V0LiBGb3IgZXhhbXBsZSBleGFtcGxlLCBpZiB0aGUgYmVha1dpZHRoIGlzIDgsIHRoZW4gdGhlIGFjdHVhbCBiZWFrV2lkdGggaXMgc3Fycm9vdCg4XjIgKyA4XjIpID0gMTEuMzF4MTEuMzEuIFNvIHRoZSBjYWxsb3V0IHdpbGwgbmVlZCB0byBiZSBhbiBleHRyYSAzIHBpeGVscyBhd2F5IGZyb20gaXRzIHRhcmdldC4gV2hpbGUgdGhlIGJlYWsgaXMgYmVpbmcgcG9zaXRpb25lZCBpbiB0aGUgY2FsbG91dCBpdCBzdGlsbCBhY3RzIGFzIHRob3VnaCBpdCB3ZXJlIDh4OC4qL1xyXG4gICAgICAgIHZhciBfYSA9IF9nZXRGbGFua2luZ0VkZ2VzKGVsZW1lbnRQb3NpdGlvbi50YXJnZXRFZGdlKSwgcG9zaXRpdmVFZGdlID0gX2EucG9zaXRpdmVFZGdlLCBuZWdhdGl2ZUVkZ2UgPSBfYS5uZWdhdGl2ZUVkZ2U7XHJcbiAgICAgICAgdmFyIGJlYWtUYXJnZXRQb2ludCA9IF9nZXRDZW50ZXJWYWx1ZSh0YXJnZXQsIGVsZW1lbnRQb3NpdGlvbi50YXJnZXRFZGdlKTtcclxuICAgICAgICB2YXIgZWxlbWVudEJvdW5kcyA9IG5ldyBSZWN0YW5nbGUoYmVha1dpZHRoIC8gMiwgZWxlbWVudFBvc2l0aW9uLmVsZW1lbnRSZWN0YW5nbGUud2lkdGggLSBiZWFrV2lkdGggLyAyLCBiZWFrV2lkdGggLyAyLCBlbGVtZW50UG9zaXRpb24uZWxlbWVudFJlY3RhbmdsZS5oZWlnaHQgLSBiZWFrV2lkdGggLyAyKTtcclxuICAgICAgICB2YXIgYmVha1Bvc2l0b24gPSBuZXcgUmVjdGFuZ2xlKDAsIGJlYWtXaWR0aCwgMCwgYmVha1dpZHRoKTtcclxuICAgICAgICBiZWFrUG9zaXRvbiA9IF9tb3ZlRWRnZShiZWFrUG9zaXRvbiwgKGVsZW1lbnRQb3NpdGlvbi50YXJnZXRFZGdlICogLTEpLCAtYmVha1dpZHRoIC8gMik7XHJcbiAgICAgICAgYmVha1Bvc2l0b24gPSBfY2VudGVyRWRnZVRvUG9pbnQoYmVha1Bvc2l0b24sIGVsZW1lbnRQb3NpdGlvbi50YXJnZXRFZGdlICogLTEsIGJlYWtUYXJnZXRQb2ludCAtIF9nZXRSZWxhdGl2ZVJlY3RFZGdlVmFsdWUocG9zaXRpdmVFZGdlLCBlbGVtZW50UG9zaXRpb24uZWxlbWVudFJlY3RhbmdsZSkpO1xyXG4gICAgICAgIGlmICghX2lzRWRnZUluQm91bmRzKGJlYWtQb3NpdG9uLCBlbGVtZW50Qm91bmRzLCBwb3NpdGl2ZUVkZ2UpKSB7XHJcbiAgICAgICAgICAgIGJlYWtQb3NpdG9uID0gX2FsaWduRWRnZXMoYmVha1Bvc2l0b24sIGVsZW1lbnRCb3VuZHMsIHBvc2l0aXZlRWRnZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKCFfaXNFZGdlSW5Cb3VuZHMoYmVha1Bvc2l0b24sIGVsZW1lbnRCb3VuZHMsIG5lZ2F0aXZlRWRnZSkpIHtcclxuICAgICAgICAgICAgYmVha1Bvc2l0b24gPSBfYWxpZ25FZGdlcyhiZWFrUG9zaXRvbiwgZWxlbWVudEJvdW5kcywgbmVnYXRpdmVFZGdlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGJlYWtQb3NpdG9uO1xyXG4gICAgfVxyXG4gICAgcG9zaXRpb25pbmdGdW5jdGlvbnMuX3Bvc2l0aW9uQmVhayA9IF9wb3NpdGlvbkJlYWs7XHJcbiAgICBmdW5jdGlvbiBfZ2V0UmVjdGFuZ2xlRnJvbUhUTUxFbGVtZW50KGVsZW1lbnQpIHtcclxuICAgICAgICB2YXIgY2xpZW50UmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XHJcbiAgICAgICAgcmV0dXJuIG5ldyBSZWN0YW5nbGUoY2xpZW50UmVjdC5sZWZ0LCBjbGllbnRSZWN0LnJpZ2h0LCBjbGllbnRSZWN0LnRvcCwgY2xpZW50UmVjdC5ib3R0b20pO1xyXG4gICAgfVxyXG4gICAgcG9zaXRpb25pbmdGdW5jdGlvbnMuX2dldFJlY3RhbmdsZUZyb21IVE1MRWxlbWVudCA9IF9nZXRSZWN0YW5nbGVGcm9tSFRNTEVsZW1lbnQ7XHJcbiAgICBmdW5jdGlvbiBfZ2V0UmVjdGFuZ2xlRnJvbUlSZWN0KHJlY3QpIHtcclxuICAgICAgICByZXR1cm4gbmV3IFJlY3RhbmdsZShyZWN0LmxlZnQsIHJlY3QucmlnaHQsIHJlY3QudG9wLCByZWN0LmJvdHRvbSk7XHJcbiAgICB9XHJcbiAgICBwb3NpdGlvbmluZ0Z1bmN0aW9ucy5fZ2V0UmVjdGFuZ2xlRnJvbUlSZWN0ID0gX2dldFJlY3RhbmdsZUZyb21JUmVjdDtcclxuICAgIGZ1bmN0aW9uIF9nZXRUYXJnZXRSZWN0KGJvdW5kcywgdGFyZ2V0KSB7XHJcbiAgICAgICAgdmFyIHRhcmdldFJlY3RhbmdsZTtcclxuICAgICAgICBpZiAodGFyZ2V0KSB7XHJcbiAgICAgICAgICAgIGlmICh0YXJnZXQucHJldmVudERlZmF1bHQpIHtcclxuICAgICAgICAgICAgICAgIHZhciBldiA9IHRhcmdldDtcclxuICAgICAgICAgICAgICAgIHRhcmdldFJlY3RhbmdsZSA9IG5ldyBSZWN0YW5nbGUoZXYuY2xpZW50WCwgZXYuY2xpZW50WCwgZXYuY2xpZW50WSwgZXYuY2xpZW50WSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodGFyZ2V0LnggIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHBvaW50ID0gdGFyZ2V0O1xyXG4gICAgICAgICAgICAgICAgdGFyZ2V0UmVjdGFuZ2xlID0gbmV3IFJlY3RhbmdsZShwb2ludC54LCBwb2ludC54LCBwb2ludC55LCBwb2ludC55KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHRhcmdldFJlY3RhbmdsZSA9IF9nZXRSZWN0YW5nbGVGcm9tSFRNTEVsZW1lbnQodGFyZ2V0KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBpZiAoIV9pc1JlY3RhbmdsZVdpdGhpbkJvdW5kcyh0YXJnZXRSZWN0YW5nbGUsIGJvdW5kcykpIHtcclxuICAgICAgICAgICAgICAgIHZhciBvdXRPZkJvdW5kcyA9IF9nZXRPdXRPZkJvdW5kc0VkZ2VzKHRhcmdldFJlY3RhbmdsZSwgYm91bmRzKTtcclxuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgb3V0T2ZCb3VuZHNfMiA9IG91dE9mQm91bmRzOyBfaSA8IG91dE9mQm91bmRzXzIubGVuZ3RoOyBfaSsrKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgdmFyIGRpcmVjdGlvbiA9IG91dE9mQm91bmRzXzJbX2ldO1xyXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldFJlY3RhbmdsZVtwb3NpdGlvbmluZ190eXBlc18xLlJlY3RhbmdsZUVkZ2VbZGlyZWN0aW9uXV0gPSBib3VuZHNbcG9zaXRpb25pbmdfdHlwZXNfMS5SZWN0YW5nbGVFZGdlW2RpcmVjdGlvbl1dO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICB0YXJnZXRSZWN0YW5nbGUgPSBuZXcgUmVjdGFuZ2xlKDAsIDAsIDAsIDApO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdGFyZ2V0UmVjdGFuZ2xlO1xyXG4gICAgfVxyXG4gICAgcG9zaXRpb25pbmdGdW5jdGlvbnMuX2dldFRhcmdldFJlY3QgPSBfZ2V0VGFyZ2V0UmVjdDtcclxuICAgIC8qKlxyXG4gICAgICogSWYgbWF4IGhlaWdodCBpcyBsZXNzIHRoYW4gemVybyBpdCByZXR1cm5zIHRoZSBib3VuZHMgaGVpZ2h0IGluc3RlYWQuXHJcbiAgICAgKi9cclxuICAgIGZ1bmN0aW9uIF9nZXRNYXhIZWlnaHRGcm9tVGFyZ2V0UmVjdGFuZ2xlKHRhcmdldFJlY3RhbmdsZSwgdGFyZ2V0RWRnZSwgZ2FwU3BhY2UsIGJvdW5kcykge1xyXG4gICAgICAgIHZhciBtYXhIZWlnaHQgPSAwO1xyXG4gICAgICAgIHN3aXRjaCAodGFyZ2V0RWRnZSkge1xyXG4gICAgICAgICAgICBjYXNlIDcgLyogYm90dG9tQXV0b0VkZ2UgKi86XHJcbiAgICAgICAgICAgIGNhc2UgNSAvKiBib3R0b21DZW50ZXIgKi86XHJcbiAgICAgICAgICAgIGNhc2UgNCAvKiBib3R0b21MZWZ0RWRnZSAqLzpcclxuICAgICAgICAgICAgY2FzZSA2IC8qIGJvdHRvbVJpZ2h0RWRnZSAqLzpcclxuICAgICAgICAgICAgICAgIG1heEhlaWdodCA9IGJvdW5kcy5ib3R0b20gLSB0YXJnZXRSZWN0YW5nbGUuYm90dG9tIC0gZ2FwU3BhY2U7XHJcbiAgICAgICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgICAgY2FzZSAzIC8qIHRvcEF1dG9FZGdlICovOlxyXG4gICAgICAgICAgICBjYXNlIDEgLyogdG9wQ2VudGVyICovOlxyXG4gICAgICAgICAgICBjYXNlIDAgLyogdG9wTGVmdEVkZ2UgKi86XHJcbiAgICAgICAgICAgIGNhc2UgMiAvKiB0b3BSaWdodEVkZ2UgKi86XHJcbiAgICAgICAgICAgICAgICBtYXhIZWlnaHQgPSB0YXJnZXRSZWN0YW5nbGUudG9wIC0gYm91bmRzLnRvcCAtIGdhcFNwYWNlO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICBtYXhIZWlnaHQgPSBib3VuZHMuYm90dG9tIC0gdGFyZ2V0UmVjdGFuZ2xlLnRvcCAtIGdhcFNwYWNlO1xyXG4gICAgICAgICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiBtYXhIZWlnaHQgPiAwID8gbWF4SGVpZ2h0IDogYm91bmRzLmhlaWdodDtcclxuICAgIH1cclxuICAgIHBvc2l0aW9uaW5nRnVuY3Rpb25zLl9nZXRNYXhIZWlnaHRGcm9tVGFyZ2V0UmVjdGFuZ2xlID0gX2dldE1heEhlaWdodEZyb21UYXJnZXRSZWN0YW5nbGU7XHJcbiAgICBmdW5jdGlvbiBfcG9zaXRpb25FbGVtZW50UmVsYXRpdmUocHJvcHMsIGhvc3RFbGVtZW50LCBlbGVtZW50VG9Qb3NpdGlvbikge1xyXG4gICAgICAgIHZhciBnYXAgPSBwcm9wcy5nYXBTcGFjZSA/IHByb3BzLmdhcFNwYWNlIDogMDtcclxuICAgICAgICB2YXIgYm91bmRpbmdSZWN0ID0gcHJvcHMuYm91bmRzID9cclxuICAgICAgICAgICAgX2dldFJlY3RhbmdsZUZyb21JUmVjdChwcm9wcy5ib3VuZHMpIDpcclxuICAgICAgICAgICAgbmV3IFJlY3RhbmdsZSgwLCB3aW5kb3cuaW5uZXJXaWR0aCAtIFV0aWxpdGllc18xLmdldFNjcm9sbGJhcldpZHRoKCksIDAsIHdpbmRvdy5pbm5lckhlaWdodCk7XHJcbiAgICAgICAgdmFyIHRhcmdldFJlY3QgPSBfZ2V0VGFyZ2V0UmVjdChib3VuZGluZ1JlY3QsIHByb3BzLnRhcmdldCk7XHJcbiAgICAgICAgdmFyIHBvc2l0aW9uRGF0YSA9IF9nZXRBbGlnbm1lbnREYXRhKF9nZXRQb3NpdGlvbkRhdGEocHJvcHMuZGlyZWN0aW9uYWxIaW50LCBwcm9wcy5kaXJlY3Rpb25hbEhpbnRGb3JSVEwpLCB0YXJnZXRSZWN0LCBib3VuZGluZ1JlY3QsIHByb3BzLmNvdmVyVGFyZ2V0KTtcclxuICAgICAgICB2YXIgcG9zaXRpb25lZEVsZW1lbnQgPSBfcG9zaXRpb25FbGVtZW50V2l0aGluQm91bmRzKF9nZXRSZWN0YW5nbGVGcm9tSFRNTEVsZW1lbnQoZWxlbWVudFRvUG9zaXRpb24pLCB0YXJnZXRSZWN0LCBib3VuZGluZ1JlY3QsIHBvc2l0aW9uRGF0YSwgZ2FwLCBwcm9wcy5kaXJlY3Rpb25hbEhpbnRGaXhlZCwgcHJvcHMuY292ZXJUYXJnZXQpO1xyXG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXNzaWduKHt9LCBwb3NpdGlvbmVkRWxlbWVudCwgeyB0YXJnZXRSZWN0YW5nbGU6IHRhcmdldFJlY3QgfSk7XHJcbiAgICB9XHJcbiAgICBwb3NpdGlvbmluZ0Z1bmN0aW9ucy5fcG9zaXRpb25FbGVtZW50UmVsYXRpdmUgPSBfcG9zaXRpb25FbGVtZW50UmVsYXRpdmU7XHJcbiAgICBmdW5jdGlvbiBfZmluYWxpemVQb3NpdGlvbkRhdGEocG9zaXRpb25lZEVsZW1lbnQsIGhvc3RFbGVtZW50KSB7XHJcbiAgICAgICAgdmFyIGZpbmFsaXplZEVsZW1lbnQgPSBfZmluYWxpemVFbGVtZW50UG9zaXRpb24ocG9zaXRpb25lZEVsZW1lbnQuZWxlbWVudFJlY3RhbmdsZSwgaG9zdEVsZW1lbnQsIHBvc2l0aW9uZWRFbGVtZW50LnRhcmdldEVkZ2UsIHBvc2l0aW9uZWRFbGVtZW50LmFsaWdubWVudEVkZ2UpO1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGVsZW1lbnRQb3NpdGlvbjogZmluYWxpemVkRWxlbWVudCxcclxuICAgICAgICAgICAgdGFyZ2V0RWRnZTogcG9zaXRpb25lZEVsZW1lbnQudGFyZ2V0RWRnZVxyXG4gICAgICAgIH07XHJcbiAgICB9XHJcbiAgICBwb3NpdGlvbmluZ0Z1bmN0aW9ucy5fZmluYWxpemVQb3NpdGlvbkRhdGEgPSBfZmluYWxpemVQb3NpdGlvbkRhdGE7XHJcbiAgICBmdW5jdGlvbiBfcG9zaXRpb25FbGVtZW50KHByb3BzLCBob3N0RWxlbWVudCwgZWxlbWVudFRvUG9zaXRpb24pIHtcclxuICAgICAgICB2YXIgcG9zaXRpb25lZEVsZW1lbnQgPSBfcG9zaXRpb25FbGVtZW50UmVsYXRpdmUocHJvcHMsIGhvc3RFbGVtZW50LCBlbGVtZW50VG9Qb3NpdGlvbik7XHJcbiAgICAgICAgcmV0dXJuIF9maW5hbGl6ZVBvc2l0aW9uRGF0YShwb3NpdGlvbmVkRWxlbWVudCwgaG9zdEVsZW1lbnQpO1xyXG4gICAgfVxyXG4gICAgcG9zaXRpb25pbmdGdW5jdGlvbnMuX3Bvc2l0aW9uRWxlbWVudCA9IF9wb3NpdGlvbkVsZW1lbnQ7XHJcbiAgICBmdW5jdGlvbiBfcG9zaXRpb25DYWxsb3V0KHByb3BzLCBob3N0RWxlbWVudCwgY2FsbG91dCkge1xyXG4gICAgICAgIHZhciBiZWFrV2lkdGggPSAhcHJvcHMuaXNCZWFrVmlzaWJsZSA/IDAgOiAocHJvcHMuYmVha1dpZHRoIHx8IDApO1xyXG4gICAgICAgIHZhciBnYXAgPSBfY2FsY3VsYXRlQWN0dWFsQmVha1dpZHRoSW5QaXhlbHMoYmVha1dpZHRoKSAvIDIgKyAocHJvcHMuZ2FwU3BhY2UgPyBwcm9wcy5nYXBTcGFjZSA6IDApO1xyXG4gICAgICAgIHZhciBwb3NpdGlvblByb3BzID0gcHJvcHM7XHJcbiAgICAgICAgcG9zaXRpb25Qcm9wcy5nYXBTcGFjZSA9IGdhcDtcclxuICAgICAgICB2YXIgcG9zaXRpb25lZEVsZW1lbnQgPSBfcG9zaXRpb25FbGVtZW50UmVsYXRpdmUocG9zaXRpb25Qcm9wcywgaG9zdEVsZW1lbnQsIGNhbGxvdXQpO1xyXG4gICAgICAgIHZhciBiZWFrUG9zaXRpb25lZCA9IF9wb3NpdGlvbkJlYWsoYmVha1dpZHRoLCBwb3NpdGlvbmVkRWxlbWVudCk7XHJcbiAgICAgICAgdmFyIGZpbmFsaXplZEJlYWtQb3NpdGlvbiA9IF9maW5hbGl6ZUJlYWtQb3NpdGlvbihwb3NpdGlvbmVkRWxlbWVudCwgYmVha1Bvc2l0aW9uZWQpO1xyXG4gICAgICAgIHJldHVybiB0c2xpYl8xLl9fYXNzaWduKHt9LCBfZmluYWxpemVQb3NpdGlvbkRhdGEocG9zaXRpb25lZEVsZW1lbnQsIGhvc3RFbGVtZW50KSwgeyBiZWFrUG9zaXRpb246IGZpbmFsaXplZEJlYWtQb3NpdGlvbiB9KTtcclxuICAgIH1cclxuICAgIHBvc2l0aW9uaW5nRnVuY3Rpb25zLl9wb3NpdGlvbkNhbGxvdXQgPSBfcG9zaXRpb25DYWxsb3V0O1xyXG4gICAgLyoqXHJcbiAgICAgKiBAZGVwcmVjYXRlZCBEbyBub3QgdXNlLCB0aGlzIHdpbGwgYmUgcmVtb3ZlZCBpbiA2LjBcclxuICAgICAqIHVzZSBlaXRoZXIgX3Bvc2l0aW9uQ2FsbG91dCBvciBfcG9zaXRpb25FbGVtZW50LlxyXG4gICAgICogQGV4cG9ydFxyXG4gICAgICogQHBhcmFtIHtJUG9zaXRpb25Qcm9wc30gcHJvcHNcclxuICAgICAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IGhvc3RFbGVtZW50XHJcbiAgICAgKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50VG9Qb3NpdGlvblxyXG4gICAgICogQHJldHVybnNcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gX2dldFJlbGF0aXZlUG9zaXRpb25zKHByb3BzLCBob3N0RWxlbWVudCwgZWxlbWVudFRvUG9zaXRpb24pIHtcclxuICAgICAgICB2YXIgcG9zaXRpb25zID0gX3Bvc2l0aW9uQ2FsbG91dChwcm9wcywgaG9zdEVsZW1lbnQsIGVsZW1lbnRUb1Bvc2l0aW9uKTtcclxuICAgICAgICB2YXIgYmVha1Bvc2l0aW9uID0gcG9zaXRpb25zICYmIHBvc2l0aW9ucy5iZWFrUG9zaXRpb24gPyBwb3NpdGlvbnMuYmVha1Bvc2l0aW9uLmVsZW1lbnRQb3NpdGlvbiA6IHVuZGVmaW5lZDtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBjYWxsb3V0UG9zaXRpb246IHBvc2l0aW9ucy5lbGVtZW50UG9zaXRpb24sXHJcbiAgICAgICAgICAgIGJlYWtQb3NpdGlvbjogeyBwb3NpdGlvbjogdHNsaWJfMS5fX2Fzc2lnbih7fSwgYmVha1Bvc2l0aW9uKSwgZGlzcGxheTogJ2Jsb2NrJyB9LFxyXG4gICAgICAgICAgICBkaXJlY3Rpb25hbENsYXNzTmFtZTogU0xJREVfQU5JTUFUSU9OU1twb3NpdGlvbnMudGFyZ2V0RWRnZV0sXHJcbiAgICAgICAgICAgIHN1Ym1lbnVEaXJlY3Rpb246IChwb3NpdGlvbnMudGFyZ2V0RWRnZSAqIC0xKSA9PT0gcG9zaXRpb25pbmdfdHlwZXNfMS5SZWN0YW5nbGVFZGdlLnJpZ2h0ID8gMTAgLyogbGVmdEJvdHRvbUVkZ2UgKi8gOiAxMyAvKiByaWdodEJvdHRvbUVkZ2UgKi9cclxuICAgICAgICB9O1xyXG4gICAgfVxyXG4gICAgcG9zaXRpb25pbmdGdW5jdGlvbnMuX2dldFJlbGF0aXZlUG9zaXRpb25zID0gX2dldFJlbGF0aXZlUG9zaXRpb25zO1xyXG59KShwb3NpdGlvbmluZ0Z1bmN0aW9ucyA9IGV4cG9ydHMucG9zaXRpb25pbmdGdW5jdGlvbnMgfHwgKGV4cG9ydHMucG9zaXRpb25pbmdGdW5jdGlvbnMgPSB7fSkpO1xyXG4vKipcclxuICogQGRlcHJlY2F0ZWQgRG8gbm90IHVzZSwgdGhpcyB3aWxsIGJlIHJlbW92ZWQgaW4gNi4wLlxyXG4gKiBVc2UgZWl0aGVyIHBvc2l0aW9uRWxlbWVudCwgb3IgcG9zaXRpb25DYWxsb3V0XHJcbiAqXHJcbiAqIEBleHBvcnRcclxuICogQHBhcmFtIHtJUG9zaXRpb25Qcm9wc30gcHJvcHNcclxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gaG9zdEVsZW1lbnRcclxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gY2FsbG91dEVsZW1lbnRcclxuICogQHJldHVybnNcclxuICovXHJcbmZ1bmN0aW9uIGdldFJlbGF0aXZlUG9zaXRpb25zKHByb3BzLCBob3N0RWxlbWVudCwgY2FsbG91dEVsZW1lbnQpIHtcclxuICAgIHJldHVybiBwb3NpdGlvbmluZ0Z1bmN0aW9ucy5fZ2V0UmVsYXRpdmVQb3NpdGlvbnMocHJvcHMsIGhvc3RFbGVtZW50LCBjYWxsb3V0RWxlbWVudCk7XHJcbn1cclxuZXhwb3J0cy5nZXRSZWxhdGl2ZVBvc2l0aW9ucyA9IGdldFJlbGF0aXZlUG9zaXRpb25zO1xyXG4vKipcclxuICogVXNlZCB0byBwb3NpdGlvbiBhbiBlbGVtZW50IHJlbGF0aXZlIHRvIHRoZSBnaXZlbiBwb3NpdGlvbmluZyBwcm9wcy5cclxuICpcclxuICogQGV4cG9ydFxyXG4gKiBAcGFyYW0ge0lQb3NpdGlvblByb3BzfSBwcm9wc1xyXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBob3N0RWxlbWVudFxyXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50VG9Qb3NpdGlvblxyXG4gKiBAcmV0dXJuc1xyXG4gKi9cclxuZnVuY3Rpb24gcG9zaXRpb25FbGVtZW50KHByb3BzLCBob3N0RWxlbWVudCwgZWxlbWVudFRvUG9zaXRpb24pIHtcclxuICAgIHJldHVybiBwb3NpdGlvbmluZ0Z1bmN0aW9ucy5fcG9zaXRpb25FbGVtZW50KHByb3BzLCBob3N0RWxlbWVudCwgZWxlbWVudFRvUG9zaXRpb24pO1xyXG59XHJcbmV4cG9ydHMucG9zaXRpb25FbGVtZW50ID0gcG9zaXRpb25FbGVtZW50O1xyXG5mdW5jdGlvbiBwb3NpdGlvbkNhbGxvdXQocHJvcHMsIGhvc3RFbGVtZW50LCBlbGVtZW50VG9Qb3NpdGlvbikge1xyXG4gICAgcmV0dXJuIHBvc2l0aW9uaW5nRnVuY3Rpb25zLl9wb3NpdGlvbkNhbGxvdXQocHJvcHMsIGhvc3RFbGVtZW50LCBlbGVtZW50VG9Qb3NpdGlvbik7XHJcbn1cclxuZXhwb3J0cy5wb3NpdGlvbkNhbGxvdXQgPSBwb3NpdGlvbkNhbGxvdXQ7XHJcbi8qKlxyXG4gKiBHZXQncyB0aGUgbWF4aW11bSBoZWlnaHQgdGhhdCBhIHJlY3RhbmdsZSBjYW4gaGF2ZSBpbiBvcmRlciB0byBmaXQgYmVsb3cgb3IgYWJvdmUgYSB0YXJnZXQuXHJcbiAqIElmIHRoZSBkaXJlY3Rpb25hbCBoaW50IHNwZWNpZmllcyBhIGxlZnQgb3IgcmlnaHQgZWRnZSAoaS5lLiBsZWZ0Q2VudGVyKSBpdCB3aWxsIGxpbWl0IHRoZSBoZWlnaHQgdG8gdGhlIHRvcEJvcmRlclxyXG4gKiBvZiB0aGUgdGFyZ2V0IGdpdmVuLlxyXG4gKiBJZiBubyBib3VuZHMgYXJlIHByb3ZpZGVkIHRoZW4gdGhlIHdpbmRvdyBpcyB0cmVhdGVkIGFzIHRoZSBib3VuZHMuXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRNYXhIZWlnaHQodGFyZ2V0LCB0YXJnZXRFZGdlLCBnYXBTcGFjZSwgYm91bmRzKSB7XHJcbiAgICBpZiAoZ2FwU3BhY2UgPT09IHZvaWQgMCkgeyBnYXBTcGFjZSA9IDA7IH1cclxuICAgIHZhciBtb3VzZVRhcmdldCA9IHRhcmdldDtcclxuICAgIHZhciBlbGVtZW50VGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgdmFyIHBvaW50VGFyZ2V0ID0gdGFyZ2V0O1xyXG4gICAgdmFyIHRhcmdldFJlY3Q7XHJcbiAgICB2YXIgYm91bmRpbmdSZWN0YW5nbGUgPSBib3VuZHMgP1xyXG4gICAgICAgIHBvc2l0aW9uaW5nRnVuY3Rpb25zLl9nZXRSZWN0YW5nbGVGcm9tSVJlY3QoYm91bmRzKSA6XHJcbiAgICAgICAgbmV3IFJlY3RhbmdsZSgwLCB3aW5kb3cuaW5uZXJXaWR0aCAtIFV0aWxpdGllc18xLmdldFNjcm9sbGJhcldpZHRoKCksIDAsIHdpbmRvdy5pbm5lckhlaWdodCk7XHJcbiAgICBpZiAobW91c2VUYXJnZXQuc3RvcFByb3BhZ2F0aW9uKSB7XHJcbiAgICAgICAgdGFyZ2V0UmVjdCA9IG5ldyBSZWN0YW5nbGUobW91c2VUYXJnZXQuY2xpZW50WCwgbW91c2VUYXJnZXQuY2xpZW50WCwgbW91c2VUYXJnZXQuY2xpZW50WSwgbW91c2VUYXJnZXQuY2xpZW50WSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChwb2ludFRhcmdldC54ICE9PSB1bmRlZmluZWQgJiYgcG9pbnRUYXJnZXQueSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgdGFyZ2V0UmVjdCA9IG5ldyBSZWN0YW5nbGUocG9pbnRUYXJnZXQueCwgcG9pbnRUYXJnZXQueCwgcG9pbnRUYXJnZXQueSwgcG9pbnRUYXJnZXQueSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICB0YXJnZXRSZWN0ID0gcG9zaXRpb25pbmdGdW5jdGlvbnMuX2dldFJlY3RhbmdsZUZyb21IVE1MRWxlbWVudChlbGVtZW50VGFyZ2V0KTtcclxuICAgIH1cclxuICAgIHJldHVybiBwb3NpdGlvbmluZ0Z1bmN0aW9ucy5fZ2V0TWF4SGVpZ2h0RnJvbVRhcmdldFJlY3RhbmdsZSh0YXJnZXRSZWN0LCB0YXJnZXRFZGdlLCBnYXBTcGFjZSwgYm91bmRpbmdSZWN0YW5nbGUpO1xyXG59XHJcbmV4cG9ydHMuZ2V0TWF4SGVpZ2h0ID0gZ2V0TWF4SGVpZ2h0O1xyXG52YXIgX2EsIF9iO1xyXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wb3NpdGlvbmluZy5qcy5tYXAiLCJcInVzZSBzdHJpY3RcIjtcclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xyXG52YXIgUmVjdGFuZ2xlRWRnZTtcclxuKGZ1bmN0aW9uIChSZWN0YW5nbGVFZGdlKSB7XHJcbiAgICBSZWN0YW5nbGVFZGdlW1JlY3RhbmdsZUVkZ2VbXCJ0b3BcIl0gPSAxXSA9IFwidG9wXCI7XHJcbiAgICBSZWN0YW5nbGVFZGdlW1JlY3RhbmdsZUVkZ2VbXCJib3R0b21cIl0gPSAtMV0gPSBcImJvdHRvbVwiO1xyXG4gICAgUmVjdGFuZ2xlRWRnZVtSZWN0YW5nbGVFZGdlW1wibGVmdFwiXSA9IDJdID0gXCJsZWZ0XCI7XHJcbiAgICBSZWN0YW5nbGVFZGdlW1JlY3RhbmdsZUVkZ2VbXCJyaWdodFwiXSA9IC0yXSA9IFwicmlnaHRcIjtcclxufSkoUmVjdGFuZ2xlRWRnZSA9IGV4cG9ydHMuUmVjdGFuZ2xlRWRnZSB8fCAoZXhwb3J0cy5SZWN0YW5nbGVFZGdlID0ge30pKTtcclxudmFyIFBvc2l0aW9uO1xyXG4oZnVuY3Rpb24gKFBvc2l0aW9uKSB7XHJcbiAgICBQb3NpdGlvbltQb3NpdGlvbltcInRvcFwiXSA9IDBdID0gXCJ0b3BcIjtcclxuICAgIFBvc2l0aW9uW1Bvc2l0aW9uW1wiYm90dG9tXCJdID0gMV0gPSBcImJvdHRvbVwiO1xyXG4gICAgUG9zaXRpb25bUG9zaXRpb25bXCJzdGFydFwiXSA9IDJdID0gXCJzdGFydFwiO1xyXG4gICAgUG9zaXRpb25bUG9zaXRpb25bXCJlbmRcIl0gPSAzXSA9IFwiZW5kXCI7XHJcbn0pKFBvc2l0aW9uID0gZXhwb3J0cy5Qb3NpdGlvbiB8fCAoZXhwb3J0cy5Qb3NpdGlvbiA9IHt9KSk7XHJcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBvc2l0aW9uaW5nLnR5cGVzLmpzLm1hcCIsIi8vIHNoaW0gZm9yIHVzaW5nIHByb2Nlc3MgaW4gYnJvd3NlclxudmFyIHByb2Nlc3MgPSBtb2R1bGUuZXhwb3J0cyA9IHt9O1xuXG4vLyBjYWNoZWQgZnJvbSB3aGF0ZXZlciBnbG9iYWwgaXMgcHJlc2VudCBzbyB0aGF0IHRlc3QgcnVubmVycyB0aGF0IHN0dWIgaXRcbi8vIGRvbid0IGJyZWFrIHRoaW5ncy4gIEJ1dCB3ZSBuZWVkIHRvIHdyYXAgaXQgaW4gYSB0cnkgY2F0Y2ggaW4gY2FzZSBpdCBpc1xuLy8gd3JhcHBlZCBpbiBzdHJpY3QgbW9kZSBjb2RlIHdoaWNoIGRvZXNuJ3QgZGVmaW5lIGFueSBnbG9iYWxzLiAgSXQncyBpbnNpZGUgYVxuLy8gZnVuY3Rpb24gYmVjYXVzZSB0cnkvY2F0Y2hlcyBkZW9wdGltaXplIGluIGNlcnRhaW4gZW5naW5lcy5cblxudmFyIGNhY2hlZFNldFRpbWVvdXQ7XG52YXIgY2FjaGVkQ2xlYXJUaW1lb3V0O1xuXG5mdW5jdGlvbiBkZWZhdWx0U2V0VGltb3V0KCkge1xuICAgIHRocm93IG5ldyBFcnJvcignc2V0VGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuZnVuY3Rpb24gZGVmYXVsdENsZWFyVGltZW91dCAoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdjbGVhclRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbihmdW5jdGlvbiAoKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBzZXRUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgaWYgKHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGRlZmF1bHRDbGVhclRpbWVvdXQ7XG4gICAgfVxufSAoKSlcbmZ1bmN0aW9uIHJ1blRpbWVvdXQoZnVuKSB7XG4gICAgaWYgKGNhY2hlZFNldFRpbWVvdXQgPT09IHNldFRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIC8vIGlmIHNldFRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRTZXRUaW1lb3V0ID09PSBkZWZhdWx0U2V0VGltb3V0IHx8ICFjYWNoZWRTZXRUaW1lb3V0KSAmJiBzZXRUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfSBjYXRjaChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbChudWxsLCBmdW4sIDApO1xuICAgICAgICB9IGNhdGNoKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3JcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwodGhpcywgZnVuLCAwKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG59XG5mdW5jdGlvbiBydW5DbGVhclRpbWVvdXQobWFya2VyKSB7XG4gICAgaWYgKGNhY2hlZENsZWFyVGltZW91dCA9PT0gY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIC8vIGlmIGNsZWFyVGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZENsZWFyVGltZW91dCA9PT0gZGVmYXVsdENsZWFyVGltZW91dCB8fCAhY2FjaGVkQ2xlYXJUaW1lb3V0KSAmJiBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICByZXR1cm4gY2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0ICB0cnVzdCB0aGUgZ2xvYmFsIG9iamVjdCB3aGVuIGNhbGxlZCBub3JtYWxseVxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKG51bGwsIG1hcmtlcik7XG4gICAgICAgIH0gY2F0Y2ggKGUpe1xuICAgICAgICAgICAgLy8gc2FtZSBhcyBhYm92ZSBidXQgd2hlbiBpdCdzIGEgdmVyc2lvbiBvZiBJLkUuIHRoYXQgbXVzdCBoYXZlIHRoZSBnbG9iYWwgb2JqZWN0IGZvciAndGhpcycsIGhvcGZ1bGx5IG91ciBjb250ZXh0IGNvcnJlY3Qgb3RoZXJ3aXNlIGl0IHdpbGwgdGhyb3cgYSBnbG9iYWwgZXJyb3IuXG4gICAgICAgICAgICAvLyBTb21lIHZlcnNpb25zIG9mIEkuRS4gaGF2ZSBkaWZmZXJlbnQgcnVsZXMgZm9yIGNsZWFyVGltZW91dCB2cyBzZXRUaW1lb3V0XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwodGhpcywgbWFya2VyKTtcbiAgICAgICAgfVxuICAgIH1cblxuXG5cbn1cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGlmICghZHJhaW5pbmcgfHwgIWN1cnJlbnRRdWV1ZSkge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHJ1blRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIHJ1bkNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHJ1blRpbWVvdXQoZHJhaW5RdWV1ZSk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucHJlcGVuZE9uY2VMaXN0ZW5lciA9IG5vb3A7XG5cbnByb2Nlc3MubGlzdGVuZXJzID0gZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIFtdIH1cblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xuICB2YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcbiAgdmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gcmVxdWlyZSgnLi9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQnKTtcbiAgdmFyIGxvZ2dlZFR5cGVGYWlsdXJlcyA9IHt9O1xufVxuXG4vKipcbiAqIEFzc2VydCB0aGF0IHRoZSB2YWx1ZXMgbWF0Y2ggd2l0aCB0aGUgdHlwZSBzcGVjcy5cbiAqIEVycm9yIG1lc3NhZ2VzIGFyZSBtZW1vcml6ZWQgYW5kIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSB0eXBlU3BlY3MgTWFwIG9mIG5hbWUgdG8gYSBSZWFjdFByb3BUeXBlXG4gKiBAcGFyYW0ge29iamVjdH0gdmFsdWVzIFJ1bnRpbWUgdmFsdWVzIHRoYXQgbmVlZCB0byBiZSB0eXBlLWNoZWNrZWRcbiAqIEBwYXJhbSB7c3RyaW5nfSBsb2NhdGlvbiBlLmcuIFwicHJvcFwiLCBcImNvbnRleHRcIiwgXCJjaGlsZCBjb250ZXh0XCJcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb21wb25lbnROYW1lIE5hbWUgb2YgdGhlIGNvbXBvbmVudCBmb3IgZXJyb3IgbWVzc2FnZXMuXG4gKiBAcGFyYW0gez9GdW5jdGlvbn0gZ2V0U3RhY2sgUmV0dXJucyB0aGUgY29tcG9uZW50IHN0YWNrLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gY2hlY2tQcm9wVHlwZXModHlwZVNwZWNzLCB2YWx1ZXMsIGxvY2F0aW9uLCBjb21wb25lbnROYW1lLCBnZXRTdGFjaykge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGZvciAodmFyIHR5cGVTcGVjTmFtZSBpbiB0eXBlU3BlY3MpIHtcbiAgICAgIGlmICh0eXBlU3BlY3MuaGFzT3duUHJvcGVydHkodHlwZVNwZWNOYW1lKSkge1xuICAgICAgICB2YXIgZXJyb3I7XG4gICAgICAgIC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cbiAgICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBhbiBpbnZhcmlhbnQgdGhhdCBnZXRzIGNhdWdodC4gSXQncyB0aGUgc2FtZVxuICAgICAgICAgIC8vIGJlaGF2aW9yIGFzIHdpdGhvdXQgdGhpcyBzdGF0ZW1lbnQgZXhjZXB0IHdpdGggYSBiZXR0ZXIgbWVzc2FnZS5cbiAgICAgICAgICBpbnZhcmlhbnQodHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdID09PSAnZnVuY3Rpb24nLCAnJXM6ICVzIHR5cGUgYCVzYCBpcyBpbnZhbGlkOyBpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSAnICsgJ3RoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGAlc2AuJywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBsb2NhdGlvbiwgdHlwZVNwZWNOYW1lLCB0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0pO1xuICAgICAgICAgIGVycm9yID0gdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0odmFsdWVzLCB0eXBlU3BlY05hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBudWxsLCBSZWFjdFByb3BUeXBlc1NlY3JldCk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgZXJyb3IgPSBleDtcbiAgICAgICAgfVxuICAgICAgICB3YXJuaW5nKCFlcnJvciB8fCBlcnJvciBpbnN0YW5jZW9mIEVycm9yLCAnJXM6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAlcyBgJXNgIGlzIGludmFsaWQ7IHRoZSB0eXBlIGNoZWNrZXIgJyArICdmdW5jdGlvbiBtdXN0IHJldHVybiBgbnVsbGAgb3IgYW4gYEVycm9yYCBidXQgcmV0dXJuZWQgYSAlcy4gJyArICdZb3UgbWF5IGhhdmUgZm9yZ290dGVuIHRvIHBhc3MgYW4gYXJndW1lbnQgdG8gdGhlIHR5cGUgY2hlY2tlciAnICsgJ2NyZWF0b3IgKGFycmF5T2YsIGluc3RhbmNlT2YsIG9iamVjdE9mLCBvbmVPZiwgb25lT2ZUeXBlLCBhbmQgJyArICdzaGFwZSBhbGwgcmVxdWlyZSBhbiBhcmd1bWVudCkuJywgY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnLCBsb2NhdGlvbiwgdHlwZVNwZWNOYW1lLCB0eXBlb2YgZXJyb3IpO1xuICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiAhKGVycm9yLm1lc3NhZ2UgaW4gbG9nZ2VkVHlwZUZhaWx1cmVzKSkge1xuICAgICAgICAgIC8vIE9ubHkgbW9uaXRvciB0aGlzIGZhaWx1cmUgb25jZSBiZWNhdXNlIHRoZXJlIHRlbmRzIHRvIGJlIGEgbG90IG9mIHRoZVxuICAgICAgICAgIC8vIHNhbWUgZXJyb3IuXG4gICAgICAgICAgbG9nZ2VkVHlwZUZhaWx1cmVzW2Vycm9yLm1lc3NhZ2VdID0gdHJ1ZTtcblxuICAgICAgICAgIHZhciBzdGFjayA9IGdldFN0YWNrID8gZ2V0U3RhY2soKSA6ICcnO1xuXG4gICAgICAgICAgd2FybmluZyhmYWxzZSwgJ0ZhaWxlZCAlcyB0eXBlOiAlcyVzJywgbG9jYXRpb24sIGVycm9yLm1lc3NhZ2UsIHN0YWNrICE9IG51bGwgPyBzdGFjayA6ICcnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNoZWNrUHJvcFR5cGVzO1xuIiwiLyoqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTMtcHJlc2VudCwgRmFjZWJvb2ssIEluYy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBlbXB0eUZ1bmN0aW9uID0gcmVxdWlyZSgnZmJqcy9saWIvZW1wdHlGdW5jdGlvbicpO1xudmFyIGludmFyaWFudCA9IHJlcXVpcmUoJ2ZianMvbGliL2ludmFyaWFudCcpO1xudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gcmVxdWlyZSgnLi9saWIvUmVhY3RQcm9wVHlwZXNTZWNyZXQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gc2hpbShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIHNlY3JldCkge1xuICAgIGlmIChzZWNyZXQgPT09IFJlYWN0UHJvcFR5cGVzU2VjcmV0KSB7XG4gICAgICAvLyBJdCBpcyBzdGlsbCBzYWZlIHdoZW4gY2FsbGVkIGZyb20gUmVhY3QuXG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGludmFyaWFudChcbiAgICAgIGZhbHNlLFxuICAgICAgJ0NhbGxpbmcgUHJvcFR5cGVzIHZhbGlkYXRvcnMgZGlyZWN0bHkgaXMgbm90IHN1cHBvcnRlZCBieSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UuICcgK1xuICAgICAgJ1VzZSBQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMoKSB0byBjYWxsIHRoZW0uICcgK1xuICAgICAgJ1JlYWQgbW9yZSBhdCBodHRwOi8vZmIubWUvdXNlLWNoZWNrLXByb3AtdHlwZXMnXG4gICAgKTtcbiAgfTtcbiAgc2hpbS5pc1JlcXVpcmVkID0gc2hpbTtcbiAgZnVuY3Rpb24gZ2V0U2hpbSgpIHtcbiAgICByZXR1cm4gc2hpbTtcbiAgfTtcbiAgLy8gSW1wb3J0YW50IVxuICAvLyBLZWVwIHRoaXMgbGlzdCBpbiBzeW5jIHdpdGggcHJvZHVjdGlvbiB2ZXJzaW9uIGluIGAuL2ZhY3RvcnlXaXRoVHlwZUNoZWNrZXJzLmpzYC5cbiAgdmFyIFJlYWN0UHJvcFR5cGVzID0ge1xuICAgIGFycmF5OiBzaGltLFxuICAgIGJvb2w6IHNoaW0sXG4gICAgZnVuYzogc2hpbSxcbiAgICBudW1iZXI6IHNoaW0sXG4gICAgb2JqZWN0OiBzaGltLFxuICAgIHN0cmluZzogc2hpbSxcbiAgICBzeW1ib2w6IHNoaW0sXG5cbiAgICBhbnk6IHNoaW0sXG4gICAgYXJyYXlPZjogZ2V0U2hpbSxcbiAgICBlbGVtZW50OiBzaGltLFxuICAgIGluc3RhbmNlT2Y6IGdldFNoaW0sXG4gICAgbm9kZTogc2hpbSxcbiAgICBvYmplY3RPZjogZ2V0U2hpbSxcbiAgICBvbmVPZjogZ2V0U2hpbSxcbiAgICBvbmVPZlR5cGU6IGdldFNoaW0sXG4gICAgc2hhcGU6IGdldFNoaW0sXG4gICAgZXhhY3Q6IGdldFNoaW1cbiAgfTtcblxuICBSZWFjdFByb3BUeXBlcy5jaGVja1Byb3BUeXBlcyA9IGVtcHR5RnVuY3Rpb247XG4gIFJlYWN0UHJvcFR5cGVzLlByb3BUeXBlcyA9IFJlYWN0UHJvcFR5cGVzO1xuXG4gIHJldHVybiBSZWFjdFByb3BUeXBlcztcbn07XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGVtcHR5RnVuY3Rpb24gPSByZXF1aXJlKCdmYmpzL2xpYi9lbXB0eUZ1bmN0aW9uJyk7XG52YXIgaW52YXJpYW50ID0gcmVxdWlyZSgnZmJqcy9saWIvaW52YXJpYW50Jyk7XG52YXIgd2FybmluZyA9IHJlcXVpcmUoJ2ZianMvbGliL3dhcm5pbmcnKTtcbnZhciBhc3NpZ24gPSByZXF1aXJlKCdvYmplY3QtYXNzaWduJyk7XG5cbnZhciBSZWFjdFByb3BUeXBlc1NlY3JldCA9IHJlcXVpcmUoJy4vbGliL1JlYWN0UHJvcFR5cGVzU2VjcmV0Jyk7XG52YXIgY2hlY2tQcm9wVHlwZXMgPSByZXF1aXJlKCcuL2NoZWNrUHJvcFR5cGVzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oaXNWYWxpZEVsZW1lbnQsIHRocm93T25EaXJlY3RBY2Nlc3MpIHtcbiAgLyogZ2xvYmFsIFN5bWJvbCAqL1xuICB2YXIgSVRFUkFUT1JfU1lNQk9MID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wuaXRlcmF0b3I7XG4gIHZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJzsgLy8gQmVmb3JlIFN5bWJvbCBzcGVjLlxuXG4gIC8qKlxuICAgKiBSZXR1cm5zIHRoZSBpdGVyYXRvciBtZXRob2QgZnVuY3Rpb24gY29udGFpbmVkIG9uIHRoZSBpdGVyYWJsZSBvYmplY3QuXG4gICAqXG4gICAqIEJlIHN1cmUgdG8gaW52b2tlIHRoZSBmdW5jdGlvbiB3aXRoIHRoZSBpdGVyYWJsZSBhcyBjb250ZXh0OlxuICAgKlxuICAgKiAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG15SXRlcmFibGUpO1xuICAgKiAgICAgaWYgKGl0ZXJhdG9yRm4pIHtcbiAgICogICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG15SXRlcmFibGUpO1xuICAgKiAgICAgICAuLi5cbiAgICogICAgIH1cbiAgICpcbiAgICogQHBhcmFtIHs/b2JqZWN0fSBtYXliZUl0ZXJhYmxlXG4gICAqIEByZXR1cm4gez9mdW5jdGlvbn1cbiAgICovXG4gIGZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICAgIHZhciBpdGVyYXRvckZuID0gbWF5YmVJdGVyYWJsZSAmJiAoSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXSk7XG4gICAgaWYgKHR5cGVvZiBpdGVyYXRvckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gaXRlcmF0b3JGbjtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQ29sbGVjdGlvbiBvZiBtZXRob2RzIHRoYXQgYWxsb3cgZGVjbGFyYXRpb24gYW5kIHZhbGlkYXRpb24gb2YgcHJvcHMgdGhhdCBhcmVcbiAgICogc3VwcGxpZWQgdG8gUmVhY3QgY29tcG9uZW50cy4gRXhhbXBsZSB1c2FnZTpcbiAgICpcbiAgICogICB2YXIgUHJvcHMgPSByZXF1aXJlKCdSZWFjdFByb3BUeXBlcycpO1xuICAgKiAgIHZhciBNeUFydGljbGUgPSBSZWFjdC5jcmVhdGVDbGFzcyh7XG4gICAqICAgICBwcm9wVHlwZXM6IHtcbiAgICogICAgICAgLy8gQW4gb3B0aW9uYWwgc3RyaW5nIHByb3AgbmFtZWQgXCJkZXNjcmlwdGlvblwiLlxuICAgKiAgICAgICBkZXNjcmlwdGlvbjogUHJvcHMuc3RyaW5nLFxuICAgKlxuICAgKiAgICAgICAvLyBBIHJlcXVpcmVkIGVudW0gcHJvcCBuYW1lZCBcImNhdGVnb3J5XCIuXG4gICAqICAgICAgIGNhdGVnb3J5OiBQcm9wcy5vbmVPZihbJ05ld3MnLCdQaG90b3MnXSkuaXNSZXF1aXJlZCxcbiAgICpcbiAgICogICAgICAgLy8gQSBwcm9wIG5hbWVkIFwiZGlhbG9nXCIgdGhhdCByZXF1aXJlcyBhbiBpbnN0YW5jZSBvZiBEaWFsb2cuXG4gICAqICAgICAgIGRpYWxvZzogUHJvcHMuaW5zdGFuY2VPZihEaWFsb2cpLmlzUmVxdWlyZWRcbiAgICogICAgIH0sXG4gICAqICAgICByZW5kZXI6IGZ1bmN0aW9uKCkgeyAuLi4gfVxuICAgKiAgIH0pO1xuICAgKlxuICAgKiBBIG1vcmUgZm9ybWFsIHNwZWNpZmljYXRpb24gb2YgaG93IHRoZXNlIG1ldGhvZHMgYXJlIHVzZWQ6XG4gICAqXG4gICAqICAgdHlwZSA6PSBhcnJheXxib29sfGZ1bmN8b2JqZWN0fG51bWJlcnxzdHJpbmd8b25lT2YoWy4uLl0pfGluc3RhbmNlT2YoLi4uKVxuICAgKiAgIGRlY2wgOj0gUmVhY3RQcm9wVHlwZXMue3R5cGV9KC5pc1JlcXVpcmVkKT9cbiAgICpcbiAgICogRWFjaCBhbmQgZXZlcnkgZGVjbGFyYXRpb24gcHJvZHVjZXMgYSBmdW5jdGlvbiB3aXRoIHRoZSBzYW1lIHNpZ25hdHVyZS4gVGhpc1xuICAgKiBhbGxvd3MgdGhlIGNyZWF0aW9uIG9mIGN1c3RvbSB2YWxpZGF0aW9uIGZ1bmN0aW9ucy4gRm9yIGV4YW1wbGU6XG4gICAqXG4gICAqICB2YXIgTXlMaW5rID0gUmVhY3QuY3JlYXRlQ2xhc3Moe1xuICAgKiAgICBwcm9wVHlwZXM6IHtcbiAgICogICAgICAvLyBBbiBvcHRpb25hbCBzdHJpbmcgb3IgVVJJIHByb3AgbmFtZWQgXCJocmVmXCIuXG4gICAqICAgICAgaHJlZjogZnVuY3Rpb24ocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lKSB7XG4gICAqICAgICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgKiAgICAgICAgaWYgKHByb3BWYWx1ZSAhPSBudWxsICYmIHR5cGVvZiBwcm9wVmFsdWUgIT09ICdzdHJpbmcnICYmXG4gICAqICAgICAgICAgICAgIShwcm9wVmFsdWUgaW5zdGFuY2VvZiBVUkkpKSB7XG4gICAqICAgICAgICAgIHJldHVybiBuZXcgRXJyb3IoXG4gICAqICAgICAgICAgICAgJ0V4cGVjdGVkIGEgc3RyaW5nIG9yIGFuIFVSSSBmb3IgJyArIHByb3BOYW1lICsgJyBpbiAnICtcbiAgICogICAgICAgICAgICBjb21wb25lbnROYW1lXG4gICAqICAgICAgICAgICk7XG4gICAqICAgICAgICB9XG4gICAqICAgICAgfVxuICAgKiAgICB9LFxuICAgKiAgICByZW5kZXI6IGZ1bmN0aW9uKCkgey4uLn1cbiAgICogIH0pO1xuICAgKlxuICAgKiBAaW50ZXJuYWxcbiAgICovXG5cbiAgdmFyIEFOT05ZTU9VUyA9ICc8PGFub255bW91cz4+JztcblxuICAvLyBJbXBvcnRhbnQhXG4gIC8vIEtlZXAgdGhpcyBsaXN0IGluIHN5bmMgd2l0aCBwcm9kdWN0aW9uIHZlcnNpb24gaW4gYC4vZmFjdG9yeVdpdGhUaHJvd2luZ1NoaW1zLmpzYC5cbiAgdmFyIFJlYWN0UHJvcFR5cGVzID0ge1xuICAgIGFycmF5OiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignYXJyYXknKSxcbiAgICBib29sOiBjcmVhdGVQcmltaXRpdmVUeXBlQ2hlY2tlcignYm9vbGVhbicpLFxuICAgIGZ1bmM6IGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKCdmdW5jdGlvbicpLFxuICAgIG51bWJlcjogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ251bWJlcicpLFxuICAgIG9iamVjdDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ29iamVjdCcpLFxuICAgIHN0cmluZzogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ3N0cmluZycpLFxuICAgIHN5bWJvbDogY3JlYXRlUHJpbWl0aXZlVHlwZUNoZWNrZXIoJ3N5bWJvbCcpLFxuXG4gICAgYW55OiBjcmVhdGVBbnlUeXBlQ2hlY2tlcigpLFxuICAgIGFycmF5T2Y6IGNyZWF0ZUFycmF5T2ZUeXBlQ2hlY2tlcixcbiAgICBlbGVtZW50OiBjcmVhdGVFbGVtZW50VHlwZUNoZWNrZXIoKSxcbiAgICBpbnN0YW5jZU9mOiBjcmVhdGVJbnN0YW5jZVR5cGVDaGVja2VyLFxuICAgIG5vZGU6IGNyZWF0ZU5vZGVDaGVja2VyKCksXG4gICAgb2JqZWN0T2Y6IGNyZWF0ZU9iamVjdE9mVHlwZUNoZWNrZXIsXG4gICAgb25lT2Y6IGNyZWF0ZUVudW1UeXBlQ2hlY2tlcixcbiAgICBvbmVPZlR5cGU6IGNyZWF0ZVVuaW9uVHlwZUNoZWNrZXIsXG4gICAgc2hhcGU6IGNyZWF0ZVNoYXBlVHlwZUNoZWNrZXIsXG4gICAgZXhhY3Q6IGNyZWF0ZVN0cmljdFNoYXBlVHlwZUNoZWNrZXIsXG4gIH07XG5cbiAgLyoqXG4gICAqIGlubGluZWQgT2JqZWN0LmlzIHBvbHlmaWxsIHRvIGF2b2lkIHJlcXVpcmluZyBjb25zdW1lcnMgc2hpcCB0aGVpciBvd25cbiAgICogaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2lzXG4gICAqL1xuICAvKmVzbGludC1kaXNhYmxlIG5vLXNlbGYtY29tcGFyZSovXG4gIGZ1bmN0aW9uIGlzKHgsIHkpIHtcbiAgICAvLyBTYW1lVmFsdWUgYWxnb3JpdGhtXG4gICAgaWYgKHggPT09IHkpIHtcbiAgICAgIC8vIFN0ZXBzIDEtNSwgNy0xMFxuICAgICAgLy8gU3RlcHMgNi5iLTYuZTogKzAgIT0gLTBcbiAgICAgIHJldHVybiB4ICE9PSAwIHx8IDEgLyB4ID09PSAxIC8geTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gU3RlcCA2LmE6IE5hTiA9PSBOYU5cbiAgICAgIHJldHVybiB4ICE9PSB4ICYmIHkgIT09IHk7XG4gICAgfVxuICB9XG4gIC8qZXNsaW50LWVuYWJsZSBuby1zZWxmLWNvbXBhcmUqL1xuXG4gIC8qKlxuICAgKiBXZSB1c2UgYW4gRXJyb3ItbGlrZSBvYmplY3QgZm9yIGJhY2t3YXJkIGNvbXBhdGliaWxpdHkgYXMgcGVvcGxlIG1heSBjYWxsXG4gICAqIFByb3BUeXBlcyBkaXJlY3RseSBhbmQgaW5zcGVjdCB0aGVpciBvdXRwdXQuIEhvd2V2ZXIsIHdlIGRvbid0IHVzZSByZWFsXG4gICAqIEVycm9ycyBhbnltb3JlLiBXZSBkb24ndCBpbnNwZWN0IHRoZWlyIHN0YWNrIGFueXdheSwgYW5kIGNyZWF0aW5nIHRoZW1cbiAgICogaXMgcHJvaGliaXRpdmVseSBleHBlbnNpdmUgaWYgdGhleSBhcmUgY3JlYXRlZCB0b28gb2Z0ZW4sIHN1Y2ggYXMgd2hhdFxuICAgKiBoYXBwZW5zIGluIG9uZU9mVHlwZSgpIGZvciBhbnkgdHlwZSBiZWZvcmUgdGhlIG9uZSB0aGF0IG1hdGNoZWQuXG4gICAqL1xuICBmdW5jdGlvbiBQcm9wVHlwZUVycm9yKG1lc3NhZ2UpIHtcbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIHRoaXMuc3RhY2sgPSAnJztcbiAgfVxuICAvLyBNYWtlIGBpbnN0YW5jZW9mIEVycm9yYCBzdGlsbCB3b3JrIGZvciByZXR1cm5lZCBlcnJvcnMuXG4gIFByb3BUeXBlRXJyb3IucHJvdG90eXBlID0gRXJyb3IucHJvdG90eXBlO1xuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBtYW51YWxQcm9wVHlwZUNhbGxDYWNoZSA9IHt9O1xuICAgICAgdmFyIG1hbnVhbFByb3BUeXBlV2FybmluZ0NvdW50ID0gMDtcbiAgICB9XG4gICAgZnVuY3Rpb24gY2hlY2tUeXBlKGlzUmVxdWlyZWQsIHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgc2VjcmV0KSB7XG4gICAgICBjb21wb25lbnROYW1lID0gY29tcG9uZW50TmFtZSB8fCBBTk9OWU1PVVM7XG4gICAgICBwcm9wRnVsbE5hbWUgPSBwcm9wRnVsbE5hbWUgfHwgcHJvcE5hbWU7XG5cbiAgICAgIGlmIChzZWNyZXQgIT09IFJlYWN0UHJvcFR5cGVzU2VjcmV0KSB7XG4gICAgICAgIGlmICh0aHJvd09uRGlyZWN0QWNjZXNzKSB7XG4gICAgICAgICAgLy8gTmV3IGJlaGF2aW9yIG9ubHkgZm9yIHVzZXJzIG9mIGBwcm9wLXR5cGVzYCBwYWNrYWdlXG4gICAgICAgICAgaW52YXJpYW50KFxuICAgICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgICAnQ2FsbGluZyBQcm9wVHlwZXMgdmFsaWRhdG9ycyBkaXJlY3RseSBpcyBub3Qgc3VwcG9ydGVkIGJ5IHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZS4gJyArXG4gICAgICAgICAgICAnVXNlIGBQcm9wVHlwZXMuY2hlY2tQcm9wVHlwZXMoKWAgdG8gY2FsbCB0aGVtLiAnICtcbiAgICAgICAgICAgICdSZWFkIG1vcmUgYXQgaHR0cDovL2ZiLm1lL3VzZS1jaGVjay1wcm9wLXR5cGVzJ1xuICAgICAgICAgICk7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAvLyBPbGQgYmVoYXZpb3IgZm9yIHBlb3BsZSB1c2luZyBSZWFjdC5Qcm9wVHlwZXNcbiAgICAgICAgICB2YXIgY2FjaGVLZXkgPSBjb21wb25lbnROYW1lICsgJzonICsgcHJvcE5hbWU7XG4gICAgICAgICAgaWYgKFxuICAgICAgICAgICAgIW1hbnVhbFByb3BUeXBlQ2FsbENhY2hlW2NhY2hlS2V5XSAmJlxuICAgICAgICAgICAgLy8gQXZvaWQgc3BhbW1pbmcgdGhlIGNvbnNvbGUgYmVjYXVzZSB0aGV5IGFyZSBvZnRlbiBub3QgYWN0aW9uYWJsZSBleGNlcHQgZm9yIGxpYiBhdXRob3JzXG4gICAgICAgICAgICBtYW51YWxQcm9wVHlwZVdhcm5pbmdDb3VudCA8IDNcbiAgICAgICAgICApIHtcbiAgICAgICAgICAgIHdhcm5pbmcoXG4gICAgICAgICAgICAgIGZhbHNlLFxuICAgICAgICAgICAgICAnWW91IGFyZSBtYW51YWxseSBjYWxsaW5nIGEgUmVhY3QuUHJvcFR5cGVzIHZhbGlkYXRpb24gJyArXG4gICAgICAgICAgICAgICdmdW5jdGlvbiBmb3IgdGhlIGAlc2AgcHJvcCBvbiBgJXNgLiBUaGlzIGlzIGRlcHJlY2F0ZWQgJyArXG4gICAgICAgICAgICAgICdhbmQgd2lsbCB0aHJvdyBpbiB0aGUgc3RhbmRhbG9uZSBgcHJvcC10eXBlc2AgcGFja2FnZS4gJyArXG4gICAgICAgICAgICAgICdZb3UgbWF5IGJlIHNlZWluZyB0aGlzIHdhcm5pbmcgZHVlIHRvIGEgdGhpcmQtcGFydHkgUHJvcFR5cGVzICcgK1xuICAgICAgICAgICAgICAnbGlicmFyeS4gU2VlIGh0dHBzOi8vZmIubWUvcmVhY3Qtd2FybmluZy1kb250LWNhbGwtcHJvcHR5cGVzICcgKyAnZm9yIGRldGFpbHMuJyxcbiAgICAgICAgICAgICAgcHJvcEZ1bGxOYW1lLFxuICAgICAgICAgICAgICBjb21wb25lbnROYW1lXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgbWFudWFsUHJvcFR5cGVDYWxsQ2FjaGVbY2FjaGVLZXldID0gdHJ1ZTtcbiAgICAgICAgICAgIG1hbnVhbFByb3BUeXBlV2FybmluZ0NvdW50Kys7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09IG51bGwpIHtcbiAgICAgICAgaWYgKGlzUmVxdWlyZWQpIHtcbiAgICAgICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1RoZSAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2AgaXMgbWFya2VkIGFzIHJlcXVpcmVkICcgKyAoJ2luIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBidXQgaXRzIHZhbHVlIGlzIGBudWxsYC4nKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignVGhlICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBpcyBtYXJrZWQgYXMgcmVxdWlyZWQgaW4gJyArICgnYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGJ1dCBpdHMgdmFsdWUgaXMgYHVuZGVmaW5lZGAuJykpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGNoYWluZWRDaGVja1R5cGUgPSBjaGVja1R5cGUuYmluZChudWxsLCBmYWxzZSk7XG4gICAgY2hhaW5lZENoZWNrVHlwZS5pc1JlcXVpcmVkID0gY2hlY2tUeXBlLmJpbmQobnVsbCwgdHJ1ZSk7XG5cbiAgICByZXR1cm4gY2hhaW5lZENoZWNrVHlwZTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyKGV4cGVjdGVkVHlwZSkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSwgc2VjcmV0KSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gZXhwZWN0ZWRUeXBlKSB7XG4gICAgICAgIC8vIGBwcm9wVmFsdWVgIGJlaW5nIGluc3RhbmNlIG9mLCBzYXksIGRhdGUvcmVnZXhwLCBwYXNzIHRoZSAnb2JqZWN0J1xuICAgICAgICAvLyBjaGVjaywgYnV0IHdlIGNhbiBvZmZlciBhIG1vcmUgcHJlY2lzZSBlcnJvciBtZXNzYWdlIGhlcmUgcmF0aGVyIHRoYW5cbiAgICAgICAgLy8gJ29mIHR5cGUgYG9iamVjdGAnLlxuICAgICAgICB2YXIgcHJlY2lzZVR5cGUgPSBnZXRQcmVjaXNlVHlwZShwcm9wVmFsdWUpO1xuXG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByZWNpc2VUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkICcpICsgKCdgJyArIGV4cGVjdGVkVHlwZSArICdgLicpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlQW55VHlwZUNoZWNrZXIoKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNOdWxsKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUFycmF5T2ZUeXBlQ2hlY2tlcih0eXBlQ2hlY2tlcikge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgaWYgKHR5cGVvZiB0eXBlQ2hlY2tlciAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ1Byb3BlcnR5IGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgY29tcG9uZW50IGAnICsgY29tcG9uZW50TmFtZSArICdgIGhhcyBpbnZhbGlkIFByb3BUeXBlIG5vdGF0aW9uIGluc2lkZSBhcnJheU9mLicpO1xuICAgICAgfVxuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheShwcm9wVmFsdWUpKSB7XG4gICAgICAgIHZhciBwcm9wVHlwZSA9IGdldFByb3BUeXBlKHByb3BWYWx1ZSk7XG4gICAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdHlwZSAnICsgKCdgJyArIHByb3BUeXBlICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkIGFuIGFycmF5LicpKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcFZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlcnJvciA9IHR5cGVDaGVja2VyKHByb3BWYWx1ZSwgaSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICdbJyArIGkgKyAnXScsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlRWxlbWVudFR5cGVDaGVja2VyKCkge1xuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGlmICghaXNWYWxpZEVsZW1lbnQocHJvcFZhbHVlKSkge1xuICAgICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgJyArICgnYCcgKyBwcm9wVHlwZSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBhIHNpbmdsZSBSZWFjdEVsZW1lbnQuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVJbnN0YW5jZVR5cGVDaGVja2VyKGV4cGVjdGVkQ2xhc3MpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICghKHByb3BzW3Byb3BOYW1lXSBpbnN0YW5jZW9mIGV4cGVjdGVkQ2xhc3MpKSB7XG4gICAgICAgIHZhciBleHBlY3RlZENsYXNzTmFtZSA9IGV4cGVjdGVkQ2xhc3MubmFtZSB8fCBBTk9OWU1PVVM7XG4gICAgICAgIHZhciBhY3R1YWxDbGFzc05hbWUgPSBnZXRDbGFzc05hbWUocHJvcHNbcHJvcE5hbWVdKTtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgYWN0dWFsQ2xhc3NOYW1lICsgJ2Agc3VwcGxpZWQgdG8gYCcgKyBjb21wb25lbnROYW1lICsgJ2AsIGV4cGVjdGVkICcpICsgKCdpbnN0YW5jZSBvZiBgJyArIGV4cGVjdGVkQ2xhc3NOYW1lICsgJ2AuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVFbnVtVHlwZUNoZWNrZXIoZXhwZWN0ZWRWYWx1ZXMpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoZXhwZWN0ZWRWYWx1ZXMpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nID8gd2FybmluZyhmYWxzZSwgJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2YsIGV4cGVjdGVkIGFuIGluc3RhbmNlIG9mIGFycmF5LicpIDogdm9pZCAwO1xuICAgICAgcmV0dXJuIGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNOdWxsO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHZhbGlkYXRlKHByb3BzLCBwcm9wTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSkge1xuICAgICAgdmFyIHByb3BWYWx1ZSA9IHByb3BzW3Byb3BOYW1lXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZXhwZWN0ZWRWYWx1ZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGlzKHByb3BWYWx1ZSwgZXhwZWN0ZWRWYWx1ZXNbaV0pKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHZhbHVlc1N0cmluZyA9IEpTT04uc3RyaW5naWZ5KGV4cGVjdGVkVmFsdWVzKTtcbiAgICAgIHJldHVybiBuZXcgUHJvcFR5cGVFcnJvcignSW52YWxpZCAnICsgbG9jYXRpb24gKyAnIGAnICsgcHJvcEZ1bGxOYW1lICsgJ2Agb2YgdmFsdWUgYCcgKyBwcm9wVmFsdWUgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgb25lIG9mICcgKyB2YWx1ZXNTdHJpbmcgKyAnLicpKTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUNoYWluYWJsZVR5cGVDaGVja2VyKHZhbGlkYXRlKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZU9iamVjdE9mVHlwZUNoZWNrZXIodHlwZUNoZWNrZXIpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICh0eXBlb2YgdHlwZUNoZWNrZXIgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdQcm9wZXJ0eSBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIGNvbXBvbmVudCBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCBoYXMgaW52YWxpZCBQcm9wVHlwZSBub3RhdGlvbiBpbnNpZGUgb2JqZWN0T2YuJyk7XG4gICAgICB9XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlICcgKyAoJ2AnICsgcHJvcFR5cGUgKyAnYCBzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYW4gb2JqZWN0LicpKTtcbiAgICAgIH1cbiAgICAgIGZvciAodmFyIGtleSBpbiBwcm9wVmFsdWUpIHtcbiAgICAgICAgaWYgKHByb3BWYWx1ZS5oYXNPd25Qcm9wZXJ0eShrZXkpKSB7XG4gICAgICAgICAgdmFyIGVycm9yID0gdHlwZUNoZWNrZXIocHJvcFZhbHVlLCBrZXksIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUgKyAnLicgKyBrZXksIFJlYWN0UHJvcFR5cGVzU2VjcmV0KTtcbiAgICAgICAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVVbmlvblR5cGVDaGVja2VyKGFycmF5T2ZUeXBlQ2hlY2tlcnMpIHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkoYXJyYXlPZlR5cGVDaGVja2VycykpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgPyB3YXJuaW5nKGZhbHNlLCAnSW52YWxpZCBhcmd1bWVudCBzdXBwbGllZCB0byBvbmVPZlR5cGUsIGV4cGVjdGVkIGFuIGluc3RhbmNlIG9mIGFycmF5LicpIDogdm9pZCAwO1xuICAgICAgcmV0dXJuIGVtcHR5RnVuY3Rpb24udGhhdFJldHVybnNOdWxsO1xuICAgIH1cblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyYXlPZlR5cGVDaGVja2Vycy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoZWNrZXIgPSBhcnJheU9mVHlwZUNoZWNrZXJzW2ldO1xuICAgICAgaWYgKHR5cGVvZiBjaGVja2VyICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHdhcm5pbmcoXG4gICAgICAgICAgZmFsc2UsXG4gICAgICAgICAgJ0ludmFsaWQgYXJndW1lbnQgc3VwcGxpZWQgdG8gb25lT2ZUeXBlLiBFeHBlY3RlZCBhbiBhcnJheSBvZiBjaGVjayBmdW5jdGlvbnMsIGJ1dCAnICtcbiAgICAgICAgICAncmVjZWl2ZWQgJXMgYXQgaW5kZXggJXMuJyxcbiAgICAgICAgICBnZXRQb3N0Zml4Rm9yVHlwZVdhcm5pbmcoY2hlY2tlciksXG4gICAgICAgICAgaVxuICAgICAgICApO1xuICAgICAgICByZXR1cm4gZW1wdHlGdW5jdGlvbi50aGF0UmV0dXJuc051bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycmF5T2ZUeXBlQ2hlY2tlcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoZWNrZXIgPSBhcnJheU9mVHlwZUNoZWNrZXJzW2ldO1xuICAgICAgICBpZiAoY2hlY2tlcihwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUsIFJlYWN0UHJvcFR5cGVzU2VjcmV0KSA9PSBudWxsKSB7XG4gICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBzdXBwbGllZCB0byAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYC4nKSk7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVOb2RlQ2hlY2tlcigpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIGlmICghaXNOb2RlKHByb3BzW3Byb3BOYW1lXSkpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBzdXBwbGllZCB0byAnICsgKCdgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYSBSZWFjdE5vZGUuJykpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVTaGFwZVR5cGVDaGVja2VyKHNoYXBlVHlwZXMpIHtcbiAgICBmdW5jdGlvbiB2YWxpZGF0ZShwcm9wcywgcHJvcE5hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBwcm9wRnVsbE5hbWUpIHtcbiAgICAgIHZhciBwcm9wVmFsdWUgPSBwcm9wc1twcm9wTmFtZV07XG4gICAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgICAgaWYgKHByb3BUeXBlICE9PSAnb2JqZWN0Jykge1xuICAgICAgICByZXR1cm4gbmV3IFByb3BUeXBlRXJyb3IoJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIG9mIHR5cGUgYCcgKyBwcm9wVHlwZSArICdgICcgKyAoJ3N1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLCBleHBlY3RlZCBgb2JqZWN0YC4nKSk7XG4gICAgICB9XG4gICAgICBmb3IgKHZhciBrZXkgaW4gc2hhcGVUeXBlcykge1xuICAgICAgICB2YXIgY2hlY2tlciA9IHNoYXBlVHlwZXNba2V5XTtcbiAgICAgICAgaWYgKCFjaGVja2VyKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVycm9yID0gY2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gY3JlYXRlQ2hhaW5hYmxlVHlwZUNoZWNrZXIodmFsaWRhdGUpO1xuICB9XG5cbiAgZnVuY3Rpb24gY3JlYXRlU3RyaWN0U2hhcGVUeXBlQ2hlY2tlcihzaGFwZVR5cGVzKSB7XG4gICAgZnVuY3Rpb24gdmFsaWRhdGUocHJvcHMsIHByb3BOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgcHJvcEZ1bGxOYW1lKSB7XG4gICAgICB2YXIgcHJvcFZhbHVlID0gcHJvcHNbcHJvcE5hbWVdO1xuICAgICAgdmFyIHByb3BUeXBlID0gZ2V0UHJvcFR5cGUocHJvcFZhbHVlKTtcbiAgICAgIGlmIChwcm9wVHlwZSAhPT0gJ29iamVjdCcpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKCdJbnZhbGlkICcgKyBsb2NhdGlvbiArICcgYCcgKyBwcm9wRnVsbE5hbWUgKyAnYCBvZiB0eXBlIGAnICsgcHJvcFR5cGUgKyAnYCAnICsgKCdzdXBwbGllZCB0byBgJyArIGNvbXBvbmVudE5hbWUgKyAnYCwgZXhwZWN0ZWQgYG9iamVjdGAuJykpO1xuICAgICAgfVxuICAgICAgLy8gV2UgbmVlZCB0byBjaGVjayBhbGwga2V5cyBpbiBjYXNlIHNvbWUgYXJlIHJlcXVpcmVkIGJ1dCBtaXNzaW5nIGZyb21cbiAgICAgIC8vIHByb3BzLlxuICAgICAgdmFyIGFsbEtleXMgPSBhc3NpZ24oe30sIHByb3BzW3Byb3BOYW1lXSwgc2hhcGVUeXBlcyk7XG4gICAgICBmb3IgKHZhciBrZXkgaW4gYWxsS2V5cykge1xuICAgICAgICB2YXIgY2hlY2tlciA9IHNoYXBlVHlwZXNba2V5XTtcbiAgICAgICAgaWYgKCFjaGVja2VyKSB7XG4gICAgICAgICAgcmV0dXJuIG5ldyBQcm9wVHlwZUVycm9yKFxuICAgICAgICAgICAgJ0ludmFsaWQgJyArIGxvY2F0aW9uICsgJyBgJyArIHByb3BGdWxsTmFtZSArICdgIGtleSBgJyArIGtleSArICdgIHN1cHBsaWVkIHRvIGAnICsgY29tcG9uZW50TmFtZSArICdgLicgK1xuICAgICAgICAgICAgJ1xcbkJhZCBvYmplY3Q6ICcgKyBKU09OLnN0cmluZ2lmeShwcm9wc1twcm9wTmFtZV0sIG51bGwsICcgICcpICtcbiAgICAgICAgICAgICdcXG5WYWxpZCBrZXlzOiAnICsgIEpTT04uc3RyaW5naWZ5KE9iamVjdC5rZXlzKHNoYXBlVHlwZXMpLCBudWxsLCAnICAnKVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGVycm9yID0gY2hlY2tlcihwcm9wVmFsdWUsIGtleSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIHByb3BGdWxsTmFtZSArICcuJyArIGtleSwgUmVhY3RQcm9wVHlwZXNTZWNyZXQpO1xuICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiBjcmVhdGVDaGFpbmFibGVUeXBlQ2hlY2tlcih2YWxpZGF0ZSk7XG4gIH1cblxuICBmdW5jdGlvbiBpc05vZGUocHJvcFZhbHVlKSB7XG4gICAgc3dpdGNoICh0eXBlb2YgcHJvcFZhbHVlKSB7XG4gICAgICBjYXNlICdudW1iZXInOlxuICAgICAgY2FzZSAnc3RyaW5nJzpcbiAgICAgIGNhc2UgJ3VuZGVmaW5lZCc6XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgIHJldHVybiAhcHJvcFZhbHVlO1xuICAgICAgY2FzZSAnb2JqZWN0JzpcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocHJvcFZhbHVlKSkge1xuICAgICAgICAgIHJldHVybiBwcm9wVmFsdWUuZXZlcnkoaXNOb2RlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJvcFZhbHVlID09PSBudWxsIHx8IGlzVmFsaWRFbGVtZW50KHByb3BWYWx1ZSkpIHtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBpdGVyYXRvckZuID0gZ2V0SXRlcmF0b3JGbihwcm9wVmFsdWUpO1xuICAgICAgICBpZiAoaXRlcmF0b3JGbikge1xuICAgICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChwcm9wVmFsdWUpO1xuICAgICAgICAgIHZhciBzdGVwO1xuICAgICAgICAgIGlmIChpdGVyYXRvckZuICE9PSBwcm9wVmFsdWUuZW50cmllcykge1xuICAgICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgICBpZiAoIWlzTm9kZShzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBJdGVyYXRvciB3aWxsIHByb3ZpZGUgZW50cnkgW2ssdl0gdHVwbGVzIHJhdGhlciB0aGFuIHZhbHVlcy5cbiAgICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgICAgdmFyIGVudHJ5ID0gc3RlcC52YWx1ZTtcbiAgICAgICAgICAgICAgaWYgKGVudHJ5KSB7XG4gICAgICAgICAgICAgICAgaWYgKCFpc05vZGUoZW50cnlbMV0pKSB7XG4gICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGlzU3ltYm9sKHByb3BUeXBlLCBwcm9wVmFsdWUpIHtcbiAgICAvLyBOYXRpdmUgU3ltYm9sLlxuICAgIGlmIChwcm9wVHlwZSA9PT0gJ3N5bWJvbCcpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cblxuICAgIC8vIDE5LjQuMy41IFN5bWJvbC5wcm90b3R5cGVbQEB0b1N0cmluZ1RhZ10gPT09ICdTeW1ib2wnXG4gICAgaWYgKHByb3BWYWx1ZVsnQEB0b1N0cmluZ1RhZyddID09PSAnU3ltYm9sJykge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gRmFsbGJhY2sgZm9yIG5vbi1zcGVjIGNvbXBsaWFudCBTeW1ib2xzIHdoaWNoIGFyZSBwb2x5ZmlsbGVkLlxuICAgIGlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHByb3BWYWx1ZSBpbnN0YW5jZW9mIFN5bWJvbCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgLy8gRXF1aXZhbGVudCBvZiBgdHlwZW9mYCBidXQgd2l0aCBzcGVjaWFsIGhhbmRsaW5nIGZvciBhcnJheSBhbmQgcmVnZXhwLlxuICBmdW5jdGlvbiBnZXRQcm9wVHlwZShwcm9wVmFsdWUpIHtcbiAgICB2YXIgcHJvcFR5cGUgPSB0eXBlb2YgcHJvcFZhbHVlO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHByb3BWYWx1ZSkpIHtcbiAgICAgIHJldHVybiAnYXJyYXknO1xuICAgIH1cbiAgICBpZiAocHJvcFZhbHVlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgICAvLyBPbGQgd2Via2l0cyAoYXQgbGVhc3QgdW50aWwgQW5kcm9pZCA0LjApIHJldHVybiAnZnVuY3Rpb24nIHJhdGhlciB0aGFuXG4gICAgICAvLyAnb2JqZWN0JyBmb3IgdHlwZW9mIGEgUmVnRXhwLiBXZSdsbCBub3JtYWxpemUgdGhpcyBoZXJlIHNvIHRoYXQgL2JsYS9cbiAgICAgIC8vIHBhc3NlcyBQcm9wVHlwZXMub2JqZWN0LlxuICAgICAgcmV0dXJuICdvYmplY3QnO1xuICAgIH1cbiAgICBpZiAoaXNTeW1ib2wocHJvcFR5cGUsIHByb3BWYWx1ZSkpIHtcbiAgICAgIHJldHVybiAnc3ltYm9sJztcbiAgICB9XG4gICAgcmV0dXJuIHByb3BUeXBlO1xuICB9XG5cbiAgLy8gVGhpcyBoYW5kbGVzIG1vcmUgdHlwZXMgdGhhbiBgZ2V0UHJvcFR5cGVgLiBPbmx5IHVzZWQgZm9yIGVycm9yIG1lc3NhZ2VzLlxuICAvLyBTZWUgYGNyZWF0ZVByaW1pdGl2ZVR5cGVDaGVja2VyYC5cbiAgZnVuY3Rpb24gZ2V0UHJlY2lzZVR5cGUocHJvcFZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiBwcm9wVmFsdWUgPT09ICd1bmRlZmluZWQnIHx8IHByb3BWYWx1ZSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuICcnICsgcHJvcFZhbHVlO1xuICAgIH1cbiAgICB2YXIgcHJvcFR5cGUgPSBnZXRQcm9wVHlwZShwcm9wVmFsdWUpO1xuICAgIGlmIChwcm9wVHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIGlmIChwcm9wVmFsdWUgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgICAgIHJldHVybiAnZGF0ZSc7XG4gICAgICB9IGVsc2UgaWYgKHByb3BWYWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cCkge1xuICAgICAgICByZXR1cm4gJ3JlZ2V4cCc7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBwcm9wVHlwZTtcbiAgfVxuXG4gIC8vIFJldHVybnMgYSBzdHJpbmcgdGhhdCBpcyBwb3N0Zml4ZWQgdG8gYSB3YXJuaW5nIGFib3V0IGFuIGludmFsaWQgdHlwZS5cbiAgLy8gRm9yIGV4YW1wbGUsIFwidW5kZWZpbmVkXCIgb3IgXCJvZiB0eXBlIGFycmF5XCJcbiAgZnVuY3Rpb24gZ2V0UG9zdGZpeEZvclR5cGVXYXJuaW5nKHZhbHVlKSB7XG4gICAgdmFyIHR5cGUgPSBnZXRQcmVjaXNlVHlwZSh2YWx1ZSk7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlICdhcnJheSc6XG4gICAgICBjYXNlICdvYmplY3QnOlxuICAgICAgICByZXR1cm4gJ2FuICcgKyB0eXBlO1xuICAgICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICBjYXNlICdkYXRlJzpcbiAgICAgIGNhc2UgJ3JlZ2V4cCc6XG4gICAgICAgIHJldHVybiAnYSAnICsgdHlwZTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiB0eXBlO1xuICAgIH1cbiAgfVxuXG4gIC8vIFJldHVybnMgY2xhc3MgbmFtZSBvZiB0aGUgb2JqZWN0LCBpZiBhbnkuXG4gIGZ1bmN0aW9uIGdldENsYXNzTmFtZShwcm9wVmFsdWUpIHtcbiAgICBpZiAoIXByb3BWYWx1ZS5jb25zdHJ1Y3RvciB8fCAhcHJvcFZhbHVlLmNvbnN0cnVjdG9yLm5hbWUpIHtcbiAgICAgIHJldHVybiBBTk9OWU1PVVM7XG4gICAgfVxuICAgIHJldHVybiBwcm9wVmFsdWUuY29uc3RydWN0b3IubmFtZTtcbiAgfVxuXG4gIFJlYWN0UHJvcFR5cGVzLmNoZWNrUHJvcFR5cGVzID0gY2hlY2tQcm9wVHlwZXM7XG4gIFJlYWN0UHJvcFR5cGVzLlByb3BUeXBlcyA9IFJlYWN0UHJvcFR5cGVzO1xuXG4gIHJldHVybiBSZWFjdFByb3BUeXBlcztcbn07XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBSRUFDVF9FTEVNRU5UX1RZUEUgPSAodHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgIFN5bWJvbC5mb3IgJiZcbiAgICBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykpIHx8XG4gICAgMHhlYWM3O1xuXG4gIHZhciBpc1ZhbGlkRWxlbWVudCA9IGZ1bmN0aW9uKG9iamVjdCkge1xuICAgIHJldHVybiB0eXBlb2Ygb2JqZWN0ID09PSAnb2JqZWN0JyAmJlxuICAgICAgb2JqZWN0ICE9PSBudWxsICYmXG4gICAgICBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbiAgfTtcblxuICAvLyBCeSBleHBsaWNpdGx5IHVzaW5nIGBwcm9wLXR5cGVzYCB5b3UgYXJlIG9wdGluZyBpbnRvIG5ldyBkZXZlbG9wbWVudCBiZWhhdmlvci5cbiAgLy8gaHR0cDovL2ZiLm1lL3Byb3AtdHlwZXMtaW4tcHJvZFxuICB2YXIgdGhyb3dPbkRpcmVjdEFjY2VzcyA9IHRydWU7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9mYWN0b3J5V2l0aFR5cGVDaGVja2VycycpKGlzVmFsaWRFbGVtZW50LCB0aHJvd09uRGlyZWN0QWNjZXNzKTtcbn0gZWxzZSB7XG4gIC8vIEJ5IGV4cGxpY2l0bHkgdXNpbmcgYHByb3AtdHlwZXNgIHlvdSBhcmUgb3B0aW5nIGludG8gbmV3IHByb2R1Y3Rpb24gYmVoYXZpb3IuXG4gIC8vIGh0dHA6Ly9mYi5tZS9wcm9wLXR5cGVzLWluLXByb2RcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2ZhY3RvcnlXaXRoVGhyb3dpbmdTaGltcycpKCk7XG59XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxMy1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIFJlYWN0UHJvcFR5cGVzU2VjcmV0ID0gJ1NFQ1JFVF9ET19OT1RfUEFTU19USElTX09SX1lPVV9XSUxMX0JFX0ZJUkVEJztcblxubW9kdWxlLmV4cG9ydHMgPSBSZWFjdFByb3BUeXBlc1NlY3JldDtcbiIsIi8qISAqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi4gQWxsIHJpZ2h0cyByZXNlcnZlZC5cclxuTGljZW5zZWQgdW5kZXIgdGhlIEFwYWNoZSBMaWNlbnNlLCBWZXJzaW9uIDIuMCAodGhlIFwiTGljZW5zZVwiKTsgeW91IG1heSBub3QgdXNlXHJcbnRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLiBZb3UgbWF5IG9idGFpbiBhIGNvcHkgb2YgdGhlXHJcbkxpY2Vuc2UgYXQgaHR0cDovL3d3dy5hcGFjaGUub3JnL2xpY2Vuc2VzL0xJQ0VOU0UtMi4wXHJcblxyXG5USElTIENPREUgSVMgUFJPVklERUQgT04gQU4gKkFTIElTKiBCQVNJUywgV0lUSE9VVCBXQVJSQU5USUVTIE9SIENPTkRJVElPTlMgT0YgQU5ZXHJcbktJTkQsIEVJVEhFUiBFWFBSRVNTIE9SIElNUExJRUQsIElOQ0xVRElORyBXSVRIT1VUIExJTUlUQVRJT04gQU5ZIElNUExJRURcclxuV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIFRJVExFLCBGSVRORVNTIEZPUiBBIFBBUlRJQ1VMQVIgUFVSUE9TRSxcclxuTUVSQ0hBTlRBQkxJVFkgT1IgTk9OLUlORlJJTkdFTUVOVC5cclxuXHJcblNlZSB0aGUgQXBhY2hlIFZlcnNpb24gMi4wIExpY2Vuc2UgZm9yIHNwZWNpZmljIGxhbmd1YWdlIGdvdmVybmluZyBwZXJtaXNzaW9uc1xyXG5hbmQgbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcbi8qIGdsb2JhbCBnbG9iYWwsIGRlZmluZSwgU3lzdGVtLCBSZWZsZWN0LCBQcm9taXNlICovXHJcbnZhciBfX2V4dGVuZHM7XHJcbnZhciBfX2Fzc2lnbjtcclxudmFyIF9fcmVzdDtcclxudmFyIF9fZGVjb3JhdGU7XHJcbnZhciBfX3BhcmFtO1xyXG52YXIgX19tZXRhZGF0YTtcclxudmFyIF9fYXdhaXRlcjtcclxudmFyIF9fZ2VuZXJhdG9yO1xyXG52YXIgX19leHBvcnRTdGFyO1xyXG52YXIgX192YWx1ZXM7XHJcbnZhciBfX3JlYWQ7XHJcbnZhciBfX3NwcmVhZDtcclxudmFyIF9fYXdhaXQ7XHJcbnZhciBfX2FzeW5jR2VuZXJhdG9yO1xyXG52YXIgX19hc3luY0RlbGVnYXRvcjtcclxudmFyIF9fYXN5bmNWYWx1ZXM7XHJcbnZhciBfX21ha2VUZW1wbGF0ZU9iamVjdDtcclxuKGZ1bmN0aW9uIChmYWN0b3J5KSB7XHJcbiAgICB2YXIgcm9vdCA9IHR5cGVvZiBnbG9iYWwgPT09IFwib2JqZWN0XCIgPyBnbG9iYWwgOiB0eXBlb2Ygc2VsZiA9PT0gXCJvYmplY3RcIiA/IHNlbGYgOiB0eXBlb2YgdGhpcyA9PT0gXCJvYmplY3RcIiA/IHRoaXMgOiB7fTtcclxuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xyXG4gICAgICAgIGRlZmluZShcInRzbGliXCIsIFtcImV4cG9ydHNcIl0sIGZ1bmN0aW9uIChleHBvcnRzKSB7IGZhY3RvcnkoY3JlYXRlRXhwb3J0ZXIocm9vdCwgY3JlYXRlRXhwb3J0ZXIoZXhwb3J0cykpKTsgfSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJvYmplY3RcIikge1xyXG4gICAgICAgIGZhY3RvcnkoY3JlYXRlRXhwb3J0ZXIocm9vdCwgY3JlYXRlRXhwb3J0ZXIobW9kdWxlLmV4cG9ydHMpKSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBmYWN0b3J5KGNyZWF0ZUV4cG9ydGVyKHJvb3QpKTtcclxuICAgIH1cclxuICAgIGZ1bmN0aW9uIGNyZWF0ZUV4cG9ydGVyKGV4cG9ydHMsIHByZXZpb3VzKSB7XHJcbiAgICAgICAgaWYgKGV4cG9ydHMgIT09IHJvb3QpIHtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiBPYmplY3QuY3JlYXRlID09PSBcImZ1bmN0aW9uXCIpIHtcclxuICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIGV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChpZCwgdikgeyByZXR1cm4gZXhwb3J0c1tpZF0gPSBwcmV2aW91cyA/IHByZXZpb3VzKGlkLCB2KSA6IHY7IH07XHJcbiAgICB9XHJcbn0pXHJcbihmdW5jdGlvbiAoZXhwb3J0ZXIpIHtcclxuICAgIHZhciBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKGIuaGFzT3duUHJvcGVydHkocCkpIGRbcF0gPSBiW3BdOyB9O1xyXG5cclxuICAgIF9fZXh0ZW5kcyA9IGZ1bmN0aW9uIChkLCBiKSB7XHJcbiAgICAgICAgZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxuICAgICAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgICAgICBkLnByb3RvdHlwZSA9IGIgPT09IG51bGwgPyBPYmplY3QuY3JlYXRlKGIpIDogKF9fLnByb3RvdHlwZSA9IGIucHJvdG90eXBlLCBuZXcgX18oKSk7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiAodCkge1xyXG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH07XHJcblxyXG4gICAgX19yZXN0ID0gZnVuY3Rpb24gKHMsIGUpIHtcclxuICAgICAgICB2YXIgdCA9IHt9O1xyXG4gICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxyXG4gICAgICAgICAgICB0W3BdID0gc1twXTtcclxuICAgICAgICBpZiAocyAhPSBudWxsICYmIHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzID09PSBcImZ1bmN0aW9uXCIpXHJcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIGlmIChlLmluZGV4T2YocFtpXSkgPCAwKVxyXG4gICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XHJcbiAgICAgICAgcmV0dXJuIHQ7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fZGVjb3JhdGUgPSBmdW5jdGlvbiAoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgICAgICB2YXIgYyA9IGFyZ3VtZW50cy5sZW5ndGgsIHIgPSBjIDwgMyA/IHRhcmdldCA6IGRlc2MgPT09IG51bGwgPyBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcih0YXJnZXQsIGtleSkgOiBkZXNjLCBkO1xyXG4gICAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gXCJvYmplY3RcIiAmJiB0eXBlb2YgUmVmbGVjdC5kZWNvcmF0ZSA9PT0gXCJmdW5jdGlvblwiKSByID0gUmVmbGVjdC5kZWNvcmF0ZShkZWNvcmF0b3JzLCB0YXJnZXQsIGtleSwgZGVzYyk7XHJcbiAgICAgICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcclxuICAgICAgICByZXR1cm4gYyA+IDMgJiYgciAmJiBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHIpLCByO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX3BhcmFtID0gZnVuY3Rpb24gKHBhcmFtSW5kZXgsIGRlY29yYXRvcikge1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHsgZGVjb3JhdG9yKHRhcmdldCwga2V5LCBwYXJhbUluZGV4KTsgfVxyXG4gICAgfTtcclxuXHJcbiAgICBfX21ldGFkYXRhID0gZnVuY3Rpb24gKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKSB7XHJcbiAgICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKTtcclxuICAgIH07XHJcblxyXG4gICAgX19hd2FpdGVyID0gZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUocmVzdWx0LnZhbHVlKTsgfSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fZ2VuZXJhdG9yID0gZnVuY3Rpb24gKHRoaXNBcmcsIGJvZHkpIHtcclxuICAgICAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xyXG4gICAgICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xyXG4gICAgICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcclxuICAgICAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xyXG4gICAgICAgICAgICB3aGlsZSAoXykgdHJ5IHtcclxuICAgICAgICAgICAgICAgIGlmIChmID0gMSwgeSAmJiAodCA9IHlbb3BbMF0gJiAyID8gXCJyZXR1cm5cIiA6IG9wWzBdID8gXCJ0aHJvd1wiIDogXCJuZXh0XCJdKSAmJiAhKHQgPSB0LmNhbGwoeSwgb3BbMV0pKS5kb25lKSByZXR1cm4gdDtcclxuICAgICAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbMCwgdC52YWx1ZV07XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKG9wWzBdKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDU6IF8ubGFiZWwrKzsgeSA9IG9wWzFdOyBvcCA9IFswXTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKHQgPSBfLnRyeXMsIHQgPSB0Lmxlbmd0aCA+IDAgJiYgdFt0Lmxlbmd0aCAtIDFdKSAmJiAob3BbMF0gPT09IDYgfHwgb3BbMF0gPT09IDIpKSB7IF8gPSAwOyBjb250aW51ZTsgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHQgJiYgXy5sYWJlbCA8IHRbMl0pIHsgXy5sYWJlbCA9IHRbMl07IF8ub3BzLnB1c2gob3ApOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcclxuICAgICAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxyXG4gICAgICAgICAgICBpZiAob3BbMF0gJiA1KSB0aHJvdyBvcFsxXTsgcmV0dXJuIHsgdmFsdWU6IG9wWzBdID8gb3BbMV0gOiB2b2lkIDAsIGRvbmU6IHRydWUgfTtcclxuICAgICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIF9fZXhwb3J0U3RhciA9IGZ1bmN0aW9uIChtLCBleHBvcnRzKSB7XHJcbiAgICAgICAgZm9yICh2YXIgcCBpbiBtKSBpZiAoIWV4cG9ydHMuaGFzT3duUHJvcGVydHkocCkpIGV4cG9ydHNbcF0gPSBtW3BdO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX3ZhbHVlcyA9IGZ1bmN0aW9uIChvKSB7XHJcbiAgICAgICAgdmFyIG0gPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb1tTeW1ib2wuaXRlcmF0b3JdLCBpID0gMDtcclxuICAgICAgICBpZiAobSkgcmV0dXJuIG0uY2FsbChvKTtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBuZXh0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgdmFsdWU6IG8gJiYgb1tpKytdLCBkb25lOiAhbyB9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfTtcclxuICAgIH07XHJcblxyXG4gICAgX19yZWFkID0gZnVuY3Rpb24gKG8sIG4pIHtcclxuICAgICAgICB2YXIgbSA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl07XHJcbiAgICAgICAgaWYgKCFtKSByZXR1cm4gbztcclxuICAgICAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcclxuICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICB3aGlsZSAoKG4gPT09IHZvaWQgMCB8fCBuLS0gPiAwKSAmJiAhKHIgPSBpLm5leHQoKSkuZG9uZSkgYXIucHVzaChyLnZhbHVlKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7IGUgPSB7IGVycm9yOiBlcnJvciB9OyB9XHJcbiAgICAgICAgZmluYWxseSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgICBpZiAociAmJiAhci5kb25lICYmIChtID0gaVtcInJldHVyblwiXSkpIG0uY2FsbChpKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGFyO1xyXG4gICAgfTtcclxuXHJcbiAgICBfX3NwcmVhZCA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmb3IgKHZhciBhciA9IFtdLCBpID0gMDsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKylcclxuICAgICAgICAgICAgYXIgPSBhci5jb25jYXQoX19yZWFkKGFyZ3VtZW50c1tpXSkpO1xyXG4gICAgICAgIHJldHVybiBhcjtcclxuICAgIH07XHJcblxyXG4gICAgX19hd2FpdCA9IGZ1bmN0aW9uICh2KSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMgaW5zdGFuY2VvZiBfX2F3YWl0ID8gKHRoaXMudiA9IHYsIHRoaXMpIDogbmV3IF9fYXdhaXQodik7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fYXN5bmNHZW5lcmF0b3IgPSBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgZ2VuZXJhdG9yKSB7XHJcbiAgICAgICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgICAgICB2YXIgZyA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSwgaSwgcSA9IFtdO1xyXG4gICAgICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaTtcclxuICAgICAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaWYgKGdbbl0pIGlbbl0gPSBmdW5jdGlvbiAodikgeyByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKGEsIGIpIHsgcS5wdXNoKFtuLCB2LCBhLCBiXSkgPiAxIHx8IHJlc3VtZShuLCB2KTsgfSk7IH07IH1cclxuICAgICAgICBmdW5jdGlvbiByZXN1bWUobiwgdikgeyB0cnkgeyBzdGVwKGdbbl0odikpOyB9IGNhdGNoIChlKSB7IHNldHRsZShxWzBdWzNdLCBlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyKSB7IHIudmFsdWUgaW5zdGFuY2VvZiBfX2F3YWl0ID8gUHJvbWlzZS5yZXNvbHZlKHIudmFsdWUudikudGhlbihmdWxmaWxsLCByZWplY3QpIDogc2V0dGxlKHFbMF1bMl0sIHIpOyAgfVxyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGwodmFsdWUpIHsgcmVzdW1lKFwibmV4dFwiLCB2YWx1ZSk7IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3QodmFsdWUpIHsgcmVzdW1lKFwidGhyb3dcIiwgdmFsdWUpOyB9XHJcbiAgICAgICAgZnVuY3Rpb24gc2V0dGxlKGYsIHYpIHsgaWYgKGYodiksIHEuc2hpZnQoKSwgcS5sZW5ndGgpIHJlc3VtZShxWzBdWzBdLCBxWzBdWzFdKTsgfVxyXG4gICAgfTtcclxuXHJcbiAgICBfX2FzeW5jRGVsZWdhdG9yID0gZnVuY3Rpb24gKG8pIHtcclxuICAgICAgICB2YXIgaSwgcDtcclxuICAgICAgICByZXR1cm4gaSA9IHt9LCB2ZXJiKFwibmV4dFwiKSwgdmVyYihcInRocm93XCIsIGZ1bmN0aW9uIChlKSB7IHRocm93IGU7IH0pLCB2ZXJiKFwicmV0dXJuXCIpLCBpW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgICAgIGZ1bmN0aW9uIHZlcmIobiwgZikgeyBpZiAob1tuXSkgaVtuXSA9IGZ1bmN0aW9uICh2KSB7IHJldHVybiAocCA9ICFwKSA/IHsgdmFsdWU6IF9fYXdhaXQob1tuXSh2KSksIGRvbmU6IG4gPT09IFwicmV0dXJuXCIgfSA6IGYgPyBmKHYpIDogdjsgfTsgfVxyXG4gICAgfTtcclxuXHJcbiAgICBfX2FzeW5jVmFsdWVzID0gZnVuY3Rpb24gKG8pIHtcclxuICAgICAgICBpZiAoIVN5bWJvbC5hc3luY0l0ZXJhdG9yKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiU3ltYm9sLmFzeW5jSXRlcmF0b3IgaXMgbm90IGRlZmluZWQuXCIpO1xyXG4gICAgICAgIHZhciBtID0gb1tTeW1ib2wuYXN5bmNJdGVyYXRvcl07XHJcbiAgICAgICAgcmV0dXJuIG0gPyBtLmNhbGwobykgOiB0eXBlb2YgX192YWx1ZXMgPT09IFwiZnVuY3Rpb25cIiA/IF9fdmFsdWVzKG8pIDogb1tTeW1ib2wuaXRlcmF0b3JdKCk7XHJcbiAgICB9O1xyXG5cclxuICAgIF9fbWFrZVRlbXBsYXRlT2JqZWN0ID0gZnVuY3Rpb24gKGNvb2tlZCwgcmF3KSB7XHJcbiAgICAgICAgaWYgKE9iamVjdC5kZWZpbmVQcm9wZXJ0eSkgeyBPYmplY3QuZGVmaW5lUHJvcGVydHkoY29va2VkLCBcInJhd1wiLCB7IHZhbHVlOiByYXcgfSk7IH0gZWxzZSB7IGNvb2tlZC5yYXcgPSByYXc7IH1cclxuICAgICAgICByZXR1cm4gY29va2VkO1xyXG4gICAgfTtcclxuXHJcbiAgICBleHBvcnRlcihcIl9fZXh0ZW5kc1wiLCBfX2V4dGVuZHMpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX2Fzc2lnblwiLCBfX2Fzc2lnbik7XHJcbiAgICBleHBvcnRlcihcIl9fcmVzdFwiLCBfX3Jlc3QpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX2RlY29yYXRlXCIsIF9fZGVjb3JhdGUpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX3BhcmFtXCIsIF9fcGFyYW0pO1xyXG4gICAgZXhwb3J0ZXIoXCJfX21ldGFkYXRhXCIsIF9fbWV0YWRhdGEpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX2F3YWl0ZXJcIiwgX19hd2FpdGVyKTtcclxuICAgIGV4cG9ydGVyKFwiX19nZW5lcmF0b3JcIiwgX19nZW5lcmF0b3IpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX2V4cG9ydFN0YXJcIiwgX19leHBvcnRTdGFyKTtcclxuICAgIGV4cG9ydGVyKFwiX192YWx1ZXNcIiwgX192YWx1ZXMpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX3JlYWRcIiwgX19yZWFkKTtcclxuICAgIGV4cG9ydGVyKFwiX19zcHJlYWRcIiwgX19zcHJlYWQpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX2F3YWl0XCIsIF9fYXdhaXQpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX2FzeW5jR2VuZXJhdG9yXCIsIF9fYXN5bmNHZW5lcmF0b3IpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX2FzeW5jRGVsZWdhdG9yXCIsIF9fYXN5bmNEZWxlZ2F0b3IpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX2FzeW5jVmFsdWVzXCIsIF9fYXN5bmNWYWx1ZXMpO1xyXG4gICAgZXhwb3J0ZXIoXCJfX21ha2VUZW1wbGF0ZU9iamVjdFwiLCBfX21ha2VUZW1wbGF0ZU9iamVjdCk7XHJcbn0pO1xyXG4iXX0=
